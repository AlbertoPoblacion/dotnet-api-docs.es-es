<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="47dc3c315c3032983e55c27b5310ada10bd2501f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406838" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limits the number of threads that can access a resource or pool of resources concurrently.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Threading.Semaphore> clase para controlar el acceso a un grupo de recursos. Subprocesos entran en el semáforo mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método, que se hereda de la <xref:System.Threading.WaitHandle> clase y libere el semáforo mediante una llamada a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
 El recuento en un semáforo es disminuye cada vez que un subproceso entra en el semáforo y aumenta cuando un subproceso libere el semáforo. Cuando el recuento es cero, las solicitudes posteriores se bloquean hasta que otros subprocesos liberan el semáforo. Cuando todos los subprocesos han liberado el semáforo, el recuento es el valor máximo especificado cuando se creó el semáforo.  
  
 No hay ningún orden garantizado, como FIFO, LIFO, en el que los subprocesos bloqueados entran el semáforo.  
  
 Un subproceso puede entrar varias veces, en el semáforo mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método varias veces. Para liberar algunas o todas estas entradas, el subproceso puede llamar sin parámetros <xref:System.Threading.Semaphore.Release> sobrecarga del método varias veces, o bien puede llamar a la <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método que especifica el número de entradas que se liberan.  
  
 El <xref:System.Threading.Semaphore> clase no exige la identidad del subproceso en las llamadas a <xref:System.Threading.WaitHandle.WaitOne%2A> o <xref:System.Threading.Semaphore.Release%2A>. Es responsabilidad del programador asegurarse de que los subprocesos no liberen el semáforo demasiadas veces. Por ejemplo, supongamos que un semáforo tiene un recuento máximo de dos y que los subprocesos A y B entran el semáforo. Si un error de programación en el subproceso B hace que llame a <xref:System.Threading.Semaphore.Release%2A> dos veces, ambas llamadas tendrán éxito. El recuento del semáforo está lleno y cuando el subproceso A finalmente llama a <xref:System.Threading.Semaphore.Release%2A>, se genera <xref:System.Threading.SemaphoreFullException>.  
  
 Semáforos son de dos tipos: semáforos locales y semáforos de sistema con nombre. Si crea un <xref:System.Threading.Semaphore> utilizando un constructor que acepta un nombre de objeto está asociado a un semáforo de sistema operativo de ese nombre. Sistema semáforos son visibles en todo el sistema operativo y pueden utilizarse para sincronizar las actividades de procesos con nombre. Puede crear varias <xref:System.Threading.Semaphore> denominado de objetos que representan el mismo semáforo de sistema y puede usar el <xref:System.Threading.Semaphore.OpenExisting%2A> método para abrir una existente denominado semáforo del sistema.  
  
 Un semáforo local sólo existe dentro del proceso. La puede usar cualquier subproceso del proceso que tenga una referencia al objeto <xref:System.Threading.Semaphore> local. Cada <xref:System.Threading.Semaphore> objeto es un semáforo local distinto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero. El ejemplo inicia cinco subprocesos que se bloquean en espera para el semáforo. El subproceso principal utiliza los <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos entrar en el semáforo. Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, llama a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo. Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior. Uso del semáforo del seguimiento mensajes de consola. El intervalo de trabajo simulado aumenta ligeramente por cada subproceso, para facilitar la lectura de la salida.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un semáforo sin nombre. Todos los subprocesos que utilizan una instancia de este tipo de semáforo deben tener referencias a la instancia.  
  
 Si `initialCount` es menor que `maximumCount`, el efecto es el mismo que si el subproceso actual hubiera llamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces. Si no desea reservar entradas para el subproceso que crea el semáforo, use el mismo número de `maximumCount` y `initialCount`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero. El ejemplo inicia cinco subprocesos que se bloquean en espera para el semáforo. El subproceso principal utiliza los <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos entrar en el semáforo. Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, llama a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo. Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior. Uso del semáforo del seguimiento mensajes de consola. El intervalo de trabajo simulado aumenta ligeramente por cada subproceso, para facilitar la lectura de la salida.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre. Puede crear varias <xref:System.Threading.Semaphore> denominado de objetos que representan el mismo semáforo de sistema.  
  
 Si el semáforo de sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`. Si el semáforo de sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos siguen producen excepciones. Si necesita determinar si se creó un semáforo de sistema con nombre, use la <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> sobrecarga de constructor en su lugar.  
  
> [!IMPORTANT]
>  Cuando utilice esta sobrecarga de constructor, la práctica recomendada es especificar el mismo número de `initialCount` y `maximumCount`. Si `initialCount` es menor que `maximumCount`y se creó un semáforo de sistema con nombre, el efecto es el mismo que si el subproceso actual hubiera llamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces. Sin embargo, con esta sobrecarga del constructor no hay ninguna manera de determinar si se creó un semáforo de sistema con nombre.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si se hubiera llamado el <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor.  
  
 Dado que los semáforos con nombre son visibles en todo el sistema operativo, puede utilizar para coordinar el uso de recursos en los límites del proceso.  
  
 Si desea averiguar si existe un semáforo de sistema con nombre, use la <xref:System.Threading.Semaphore.OpenExisting%2A> método. El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir un semáforo con nombre existente y produce una excepción si el semáforo del sistema no existe.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre. En el ejemplo se crea un semáforo con nombre con un recuento máximo de cinco y un recuento inicial de cinco. El programa realiza tres llamadas a la <xref:System.Threading.WaitHandle.WaitOne%2A> método. Por lo tanto, si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia se bloqueará en la tercera llamada a <xref:System.Threading.WaitHandle.WaitOne%2A>. Liberar una o más entradas en la primera copia del programa para desbloquear a la segunda.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para crear un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre. Puede crear varias <xref:System.Threading.Semaphore> denominado de objetos que representan el mismo semáforo de sistema.  
  
 Si el semáforo de sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`. Si el semáforo de sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos siguen producen excepciones. Utilice `createdNew` para determinar si se creó el semáforo de sistema.  
  
 Si `initialCount` es menor que `maximumCount`, y `createdNew` es `true`, el efecto es el mismo que si el subproceso actual hubiera llamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si se hubiera llamado el <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor. En este caso, `createdNew` siempre es `true`.  
  
 Dado que los semáforos con nombre son visibles en todo el sistema operativo, puede utilizar para coordinar el uso de recursos en los límites del proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre. En el ejemplo se crea un semáforo con nombre con un recuento máximo de cinco y un recuento inicial de dos. Es decir, reserva tres entradas para el subproceso que llama al constructor. Si `createNew` es `false`, el programa realiza tres llamadas a la <xref:System.Threading.WaitHandle.WaitOne%2A> método. Por lo tanto, si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia se bloqueará en la tercera llamada a <xref:System.Threading.WaitHandle.WaitOne%2A>. Liberar una o más entradas en la primera copia del programa para desbloquear a la segunda.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para crear un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed. This parameter is passed uninitialized.</param>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para aplicar la seguridad de control de acceso para un semáforo de sistema con nombre cuando se crea, impide que otro código tome el control del semáforo.  
  
 Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre. Puede crear varias <xref:System.Threading.Semaphore> denominado de objetos que representan el mismo semáforo de sistema.  
  
 Si el semáforo de sistema con nombre no existe, se crea con la seguridad de control de acceso especificada. Si el semáforo con nombre existe, se omite la seguridad de control de acceso especificada.  
  
> [!NOTE]
>  El llamador tiene control total sobre el recién creado <xref:System.Threading.Semaphore> objeto incluso si `semaphoreSecurity` deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual. Sin embargo, si el usuario actual intenta obtener otro <xref:System.Threading.Semaphore> representar el mismo semáforo con nombre, utilizando un constructor de objeto o el <xref:System.Threading.Semaphore.OpenExisting%2A> método, se aplica la seguridad de control de acceso de Windows.  
  
 Si el semáforo de sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`. Si el semáforo de sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos siguen producen excepciones. Use la `createdNew` parámetro para determinar si este constructor creó el semáforo del sistema.  
  
 Si `initialCount` es menor que `maximumCount`, y `createdNew` es `true`, el efecto es el mismo que si el subproceso actual hubiera llamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si se hubiera llamado el <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor. En este caso, `createdNew` siempre es `true`.  
  
 Dado que los semáforos con nombre son visibles en todo el sistema operativo, puede utilizar para coordinar el uso de recursos en los límites del proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre. Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo pero le concede el derecho a leer y cambiar los permisos en el semáforo. Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.  
  
 Una vez cambiados los permisos, se abre el semáforo con los derechos necesarios para entrada y liberación. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para crear un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the access control security for a named system semaphore.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Semaphore.GetAccessControl%2A> método utiliza la siguiente combinación de indicadores (combinados mediante la operación OR bit a bit) para buscar los permisos: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, y <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 El usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> derechos para llamar a este método y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> derechos.  
  
 En un semáforo local, la seguridad de control de acceso es irrelevante. Si el <xref:System.Threading.Semaphore> objeto no representa un semáforo de sistema con nombre, este método devuelve un <xref:System.Security.AccessControl.SemaphoreSecurity> objeto que concede todos los derechos a cualquier usuario.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.  
  
 Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo, pero le concede el derecho a leer y cambiar los permisos en el semáforo.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos. La seguridad de control de acceso para el semáforo del sistema se obtiene mediante la <xref:System.Threading.Semaphore.GetAccessControl%2A> método.  
  
 Una vez cambiados los permisos, se abre el semáforo con los derechos necesarios para entrada y liberación. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.  -or-  The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named semaphore, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <summary>Opens the specified named semaphore, if it already exists.</summary>
        <returns>An object that represents the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir el semáforo con nombre especificado. Si el semáforo del sistema no existe, este método produce una excepción en lugar de crear el semáforo del sistema. Para crear el semáforo del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tenga un `name` parámetro.  
  
 Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Semaphore> objeto, incluso si los objetos que se devuelven representan el mismo semáforo con nombre sistema.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Semaphore.OpenExisting%2A> sobrecarga del método y especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.  
  
 Especificar el <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso para entrar en el semáforo y especificando la <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.  
  
 Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo, pero que concede el derecho a leer y cambiar permisos en el semáforo.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.  
  
 Una vez cambiados los permisos, se abre el semáforo con los derechos necesarios para escribir y liberarla. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para abrir un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named semaphore, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `rights` debe incluir el parámetro la <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos entran en el semáforo y el <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
 El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir un semáforo con nombre existente. Si el semáforo del sistema no existe, este método produce una excepción en lugar de crear el semáforo del sistema. Para crear el semáforo del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tenga un `name` parámetro.  
  
 Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Semaphore> objeto, incluso si los objetos que se devuelven representan el mismo semáforo con nombre sistema.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.  
  
 Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo, pero le concede el derecho a leer y cambiar los permisos en el semáforo.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.  
  
 Una vez cambiados los permisos, se abre el semáforo con los derechos necesarios para escribir y liberarla. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the desired security access rights.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para crear un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exits the semaphore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exits the semaphore and returns the previous count.</summary>
        <returns>The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los subprocesos normalmente utilizan el <xref:System.Threading.WaitHandle.WaitOne%2A> método para entrar en el semáforo y se suele utilizar esta sobrecarga del método para salir.  
  
 Si un <xref:System.Threading.SemaphoreFullException> producida por la <xref:System.Threading.Semaphore.Release%2A> método, no indica necesariamente un problema con el subproceso que realiza la llamada. Un error de programación en otro subproceso haya podido provocar que ese subproceso que sale del semáforo más veces de las que especificó.  
  
 Si la actual <xref:System.Threading.Semaphore> objeto representa un semáforo de sistema con nombre, el usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero. El ejemplo inicia cinco subprocesos que se bloquean en espera para el semáforo. El subproceso principal utiliza los <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos entrar en el semáforo. Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, llama a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo.  
  
 Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior. Uso del semáforo del seguimiento mensajes de consola. El intervalo de trabajo simulado aumenta ligeramente por cada subproceso, para facilitar la lectura de la salida.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">The semaphore count is already at the maximum value.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred with a named semaphore.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  -or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">The number of times to exit the semaphore.</param>
        <summary>Exits the semaphore a specified number of times and returns the previous count.</summary>
        <returns>The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un subproceso ha entrado varias veces en el semáforo, esta sobrecarga del método permite el recuento del semáforo completo que se restaurarán con una llamada.  
  
 Si un <xref:System.Threading.SemaphoreFullException> producida por la <xref:System.Threading.Semaphore.Release%2A> método, no indica necesariamente un problema con el subproceso que realiza la llamada. Un error de programación en otro subproceso haya podido provocar que ese subproceso que sale del semáforo más veces de las que especificó.  
  
 Si la actual <xref:System.Threading.Semaphore> objeto representa un semáforo de sistema con nombre, el usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero. El ejemplo inicia cinco subprocesos que se bloquean en espera para el semáforo. El subproceso principal utiliza los <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos entrar en el semáforo. Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, llama a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo.  
  
 Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior. Uso del semáforo del seguimiento mensajes de consola. El intervalo de trabajo simulado aumenta ligeramente por cada subproceso, para facilitar la lectura de la salida.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> is less than 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">The semaphore count is already at the maximum value.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred with a named semaphore.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.  -or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</param>
        <summary>Sets the access control security for a named system semaphore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede establecer la seguridad de control de acceso sólo en <xref:System.Threading.Semaphore> objetos que representan semáforos de sistema con nombre.  
  
 El usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> derechos para llamar a este método y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> derechos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.  
  
 Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo pero le concede el derecho a leer y cambiar los permisos en el semáforo.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.  
  
 Una vez cambiados los permisos, mediante el <xref:System.Threading.Semaphore.SetAccessControl%2A> método, el semáforo se abre con los derechos necesarios para entrada y liberación. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.  -or-  The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</exception>
        <exception cref="T:System.NotSupportedException">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el semáforo con nombre no existe, este método no la crea. Para crear el semáforo del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tenga un `name` parámetro.  
  
 Si no está seguro de si existe un semáforo con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método que produce una excepción si el semáforo no existe.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Semaphore.TryOpenExisting%2A> sobrecarga del método y especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit. Especificar el <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso para entrar en el semáforo y especificando la <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el semáforo con nombre no existe, este método no la crea. Para crear el semáforo del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tenga un `name` parámetro.  
  
 Si no está seguro de si existe un semáforo con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método que produce una excepción si el semáforo no existe.  
  
 El `rights` debe incluir el parámetro la <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos entran en el semáforo y el <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
 Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Semaphore> objeto, incluso si los objetos que se devuelven representan el mismo semáforo con nombre sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
      </Docs>
    </Member>
  </Members>
</Type>