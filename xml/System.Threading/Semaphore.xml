<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530949" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="a1dc0-101">Limita el número de subprocesos que pueden tener acceso a un recurso o grupo de recursos simultáneamente.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a1dc0-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-102">Use la <xref:System.Threading.Semaphore> clase para controlar el acceso a un grupo de recursos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="a1dc0-103">Subprocesos entran en el semáforo mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método, que se hereda de la <xref:System.Threading.WaitHandle> clase y libere el semáforo mediante una llamada a la <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="a1dc0-104">El recuento en un semáforo es disminuye cada vez que un subproceso entra en el semáforo y aumenta cuando un subproceso libere el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="a1dc0-105">Cuando el recuento es cero, las solicitudes posteriores se bloquean hasta que otros subprocesos liberan el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="a1dc0-106">Cuando todos los subprocesos han liberado el semáforo, el recuento es el valor máximo especificado cuando se creó el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="a1dc0-107">No hay ningún orden garantizado, como FIFO, LIFO, en el que los subprocesos bloqueados entran el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-108">Un subproceso puede entrar varias veces, en el semáforo mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método varias veces.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="a1dc0-109">Para liberar algunas o todas estas entradas, el subproceso puede llamar sin parámetros <xref:System.Threading.Semaphore.Release> sobrecarga del método varias veces, o bien puede llamar a la <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método que especifica el número de entradas que se liberan.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="a1dc0-110">El <xref:System.Threading.Semaphore> clase no exige la identidad del subproceso en las llamadas a <xref:System.Threading.WaitHandle.WaitOne%2A> o <xref:System.Threading.Semaphore.Release%2A>.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="a1dc0-111">Es responsabilidad del programador asegurarse de que los subprocesos no liberen el semáforo demasiadas veces.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="a1dc0-112">Por ejemplo, supongamos que un semáforo tiene un recuento máximo de dos y que los subprocesos A y B entran el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="a1dc0-113">Si un error de programación en el subproceso B hace que llame a <xref:System.Threading.Semaphore.Release%2A> dos veces, ambas llamadas tendrán éxito.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="a1dc0-114">El recuento del semáforo está lleno y cuando el subproceso A finalmente llama a <xref:System.Threading.Semaphore.Release%2A>, se genera <xref:System.Threading.SemaphoreFullException>.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="a1dc0-115">Semáforos son de dos tipos: semáforos locales y semáforos de sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="a1dc0-116">Si crea un <xref:System.Threading.Semaphore> utilizando un constructor que acepta un nombre de objeto está asociado a un semáforo de sistema operativo de ese nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="a1dc0-117">Sistema semáforos son visibles en todo el sistema operativo y pueden utilizarse para sincronizar las actividades de procesos con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="a1dc0-118">Puede crear varias <xref:System.Threading.Semaphore> denominado de objetos que representan el mismo semáforo de sistema y puede usar el <xref:System.Threading.Semaphore.OpenExisting%2A> método para abrir una existente denominado semáforo del sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-119">Un semáforo local sólo existe dentro del proceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="a1dc0-120">La puede usar cualquier subproceso del proceso que tenga una referencia al objeto <xref:System.Threading.Semaphore> local.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="a1dc0-121">Cada <xref:System.Threading.Semaphore> objeto es un semáforo local distinto.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-122">En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="a1dc0-123">El ejemplo inicia cinco subprocesos que se bloquean en espera para el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="a1dc0-124">El subproceso principal utiliza los <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos entrar en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="a1dc0-125">Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, llama a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="a1dc0-126">Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="a1dc0-127">Uso del semáforo del seguimiento mensajes de consola.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-127">Console messages track semaphore use.</span></span> <span data-ttu-id="a1dc0-128">El intervalo de trabajo simulado aumenta ligeramente por cada subproceso, para facilitar la lectura de la salida.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="a1dc0-129">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a1dc0-129">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1dc0-130">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-130">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="a1dc0-131">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-131">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="a1dc0-132">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-132">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-133">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />, que especifica el número inicial de entradas y el número máximo de entradas simultáneas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-133">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-134">Este constructor inicializa un semáforo sin nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-134">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="a1dc0-135">Todos los subprocesos que utilizan una instancia de este tipo de semáforo deben tener referencias a la instancia.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-135">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="a1dc0-136">Si `initialCount` es menor que `maximumCount`, el efecto es el mismo que si el subproceso actual hubiera llamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-136">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="a1dc0-137">Si no desea reservar entradas para el subproceso que crea el semáforo, use el mismo número de `maximumCount` y `initialCount`.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-137">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-138">En el ejemplo siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-138">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="a1dc0-139">El ejemplo inicia cinco subprocesos que se bloquean en espera para el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-139">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="a1dc0-140">El subproceso principal utiliza los <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos entrar en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-140">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="a1dc0-141">Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, llama a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-141">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="a1dc0-142">Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-142">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="a1dc0-143">Uso del semáforo del seguimiento mensajes de consola.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-143">Console messages track semaphore use.</span></span> <span data-ttu-id="a1dc0-144">El intervalo de trabajo simulado aumenta ligeramente por cada subproceso, para facilitar la lectura de la salida.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-144">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a1dc0-145">
            <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-145">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1dc0-146">
            <paramref name="maximumCount" /> es menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-146">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="a1dc0-147">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-147">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-148">
            <paramref name="initialCount" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-148">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="a1dc0-149">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-149">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="a1dc0-150">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-150">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="a1dc0-151">Nombre de un objeto de semáforo del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-151">The name of a named system semaphore object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-152">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />, que especifica el número inicial de entradas y el número máximo de entradas simultáneas, y especificando de forma opcional el nombre de un objeto semáforo de sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-152">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-153">Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-153">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="a1dc0-154">Puede crear varias <xref:System.Threading.Semaphore> denominado de objetos que representan el mismo semáforo de sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-154">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-155">Si el semáforo de sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-155">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="a1dc0-156">Si el semáforo de sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos siguen producen excepciones.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-156">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="a1dc0-157">Si necesita determinar si se creó un semáforo de sistema con nombre, use la <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> sobrecarga de constructor en su lugar.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-157">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a1dc0-158">Cuando utilice esta sobrecarga de constructor, la práctica recomendada es especificar el mismo número de `initialCount` y `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-158">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="a1dc0-159">Si `initialCount` es menor que `maximumCount`y se creó un semáforo de sistema con nombre, el efecto es el mismo que si el subproceso actual hubiera llamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-159">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="a1dc0-160">Sin embargo, con esta sobrecarga del constructor no hay ninguna manera de determinar si se creó un semáforo de sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-160">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="a1dc0-161">Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si se hubiera llamado el <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-161">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="a1dc0-162">Dado que los semáforos con nombre son visibles en todo el sistema operativo, puede utilizar para coordinar el uso de recursos en los límites del proceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-162">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="a1dc0-163">Si desea averiguar si existe un semáforo de sistema con nombre, use la <xref:System.Threading.Semaphore.OpenExisting%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-163">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="a1dc0-164">El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir un semáforo con nombre existente y produce una excepción si el semáforo del sistema no existe.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-164">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-165">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-165">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="a1dc0-166">En el ejemplo se crea un semáforo con nombre con un recuento máximo de cinco y un recuento inicial de cinco.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-166">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="a1dc0-167">El programa realiza tres llamadas a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-167">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a1dc0-168">Por lo tanto, si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia se bloqueará en la tercera llamada a <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-168">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="a1dc0-169">Liberar una o más entradas en la primera copia del programa para desbloquear a la segunda.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-169">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a1dc0-170">
            <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-170">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="a1dc0-171">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-171">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-172">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-172">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1dc0-173">
            <paramref name="maximumCount" /> es menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-173">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="a1dc0-174">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-174">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-175">
            <paramref name="initialCount" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-175">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-176">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-176">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-177">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-177">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="a1dc0-178">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-178">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1dc0-179">para llamar a código no administrado para crear un semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-179">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="a1dc0-180">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-180">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="a1dc0-181">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-181">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="a1dc0-182">Número inicial de solicitudes para el semáforo que se puede satisfacer simultáneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-182">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="a1dc0-183">Número máximo de solicitudes para el semáforo que se puede satisfacer simultáneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-183">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="a1dc0-184">Nombre de un objeto de semáforo del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-184">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="a1dc0-185">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se ha creado un semáforo local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se ha creado el semáforo del sistema con nombre especificado; es <see langword="false" /> si el semáforo del sistema con nombre especificado ya existía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-185">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="a1dc0-186">Este parámetro se pasa sin inicializar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-186">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-187">Inicializa una instancia nueva de la clase <see cref="T:System.Threading.Semaphore" />, especificando el número inicial de entradas y el número máximo de entradas simultáneas, especificando de forma opcional el nombre de un objeto semáforo de sistema y especificando una variable que recibe un valor que indica si se creó un semáforo del sistema nuevo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-187">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-188">Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-188">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="a1dc0-189">Puede crear varias <xref:System.Threading.Semaphore> denominado de objetos que representan el mismo semáforo de sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-189">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-190">Si el semáforo de sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-190">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="a1dc0-191">Si el semáforo de sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos siguen producen excepciones.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-191">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="a1dc0-192">Utilice `createdNew` para determinar si se creó el semáforo de sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-192">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="a1dc0-193">Si `initialCount` es menor que `maximumCount`, y `createdNew` es `true`, el efecto es el mismo que si el subproceso actual hubiera llamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-193">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="a1dc0-194">Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si se hubiera llamado el <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-194">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="a1dc0-195">En este caso, `createdNew` siempre es `true`.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-195">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="a1dc0-196">Dado que los semáforos con nombre son visibles en todo el sistema operativo, puede utilizar para coordinar el uso de recursos en los límites del proceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-196">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-197">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-197">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="a1dc0-198">En el ejemplo se crea un semáforo con nombre con un recuento máximo de cinco y un recuento inicial de dos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-198">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="a1dc0-199">Es decir, reserva tres entradas para el subproceso que llama al constructor.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-199">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="a1dc0-200">Si `createNew` es `false`, el programa realiza tres llamadas a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-200">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a1dc0-201">Por lo tanto, si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia se bloqueará en la tercera llamada a <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-201">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="a1dc0-202">Liberar una o más entradas en la primera copia del programa para desbloquear a la segunda.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-202">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a1dc0-203">
            <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-203">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="a1dc0-204">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-204">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-205">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-205">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1dc0-206">
            <paramref name="maximumCount" /> es menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-206">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="a1dc0-207">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-207">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-208">
            <paramref name="initialCount" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-208">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-209">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-209">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-210">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-210">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="a1dc0-211">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-211">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1dc0-212">para llamar a código no administrado para crear un semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-212">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="a1dc0-213">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-213">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="a1dc0-214">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-214">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="a1dc0-215">Número inicial de solicitudes para el semáforo que se puede satisfacer simultáneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-215">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="a1dc0-216">Número máximo de solicitudes para el semáforo que se puede satisfacer simultáneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-216">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="a1dc0-217">Nombre de un objeto de semáforo del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-217">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="a1dc0-218">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se ha creado un semáforo local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se ha creado el semáforo del sistema con nombre especificado; es <see langword="false" /> si el semáforo del sistema con nombre especificado ya existía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-218">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="a1dc0-219">Este parámetro se pasa sin inicializar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-219">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="semaphoreSecurity">
          <span data-ttu-id="a1dc0-220">Objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa la seguridad de control de acceso que se aplicará al semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-220">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-221">Inicializa una instancia nueva de la clase <see cref="T:System.Threading.Semaphore" />, especificando el número inicial de entradas y el número máximo de entradas simultáneas, especificando de forma opcional el nombre de un objeto semáforo de sistema, especificando una variable que recibe un valor que indica si se creó un semáforo del sistema y especificando la seguridad de control de acceso para el semáforo del sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-221">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-222">Utilice este constructor para aplicar la seguridad de control de acceso para un semáforo de sistema con nombre cuando se crea, impide que otro código tome el control del semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-222">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-223">Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-223">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="a1dc0-224">Puede crear varias <xref:System.Threading.Semaphore> denominado de objetos que representan el mismo semáforo de sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-224">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-225">Si el semáforo de sistema con nombre no existe, se crea con la seguridad de control de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-225">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="a1dc0-226">Si el semáforo con nombre existe, se omite la seguridad de control de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-226">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a1dc0-227">El llamador tiene control total sobre el recién creado <xref:System.Threading.Semaphore> objeto incluso si `semaphoreSecurity` deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-227">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="a1dc0-228">Sin embargo, si el usuario actual intenta obtener otro <xref:System.Threading.Semaphore> representar el mismo semáforo con nombre, utilizando un constructor de objeto o el <xref:System.Threading.Semaphore.OpenExisting%2A> método, se aplica la seguridad de control de acceso de Windows.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-228">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="a1dc0-229">Si el semáforo de sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-229">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="a1dc0-230">Si el semáforo de sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos siguen producen excepciones.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-230">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="a1dc0-231">Use la `createdNew` parámetro para determinar si este constructor creó el semáforo del sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-231">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="a1dc0-232">Si `initialCount` es menor que `maximumCount`, y `createdNew` es `true`, el efecto es el mismo que si el subproceso actual hubiera llamado <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-232">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="a1dc0-233">Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si se hubiera llamado el <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-233">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="a1dc0-234">En este caso, `createdNew` siempre es `true`.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-234">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="a1dc0-235">Dado que los semáforos con nombre son visibles en todo el sistema operativo, puede utilizar para coordinar el uso de recursos en los límites del proceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-235">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-236">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-236">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a1dc0-237">El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-237">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="a1dc0-238">Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo pero le concede el derecho a leer y cambiar los permisos en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-238">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="a1dc0-239">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-239">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="a1dc0-240">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-240">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="a1dc0-241">Una vez cambiados los permisos, se abre el semáforo con los derechos necesarios para entrada y liberación.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-241">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="a1dc0-242">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-242">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a1dc0-243">
            <paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-243">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="a1dc0-244">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-244">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-245">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-245">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1dc0-246">
            <paramref name="maximumCount" /> es menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-246">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="a1dc0-247">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-247">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-248">
            <paramref name="initialCount" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-248">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-249">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-249">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-250">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-250">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="a1dc0-251">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-251">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1dc0-252">para llamar a código no administrado para crear un semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-252">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="a1dc0-253">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-253">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="a1dc0-254">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-254">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a1dc0-255">Obtiene la seguridad de control de acceso para un semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-255">Gets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1dc0-256">Objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa la seguridad de control de acceso para el semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-256">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-257">El <xref:System.Threading.Semaphore.GetAccessControl%2A> método utiliza la siguiente combinación de indicadores (combinados mediante la operación OR bit a bit) para buscar los permisos: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, y <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-257">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a1dc0-258">El usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> derechos para llamar a este método y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> derechos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-258">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="a1dc0-259">En un semáforo local, la seguridad de control de acceso es irrelevante.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-259">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="a1dc0-260">Si el <xref:System.Threading.Semaphore> objeto no representa un semáforo de sistema con nombre, este método devuelve un <xref:System.Security.AccessControl.SemaphoreSecurity> objeto que concede todos los derechos a cualquier usuario.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-260">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-261">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-261">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a1dc0-262">El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-262">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-263">Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo, pero le concede el derecho a leer y cambiar los permisos en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-263">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-264">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-264">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="a1dc0-265">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-265">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="a1dc0-266">La seguridad de control de acceso para el semáforo del sistema se obtiene mediante la <xref:System.Threading.Semaphore.GetAccessControl%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-266">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="a1dc0-267">Una vez cambiados los permisos, se abre el semáforo con los derechos necesarios para entrada y liberación.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-267">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="a1dc0-268">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-268">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-269">El objeto <see cref="T:System.Threading.Semaphore" /> actual representa un semáforo del sistema con nombre y el usuario no tiene derechos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-269">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
          <span data-ttu-id="a1dc0-270">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-270">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-271">El objeto <see cref="T:System.Threading.Semaphore" /> actual representa un semáforo del sistema con nombre y no se abrió con <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-271">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a1dc0-272">No se admite para Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-272">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1dc0-273">Abre un semáforo con nombre especificado, si ya existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-273">Opens a specified named semaphore, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a1dc0-274">Nombre del semáforo del sistema que se va a abrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-274">The name of the system semaphore to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-275">Abre el semáforo con nombre especificado, si ya existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-275">Opens the specified named semaphore, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1dc0-276">Objeto que representa el semáforo del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-276">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-277">El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir el semáforo con nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-277">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="a1dc0-278">Si el semáforo del sistema no existe, este método produce una excepción en lugar de crear el semáforo del sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-278">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="a1dc0-279">Para crear el semáforo del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tenga un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-279">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="a1dc0-280">Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Semaphore> objeto, incluso si los objetos que se devuelven representan el mismo semáforo con nombre sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-280">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-281">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Semaphore.OpenExisting%2A> sobrecarga del método y especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-281">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="a1dc0-282">Especificar el <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso para entrar en el semáforo y especificando la <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-282">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-283">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-283">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a1dc0-284">El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-284">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-285">Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo, pero que concede el derecho a leer y cambiar permisos en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-285">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-286">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-286">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="a1dc0-287">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-287">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="a1dc0-288">Una vez cambiados los permisos, se abre el semáforo con los derechos necesarios para escribir y liberarla.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-288">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="a1dc0-289">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-289">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a1dc0-290">
            <paramref name="name" /> es una cadena vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-290">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="a1dc0-291">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-291">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-292">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-292">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1dc0-293">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-293">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="a1dc0-294">El semáforo con nombre no existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-294">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-295">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-295">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-296">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-296">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1dc0-297">para llamar a código no administrado para abrir un semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-297">for calling unmanaged code to open a named system semaphore.</span>
          </span>
          <span data-ttu-id="a1dc0-298">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="a1dc0-299">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-299">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a1dc0-300">Nombre del semáforo del sistema que se va a abrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-300">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="a1dc0-301">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-301">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-302">Abre el semáforo con nombre especificado, si ya existe, con el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-302">Opens the specified named semaphore, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1dc0-303">Objeto que representa el semáforo del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-303">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-304">El `rights` debe incluir el parámetro la <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos entran en el semáforo y el <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-304">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="a1dc0-305">El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir un semáforo con nombre existente.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-305">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="a1dc0-306">Si el semáforo del sistema no existe, este método produce una excepción en lugar de crear el semáforo del sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-306">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="a1dc0-307">Para crear el semáforo del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tenga un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-307">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="a1dc0-308">Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Semaphore> objeto, incluso si los objetos que se devuelven representan el mismo semáforo con nombre sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-308">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-309">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-309">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a1dc0-310">El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-310">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-311">Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo, pero le concede el derecho a leer y cambiar los permisos en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-311">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-312">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-312">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="a1dc0-313">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-313">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="a1dc0-314">Una vez cambiados los permisos, se abre el semáforo con los derechos necesarios para escribir y liberarla.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-314">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="a1dc0-315">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-315">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a1dc0-316">
            <paramref name="name" /> es una cadena vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-316">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="a1dc0-317">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-317">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-318">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-318">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1dc0-319">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-319">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="a1dc0-320">El semáforo con nombre no existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-320">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-321">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-321">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-322">El semáforo con nombre existe, pero el usuario no tiene los derechos de acceso de seguridad deseados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-322">The named semaphore exists, but the user does not have the desired security access rights.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="a1dc0-323">para llamar a código no administrado para crear un semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-323">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="a1dc0-324">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-324">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="a1dc0-325">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-325">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1dc0-326">Sale del semáforo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-326">Exits the semaphore.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a1dc0-327">Sale del semáforo y devuelve el recuento anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-327">Exits the semaphore and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1dc0-328">Recuento en el semáforo antes de la llamada al método <see cref="Overload:System.Threading.Semaphore.Release" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-328">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-329">Los subprocesos normalmente utilizan el <xref:System.Threading.WaitHandle.WaitOne%2A> método para entrar en el semáforo y se suele utilizar esta sobrecarga del método para salir.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-329">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="a1dc0-330">Si un <xref:System.Threading.SemaphoreFullException> producida por la <xref:System.Threading.Semaphore.Release%2A> método, no indica necesariamente un problema con el subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-330">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="a1dc0-331">Un error de programación en otro subproceso haya podido provocar que ese subproceso que sale del semáforo más veces de las que especificó.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-331">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="a1dc0-332">Si la actual <xref:System.Threading.Semaphore> objeto representa un semáforo de sistema con nombre, el usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-332">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-333">En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-333">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="a1dc0-334">El ejemplo inicia cinco subprocesos que se bloquean en espera para el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-334">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="a1dc0-335">El subproceso principal utiliza los <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos entrar en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-335">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="a1dc0-336">Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, llama a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-336">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-337">Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-337">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="a1dc0-338">Uso del semáforo del seguimiento mensajes de consola.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-338">Console messages track semaphore use.</span></span> <span data-ttu-id="a1dc0-339">El intervalo de trabajo simulado aumenta ligeramente por cada subproceso, para facilitar la lectura de la salida.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-339">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="a1dc0-340">El recuento del semáforo ya está en el valor máximo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-340">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-341">Error de Win32 con un semáforo con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-341">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-342">El semáforo actual representa un semáforo de sistema con nombre, pero el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-342">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
          <span data-ttu-id="a1dc0-343">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-343">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-344">El semáforo actual representa un semáforo de sistema con nombre, pero no se abrió con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-344">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">
          <span data-ttu-id="a1dc0-345">Número de veces que se abandona el semáforo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-345">The number of times to exit the semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-346">Sale del semáforo un número especificado de veces y devuelve el recuento anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-346">Exits the semaphore a specified number of times and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1dc0-347">Recuento en el semáforo antes de la llamada al método <see cref="Overload:System.Threading.Semaphore.Release" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-347">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-348">Si un subproceso ha entrado varias veces en el semáforo, esta sobrecarga del método permite el recuento del semáforo completo que se restaurarán con una llamada.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-348">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="a1dc0-349">Si un <xref:System.Threading.SemaphoreFullException> producida por la <xref:System.Threading.Semaphore.Release%2A> método, no indica necesariamente un problema con el subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-349">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="a1dc0-350">Un error de programación en otro subproceso haya podido provocar que ese subproceso que sale del semáforo más veces de las que especificó.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-350">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="a1dc0-351">Si la actual <xref:System.Threading.Semaphore> objeto representa un semáforo de sistema con nombre, el usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-351">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-352">En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-352">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="a1dc0-353">El ejemplo inicia cinco subprocesos que se bloquean en espera para el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-353">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="a1dc0-354">El subproceso principal utiliza los <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos entrar en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-354">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="a1dc0-355">Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, llama a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-355">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-356">Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-356">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="a1dc0-357">Uso del semáforo del seguimiento mensajes de consola.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-357">Console messages track semaphore use.</span></span> <span data-ttu-id="a1dc0-358">El intervalo de trabajo simulado aumenta ligeramente por cada subproceso, para facilitar la lectura de la salida.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-358">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a1dc0-359">
            <paramref name="releaseCount" /> es menor que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-359">
              <paramref name="releaseCount" /> is less than 1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="a1dc0-360">El recuento del semáforo ya está en el valor máximo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-360">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-361">Error de Win32 con un semáforo con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-361">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-362">El semáforo actual representa un semáforo de sistema con nombre, pero el usuario no tiene derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-362">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
          <span data-ttu-id="a1dc0-363">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-363">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-364">El semáforo actual representa un semáforo de sistema con nombre, pero no se abrió con derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-364">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">
          <span data-ttu-id="a1dc0-365">Objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa la seguridad de control de acceso que se aplicará al semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-365">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-366">Establece la seguridad de control de acceso para un semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-366">Sets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-367">Puede establecer la seguridad de control de acceso sólo en <xref:System.Threading.Semaphore> objetos que representan semáforos de sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-367">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="a1dc0-368">El usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> derechos para llamar a este método y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> derechos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-368">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1dc0-369">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-369">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="a1dc0-370">El ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un semáforo con nombre.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-370">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-371">Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a utilizar el semáforo pero le concede el derecho a leer y cambiar los permisos en el semáforo.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-371">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="a1dc0-372">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-372">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="a1dc0-373">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-373">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="a1dc0-374">Una vez cambiados los permisos, mediante el <xref:System.Threading.Semaphore.SetAccessControl%2A> método, el semáforo se abre con los derechos necesarios para entrada y liberación.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-374">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="a1dc0-375">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-375">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1dc0-376">
            <paramref name="semaphoreSecurity" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-376">
              <paramref name="semaphoreSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-377">El usuario no tiene los derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-377">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
          <span data-ttu-id="a1dc0-378">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-378">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-379">El semáforo no se abrió con derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-379">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a1dc0-380">El objeto <see cref="T:System.Threading.Semaphore" /> actual no representa un semáforo de sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-380">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a1dc0-381">Abre un semáforo con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-381">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a1dc0-382">Nombre del semáforo del sistema que se va a abrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-382">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="a1dc0-383">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Semaphore" /> que representa el semáforo con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-383">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="a1dc0-384">Este parámetro se trata como sin inicializar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-384">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-385">Abre el semáforo con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-385">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1dc0-386">
            <see langword="true" /> si el semáforo con nombre se abrió correctamente; si no, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-386">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-387">Si el semáforo con nombre no existe, este método no la crea.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-387">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="a1dc0-388">Para crear el semáforo del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tenga un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-388">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="a1dc0-389">Si no está seguro de si existe un semáforo con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método que produce una excepción si el semáforo no existe.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-389">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="a1dc0-390">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Semaphore.TryOpenExisting%2A> sobrecarga del método y especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-390">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="a1dc0-391">Especificar el <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso para entrar en el semáforo y especificando la <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-391">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a1dc0-392">
            <paramref name="name" /> es una cadena vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-392">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="a1dc0-393">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-393">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-394">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-394">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1dc0-395">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-395">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-396">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-396">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-397">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-397">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="a1dc0-398">Nombre del semáforo del sistema que se va a abrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-398">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="a1dc0-399">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-399">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="a1dc0-400">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Semaphore" /> que representa el semáforo con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-400">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="a1dc0-401">Este parámetro se trata como sin inicializar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-401">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a1dc0-402">Abre el semáforo con nombre especificado, si ya existe, con el acceso de seguridad deseado, y devuelve un valor que indica si la operación se realizó correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-402">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a1dc0-403">
            <see langword="true" /> si el semáforo con nombre se abrió correctamente; si no, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-403">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1dc0-404">Si el semáforo con nombre no existe, este método no la crea.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-404">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="a1dc0-405">Para crear el semáforo del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tenga un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-405">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="a1dc0-406">Si no está seguro de si existe un semáforo con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método que produce una excepción si el semáforo no existe.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-406">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="a1dc0-407">El `rights` debe incluir el parámetro la <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos entran en el semáforo y el <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Semaphore.Release%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-407">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="a1dc0-408">Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Semaphore> objeto, incluso si los objetos que se devuelven representan el mismo semáforo con nombre sistema.</span><span class="sxs-lookup"><span data-stu-id="a1dc0-408">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a1dc0-409">
            <paramref name="name" /> es una cadena vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-409">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="a1dc0-410">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-410">-or-</span>
          </span>
          <span data-ttu-id="a1dc0-411">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-411">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a1dc0-412">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-412">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="a1dc0-413">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-413">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="a1dc0-414">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a1dc0-414">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>