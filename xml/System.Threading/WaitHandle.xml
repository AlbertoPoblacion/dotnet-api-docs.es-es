<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9c30c9bf2d271da2afe9d173213a99d04fceefda" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="a0db4-101">Encapsula los objetos específicos del sistema operativo que esperan obtener un acceso exclusivo a los recursos compartidos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0db4-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-102">La <xref:System.Threading.WaitHandle> clase encapsula identificadores de sincronización de Win32 y se utiliza para representar todos los objetos de sincronización en el tiempo de ejecución que permiten varias operaciones de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="a0db4-103">Para obtener una comparación de identificadores de espera con otros objetos de sincronización, vea [información general sobre los primitivos de sincronización](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="a0db4-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="a0db4-104">La <xref:System.Threading.WaitHandle> clase es abstracta.</span><span class="sxs-lookup"><span data-stu-id="a0db4-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="a0db4-105">Las clases derivadas de <xref:System.Threading.WaitHandle> definir un mecanismo de señalización para indicar que están tomando o liberando acceso a un recurso compartido, pero usan el heredados <xref:System.Threading.WaitHandle> métodos para bloquear mientras se espera para el acceso a recursos comparten.</span><span class="sxs-lookup"><span data-stu-id="a0db4-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="a0db4-106">Las clases derivadas de <xref:System.Threading.WaitHandle> incluyen:</span><span class="sxs-lookup"><span data-stu-id="a0db4-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="a0db4-107">La clase <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="a0db4-108">Vea [exclusiones mutuas](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="a0db4-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="a0db4-109">El <xref:System.Threading.EventWaitHandle> clase y sus clases derivadas, <xref:System.Threading.AutoResetEvent> y <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="a0db4-110">Vea [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="a0db4-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="a0db4-111">La clase <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="a0db4-112">Vea [Semaphore y SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="a0db4-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="a0db4-113">Los subprocesos pueden bloquear en un identificador de espera individual llamando al método de instancia <xref:System.Threading.WaitHandle.WaitOne%2A>, que es heredado por las clases derivadas de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="a0db4-114">Las clases derivadas de <xref:System.Threading.WaitHandle> difieren en su afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="a0db4-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="a0db4-115">Identificadores de espera de evento (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, y <xref:System.Threading.ManualResetEvent>) y los semáforos no tienen afinidad de subprocesos; cualquier subproceso puede señalar un identificador de espera de evento o un semáforo.</span><span class="sxs-lookup"><span data-stu-id="a0db4-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="a0db4-116">Las exclusiones mutuas, por otro lado, tienen afinidad de subprocesos; el subproceso que posee una exclusión mutua debe liberarlo y se produce una excepción si un subproceso llama a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método en una exclusión mutua que no le pertenece.</span><span class="sxs-lookup"><span data-stu-id="a0db4-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="a0db4-117">Dado que la <xref:System.Threading.WaitHandle> clase se deriva de <xref:System.MarshalByRefObject>, estas clases se pueden utilizar para sincronizar las actividades de subprocesos en los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="a0db4-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="a0db4-118">Además de sus clases derivadas, la <xref:System.Threading.WaitHandle> clase tiene un número de métodos estáticos que bloquea un subproceso hasta que uno o más objetos de sincronización reciban una señal...</span><span class="sxs-lookup"><span data-stu-id="a0db4-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="a0db4-119">Se incluyen los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0db4-119">These include:</span></span>  
  
-   <span data-ttu-id="a0db4-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, que permite que un subproceso indicar un identificador de espera y espere inmediatamente a otro.</span><span class="sxs-lookup"><span data-stu-id="a0db4-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="a0db4-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, que permite que un subproceso debe esperar hasta que todos los identificadores de espera de una matriz reciban una señal.</span><span class="sxs-lookup"><span data-stu-id="a0db4-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="a0db4-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, que permite que un subproceso debe esperar hasta que se haya señalado cualquiera de un conjunto de identificadores de espera especificado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="a0db4-123">Las sobrecargas de estos métodos proporcionan intervalos de tiempo de espera para abandonar la espera y la oportunidad de salir de un contexto de sincronización antes de entrar en la espera, que permite que otros subprocesos utilizar el contexto de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0db4-124">Este tipo implementa la <xref:System.IDisposable> interfaz.</span><span class="sxs-lookup"><span data-stu-id="a0db4-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="a0db4-125">Cuando haya terminado de utilizar el tipo o un tipo derivado de éste, debe eliminar del mismo directa o indirectamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="a0db4-126">Para deshacerse del tipo directamente, llame a su <xref:System.Threading.WaitHandle.Close%2A> método en un `try` / `catch` bloque.</span><span class="sxs-lookup"><span data-stu-id="a0db4-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="a0db4-127">Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="a0db4-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="a0db4-128">Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="a0db4-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="a0db4-129"><xref:System.Threading.WaitHandle> implementa el <xref:System.IDisposable.Dispose%2A> patrón.</span><span class="sxs-lookup"><span data-stu-id="a0db4-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="a0db4-130">Vea [patrón de Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="a0db4-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="a0db4-131">Al derivar de <xref:System.Threading.WaitHandle>, use el <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad para almacenar el identificador del sistema operativo de identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="a0db4-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="a0db4-132">No es necesario reemplazar el protegido <xref:System.Threading.WaitHandle.Dispose%2A> método a menos que utilice recursos no administrados adicionales.</span><span class="sxs-lookup"><span data-stu-id="a0db4-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-133">El siguiente ejemplo de código muestra cómo dos subprocesos pueden realizan tareas en segundo plano mientras el método Main subproceso espera a que las tareas se completan mediante el método estático <xref:System.Threading.WaitHandle.WaitAny%2A> y <xref:System.Threading.WaitHandle.WaitAll%2A> métodos de la <xref:System.Threading.WaitHandle> clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="a0db4-134">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0db4-134">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-135">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-136">Libera todos los recursos mantenidos por el objeto <see cref="T:System.Threading.WaitHandle" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-137">Este método es una implementación pública de la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método para el <xref:System.Threading.WaitHandle> clase y sus clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="a0db4-138">Proporciona una implementación estándar que llama el `Dispose(Boolean)` sobrecarga con un `true` argumento y, a continuación, llama el <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a0db4-139">Llamar a este método para liberar todos los recursos mantenidos por una instancia de `WaitHandle` o una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="a0db4-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="a0db4-140">Una vez que se llama a este método, las referencias a la instancia actual provocar un comportamiento indefinido.</span><span class="sxs-lookup"><span data-stu-id="a0db4-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-141">Llame siempre a <xref:System.Threading.WaitHandle.Close%2A> o <xref:System.Threading.WaitHandle.Dispose> antes de liberar la última referencia a la <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="a0db4-142">En caso contrario, no se liberarán los recursos que está usando.</span><span class="sxs-lookup"><span data-stu-id="a0db4-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0db4-143">Debe invalidar el <see langword="Dispose(Boolean)" /> método para liberar los recursos asignados en las clases derivadas.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0db4-143">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-144">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-145">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-146">Este método es equivalente a la <xref:System.Threading.WaitHandle.Close%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-147">Llame siempre a <xref:System.Threading.WaitHandle.Close%2A> o <xref:System.Threading.WaitHandle.Dispose> antes de liberar la última referencia a la <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="a0db4-148">En caso contrario, no se liberarán los recursos que está usando.</span><span class="sxs-lookup"><span data-stu-id="a0db4-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="a0db4-149">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-149">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-150">Cuando se reemplaza en una clase derivada, libera los recursos no administrados que usa <see cref="T:System.Threading.WaitHandle" /> y, de forma opcional, libera los recursos administrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-151">Este método es invocado por el <xref:System.Threading.WaitHandle.Close%2A> y <xref:System.Threading.WaitHandle.Dispose> métodos con el `explicitDisposing` parámetro establecido en `true`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="a0db4-152">Cuando el `explicitDisposing` parámetro es `true`, este método libera todos los recursos retenidos por los objetos administrados que este <xref:System.Threading.WaitHandle> referencias a objetos.</span><span class="sxs-lookup"><span data-stu-id="a0db4-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0db4-153">Debe invalidar el <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> método para liberar los recursos asignados en las clases derivadas.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0db4-153">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
            <span data-ttu-id="a0db4-154">El <see cref="M:System.Threading.WaitHandle.Close" /> o <see cref="M:System.Threading.WaitHandle.Dispose" /> método puede recibir varias llamadas de otros objetos.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0db4-154">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="a0db4-155">Al reemplazar este método, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" /> o <see langword="Close" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0db4-155">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-156">Obtiene o establece el identificador del sistema operativo nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-156">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a0db4-157">
            <see langword="IntPtr" /> que representa el identificador del sistema operativo nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-157">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="a0db4-158">El valor predeterminado es el valor del campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-158">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-159">Asignar un nuevo valor para el <xref:System.Threading.WaitHandle.Handle%2A> propiedad no cierra el identificador anterior.</span><span class="sxs-lookup"><span data-stu-id="a0db4-159">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="a0db4-160">Esto puede dar lugar a un identificador con pérdidas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-160">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="a0db4-161">No utilice esta propiedad en .NET Framework versión 2.0 o posterior; Utilice la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad en su lugar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-161">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="a0db4-162">Establecer esta propiedad en un identificador válido también establece la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad, pero si se establece en <xref:System.Threading.WaitHandle.InvalidHandle> puede dar lugar a un identificador con pérdidas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-162">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a0db4-163">Requiere plena confianza para el llamador inmediato establecer el valor de propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-163">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="a0db4-164">Este miembro no se puede establecer mediante código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-164">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="a0db4-165">Los tipos derivados deben tener <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para establecer el valor de propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-165">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-166">Representa un identificador del sistema operativo nativo no válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-166">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="a0db4-167">Este campo es de solo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-167">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-168">Se usa internamente para inicializar el <xref:System.Threading.WaitHandle.Handle%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="a0db4-168">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0db4-169">Puede utilizar este valor para determinar si el <see cref="P:System.Threading.WaitHandle.Handle" /> propiedad contiene un identificador de sistema operativo nativo válido.</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0db4-169">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-170">Obtiene o establece el identificador del sistema operativo nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-170">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a0db4-171">
            <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> que representa el identificador del sistema operativo nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-172">Cuando asigna un nuevo valor para el <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad, se cerrará el identificador anterior al anterior <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> los objetos se recogen.</span><span class="sxs-lookup"><span data-stu-id="a0db4-172">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="a0db4-173">No cierre el identificador manualmente, ya que esto da como resultado un <xref:System.ObjectDisposedException> cuando el <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> intenta cerrar el identificador.</span><span class="sxs-lookup"><span data-stu-id="a0db4-173">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="a0db4-174"><xref:System.Threading.WaitHandle> implementa el <xref:System.IDisposable.Dispose%2A> patrón.</span><span class="sxs-lookup"><span data-stu-id="a0db4-174"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="a0db4-175">Vea [patrón de Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="a0db4-175">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="a0db4-176">Al derivar de <xref:System.Threading.WaitHandle>, use el <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad para almacenar el identificador del sistema operativo de identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="a0db4-176">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="a0db4-177">No es necesario reemplazar el protegido <xref:System.Threading.WaitHandle.Dispose%2A> método a menos que utilice recursos no administrados adicionales.</span><span class="sxs-lookup"><span data-stu-id="a0db4-177">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="a0db4-178">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-178">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="a0db4-179">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-179">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="a0db4-180">Los tipos derivados deben tener <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para llamar a este miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-180">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-181">Señala un <see cref="T:System.Threading.WaitHandle" /> y espera en otro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-181">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="a0db4-182">
            <see cref="T:System.Threading.WaitHandle" /> que se va a señalar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-182">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="a0db4-183">
            <see cref="T:System.Threading.WaitHandle" /> en donde se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-183">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-184">Señala un <see cref="T:System.Threading.WaitHandle" /> y espera en otro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-184">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-185">
            <see langword="true" /> si la señal y la espera finalizan correctamente; si la espera no finaliza, el método no devuelve ningún resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-185">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-186">Esta operación no se garantiza para ser atómicas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-186">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="a0db4-187">Después de las señales de subproceso actual `toSignal` pero antes de que espera en `toWaitOn`, podría señalar a un subproceso que se ejecuta en otro procesador `toWaitOn` o esperar en él.</span><span class="sxs-lookup"><span data-stu-id="a0db4-187">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-188">El siguiente ejemplo de código utiliza el <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga del método para permitir que el subproceso principal indicar un subproceso bloqueado y, a continuación, espere a que el subproceso finalice una tarea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-188">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="a0db4-189">El ejemplo inicia cinco subprocesos, se les permite bloquearse en un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca y a continuación versiones un subproceso cada vez el usuario presiona la tecla ENTRAR.</span><span class="sxs-lookup"><span data-stu-id="a0db4-189">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="a0db4-190">En el ejemplo, a continuación, pone en cola otros cinco subprocesos y se liberan todos ellos utilizando una <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="a0db4-190">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-191">
            <paramref name="toSignal" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-191">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-192">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-192">-or-</span>
          </span>
          <span data-ttu-id="a0db4-193">
            <paramref name="toWaitOn" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-193">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-194">Se llamó al método en un subproceso con <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-194">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="a0db4-195">No se admite este método en Windows 98 ni en Windows Millennium.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-195">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-196">
            <paramref name="toSignal" /> es un semáforo y su contador ya está completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-196">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-197">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-197">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-198">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-198">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="a0db4-199">
            <see cref="T:System.Threading.WaitHandle" /> que se va a señalar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-199">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="a0db4-200">
            <see cref="T:System.Threading.WaitHandle" /> en donde se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-200">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a0db4-201">Entero que representa el intervalo que se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-201">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="a0db4-202">Si el valor es <see cref="F:System.Threading.Timeout.Infinite" />, esto es, -1, la espera es infinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-202">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a0db4-203">
            <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-203">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-204">Señala un <see cref="T:System.Threading.WaitHandle" /> y espera en otro, para lo que determina un intervalo de tiempo de espera como entero con signo de 32 bits y especifica si se sale del dominio de sincronización para el contexto antes de entrar en la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-204">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-205">Es <see langword="true" /> si la señal y la espera finalizan correctamente, o <see langword="false" /> si la señal finaliza pero el tiempo de la espera se agota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-205">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-206">Esta operación no se garantiza para ser atómicas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-206">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="a0db4-207">Después de las señales de subproceso actual `toSignal` pero antes de que espera en `toWaitOn`, podría señalar a un subproceso que se ejecuta en otro procesador `toWaitOn` o esperar en él.</span><span class="sxs-lookup"><span data-stu-id="a0db4-207">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="a0db4-208">Si `millisecondsTimeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-208">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-209">Comprueba que el estado de la `toWaitOn` y se devuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-209">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a0db4-210">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="a0db4-210">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a0db4-211">El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-211">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a0db4-212">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-212">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a0db4-213">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a0db4-213">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a0db4-214">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-214">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="a0db4-215">El subproceso vuelve al contexto no predeterminado original después de llamar a la <xref:System.Threading.WaitHandle.SignalAndWait%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="a0db4-215">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="a0db4-216">Esto puede ser útil cuando la clase enlazadas a un contexto tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-216">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a0db4-217">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-217">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a0db4-218">Si el código de la pila de llamadas de un miembro llama el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-218">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a0db4-219">Cuando el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-219">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-220">
            <paramref name="toSignal" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-220">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-221">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-221">-or-</span>
          </span>
          <span data-ttu-id="a0db4-222">
            <paramref name="toWaitOn" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-222">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-223">Se llama al método en un subproceso con <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-223">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="a0db4-224">No se admite este método en Windows 98 ni en Windows Millennium.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-224">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-225">No se puede señalar a <see cref="T:System.Threading.WaitHandle" /> porque se superaría su recuento máximo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-225">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-226">
            <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-226">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-227">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-227">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-228">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-228">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="a0db4-229">
            <see cref="T:System.Threading.WaitHandle" /> que se va a señalar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-229">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="a0db4-230">
            <see cref="T:System.Threading.WaitHandle" /> en donde se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-230">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a0db4-231">
            <see cref="T:System.TimeSpan" /> que representa el intervalo que se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-231">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="a0db4-232">Si el valor es -1, la espera es infinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-232">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a0db4-233">
            <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-233">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-234">Señala un <see cref="T:System.Threading.WaitHandle" /> y espera en otro, para lo que determina el intervalo de tiempo de espera como <see cref="T:System.TimeSpan" /> y especifica si se sale del dominio de sincronización para el contexto antes de entrar en la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-234">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-235">Es <see langword="true" /> si la señal y la espera finalizan correctamente, o <see langword="false" /> si la señal finaliza pero el tiempo de la espera se agota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-235">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-236">Esta operación no se garantiza para ser atómicas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-236">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="a0db4-237">Después de las señales de subproceso actual `toSignal` pero antes de que espera en `toWaitOn`, podría señalar a un subproceso que se ejecuta en otro procesador `toWaitOn` o esperar en él.</span><span class="sxs-lookup"><span data-stu-id="a0db4-237">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="a0db4-238">El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-238">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a0db4-239">Si `timeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-239">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-240">Comprueba que el estado de la `toWaitOn` y se devuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-240">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a0db4-241">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="a0db4-241">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a0db4-242">El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-242">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a0db4-243">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-243">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a0db4-244">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a0db4-244">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a0db4-245">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-245">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="a0db4-246">El subproceso vuelve al contexto no predeterminado original después de llamar a la <xref:System.Threading.WaitHandle.SignalAndWait%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="a0db4-246">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="a0db4-247">Esto puede ser útil cuando la clase enlazadas a un contexto tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-247">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a0db4-248">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-248">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a0db4-249">Si el código de la pila de llamadas de un miembro llama el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-249">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a0db4-250">Cuando el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-250">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-251">
            <paramref name="toSignal" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-251">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-252">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-252">-or-</span>
          </span>
          <span data-ttu-id="a0db4-253">
            <paramref name="toWaitOn" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-253">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-254">Se llamó al método en un subproceso con <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-254">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="a0db4-255">No se admite este método en Windows 98 ni en Windows Millennium.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-255">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-256">
            <paramref name="toSignal" /> es un semáforo y su contador ya está completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-256">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-257">
            <paramref name="timeout" /> se evalúa como un número negativo de milisegundos distinto de -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-257">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="a0db4-258">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-258">-or-</span>
          </span>
          <span data-ttu-id="a0db4-259">
            <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-259">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-260">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-260">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-261">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-261">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-262">Espera a que todos los elementos de la matriz especificada reciban una señal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-262">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-263">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-263">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a0db4-264">Esta matriz no puede contener varias referencias al mismo objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-264">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-265">Espera a que todos los elementos de la matriz especificada reciban una señal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-265">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-266">
            <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> reciben una señal; en caso contrario, el método nunca devuelve ningún valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-266">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-267"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-267"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-268">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAll%2A> método `true` cuando se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-268">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-269">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-269">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-270">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-270">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-271">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-271">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-272">El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando se señalan todos los identificadores.</span><span class="sxs-lookup"><span data-stu-id="a0db4-272">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="a0db4-273">En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-273">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a0db4-274">Si la matriz contiene duplicados, se produce un error en la llamada con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-274">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-275">El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-275">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="a0db4-276">Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga del método y especificar -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` y `true` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-276">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-277">En el ejemplo de código siguiente se muestra cómo utilizar el grupo de subprocesos para crear y escribir en un grupo de archivos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a0db4-277">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="a0db4-278">Cada operación de escritura se pone en cola como un elemento de trabajo y las señales cuando haya finalizado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-278">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="a0db4-279">El subproceso principal espera a que todos los elementos señalar y, a continuación, se cierra.</span><span class="sxs-lookup"><span data-stu-id="a0db4-279">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-280">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-280">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-281">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-281">-or-</span>
          </span>
          <span data-ttu-id="a0db4-282">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-282">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-283">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-283">-or-</span>
          </span>
          <span data-ttu-id="a0db4-284">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-284">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="a0db4-285">En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="a0db4-285">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="a0db4-286">La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-286">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-287">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-287">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a0db4-288">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-288">-or-</span>
          </span>
          <span data-ttu-id="a0db4-289">El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-289">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a0db4-290">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-290">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-291">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-291">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-292">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-292">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-293">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-293">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-294">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-294">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a0db4-295">Esta matriz no puede contener varias referencias al mismo objeto (duplicados).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-295">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a0db4-296">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-296">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-297">Espera a que todos los elementos de la matriz especificada reciban una señal mediante un valor <see cref="T:System.Int32" /> para especificar el intervalo de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-297">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-298">
            <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> reciben una señal; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-298">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-299">Si `millisecondsTimeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-299">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-300">Comprueba el estado de los identificadores de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-300">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-301">El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando finaliza la espera, lo que significa que cuando se señalan todos los identificadores o cuando se produce el tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-301">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="a0db4-302">En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-302">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a0db4-303">Si hay duplicados en la matriz, se produce un error en la llamada con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-303">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-304">El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-304">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="a0db4-305">Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga y la especificación `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-305">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-306">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-306">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-307">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-307">-or-</span>
          </span>
          <span data-ttu-id="a0db4-308">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-308">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-309">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-309">-or-</span>
          </span>
          <span data-ttu-id="a0db4-310">
            <paramref name="waitHandles" /> es una matriz sin elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-310">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="a0db4-311">En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="a0db4-311">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="a0db4-312">La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-312">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-313">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-313">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a0db4-314">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-314">-or-</span>
          </span>
          <span data-ttu-id="a0db4-315">El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-315">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-316">
            <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-316">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-317">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-317">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-318">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-318">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-319">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-319">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-320">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-320">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a0db4-321">Esta matriz no puede contener varias referencias al mismo objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-321">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a0db4-322">
            <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-322">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-323">Espera a que todos los elementos de la matriz especificada reciban una señal, usando un valor <see cref="T:System.TimeSpan" /> para especificar el intervalo de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-323">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-324">
            <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> reciben una señal; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-324">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-325">Si `timeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-325">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-326">Comprueba el estado de los identificadores de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-326">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-327">El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando finaliza la espera, lo que significa que todos los identificadores están señalados o se produce un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-327">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="a0db4-328">En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-328">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a0db4-329">Si la matriz contiene duplicados, se producirá un error en la llamada.</span><span class="sxs-lookup"><span data-stu-id="a0db4-329">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-330">El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-330">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="a0db4-331">El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-331">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a0db4-332">Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga y la especificación `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-332">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-333">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-333">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-334">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-334">-or-</span>
          </span>
          <span data-ttu-id="a0db4-335">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-335">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-336">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-336">-or-</span>
          </span>
          <span data-ttu-id="a0db4-337">
            <paramref name="waitHandles" /> es una matriz sin elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-337">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="a0db4-338">En [.NET para aplicaciones de la Tienda Windows](http://go.microsoft.com/fwlink/?LinkID=247912) o la [Biblioteca de clases portable](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture en su lugar la excepción de clase base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="a0db4-338">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="a0db4-339">La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-339">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-340">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-340">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a0db4-341">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-341">-or-</span>
          </span>
          <span data-ttu-id="a0db4-342">El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-342">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-343">
            <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-343">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a0db4-344">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-344">-or-</span>
          </span>
          <span data-ttu-id="a0db4-345">
            <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-345">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-346">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-346">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-347">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-347">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-348">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-348">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-349">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-349">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a0db4-350">Esta matriz no puede contener varias referencias al mismo objeto (duplicados).</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-350">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a0db4-351">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-351">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a0db4-352">
            <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-352">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-353">Espera a que todos los elementos de la matriz especificada reciban una señal; usa un valor <see cref="T:System.Int32" /> para determinar el intervalo de tiempo y especifica si se va a salir del dominio de sincronización antes de finalizar la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-353">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-354">
            <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> reciben una señal; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-354">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-355">Si `millisecondsTimeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-355">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-356">Comprueba el estado de los identificadores de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-356">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-357"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-357"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-358">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAll%2A> método `true` cuando se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-358">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-359">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-359">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-360">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-360">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-361">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-361">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-362">El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando finaliza la espera, lo que significa que cuando se señalan todos los identificadores o cuando se produce el tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-362">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="a0db4-363">En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-363">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a0db4-364">Si hay duplicados en la matriz, se produce un error en la llamada con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-364">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-365">El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-365">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a0db4-366">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="a0db4-366">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a0db4-367">El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitAll%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-367">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a0db4-368">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-368">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a0db4-369">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a0db4-369">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a0db4-370">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-370">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="a0db4-371">El subproceso vuelve al contexto no predeterminado original después de llamar a la <xref:System.Threading.WaitHandle.WaitAll%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="a0db4-371">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="a0db4-372">Esto puede ser útil cuando la clase enlazadas a un contexto tiene la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="a0db4-372">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="a0db4-373">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-373">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a0db4-374">Si el código de la pila de llamadas de un miembro llama el <xref:System.Threading.WaitHandle.WaitAll%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-374">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a0db4-375">Cuando el <xref:System.Threading.WaitHandle.WaitAll%2A> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-375">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-376">En el ejemplo de código siguiente se muestra cómo utilizar el grupo de subprocesos para crear y escribir en un grupo de archivos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a0db4-376">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="a0db4-377">Cada operación de escritura se pone en cola como un elemento de trabajo y las señales cuando haya finalizado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-377">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="a0db4-378">El subproceso principal espera a que todos los elementos señalar y, a continuación, se cierra.</span><span class="sxs-lookup"><span data-stu-id="a0db4-378">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-379">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-379">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-380">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-380">-or-</span>
          </span>
          <span data-ttu-id="a0db4-381">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-381">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-382">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-382">-or-</span>
          </span>
          <span data-ttu-id="a0db4-383">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-383">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="a0db4-384">La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-384">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-385">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-385">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a0db4-386">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-386">-or-</span>
          </span>
          <span data-ttu-id="a0db4-387">El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-387">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a0db4-388">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-388">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-389">
            <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-389">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-390">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-390">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-391">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-391">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-392">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-392">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-393">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-393">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="a0db4-394">Esta matriz no puede contener varias referencias al mismo objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-394">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a0db4-395">
            <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-395">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a0db4-396">
            <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-396">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-397">Espera a que todos los elementos de la matriz especificada reciban una señal; usa un valor <see cref="T:System.TimeSpan" /> para determinar el intervalo de tiempo y especifica si se va a salir del dominio de sincronización antes de finalizar la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-397">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-398">Es <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> han recibido una señal; en caso contrario es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-398">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-399">Si `timeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-399">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-400">Comprueba el estado de los identificadores de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-400">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-401"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-401"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-402">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAll%2A> método `true` cuando se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-402">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-403">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-403">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-404">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-404">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-405">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-405">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-406">El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando finaliza la espera, lo que significa que todos los identificadores están señalados o se produce un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-406">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="a0db4-407">En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-407">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="a0db4-408">Si la matriz contiene duplicados, se producirá un error en la llamada.</span><span class="sxs-lookup"><span data-stu-id="a0db4-408">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-409">El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-409">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="a0db4-410">El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-410">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a0db4-411">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="a0db4-411">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a0db4-412">El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitAll%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-412">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a0db4-413">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-413">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a0db4-414">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a0db4-414">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a0db4-415">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-415">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="a0db4-416">Se devuelve al contexto no predeterminado original después de la llamada a la <xref:System.Threading.WaitHandle.WaitAll%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="a0db4-416">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="a0db4-417">Esto puede ser útil cuando la clase enlazadas a un contexto tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-417">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a0db4-418">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-418">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a0db4-419">Si el código de la pila de llamadas de un miembro llama el <xref:System.Threading.WaitHandle.WaitAll%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-419">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a0db4-420">Cuando el <xref:System.Threading.WaitHandle.WaitAll%2A> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-420">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-421">En el ejemplo de código siguiente se muestra cómo utilizar el grupo de subprocesos para crear y escribir en un grupo de archivos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a0db4-421">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="a0db4-422">Cada operación de escritura se pone en cola como un elemento de trabajo y las señales cuando haya finalizado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-422">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="a0db4-423">El subproceso principal espera a que todos los elementos señalar y, a continuación, se cierra.</span><span class="sxs-lookup"><span data-stu-id="a0db4-423">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-424">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-424">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-425">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-425">-or-</span>
          </span>
          <span data-ttu-id="a0db4-426">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-426">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-427">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-427">-or-</span>
          </span>
          <span data-ttu-id="a0db4-428">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-428">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="a0db4-429">La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-429">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-430">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-430">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="a0db4-431">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-431">-or-</span>
          </span>
          <span data-ttu-id="a0db4-432">El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-432">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a0db4-433">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-433">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-434">
            <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-434">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a0db4-435">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-435">-or-</span>
          </span>
          <span data-ttu-id="a0db4-436">
            <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-436">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-437">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-437">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-438">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-438">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-439">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-439">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-440">Espera a que cualquiera de los elementos de la matriz especificada reciba una señal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-440">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-441">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-441">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-442">Espera a que cualquiera de los elementos de la matriz especificada reciba una señal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-442">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-443">Índice de la matriz del objeto que satisfizo la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-443">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-444"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-444"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-445">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAny%2A> método `true` si la espera finaliza porque se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-445">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-446">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-446">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-447">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-447">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-448">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-448">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-449">El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce un <xref:System.Threading.AbandonedMutexException> sólo cuando finaliza la espera debido a un mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-449">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a0db4-450">Si `waitHandles` contiene una exclusión mutua liberada con un número de índice menor que el mutex abandonado la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.</span><span class="sxs-lookup"><span data-stu-id="a0db4-450">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-451">En las versiones de .NET Framework anterior a la versión 2.0, si un subproceso termina o se interrumpe sin liberar explícitamente un <xref:System.Threading.Mutex>y que `Mutex` está en el índice 0 (cero) en un `WaitAny` matriz en otro subproceso, el índice devuelto por `WaitAny` es 128 en lugar de 0.</span><span class="sxs-lookup"><span data-stu-id="a0db4-451">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="a0db4-452">Este método devuelve cuando se señala a cualquiera de ellos.</span><span class="sxs-lookup"><span data-stu-id="a0db4-452">This method returns when any handle is signaled.</span></span> <span data-ttu-id="a0db4-453">Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados.</span><span class="sxs-lookup"><span data-stu-id="a0db4-453">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a0db4-454">En algunas implementaciones, si se pasan 64 identificadores, más de un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-454">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="a0db4-455">Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga del método y especificar -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` y `true` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-455">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-456">En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-456">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-457">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-457">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-458">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-458">-or-</span>
          </span>
          <span data-ttu-id="a0db4-459">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-459">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-460">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-460">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a0db4-461">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-461">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-462">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-462">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-463">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-463">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a0db4-464">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-464">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-465">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-465">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-466">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-466">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a0db4-467">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-467">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-468">Espera a que cualquiera de los elementos de la matriz especificada reciba una señal, utilizando un entero de 32 bits con signo para especificar el intervalo de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-468">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-469">Índice de matriz del objeto que satisfizo la espera o <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si ningún objeto satisfizo la espera y transcurrió un intervalo de tiempo equivalente a <paramref name="millisecondsTimeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-469">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-470">Si `millisecondsTimeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-470">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-471">Comprueba el estado de los identificadores de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-471">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-472">El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce un <xref:System.Threading.AbandonedMutexException> sólo cuando finaliza la espera debido a un mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-472">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a0db4-473">Si `waitHandles` contiene una exclusión mutua liberada con un número de índice menor que el mutex abandonado la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.</span><span class="sxs-lookup"><span data-stu-id="a0db4-473">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="a0db4-474">Este método devuelve cuando finaliza la espera, cuando cualquiera de los identificadores está señalado o cuando se produce un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-474">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="a0db4-475">Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados.</span><span class="sxs-lookup"><span data-stu-id="a0db4-475">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a0db4-476">En algunas implementaciones, si se pasan 64 identificadores, más de un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-476">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="a0db4-477">Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga y la especificación `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-477">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-478">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-478">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-479">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-479">-or-</span>
          </span>
          <span data-ttu-id="a0db4-480">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-480">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-481">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-481">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-482">
            <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-482">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-483">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-483">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-484">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-484">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a0db4-485">
            <paramref name="waitHandles" /> es una matriz sin elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-485">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-486">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-486">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-487">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-487">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a0db4-488">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-488">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-489">Espera a que cualquiera de los elementos de la matriz especificada reciba una señal, usando un <see cref="T:System.TimeSpan" /> para especificar el intervalo de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-489">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-490">Índice de matriz del objeto que satisfizo la espera o <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si ningún objeto satisfizo la espera y transcurrió un intervalo de tiempo equivalente a <paramref name="timeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-490">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-491">Si `timeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-491">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-492">Comprueba el estado de los identificadores de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-492">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-493">El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce un <xref:System.Threading.AbandonedMutexException> sólo cuando finaliza la espera debido a un mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-493">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a0db4-494">Si `waitHandles` contiene una exclusión mutua liberada con un número de índice menor que el mutex abandonado la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.</span><span class="sxs-lookup"><span data-stu-id="a0db4-494">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="a0db4-495">Este método devuelve cuando finaliza la espera, cuando cualquiera de los identificadores está señalado o cuando se produce un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-495">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="a0db4-496">Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados.</span><span class="sxs-lookup"><span data-stu-id="a0db4-496">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a0db4-497">En algunas implementaciones, si se pasan 64 identificadores, más de un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-497">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="a0db4-498">El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-498">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a0db4-499">Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga y la especificación `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-499">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-500">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-500">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-501">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-501">-or-</span>
          </span>
          <span data-ttu-id="a0db4-502">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-502">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-503">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-503">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-504">
            <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-504">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a0db4-505">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-505">-or-</span>
          </span>
          <span data-ttu-id="a0db4-506">
            <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-506">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-507">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-507">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-508">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-508">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a0db4-509">
            <paramref name="waitHandles" /> es una matriz sin elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-509">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-510">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-510">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-511">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-511">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a0db4-512">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-512">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a0db4-513">
            <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-513">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-514">Espera a que cualquiera de los elementos de la matriz especificada reciba una señal; utiliza un entero de 32 bits con signo para determinar el intervalo de tiempo y especifica si se va a salir del dominio de sincronización antes de la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-514">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-515">Índice de matriz del objeto que satisfizo la espera o <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si ningún objeto satisfizo la espera y transcurrió un intervalo de tiempo equivalente a <paramref name="millisecondsTimeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-515">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-516">Si `millisecondsTimeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-516">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-517">Comprueba el estado de los identificadores de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-517">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-518"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-518"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-519">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAny%2A> método `true` si la espera finaliza porque se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-519">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-520">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-520">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-521">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-521">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-522">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-522">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-523">El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce un <xref:System.Threading.AbandonedMutexException> sólo cuando finaliza la espera debido a un mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-523">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a0db4-524">Si `waitHandles` contiene una exclusión mutua liberada con un número de índice menor que el mutex abandonado la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.</span><span class="sxs-lookup"><span data-stu-id="a0db4-524">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-525">En las versiones de .NET Framework anterior a la versión 2.0, si un subproceso termina o se interrumpe sin liberar explícitamente un <xref:System.Threading.Mutex>y que `Mutex` está en el índice 0 (cero) en un `WaitAny` matriz en otro subproceso, el índice devuelto por `WaitAny` es 128 en lugar de 0.</span><span class="sxs-lookup"><span data-stu-id="a0db4-525">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="a0db4-526">Este método devuelve cuando finaliza la espera, cuando cualquiera de los identificadores está señalado o cuando se produce un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-526">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="a0db4-527">Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados.</span><span class="sxs-lookup"><span data-stu-id="a0db4-527">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a0db4-528">En algunas implementaciones, si se pasan 64 identificadores, más de un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-528">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a0db4-529">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="a0db4-529">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a0db4-530">El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitAny%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-530">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a0db4-531">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-531">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a0db4-532">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a0db4-532">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a0db4-533">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-533">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="a0db4-534">El subproceso vuelve al contexto no predeterminado original después de llamar a la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="a0db4-534">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="a0db4-535">Esto puede ser útil cuando la clase enlazadas a un contexto tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-535">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a0db4-536">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-536">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a0db4-537">Si el código de la pila de llamadas de un miembro llama el <xref:System.Threading.WaitHandle.WaitAny%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-537">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a0db4-538">Cuando el <xref:System.Threading.WaitHandle.WaitAny%2A> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-538">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-539">En el ejemplo de código siguiente se muestra cómo utilizar el grupo de subprocesos para buscar un archivo en varios discos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="a0db4-539">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="a0db4-540">Por motivos de espacio, se busca únicamente el directorio raíz de cada disco.</span><span class="sxs-lookup"><span data-stu-id="a0db4-540">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-541">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-541">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-542">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-542">-or-</span>
          </span>
          <span data-ttu-id="a0db4-543">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-543">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-544">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-544">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a0db4-545">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-545">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-546">
            <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-546">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-547">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-547">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-548">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-548">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a0db4-549">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-549">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-550">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-550">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="a0db4-551">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-551">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="a0db4-552">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-552">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a0db4-553">
            <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-553">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-554">Espera a que cualquiera de los elementos de la matriz especificada reciba una señal; usa un <see cref="T:System.TimeSpan" /> para especificar el intervalo de tiempo y especifica si se va a salir del dominio de sincronización antes de la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-554">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-555">Índice de matriz del objeto que satisfizo la espera o <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si ningún objeto satisfizo la espera y transcurrió un intervalo de tiempo equivalente a <paramref name="timeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-555">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-556">Si `timeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-556">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-557">Comprueba el estado de los identificadores de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-557">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-558"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-558"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-559">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAny%2A> método `true` si la espera finaliza porque se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-559">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-560">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-560">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-561">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-561">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-562">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-562">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-563">El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce un <xref:System.Threading.AbandonedMutexException> sólo cuando finaliza la espera debido a un mutex abandonado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-563">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="a0db4-564">Si `waitHandles` contiene una exclusión mutua liberada con un número de índice menor que el mutex abandonado la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.</span><span class="sxs-lookup"><span data-stu-id="a0db4-564">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0db4-565">En las versiones de .NET Framework anterior a la versión 2.0, si un subproceso termina o se interrumpe sin liberar explícitamente un <xref:System.Threading.Mutex>y que `Mutex` está en el índice 0 (cero) en un `WaitAny` matriz en otro subproceso, el índice devuelto por `WaitAny` es 128 en lugar de 0.</span><span class="sxs-lookup"><span data-stu-id="a0db4-565">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="a0db4-566">Este método devuelve cuando finaliza la espera, cuando cualquiera de los identificadores está señalado o cuando se produce un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-566">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="a0db4-567">Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados.</span><span class="sxs-lookup"><span data-stu-id="a0db4-567">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="a0db4-568">En algunas implementaciones, si se pasan 64 identificadores, más de un <xref:System.NotSupportedException> se produce.</span><span class="sxs-lookup"><span data-stu-id="a0db4-568">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="a0db4-569">El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-569">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a0db4-570">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="a0db4-570">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a0db4-571">El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitAny%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-571">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a0db4-572">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-572">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a0db4-573">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a0db4-573">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a0db4-574">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-574">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="a0db4-575">El subproceso vuelve al contexto no predeterminado original después de llamar a la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="a0db4-575">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="a0db4-576">Esto puede ser útil cuando la clase enlazadas a un contexto tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-576">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a0db4-577">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-577">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a0db4-578">Si el código de la pila de llamadas de un miembro llama el <xref:System.Threading.WaitHandle.WaitAny%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-578">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a0db4-579">Cuando el <xref:System.Threading.WaitHandle.WaitAny%2A> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-579">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-580">En el ejemplo de código siguiente se muestra cómo utilizar el grupo de subprocesos para buscar un archivo en varios discos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="a0db4-580">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="a0db4-581">Por motivos de espacio, se busca únicamente el directorio raíz de cada disco.</span><span class="sxs-lookup"><span data-stu-id="a0db4-581">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="a0db4-582">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-582">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="a0db4-583">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-583">-or-</span>
          </span>
          <span data-ttu-id="a0db4-584">Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-584">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="a0db4-585">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-585">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="a0db4-586">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-586">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-587">
            <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-587">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a0db4-588">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-588">-or-</span>
          </span>
          <span data-ttu-id="a0db4-589">
            <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-589">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-590">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-590">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-591">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-591">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="a0db4-592">
            <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-592">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-593">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-593">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-594">Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.WaitHandle" /> actual recibe una señal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-594">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-595">Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.WaitHandle" /> actual recibe una señal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-595">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-596">Es <see langword="true" /> si la instancia actual recibe una señal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-596">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="a0db4-597">Si nunca se señala a la instancia actual, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nunca devuelve nada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-597">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-598"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-598"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-599">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitOne%2A> método `true` cuando se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-599">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-600">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-600">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-601">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-601">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-602">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-602">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-603">El llamador de este método se bloquea indefinidamente hasta que la instancia actual recibe una señal.</span><span class="sxs-lookup"><span data-stu-id="a0db4-603">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="a0db4-604">Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a0db4-604">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a0db4-605">Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.</span><span class="sxs-lookup"><span data-stu-id="a0db4-605">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a0db4-606">Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga del método y especificando -1 o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para el primer parámetro y `false` para el segundo parámetro.</span><span class="sxs-lookup"><span data-stu-id="a0db4-606">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="a0db4-607">Invalide este método para personalizar el comportamiento de las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-607">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-608">En el ejemplo de código siguiente se muestra cómo utilizar un identificador de espera para impedir que un proceso de finalización mientras se espera a que finalice la ejecución de un subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="a0db4-608">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a0db4-609">Ya se ha eliminado la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-609">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-610">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-610">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-611">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-611">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-612">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-612">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a0db4-613">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-613">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-614">Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.WaitHandle" /> actual recibe una señal, usando un entero de 32 bits con signo para especificar el intervalo de tiempo en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-614">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-615">
            <see langword="true" /> si la instancia actual recibe una señal; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-615">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-616">Si `millisecondsTimeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-616">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-617">Comprueba el estado del identificador de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-617">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-618">Se produce el llamador de este método se bloquea hasta que la instancia actual recibe una señal o un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-618">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="a0db4-619">Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a0db4-619">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a0db4-620">Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.</span><span class="sxs-lookup"><span data-stu-id="a0db4-620">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a0db4-621">Invalide este método para personalizar el comportamiento de las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-621">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="a0db4-622">Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga y la especificación `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-622">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-623">En el ejemplo de código siguiente se muestra cómo utilizar un identificador de espera para impedir que un proceso de finalización mientras se espera a que finalice la ejecución de un subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="a0db4-623">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a0db4-624">Ya se ha eliminado la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-624">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-625">
            <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-625">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-626">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-626">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-627">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-628">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="a0db4-629">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-629">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-630">Bloquea el subproceso actual hasta que la instancia actual recibe una señal, usando <see cref="T:System.TimeSpan" /> para especificar el intervalo de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-630">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-631">
            <see langword="true" /> si la instancia actual recibe una señal; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-631">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-632">Si `timeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-632">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-633">Comprueba el estado del identificador de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-634">Se produce el llamador de este método se bloquea hasta que la instancia actual recibe una señal o un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="a0db4-635">Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a0db4-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a0db4-636">Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.</span><span class="sxs-lookup"><span data-stu-id="a0db4-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a0db4-637">Invalide este método para personalizar el comportamiento de las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="a0db4-638">El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-638">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a0db4-639">Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> sobrecarga y la especificación `false` para `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a0db4-640">Ya se ha eliminado la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-640">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-641">
            <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-641">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a0db4-642">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-642">-or-</span>
          </span>
          <span data-ttu-id="a0db4-643">
            <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-643">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-644">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-644">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-645">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-645">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-646">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-646">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="a0db4-647">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-647">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a0db4-648">
            <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-648">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-649">Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.WaitHandle" /> actual recibe una señal, usa un entero de 32 bits con signo para determinar el intervalo de tiempo y especifica si hay que salir del dominio de sincronización antes de la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-649">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-650">
            <see langword="true" /> si la instancia actual recibe una señal; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-650">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-651">Si `millisecondsTimeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-651">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-652">Comprueba el estado del identificador de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-652">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-653"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-653"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-654">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitOne%2A> método `true` cuando se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-654">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-655">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-655">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-656">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-656">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-657">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-657">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-658">Se produce el llamador de este método se bloquea hasta que la instancia actual recibe una señal o un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-658">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="a0db4-659">Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a0db4-659">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a0db4-660">Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.</span><span class="sxs-lookup"><span data-stu-id="a0db4-660">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a0db4-661">Invalide este método para personalizar el comportamiento de las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-661">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a0db4-662">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="a0db4-662">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a0db4-663">El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitOne%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-663">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a0db4-664">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-664">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a0db4-665">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a0db4-665">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a0db4-666">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-666">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a0db4-667">El subproceso vuelve al contexto no predeterminado original después de llamar a la <xref:System.Threading.WaitHandle.WaitOne%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="a0db4-667">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="a0db4-668">Esto puede ser útil cuando la clase enlazadas a un contexto tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-668">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a0db4-669">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-669">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a0db4-670">Si el código de la pila de llamadas de un miembro llama el <xref:System.Threading.WaitHandle.WaitOne%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-670">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a0db4-671">Cuando el <xref:System.Threading.WaitHandle.WaitOne%2A> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-671">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-672">El siguiente ejemplo se muestra cómo el <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga del método se comporta cuando se llama dentro de un dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-672">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="a0db4-673">En primer lugar, un subproceso espera con `exitContext` establecido en `false` y se bloquea hasta que expire el tiempo de espera de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-673">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="a0db4-674">Un segundo subproceso se ejecuta después de que el primer subproceso finaliza y se espera con `exitContext` establecido en `true`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-674">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="a0db4-675">La llamada para indicar el identificador de espera para este segundo subproceso no se bloquea y finaliza el subproceso antes de la espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-675">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a0db4-676">Ya se ha eliminado la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-676">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-677">
            <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-677">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-678">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-678">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-679">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-679">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-680">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-680">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="a0db4-681">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-681">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="a0db4-682">
            <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-682">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0db4-683">Bloquea el subproceso actual hasta que la instancia actual recibe una señal; usa <see cref="T:System.TimeSpan" /> para determinar el intervalo de tiempo y especifica si hay que abandonar el dominio de sincronización antes de la espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-683">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0db4-684">
            <see langword="true" /> si la instancia actual recibe una señal; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-684">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-685">Si `timeout` es cero, el método no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="a0db4-685">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="a0db4-686">Comprueba el estado del identificador de espera y vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a0db4-686">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="a0db4-687"><xref:System.Threading.AbandonedMutexException> Novedades en la versión 2.0 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a0db4-687"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="a0db4-688">En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitOne%2A> método `true` cuando se abandona una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="a0db4-688">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="a0db4-689">A menudo, un mutex abandonado indica un error de codificación grave.</span><span class="sxs-lookup"><span data-stu-id="a0db4-689">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="a0db4-690">En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado inesperadamente (por ejemplo, mediante el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="a0db4-690">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="a0db4-691">La excepción contiene información útil para la depuración.</span><span class="sxs-lookup"><span data-stu-id="a0db4-691">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="a0db4-692">Se produce el llamador de este método se bloquea hasta que la instancia actual recibe una señal o un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="a0db4-692">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="a0db4-693">Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a0db4-693">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="a0db4-694">Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.</span><span class="sxs-lookup"><span data-stu-id="a0db4-694">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="a0db4-695">Invalide este método para personalizar el comportamiento de las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a0db4-695">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="a0db4-696">El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-696">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="a0db4-697">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="a0db4-697">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="a0db4-698">El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitOne%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a0db4-698">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="a0db4-699">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-699">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="a0db4-700">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="a0db4-700">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="a0db4-701">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="a0db4-701">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="a0db4-702">El subproceso vuelve al contexto no predeterminado original después de llamar a la <xref:System.Threading.WaitHandle.WaitOne%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="a0db4-702">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="a0db4-703">Esto puede ser útil cuando la clase enlazadas a un contexto tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="a0db4-703">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="a0db4-704">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</span><span class="sxs-lookup"><span data-stu-id="a0db4-704">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="a0db4-705">Si el código de la pila de llamadas de un miembro llama el <xref:System.Threading.WaitHandle.WaitOne%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="a0db4-705">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="a0db4-706">Cuando el <xref:System.Threading.WaitHandle.WaitOne%2A> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="a0db4-706">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-707">En el ejemplo de código siguiente se muestra cómo utilizar un identificador de espera para impedir que un proceso de finalización mientras se espera a que finalice la ejecución de un subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="a0db4-707">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="a0db4-708">Ya se ha eliminado la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-708">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="a0db4-709">
            <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-709">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="a0db4-710">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-710">-or-</span>
          </span>
          <span data-ttu-id="a0db4-711">
            <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-711">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="a0db4-712">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-712">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="a0db4-713">Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-713">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0db4-714">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-714">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="a0db4-715">Indica que una operación <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> ha superado el tiempo de espera antes de que se señalara un identificador de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-715">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="a0db4-716">Este campo es constante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0db4-716">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0db4-717">Este campo es uno de los valores devueltos posibles de `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="a0db4-717">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0db4-718">En el ejemplo de código siguiente se muestra cómo utilizar el grupo de subprocesos para buscar un archivo en varios discos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="a0db4-718">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="a0db4-719">Por motivos de espacio, se busca únicamente el directorio raíz de cada disco.</span><span class="sxs-lookup"><span data-stu-id="a0db4-719">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>