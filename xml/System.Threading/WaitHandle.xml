<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b0743bee28025334f71604c9b2d0c45160aa6bc8" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52608553" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsula los objetos específicos del sistema operativo que esperan obtener un acceso exclusivo a los recursos compartidos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Threading.WaitHandle> clase encapsula un identificador de la sincronización del sistema operativo nativo y se utiliza para representar todos los objetos de sincronización en el tiempo de ejecución que permiten varias operaciones de espera. Para obtener una comparación de identificadores de espera con otros objetos de sincronización, consulte [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 El <xref:System.Threading.WaitHandle> propia clase es abstracta. Las clases derivadas de <xref:System.Threading.WaitHandle> definen un mecanismo de señalización para indicar que están tomando o liberando el acceso a un recurso compartido, pero usan el heredado <xref:System.Threading.WaitHandle> métodos para bloquear mientras se espera para el acceso a recursos comparten. Las clases derivadas de <xref:System.Threading.WaitHandle> incluyen:  
  
-   La clase <xref:System.Threading.Mutex>. Consulte [exclusiones mutuas](~/docs/standard/threading/mutexes.md).  
  
-   El <xref:System.Threading.EventWaitHandle> clase y sus clases derivadas, <xref:System.Threading.AutoResetEvent> y <xref:System.Threading.ManualResetEvent>. Vea [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   La clase <xref:System.Threading.Semaphore>. Consulte [Semaphore y SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Los subprocesos pueden bloquear en un identificador de espera individuales llamando al método de instancia <xref:System.Threading.WaitHandle.WaitOne%2A>, que es heredado por las clases derivadas de <xref:System.Threading.WaitHandle>.  
  
 Las clases derivadas de <xref:System.Threading.WaitHandle> difieren en su afinidad de subprocesos. Identificadores de espera de evento (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, y <xref:System.Threading.ManualResetEvent>) y los semáforos no tienen afinidad de subprocesos; en cualquier subproceso puede señalar un semáforo o un identificador de espera de evento. Las exclusiones mutuas, por otro lado, tienen afinidad de subprocesos; debe liberar el subproceso que posee una exclusión mutua, y se produce una excepción si un subproceso llama a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método en una exclusión mutua que no le pertenece.  
  
 Dado que el <xref:System.Threading.WaitHandle> clase se deriva de <xref:System.MarshalByRefObject>, estas clases se pueden utilizar para sincronizar las actividades de subprocesos entre los límites del dominio de aplicación.  
  
 Además de sus clases derivadas, la <xref:System.Threading.WaitHandle> clase tiene un número de métodos estáticos que bloquea un subproceso hasta que uno o más objetos de sincronización reciban una señal. Se incluyen los siguientes:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, que permite que un subproceso indicar un identificador de espera y espere inmediatamente a otro.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, que permite que un subproceso esperar hasta que todos los identificadores de espera en una matriz reciban una señal.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, que permite que un subproceso esperar hasta que se haya señalado cualquiera de un conjunto de identificadores de espera especificado.  
  
 Las sobrecargas de estos métodos proporcionan los intervalos de tiempo de espera para abandonar la espera y la oportunidad de salir de un contexto de sincronización antes de entrar en la espera, lo que permite utilizar el contexto de sincronización de otros subprocesos.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo o un tipo derivado de ella, debe eliminar de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.Threading.WaitHandle.Close%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 <xref:System.Threading.WaitHandle> implementa el <xref:System.IDisposable.Dispose%2A> patrón. Consulte [patrón de Dispose](~/docs/standard/design-guidelines/dispose-pattern.md). Al derivar de <xref:System.Threading.WaitHandle>, utilice el <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad para almacenar el identificador del sistema operativo nativo. No es necesario invalidar protegido <xref:System.Threading.WaitHandle.Dispose%2A> método a menos que utilice recursos no administrados adicionales.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo dos subprocesos pueden realizan tareas en segundo plano mientras el método Main de subproceso espera a que las tareas se completen con estático <xref:System.Threading.WaitHandle.WaitAny%2A> y <xref:System.Threading.WaitHandle.WaitAll%2A> métodos de la <xref:System.Threading.WaitHandle> clase.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Subprocesos</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Objetos y características de subprocesos</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semáforos</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos mantenidos por el objeto <see cref="T:System.Threading.WaitHandle" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una implementación pública de la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método para el <xref:System.Threading.WaitHandle> clase y sus clases derivadas. Proporciona una implementación estándar que llama a la `Dispose(Boolean)` sobrecarga con un `true` argumento y, a continuación, llama a la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método. Llame a este método para liberar todos los recursos mantenidos por una instancia de `WaitHandle` o una clase derivada.  
  
 Una vez que se llama a este método, las referencias a la instancia actual de provocan un comportamiento indefinido.  
  
> [!NOTE]
>  Llame siempre a <xref:System.Threading.WaitHandle.Close%2A> o <xref:System.Threading.WaitHandle.Dispose> antes de liberar la última referencia a la <xref:System.Threading.WaitHandle>. En caso contrario, no se liberarán los recursos que está usando.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se debe reemplazar el <see langword="Dispose(Boolean)" /> método para liberar los recursos asignados en las clases derivadas.</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementar un método Dispose</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a la <xref:System.Threading.WaitHandle.Close%2A> método.  
  
> [!NOTE]
>  Llame siempre a <xref:System.Threading.WaitHandle.Close%2A> o <xref:System.Threading.WaitHandle.Dispose> antes de liberar la última referencia a la <xref:System.Threading.WaitHandle>. En caso contrario, no se liberarán los recursos que está usando.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Limpiar recursos no administrados</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Cuando se reemplaza en una clase derivada, libera los recursos no administrados que usa <see cref="T:System.Threading.WaitHandle" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es invocado por el <xref:System.Threading.WaitHandle.Close%2A> y <xref:System.Threading.WaitHandle.Dispose> métodos con el `explicitDisposing` parámetro establecido en `true`.  Cuando el `explicitDisposing` parámetro es `true`, este método libera todos los recursos mantenidos por los objetos administrados que <xref:System.Threading.WaitHandle> las referencias a objetos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se debe reemplazar el <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> método para liberar los recursos asignados en las clases derivadas.  
  
El <see cref="M:System.Threading.WaitHandle.Close" /> o <see cref="M:System.Threading.WaitHandle.Dispose" /> método puede llamarse varias veces por otros objetos. Al reemplazar este método, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" /> o <see langword="Close" />.</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementar un método Dispose</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos mantenidos por la instancia actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> Este miembro se quitó de la versión 2.0 de .NET Framework y versiones posteriores. En este tema se aplica solo a las versiones incluidas en "Información de versión" más adelante en este tema.


Código de la aplicación no llama a este método; se invoca automáticamente durante la recolección de elementos no utilizados, a menos que se ha deshabilitado la finalización por el recolector de elementos no utilizados. Para obtener más información, vea <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> y <xref:System.Object.Finalize>. Este método invalida <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el identificador del sistema operativo nativo.</summary>
        <value>
          <see langword="IntPtr" /> que representa el identificador del sistema operativo nativo. El valor predeterminado es el valor del campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asignación de un nuevo valor para el <xref:System.Threading.WaitHandle.Handle%2A> propiedad no cierra el identificador anterior. Esto puede dar lugar a un identificador con pérdidas.  
  
 No utilice esta propiedad en .NET Framework versión 2.0 o posterior; Utilice el <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad en su lugar. Establecer esta propiedad en un identificador válido también establece la <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad, pero si se establece en <xref:System.Threading.WaitHandle.InvalidHandle> puede dar lugar a un identificador con pérdidas.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato establecer el valor de propiedad. Este miembro no se puede establecer código de confianza parcial o transparente.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Tipos derivados deben tener <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para establecer el valor de propiedad.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa un identificador del sistema operativo nativo no válido. Este campo es de solo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se utiliza internamente para inicializar el <xref:System.Threading.WaitHandle.Handle%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Puede usar este valor para determinar si el <see cref="P:System.Threading.WaitHandle.Handle" /> propiedad contiene un identificador válido del sistema operativo nativo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el identificador del sistema operativo nativo.</summary>
        <value>
          <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> que representa el identificador del sistema operativo nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al asignar un nuevo valor para el <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad, el identificador anterior se cerrarán cuando anterior <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objeto se recopila. No cierre el identificador manualmente, ya que esto da como resultado un <xref:System.ObjectDisposedException> cuando el <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> intenta cerrar el identificador.  
  
 <xref:System.Threading.WaitHandle> implementa el <xref:System.IDisposable.Dispose%2A> patrón. Consulte [patrón de Dispose](~/docs/standard/design-guidelines/dispose-pattern.md). Al derivar de <xref:System.Threading.WaitHandle>, utilice el <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propiedad para almacenar el identificador del sistema operativo de identificador nativo. No es necesario invalidar protegido <xref:System.Threading.WaitHandle.Dispose%2A> método a menos que utilice recursos no administrados adicionales.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Tipos derivados deben tener <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para llamar a este miembro.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Señala un <see cref="T:System.Threading.WaitHandle" /> y espera en otro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> que se va a señalar.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> en donde se va a esperar.</param>
        <summary>Señala un <see cref="T:System.Threading.WaitHandle" /> y espera en otro.</summary>
        <returns>
          <see langword="true" /> si la señal y la espera finalizan correctamente; si la espera no finaliza, el método no devuelve ningún resultado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se garantiza para ser atómicas. Después de las señales del subproceso actual `toSignal` pero antes de que espera en `toWaitOn`, podría señalar a un subproceso que se está ejecutando en otro procesador `toWaitOn` o esperar en él.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga del método para permitir que el subproceso principal indicar un subproceso bloqueado y, a continuación, espere a que el subproceso finalice una tarea.  
  
 En el ejemplo se inician cinco subprocesos, le permite bloquear un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca y las versiones un subproceso cada vez el usuario presiona la tecla ENTRAR. En el ejemplo, a continuación, pone en cola otros cinco subprocesos y liberan todos ellos utilizando una <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="toSignal" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="toWaitOn" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Se llamó al método en un subproceso con <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se admite este método en Windows 98 ni en Windows Millennium.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> es un semáforo y su contador ya está completo.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> que se va a señalar.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> en donde se va a esperar.</param>
        <param name="millisecondsTimeout">Entero que representa el intervalo que se va a esperar. Si el valor es <see cref="F:System.Threading.Timeout.Infinite" />, esto es, -1, la espera es infinita.</param>
        <param name="exitContext">
          <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</param>
        <summary>Señala un <see cref="T:System.Threading.WaitHandle" /> y espera en otro, para lo que determina un intervalo de tiempo de espera como entero con signo de 32 bits y especifica si se sale del dominio de sincronización para el contexto antes de entrar en la espera.</summary>
        <returns>Es <see langword="true" /> si la señal y la espera finalizan correctamente, o <see langword="false" /> si la señal finaliza pero el tiempo de la espera se agota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se garantiza para ser atómicas. Después de las señales del subproceso actual `toSignal` pero antes de que espera en `toWaitOn`, podría señalar a un subproceso que se está ejecutando en otro procesador `toWaitOn` o esperar en él.  
  
 Si `millisecondsTimeout` es cero, el método no se bloquea. Comprueba el estado de la `toWaitOn` y se devuelve inmediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método. El subproceso vuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.WaitHandle.SignalAndWait%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.WaitHandle.SignalAndWait%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="toSignal" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="toWaitOn" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Se llama al método en un subproceso con <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se admite este método en Windows 98 ni en Windows Millennium.</exception>
        <exception cref="T:System.InvalidOperationException">No se puede señalar a <see cref="T:System.Threading.WaitHandle" /> porque se superaría su recuento máximo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <see cref="T:System.Threading.WaitHandle" /> que se va a señalar.</param>
        <param name="toWaitOn">
          <see cref="T:System.Threading.WaitHandle" /> en donde se va a esperar.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que representa el intervalo que se va a esperar. Si el valor es -1, la espera es infinita.</param>
        <param name="exitContext">
          <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</param>
        <summary>Señala un <see cref="T:System.Threading.WaitHandle" /> y espera en otro, para lo que determina el intervalo de tiempo de espera como <see cref="T:System.TimeSpan" /> y especifica si se sale del dominio de sincronización para el contexto antes de entrar en la espera.</summary>
        <returns>Es <see langword="true" /> si la señal y la espera finalizan correctamente, o <see langword="false" /> si la señal finaliza pero el tiempo de la espera se agota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se garantiza para ser atómicas. Después de las señales del subproceso actual `toSignal` pero antes de que espera en `toWaitOn`, podría señalar a un subproceso que se está ejecutando en otro procesador `toWaitOn` o esperar en él.  
  
 El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Si `timeout` es cero, el método no se bloquea. Comprueba el estado de la `toWaitOn` y se devuelve inmediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método. El subproceso vuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.WaitHandle.SignalAndWait%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.WaitHandle.SignalAndWait%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.WaitHandle.SignalAndWait%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="toSignal" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="toWaitOn" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Se llamó al método en un subproceso con <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se admite este método en Windows 98 ni en Windows Millennium.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> es un semáforo y su contador ya está completo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> se evalúa como un número negativo de milisegundos distinto de -1.  
  
O bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Una llamada a `Dispose` permite a los recursos utilizados por el <xref:System.Threading.WaitHandle> que reasignarse para otros fines. Para obtener más información acerca de `Dispose`, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Espera a que todos los elementos de la matriz especificada reciban una señal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará. Esta matriz no puede contener varias referencias al mismo objeto.</param>
        <summary>Espera a que todos los elementos de la matriz especificada reciban una señal.</summary>
        <returns>
          <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> reciben una señal; en caso contrario, el método nunca devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAll%2A> devuelve del método `true` cuando se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando se señalizan todos los identificadores. En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce. Si la matriz contiene duplicados, se produce un error en la llamada con un <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.  
  
 Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga del método y especificar -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` y `true` para `exitContext`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar el grupo de subprocesos para crear y escribir en un grupo de archivos de forma asincrónica. Cada operación de escritura se pone en cola como un elemento de trabajo y las señales cuando haya finalizado. El subproceso principal espera a que todos los elementos señalar y, a continuación, se cierra.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />. O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.  
  
O bien 
 <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.  
  
O bien 
El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará. Esta matriz no puede contener varias referencias al mismo objeto (duplicados).</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Espera a que todos los elementos de la matriz especificada reciban una señal mediante un valor <see cref="T:System.Int32" /> para especificar el intervalo de tiempo.</summary>
        <returns>
          <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> reciben una señal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` es cero, el método no se bloquea. Comprueba el estado de los identificadores de espera y vuelve inmediatamente.  
  
 El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando finaliza la espera, lo que significa que cuando están señalados todos los identificadores o cuando se produce el tiempo de espera. En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce. Si hay duplicados en la matriz, no se puede llamar con un <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.  
  
 Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga y especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.  
  
O bien 
 <paramref name="waitHandles" /> es una matriz sin elementos.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.  
  
O bien 
El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará. Esta matriz no puede contener varias referencias al mismo objeto.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Espera a que todos los elementos de la matriz especificada reciban una señal, usando un valor <see cref="T:System.TimeSpan" /> para especificar el intervalo de tiempo.</summary>
        <returns>
          <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> reciben una señal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` es cero, el método no se bloquea. Comprueba el estado de los identificadores de espera y vuelve inmediatamente.  
  
 El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando finaliza la espera, lo que significa que todos los identificadores están señalados o se produce un tiempo de espera. En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce. Si la matriz contiene duplicados, se producirá un error en la llamada.  
  
> [!NOTE]
>  El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.  
  
 El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga y especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.  
  
O bien 
 <paramref name="waitHandles" /> es una matriz sin elementos.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.  
  
O bien 
El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito. 
O bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará. Esta matriz no puede contener varias referencias al mismo objeto (duplicados).</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</param>
        <summary>Espera a que todos los elementos de la matriz especificada reciban una señal; usa un valor <see cref="T:System.Int32" /> para determinar el intervalo de tiempo y especifica si se va a salir del dominio de sincronización antes de finalizar la espera.</summary>
        <returns>
          <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> reciben una señal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` es cero, el método no se bloquea. Comprueba el estado de los identificadores de espera y vuelve inmediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAll%2A> devuelve del método `true` cuando se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando finaliza la espera, lo que significa que cuando están señalados todos los identificadores o cuando se produce el tiempo de espera. En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce. Si hay duplicados en la matriz, no se puede llamar con un <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitAll%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitAll%2A> método. El subproceso vuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.WaitHandle.WaitAll%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene el <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.WaitHandle.WaitAll%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.WaitHandle.WaitAll%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar el grupo de subprocesos para crear y escribir en un grupo de archivos de forma asincrónica. Cada operación de escritura se pone en cola como un elemento de trabajo y las señales cuando haya finalizado. El subproceso principal espera a que todos los elementos señalar y, a continuación, se cierra.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.  
  
O bien 
 <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.  
  
O bien 
El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará. Esta matriz no puede contener varias referencias al mismo objeto.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</param>
        <summary>Espera a que todos los elementos de la matriz especificada reciban una señal; usa un valor <see cref="T:System.TimeSpan" /> para determinar el intervalo de tiempo y especifica si se va a salir del dominio de sincronización antes de finalizar la espera.</summary>
        <returns>Es <see langword="true" /> cuando todos los elementos de <paramref name="waitHandles" /> han recibido una señal; en caso contrario es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` es cero, el método no se bloquea. Comprueba el estado de los identificadores de espera y vuelve inmediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAll%2A> devuelve del método `true` cuando se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 El <xref:System.Threading.WaitHandle.WaitAll%2A> método devuelve cuando finaliza la espera, lo que significa que todos los identificadores están señalados o se produce un tiempo de espera. En algunas implementaciones, si se pasan más de 64 identificadores, un <xref:System.NotSupportedException> se produce. Si la matriz contiene duplicados, se producirá un error en la llamada.  
  
> [!NOTE]
>  El <xref:System.Threading.WaitHandle.WaitAll%2A> método no se admite en subprocesos que tienen <xref:System.STAThreadAttribute>.  
  
 El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitAll%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitAll%2A> método. Devuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.WaitHandle.WaitAll%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.WaitHandle.WaitAll%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.WaitHandle.WaitAll%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar el grupo de subprocesos para crear y escribir en un grupo de archivos de forma asincrónica. Cada operación de escritura se pone en cola como un elemento de trabajo y las señales cuando haya finalizado. El subproceso principal espera a que todos los elementos señalar y, a continuación, se cierra.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.  
  
O bien 
 <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">La matriz <paramref name="waitHandles" /> contiene elementos que son duplicados.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.  
  
O bien 
El atributo <see cref="T:System.STAThreadAttribute" /> se aplica al procedimiento de subproceso para el subproceso actual, y <paramref name="waitHandles" /> contiene más de un elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito. 
O bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Espera a que cualquiera de los elementos de la matriz especificada reciba una señal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</param>
        <summary>Espera a que cualquiera de los elementos de la matriz especificada reciba una señal.</summary>
        <returns>Índice de la matriz del objeto que satisfizo la espera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAny%2A> devuelve del método `true` si la espera finaliza porque se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce una <xref:System.Threading.AbandonedMutexException> solo cuando finaliza la espera debido a una exclusión mutua abandonada. Si `waitHandles` contiene una exclusión mutua liberada con un número de índice inferior de la exclusión mutua abandonada, el <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.  
  
> [!NOTE]
>  En las versiones de .NET Framework anteriores a la versión 2.0, si un subproceso se cierra o anula sin liberar explícitamente un <xref:System.Threading.Mutex>y que `Mutex` está en el índice 0 (cero) en un `WaitAny` matriz en otro subproceso, el índice devuelto por `WaitAny` es 128 en lugar de 0.  
  
 Este método devuelve cuando se señala a cualquiera de ellos. Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados. En algunas implementaciones, si más de 64 identificadores se pasan, un <xref:System.NotSupportedException> se produce.  
  
 Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga del método y especificar -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` y `true` para `exitContext`.  
  
   
  
## Examples  
 El ejemplo de código siguiente se muestra cómo llamar el <xref:System.Threading.WaitHandle.WaitAny%2A> método.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Espera a que cualquiera de los elementos de la matriz especificada reciba una señal, utilizando un entero de 32 bits con signo para especificar el intervalo de tiempo.</summary>
        <returns>Índice de matriz del objeto que satisfizo la espera o <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si ningún objeto satisfizo la espera y transcurrió un intervalo de tiempo equivalente a <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` es cero, el método no se bloquea. Comprueba el estado de los identificadores de espera y vuelve inmediatamente.  
  
 El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce una <xref:System.Threading.AbandonedMutexException> solo cuando finaliza la espera debido a una exclusión mutua abandonada. Si `waitHandles` contiene una exclusión mutua liberada con un número de índice inferior de la exclusión mutua abandonada, el <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.  
  
 Este método devuelve cuando finaliza la espera, o cuando se señala a cualquiera de los controladores cuando se produce un tiempo de espera. Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados. En algunas implementaciones, si más de 64 identificadores se pasan, un <xref:System.NotSupportedException> se produce.  
  
 Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga y especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> es una matriz sin elementos.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</param>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Espera a que cualquiera de los elementos de la matriz especificada reciba una señal, usando un <see cref="T:System.TimeSpan" /> para especificar el intervalo de tiempo.</summary>
        <returns>Índice de matriz del objeto que satisfizo la espera o <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si ningún objeto satisfizo la espera y transcurrió un intervalo de tiempo equivalente a <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` es cero, el método no se bloquea. Comprueba el estado de los identificadores de espera y vuelve inmediatamente.  
  
 El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce una <xref:System.Threading.AbandonedMutexException> solo cuando finaliza la espera debido a una exclusión mutua abandonada. Si `waitHandles` contiene una exclusión mutua liberada con un número de índice inferior de la exclusión mutua abandonada, el <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.  
  
 Este método devuelve cuando finaliza la espera, o cuando se señala a cualquiera de los controladores cuando se produce un tiempo de espera. Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados. En algunas implementaciones, si más de 64 identificadores se pasan, un <xref:System.NotSupportedException> se produce.  
  
 El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga y especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito. 
O bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> es una matriz sin elementos.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</param>
        <summary>Espera a que cualquiera de los elementos de la matriz especificada reciba una señal; utiliza un entero de 32 bits con signo para determinar el intervalo de tiempo y especifica si se va a salir del dominio de sincronización antes de la espera.</summary>
        <returns>Índice de matriz del objeto que satisfizo la espera o <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si ningún objeto satisfizo la espera y transcurrió un intervalo de tiempo equivalente a <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` es cero, el método no se bloquea. Comprueba el estado de los identificadores de espera y vuelve inmediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAny%2A> devuelve del método `true` si la espera finaliza porque se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce una <xref:System.Threading.AbandonedMutexException> solo cuando finaliza la espera debido a una exclusión mutua abandonada. Si `waitHandles` contiene una exclusión mutua liberada con un número de índice inferior de la exclusión mutua abandonada, el <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.  
  
> [!NOTE]
>  En las versiones de .NET Framework anteriores a la versión 2.0, si un subproceso se cierra o anula sin liberar explícitamente un <xref:System.Threading.Mutex>y que `Mutex` está en el índice 0 (cero) en un `WaitAny` matriz en otro subproceso, el índice devuelto por `WaitAny` es 128 en lugar de 0.  
  
 Este método devuelve cuando finaliza la espera, o cuando se señala a cualquiera de los controladores cuando se produce un tiempo de espera. Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados. En algunas implementaciones, si más de 64 identificadores se pasan, un <xref:System.NotSupportedException> se produce.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitAny%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitAny%2A> método. El subproceso vuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.WaitHandle.WaitAny%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.WaitHandle.WaitAny%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar el grupo de subprocesos para buscar un archivo en varios discos simultáneamente. Por motivos de espacio, se busca sólo el directorio raíz de cada disco.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matriz <see langword="WaitHandle" /> que contiene los objetos por los que la instancia actual esperará.</param>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</param>
        <summary>Espera a que cualquiera de los elementos de la matriz especificada reciba una señal; usa un <see cref="T:System.TimeSpan" /> para especificar el intervalo de tiempo y especifica si se va a salir del dominio de sincronización antes de la espera.</summary>
        <returns>Índice de matriz del objeto que satisfizo la espera o <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> si ningún objeto satisfizo la espera y transcurrió un intervalo de tiempo equivalente a <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` es cero, el método no se bloquea. Comprueba el estado de los identificadores de espera y vuelve inmediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitAny%2A> devuelve del método `true` si la espera finaliza porque se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 El <xref:System.Threading.WaitHandle.WaitAny%2A> método produce una <xref:System.Threading.AbandonedMutexException> solo cuando finaliza la espera debido a una exclusión mutua abandonada. Si `waitHandles` contiene una exclusión mutua liberada con un número de índice inferior de la exclusión mutua abandonada, el <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa con normalidad y no se produce la excepción.  
  
> [!NOTE]
>  En las versiones de .NET Framework anteriores a la versión 2.0, si un subproceso se cierra o anula sin liberar explícitamente un <xref:System.Threading.Mutex>y que `Mutex` está en el índice 0 (cero) en un `WaitAny` matriz en otro subproceso, el índice devuelto por `WaitAny` es 128 en lugar de 0.  
  
 Este método devuelve cuando finaliza la espera, o cuando se señala a cualquiera de los controladores cuando se produce un tiempo de espera. Si más de un objeto se señaliza durante la llamada, el valor devuelto es el índice de matriz del objeto señalado con el menor valor de índice de todos los objetos señalados. En algunas implementaciones, si más de 64 identificadores se pasan, un <xref:System.NotSupportedException> se produce.  
  
 El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitAny%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitAny%2A> método. El subproceso vuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.WaitHandle.WaitAny%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.WaitHandle.WaitAny%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.WaitHandle.WaitAny%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar el grupo de subprocesos para buscar un archivo en varios discos simultáneamente. Por motivos de espacio, se busca sólo el directorio raíz de cada disco.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="waitHandles" /> es <see langword="null" />.  
  
O bien 
Uno o varios objetos de la matriz <paramref name="waitHandles" /> son <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El número de objetos de <paramref name="waitHandles" /> es mayor de lo que permite el sistema.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 1.0 o 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito. 
O bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> es una matriz sin elementos y la versión de .NET Framework es 2.0 o posterior.</exception>
        <exception cref="T:System.InvalidOperationException">La matriz <paramref name="waitHandles" /> contiene un proxy transparente para un <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.WaitHandle" /> actual recibe una señal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.WaitHandle" /> actual recibe una señal.</summary>
        <returns>Es <see langword="true" /> si la instancia actual recibe una señal. Si nunca se señala a la instancia actual, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nunca devuelve nada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitOne%2A> devuelve del método `true` cuando se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 El llamador de este método se bloquea indefinidamente hasta que la instancia actual recibe una señal. Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica. Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.  
  
 Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga del método y especificar -1 o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para el primer parámetro y `false` para el segundo parámetro.  
  
 Invalide este método para personalizar el comportamiento de las clases derivadas.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar un identificador de espera para impedir que un proceso de terminación mientras espera a que termine de ejecutarse un subproceso en segundo plano.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.WaitHandle" /> actual recibe una señal, usando un entero de 32 bits con signo para especificar el intervalo de tiempo en milisegundos.</summary>
        <returns>
          <see langword="true" /> si la instancia actual recibe una señal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` es cero, el método no se bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente.  
  
 Se produce el llamador de este método se bloquea hasta que la instancia actual recibe una señal o un tiempo de espera. Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica. Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.  
  
 Invalide este método para personalizar el comportamiento de las clases derivadas.  
  
 Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga y especificando `false` para `exitContext`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar un identificador de espera para impedir que un proceso de terminación mientras espera a que termine de ejecutarse un subproceso en segundo plano.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Bloquea el subproceso actual hasta que la instancia actual recibe una señal, usando <see cref="T:System.TimeSpan" /> para especificar el intervalo de tiempo.</summary>
        <returns>
          <see langword="true" /> si la instancia actual recibe una señal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` es cero, el método no se bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente.  
  
 Se produce el llamador de este método se bloquea hasta que la instancia actual recibe una señal o un tiempo de espera. Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica. Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.  
  
 Invalide este método para personalizar el comportamiento de las clases derivadas.  
  
 El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> sobrecarga y especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito. 
O bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</param>
        <summary>Bloquea el subproceso actual hasta que el objeto <see cref="T:System.Threading.WaitHandle" /> actual recibe una señal, usa un entero de 32 bits con signo para determinar el intervalo de tiempo y especifica si hay que salir del dominio de sincronización antes de la espera.</summary>
        <returns>
          <see langword="true" /> si la instancia actual recibe una señal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `millisecondsTimeout` es cero, el método no se bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitOne%2A> devuelve del método `true` cuando se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 Se produce el llamador de este método se bloquea hasta que la instancia actual recibe una señal o un tiempo de espera. Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica. Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.  
  
 Invalide este método para personalizar el comportamiento de las clases derivadas.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitOne%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitOne%2A> método. El subproceso vuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.WaitHandle.WaitOne%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.WaitHandle.WaitOne%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.WaitHandle.WaitOne%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo el <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga del método se comporta cuando se llama dentro de un dominio de sincronización. En primer lugar, espera a que un subproceso con `exitContext` establecido en `false` y se bloquea hasta que expira el tiempo de espera de la espera. Un segundo subproceso se ejecuta después de que el primer subproceso finaliza y espera a que con `exitContext` establecido en `true`. La llamada para indicar el identificador de espera para este segundo subproceso no está bloqueada y finaliza el subproceso antes de la espera.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para salir del dominio de sincronización del contexto antes de la espera (en caso de encontrarse en un contexto sincronizado) y volver a adquirirlo más tarde; de lo contrario, <see langword="false" />.</param>
        <summary>Bloquea el subproceso actual hasta que la instancia actual recibe una señal; usa <see cref="T:System.TimeSpan" /> para determinar el intervalo de tiempo y especifica si hay que abandonar el dominio de sincronización antes de la espera.</summary>
        <returns>
          <see langword="true" /> si la instancia actual recibe una señal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `timeout` es cero, el método no se bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> Novedades de la versión 2.0 de .NET Framework. En versiones anteriores, el <xref:System.Threading.WaitHandle.WaitOne%2A> devuelve del método `true` cuando se abandona una exclusión mutua. A menudo, una exclusión mutua abandonada indica un error grave de codificación. En el caso de una exclusión mutua todo el sistema, podría indicar que una aplicación ha finalizado abruptamente (por ejemplo, mediante el Administrador de tareas de Windows). La excepción contiene información útil para la depuración.  
  
 Se produce el llamador de este método se bloquea hasta que la instancia actual recibe una señal o un tiempo de espera. Utilice este método para bloquear hasta que un <xref:System.Threading.WaitHandle> recibe una señal de otro subproceso, como se genera cuando se completa una operación asincrónica. Para obtener más información, consulte el <xref:System.IAsyncResult> interfaz.  
  
 Invalide este método para personalizar el comportamiento de las clases derivadas.  
  
 El valor máximo de `timeout` es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El `exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.WaitHandle.WaitOne%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva de <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.WaitHandle.WaitOne%2A> método. El subproceso vuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.WaitHandle.WaitOne%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.WaitHandle.WaitOne%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.WaitHandle.WaitOne%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar un identificador de espera para impedir que un proceso de terminación mientras espera a que termine de ejecutarse un subproceso en segundo plano.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito. 
O bien 
 <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">La espera finalizó porque un subproceso se cierra sin liberar una exclusión mutua. Esta excepción no se produce en Windows 98 o en Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La instancia actual es un proxy transparente para un objeto <see cref="T:System.Threading.WaitHandle" /> en otro dominio de aplicación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indica que una operación <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> ha superado el tiempo de espera antes de que se señalara un identificador de espera. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo es uno de los valores devueltos posibles de `WaitAny`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar el grupo de subprocesos para buscar un archivo en varios discos simultáneamente. Por motivos de espacio, se busca sólo el directorio raíz de cada disco.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>