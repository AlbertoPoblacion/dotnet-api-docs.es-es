<Type Name="CancellationTokenSource" FullName="System.Threading.CancellationTokenSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6eb9b604f17039a1cdce3672195d63b2ea1bdc2c" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51917729" /></Metadata><TypeSignature Language="C#" Value="public class CancellationTokenSource : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CancellationTokenSource extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.CancellationTokenSource" />
  <TypeSignature Language="VB.NET" Value="Public Class CancellationTokenSource&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CancellationTokenSource : IDisposable" />
  <TypeSignature Language="F#" Value="type CancellationTokenSource = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Señala un objeto <see cref="T:System.Threading.CancellationToken" /> que debe cancelarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework usa un modelo unificado para la cancelación cooperativa de operaciones sincrónicas asincrónicas o de larga ejecución que implica dos objetos:  
  
-   Un <xref:System.Threading.CancellationTokenSource> object, que proporciona un token de cancelación a través de su <xref:System.Threading.CancellationTokenSource.Token%2A> propiedad y envía una cancelación de mensajes mediante una llamada a su <xref:System.Threading.CancellationTokenSource.Cancel%2A> o <xref:System.Threading.CancellationTokenSource.CancelAfter%2A> método.  
  
-   Un <xref:System.Threading.CancellationToken> objeto, que indica si se solicita la cancelación.  
  
 El patrón general para implementar el modelo de cancelación cooperativa es:  
  
-   Crear una instancia de un objeto <xref:System.Threading.CancellationTokenSource>, que administra y envía una notificación de cancelación a los tokens de cancelación individuales.  
  
-   Pasar el token devuelto por la propiedad <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> para cada tarea o el subproceso que realiza escuchas de cancelación.  
  
-   Llame a la <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> método desde las operaciones que reciben el token de cancelación. Proporcionan un mecanismo para cada tarea o subproceso responda a una solicitud de cancelación. Si decide cancelar una operación, y exactamente cómo hacerlo, depende de la lógica de aplicación.  
  
-   Llamar al método <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> para proporcionar una notificación de cancelación. Esto establece la <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> propiedad de todas las copias del token de cancelación a `true`.  
  
-   Llame a la <xref:System.Threading.CancellationTokenSource.Dispose%2A> método cuando haya terminado con el <xref:System.Threading.CancellationTokenSource> objeto.  
  
 Para más información, consulte el tema sobre la [cancelación en subprocesos administrados](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar una instancia del tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
   
  
## Examples  
 El ejemplo siguiente utiliza un generador de números aleatorios para emular una aplicación de recopilación de datos que lee los 10 valores enteros de once instruments diferentes. Un valor de cero indica que ha fallado la medida para un instrumento, en cuyo caso se debe cancelar la operación y no Media general se deben calcular.  
  
 Para controlar la cancelación posibles de la operación, el ejemplo crea un <xref:System.Threading.CancellationTokenSource> objeto que genera un token de cancelación que se pasa a un <xref:System.Threading.Tasks.TaskFactory> objeto. La <xref:System.Threading.Tasks.TaskFactory> objeto a su vez pasa el token de cancelación a cada una de las tareas responsable de recopilar lecturas para un método determinado. El <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método se llama para asegurarse de que se calcula la media solo después de que haya recopilado correctamente todas las lecturas. Si una tarea tiene no porque se ha cancelado, la llamada a la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> método produce una excepción.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros públicos y protegidos de <see cref="T:System.Threading.CancellationTokenSource" /> son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos, con la excepción de <see cref="M:System.Threading.CancellationTokenSource.Dispose" />, que debe usarse solo cuando todas las operaciones en el <see cref="T:System.Threading.CancellationTokenSource" /> objeto se ha completado.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa el <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationTokenSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationTokenSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationTokenSource (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (millisecondsDelay As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationTokenSource(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="new System.Threading.CancellationTokenSource : int -&gt; System.Threading.CancellationTokenSource" Usage="new System.Threading.CancellationTokenSource millisecondsDelay" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Intervalo de tiempo en milisegundos que se esperará antes de cancelar este <see cref="T:System.Threading.CancellationTokenSource" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.CancellationTokenSource" /> que se cancela después del retraso especificado en milisegundos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cuenta regresiva para el `millisecondsDelay` se inicia durante la llamada al constructor.  Cuando el `millisecondsDelay` expira, construido <xref:System.Threading.CancellationTokenSource> se cancela (si no se ha cancelado ya).  
  
 Las llamadas subsiguientes a <xref:System.Threading.CancellationTokenSource.CancelAfter%2A> restablecerá el `millisecondsDelay` para construido <xref:System.Threading.CancellationTokenSource>, si ya no se han cancelado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsDelay" /> es menor que 1.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationTokenSource (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.#ctor(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (delay As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationTokenSource(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="new System.Threading.CancellationTokenSource : TimeSpan -&gt; System.Threading.CancellationTokenSource" Usage="new System.Threading.CancellationTokenSource delay" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Intervalo de tiempo que se esperará antes de cancelar este <see cref="T:System.Threading.CancellationTokenSource" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.CancellationTokenSource" /> que se cancela después del intervalo de tiempo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cuenta regresiva para el retraso se inicia durante la llamada al constructor. Cuando transcurra el retraso, construido <xref:System.Threading.CancellationTokenSource> se cancela, si ya no se han cancelado.  
  
 Subsequent calls to <xref:System.Threading.CancellationTokenSource.CancelAfter%2A> will reset the delay for the constructed <xref:System.Threading.CancellationTokenSource>, if it has not been canceled already.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" />
          <see langword="." />
          <see cref="P:System.TimeSpan.TotalMilliseconds" /> es menor que -1 o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="  &#xA;            T:System.ArgumentOutOfRangeException"><paramref name="delay" />
          <see langword="." />
          <see cref="P:System.TimeSpan.TotalMilliseconds" /> es menor que -1 o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Cancel">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comunica una solicitud de cancelación.</summary>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.Cancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel();" />
      <MemberSignature Language="F#" Value="member this.Cancel : unit -&gt; unit" Usage="cancellationTokenSource.Cancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comunica una solicitud de cancelación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El asociado <xref:System.Threading.CancellationToken> le notificará de la cancelación y pasará a un estado donde <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> devuelve true.  
  
 Las operaciones cancelables ni las devoluciones de llamada registran con el <xref:System.Threading.CancellationToken> se ejecutará.  
  
 Se recomienda que las operaciones cancelables y las devoluciones de llamada registran con <xref:System.Threading.CancellationToken> no producir excepciones. 
 
 Esta sobrecarga de Cancel realizará la agregación de las excepciones producidas en un <xref:System.AggregateException>, de modo que una devolución de llamada que producir una excepción no impedirá que otras devoluciones de llamada registradas que se está ejecutando. 
   
  
## Examples  
 El ejemplo siguiente utiliza un generador de números aleatorios para emular una aplicación de recopilación de datos que lee los 10 valores enteros de once instruments diferentes. Un valor de cero indica que ha fallado la medida para un instrumento, en cuyo caso se debe cancelar la operación y no Media general se deben calcular.  
  
 Para controlar la cancelación posibles de la operación, el ejemplo crea un <xref:System.Threading.CancellationTokenSource> objeto que genera un token de cancelación que se pasa a un <xref:System.Threading.Tasks.TaskFactory> objeto. La <xref:System.Threading.Tasks.TaskFactory> objeto a su vez pasa el token de cancelación a cada una de las tareas responsable de recopilar lecturas para un método determinado. El <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método se llama para asegurarse de que se calcula la media solo después de que haya recopilado correctamente todas las lecturas. Si una tarea tiene no porque se ha cancelado, la llamada a la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> método produce una excepción.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Esta interfaz <see cref="T:System.Threading.CancellationTokenSource" /> se ha eliminado.</exception>
        <exception cref="T:System.AggregateException">Una excepción agregada que contiene todas las excepciones producidas por las devoluciones de llamada registradas en el <see cref="T:System.Threading.CancellationToken" /> asociado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel (bool throwOnFirstException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel(bool throwOnFirstException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel (throwOnFirstException As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel(bool throwOnFirstException);" />
      <MemberSignature Language="F#" Value="member this.Cancel : bool -&gt; unit" Usage="cancellationTokenSource.Cancel throwOnFirstException" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="throwOnFirstException" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="throwOnFirstException"><see langword="true" /> si las excepciones se propagan inmediatamente; si no, <see langword="false" />.</param>
        <summary>Comunica una solicitud de cancelación y especifica si se deben procesar las devoluciones de llamada restantes y las operaciones cancelables si se produce una excepción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El asociado <xref:System.Threading.CancellationToken> le notificará de la cancelación y pasará a un estado donde <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> devuelve `true`.  
  
 Las operaciones cancelables ni las devoluciones de llamada registran con el <xref:System.Threading.CancellationToken> se ejecutará. Las devoluciones de llamada se ejecutará de forma sincrónica en orden LIFO. 
  
 Se recomienda que las operaciones cancelables y las devoluciones de llamada registran con <xref:System.Threading.CancellationToken> no producir excepciones. 
  
 Si `throwOnFirstException` es `true`, se propagará inmediatamente una excepción fuera de la llamada a <xref:System.Threading.CancellationTokenSource.Cancel%2A>, que impide que las devoluciones de llamada restantes y operaciones cancelables que se está procesando.  
  
 Si `throwOnFirstException` es `false`, esta sobrecarga agregará cualquier excepción producida en una <xref:System.AggregateException>, de modo que una devolución de llamada que producir una excepción no impedirá que otras devoluciones de llamada registradas que se está ejecutando.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Esta interfaz <see cref="T:System.Threading.CancellationTokenSource" /> se ha eliminado.</exception>
        <exception cref="T:System.AggregateException">Una excepción agregada que contiene todas las excepciones producidas por las devoluciones de llamada registradas en el <see cref="T:System.Threading.CancellationToken" /> asociado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CancelAfter">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Programa una operación de cancelación en este <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CancelAfter">
      <MemberSignature Language="C#" Value="public void CancelAfter (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAfter(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.CancelAfter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAfter (millisecondsDelay As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAfter(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="member this.CancelAfter : int -&gt; unit" Usage="cancellationTokenSource.CancelAfter millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Intervalo de tiempo que hay que esperar antes de cancelar este <see cref="T:System.Threading.CancellationTokenSource" />.</param>
        <summary>Programa una operación de cancelación en este <see cref="T:System.Threading.CancellationTokenSource" /> después del número especificado de milisegundos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cuenta regresiva para el `millisecondsDelay` se inicia durante esta llamada. Cuando el `millisecondsDelay` expira, esto <xref:System.Threading.CancellationTokenSource> se cancela, si ya no se han cancelado.  
  
 Las llamadas subsiguientes a CancelAfter restablecerá el `millisecondsDelay` para este <xref:System.Threading.CancellationTokenSource>, si ya no se han cancelado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Excepción que se produce cuando se ha desechado este <see cref="T:System.Threading.CancellationTokenSource" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Excepción que se produce cuando <paramref name="millisecondsDelay" /> es menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelAfter">
      <MemberSignature Language="C#" Value="public void CancelAfter (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAfter(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.CancelAfter(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAfter (delay As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAfter(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="member this.CancelAfter : TimeSpan -&gt; unit" Usage="cancellationTokenSource.CancelAfter delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Intervalo de tiempo que hay que esperar antes de cancelar este <see cref="T:System.Threading.CancellationTokenSource" />.</param>
        <summary>Programa una operación de cancelación en este <see cref="T:System.Threading.CancellationTokenSource" /> después del intervalo de tiempo especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Excepción que se produce cuando se ha desechado este <see cref="T:System.Threading.CancellationTokenSource" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Excepción que se produce cuando <paramref name="delay" /> es menor que -1 o mayor que Int32.MaxValue.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLinkedTokenSource">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un <see cref="T:System.Threading.CancellationTokenSource" /> que tendrá el estado cancelado cuando alguno de los tokens de origen tenga el estado cancelado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLinkedTokenSource">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationTokenSource CreateLinkedTokenSource (params System.Threading.CancellationToken[] tokens);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.CancellationTokenSource CreateLinkedTokenSource(valuetype System.Threading.CancellationToken[] tokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateLinkedTokenSource (ParamArray tokens As CancellationToken()) As CancellationTokenSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::CancellationTokenSource ^ CreateLinkedTokenSource(... cli::array &lt;System::Threading::CancellationToken&gt; ^ tokens);" />
      <MemberSignature Language="F#" Value="static member CreateLinkedTokenSource : System.Threading.CancellationToken[] -&gt; System.Threading.CancellationTokenSource" Usage="System.Threading.CancellationTokenSource.CreateLinkedTokenSource tokens" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokens" Type="System.Threading.CancellationToken[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tokens">Matriz que contiene instancias de tokens de cancelación que se van a observar.</param>
        <summary>Crea un <see cref="T:System.Threading.CancellationTokenSource" /> que tendrá el estado cancelado cuando alguno de los tokens de origen del la matriz especificada tenga el estado cancelado.</summary>
        <returns><see cref="T:System.Threading.CancellationTokenSource" /> que está vinculado a los tokens de origen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado un <see cref="T:System.Threading.CancellationTokenSource" /> asociado a uno de los tokens de origen.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="tokens" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tokens" /> está vacía.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6f4f3804-2ed7-41b4-a97a-6e32b93f6e05">Cómo: Realizar escuchas de varias solicitudes de cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="CreateLinkedTokenSource">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationTokenSource CreateLinkedTokenSource (System.Threading.CancellationToken token1, System.Threading.CancellationToken token2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.CancellationTokenSource CreateLinkedTokenSource(valuetype System.Threading.CancellationToken token1, valuetype System.Threading.CancellationToken token2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.CreateLinkedTokenSource(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateLinkedTokenSource (token1 As CancellationToken, token2 As CancellationToken) As CancellationTokenSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::CancellationTokenSource ^ CreateLinkedTokenSource(System::Threading::CancellationToken token1, System::Threading::CancellationToken token2);" />
      <MemberSignature Language="F#" Value="static member CreateLinkedTokenSource : System.Threading.CancellationToken * System.Threading.CancellationToken -&gt; System.Threading.CancellationTokenSource" Usage="System.Threading.CancellationTokenSource.CreateLinkedTokenSource (token1, token2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token1" Type="System.Threading.CancellationToken" />
        <Parameter Name="token2" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="token1">Primer token de cancelación que se va a observar.</param>
        <param name="token2">Segundo token de cancelación que se va a observar.</param>
        <summary>Crea un <see cref="T:System.Threading.CancellationTokenSource" /> que tendrá el estado cancelado cuando alguno de los tokens de origen tenga el estado cancelado.</summary>
        <returns><see cref="T:System.Threading.CancellationTokenSource" /> que está vinculado a los tokens de origen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado un <see cref="T:System.Threading.CancellationTokenSource" /> asociado a uno de los tokens de origen.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6f4f3804-2ed7-41b4-a97a-6e32b93f6e05">Cómo: Realizar escuchas de varias solicitudes de cancelación</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="cancellationTokenSource.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a `Dispose` cuando haya terminado de usar <xref:System.Threading.CancellationTokenSource>. El método `Dispose` deja el <xref:System.Threading.CancellationTokenSource> en un estado no utilizable. Después de llamar a `Dispose`, debe liberar todas las referencias a la <xref:System.Threading.CancellationTokenSource> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Threading.CancellationTokenSource> estaba ocupando.  
  
 Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a `Dispose` antes de liberar la última referencia al objeto <xref:System.Threading.CancellationTokenSource>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Threading.CancellationTokenSource> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationTokenSource.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="cancellationTokenSource.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados utilizados por la clase <see cref="T:System.Threading.CancellationTokenSource" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCancellationRequested">
      <MemberSignature Language="C#" Value="public bool IsCancellationRequested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCancellationRequested" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationTokenSource.IsCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCancellationRequested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCancellationRequested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCancellationRequested : bool" Usage="System.Threading.CancellationTokenSource.IsCancellationRequested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si se solicitó la cancelación de este <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
        <value><see langword="false" /> si se solicitó la cancelación de este <see langword="true" />; en caso contrario, <see cref="T:System.Threading.CancellationTokenSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad indica si ha solicitado la cancelación para este origen de token, por ejemplo, debido a una llamada a su <xref:System.Threading.CancellationTokenSource.Cancel%2A> método.  
  
 Si esta propiedad devuelve `true`, solo garantiza que se ha solicitado la cancelación. No se garantiza que cada controlador registrado con el token correspondiente ha terminado de ejecutar, ni que las solicitudes de cancelación han acabado de propagarse a todos los controladores registrados. Una sincronización adicional puede ser necesaria, especialmente en situaciones donde se cancelan los objetos relacionados al mismo tiempo.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="Token">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken Token { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken Token" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationTokenSource.Token" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Token As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken Token { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.Token : System.Threading.CancellationToken" Usage="System.Threading.CancellationTokenSource.Token" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Threading.CancellationToken" /> asociado a <see cref="T:System.Threading.CancellationTokenSource" />.</summary>
        <value><see cref="T:System.Threading.CancellationToken" /> asociada a esta <see cref="T:System.Threading.CancellationTokenSource" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el origen del token.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
  </Members>
</Type>