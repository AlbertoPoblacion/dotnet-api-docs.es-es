<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ff770bb9446d6ebe71649784ebe115f60734cc0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="8d3eb-101">Representa un bloqueo que se usa para administrar el acceso a un recurso y que permite que varios subprocesos lean o tengan acceso exclusivo a escritura.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8d3eb-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-102">Use <xref:System.Threading.ReaderWriterLockSlim> para proteger un recurso que se leen varios subprocesos y escribiendo en un subproceso a la vez.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="8d3eb-103"><xref:System.Threading.ReaderWriterLockSlim> permite que varios subprocesos en modo de lectura, permite que un subproceso esté en modo de escritura con propiedad exclusiva del bloqueo y permite que un subproceso que tiene acceso de lectura a estar en modo de lectura actualizable, desde el que puede actualizar el subproceso para el modo de escritura sin tener que abandonarlo s el acceso de lectura al recurso.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-104"><xref:System.Threading.ReaderWriterLockSlim> es similar a <xref:System.Threading.ReaderWriterLock>, pero se han simplificado las reglas para la recursividad y para actualizar y degradar el estado de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="8d3eb-105"><xref:System.Threading.ReaderWriterLockSlim> evita muchos casos de interbloqueo potencial.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="8d3eb-106">Además, el rendimiento de <xref:System.Threading.ReaderWriterLockSlim> es significativamente mayor que <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="8d3eb-107"><xref:System.Threading.ReaderWriterLockSlim> se recomienda para todos los nuevos desarrollos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="8d3eb-108">De forma predeterminada, las nuevas instancias de <xref:System.Threading.ReaderWriterLockSlim> se crean con el <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> marca y no permiten la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="8d3eb-109">Esta directiva predeterminada se recomienda para todos los nuevos desarrollos, porque la recursividad presenta complicaciones innecesarias y hace que el código sea más susceptible a los interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="8d3eb-110">Para simplificar la migración desde existente los proyectos que utilizan <xref:System.Threading.Monitor> o <xref:System.Threading.ReaderWriterLock>, puede usar el <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> marca para crear instancias de <xref:System.Threading.ReaderWriterLockSlim> que permiten la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="8d3eb-111">Un subproceso puede entrar en el bloqueo en tres modos: modo, en modo de escritura y en modo de lectura de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="8d3eb-112">(En el resto de este tema, "modo de lectura actualizable" se conoce como "en modo de actualización" y la frase "escriba `x` modo" se usa con preferencia a la frase más larga "entrar en el bloqueo en `x` modo".)</span><span class="sxs-lookup"><span data-stu-id="8d3eb-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="8d3eb-113">Independientemente de la directiva de recursividad, sólo un subproceso puede estar en modo de escritura en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="8d3eb-114">Cuando un subproceso está en modo de escritura, ningún otro subproceso puede entrar en el bloqueo en cualquier modo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="8d3eb-115">Solo un subproceso puede estar en modo de actualización en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="8d3eb-116">Puede ser cualquier número de subprocesos en modo de lectura, y puede haber un subproceso en modo de actualización mientras otros subprocesos están en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d3eb-117">Este tipo implementa la <xref:System.IDisposable> interfaz.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="8d3eb-118">Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="8d3eb-119">Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="8d3eb-120">Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="8d3eb-121">Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="8d3eb-122"><xref:System.Threading.ReaderWriterLockSlim> se administra la afinidad de subprocesos; es decir, cada uno de ellos <xref:System.Threading.Thread> objeto debe realizar sus propia llamadas de método al entrar y salir de los modos de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="8d3eb-123">No hay ningún subproceso puede cambiar el modo de otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="8d3eb-124">Si un <xref:System.Threading.ReaderWriterLockSlim> no permite la recursividad, un subproceso que intenta entrar en el bloqueo se puede bloquear por varias razones:</span><span class="sxs-lookup"><span data-stu-id="8d3eb-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="8d3eb-125">Un subproceso que intenta entrar en modo de lectura se bloquea si hay subprocesos a la espera de entrar en modo de escritura o si hay un solo subproceso en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="8d3eb-126">Cuando se ponen en cola los escritores de bloqueo nuevos lectores es una directiva de equidad de bloqueo que favorece a escritores.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="8d3eb-127">La directiva de equidad actual equilibra la equidad para lectores y escritores, para mejorar el rendimiento en los escenarios más comunes.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="8d3eb-128">Las versiones futuras de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] pueden introducir nuevas directivas de equidad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="8d3eb-129">Un subproceso que intenta entrar en modo de actualización se bloquea si ya hay un subproceso en modo de actualización, si hay subprocesos a la espera de entrar en modo de escritura, o si hay un solo subproceso en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="8d3eb-130">Un subproceso que intenta entrar en modo de escritura se bloquea si hay un subproceso en cualquiera de los tres modos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="8d3eb-131">Actualizar y degradar bloqueos</span><span class="sxs-lookup"><span data-stu-id="8d3eb-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="8d3eb-132">En modo de actualización está pensado para los casos donde un subproceso normalmente lee el recurso protegido, pero que tenga que escribir en ella si se cumple alguna condición.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="8d3eb-133">Un subproceso que ha entrado en un <xref:System.Threading.ReaderWriterLockSlim> en modo de actualización tiene acceso de lectura al recurso protegido y puede actualizarse al modo de escritura mediante una llamada a la <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="8d3eb-134">Porque puede haber solo un subproceso en modo de actualización a la vez, no se puede actualizar a modo de escritura deadlock cuando no se permite la recursividad, que es la directiva predeterminada.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d3eb-135">Independientemente de la directiva de recursividad, un subproceso que entró inicialmente lee modo no se admite para actualizar a modo de actualización o en modo de escritura, porque ese modelo genera una gran probabilidad de interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="8d3eb-136">Por ejemplo, si dos subprocesos en modo de lectura intentan entrar en modo de escritura, interbloquee.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="8d3eb-137">En modo de actualización está diseñado para evitar estos interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="8d3eb-138">Si hay otros subprocesos en modo de lectura, el subproceso que está actualizando se bloquea.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="8d3eb-139">Mientras el subproceso está bloqueado, se bloquean otros subprocesos que intenten entrar en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="8d3eb-140">Cuando todos los subprocesos han salido del modo de lectura, el subproceso actualizable bloqueado entra en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="8d3eb-141">Si hay otros subprocesos a la espera de entrar en modo de escritura, siguen bloqueados, porque el subproceso que está en modo de actualización evita que obtengan acceso exclusivo al recurso.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="8d3eb-142">Cuando el subproceso en modo de actualización sale del modo de escritura, otros subprocesos que están a la espera de entrar en modo de lectura pueden hacer por lo tanto, a menos que haya subprocesos espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="8d3eb-143">El subproceso en modo de actualización puede actualizar y degradar indefinidamente, siempre y cuando sea el único subproceso que escribe en el recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d3eb-144">Si permite que varios subprocesos entren en modo de escritura o en modo de actualización, que no debe permitir un subproceso monopolice en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="8d3eb-145">En caso contrario, los subprocesos que intenten entrar escriben modo directamente se bloqueará indefinidamente, y mientras estén bloqueados, otros subprocesos no podrá entrar en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="8d3eb-146">Un subproceso en modo de actualización puede producir una degradación para modo de lectura llamando primero la <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método y, a continuación, llamar a la <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="8d3eb-147">Este modelo de degradación se permite para todas las directivas de recursividad de bloqueo, incluso <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="8d3eb-148">Después de degradar para el modo de lectura, un subproceso no puede volver a escribir en modo de actualización hasta que se ha salido del modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="8d3eb-149">Especificar el bloqueo de forma recursiva</span><span class="sxs-lookup"><span data-stu-id="8d3eb-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="8d3eb-150">Puede crear un <xref:System.Threading.ReaderWriterLockSlim> que admite la entrada de bloqueo recursiva mediante el <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor que especifica la directiva de bloqueo y especificando <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-151">El uso de la recursividad no se recomienda para nuevo desarrollo, porque presenta complicaciones innecesarias y hace que el código sea más susceptible a los interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="8d3eb-152">Para un <xref:System.Threading.ReaderWriterLockSlim> que permite la recursividad, se puede decir lo siguiente acerca de los modos de un subproceso puede entrar:</span><span class="sxs-lookup"><span data-stu-id="8d3eb-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="8d3eb-153">Un subproceso en modo de lectura puede entrar de forma recursiva de modo de lectura, pero no puede entrar en modo de escritura o en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="8d3eb-154">Si intenta hacerlo, un <xref:System.Threading.LockRecursionException> se produce.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="8d3eb-155">Escribir lee modo y, a continuación, escriba en modo de escritura o en modo de actualización es un modelo con muchas probabilidades de interbloqueos, por lo que no está permitido.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="8d3eb-156">Como se indicó anteriormente, en modo de actualización se proporciona para los casos donde es necesario actualizar un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="8d3eb-157">Un subproceso en modo de actualización puede entrar en modo de escritura y/o modo de lectura y puede especificar cualquiera de la tres modos de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="8d3eb-158">Sin embargo, se intenta escribir escribir bloques de modo si hay otros subprocesos en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="8d3eb-159">Un subproceso en modo de escritura puede entrar en modo de lectura y/o en modo de actualización y puede especificar cualquiera de la tres modos de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="8d3eb-160">Un subproceso que no ha entrado en el bloqueo puede entrar en cualquier modo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="8d3eb-161">Este intento puede bloquear por las mismas razones como un intento de entrar en un bloqueo no recursivo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="8d3eb-162">Un subproceso puede salir de los modos que ha entrado en cualquier orden, siempre y cuando sale del modo de cada exactamente como tantas veces como entró en ese modo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="8d3eb-163">Si un subproceso intenta salir de un modo demasiadas veces, o para salir de un modo no entró, un <xref:System.Threading.SynchronizationLockException> se produce.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="8d3eb-164">Estados de bloqueo</span><span class="sxs-lookup"><span data-stu-id="8d3eb-164">Lock States</span></span>  
 <span data-ttu-id="8d3eb-165">Puede que le resulte útil pensar en el bloqueo en términos de sus Estados.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="8d3eb-166">Un <xref:System.Threading.ReaderWriterLockSlim> puede estar en uno de cuatro estados: no se especifica, leer, actualizar y escribir.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="8d3eb-167">No se especificó: en este estado, no hay ningún subproceso ha entrado en el bloqueo (o todos los subprocesos han salido el bloqueo).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="8d3eb-168">Lectura: En este estado, uno o más subprocesos han entrado en el bloqueo para el acceso de lectura al recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="8d3eb-169">Un subproceso puede entrar en el bloqueo en modo de lectura mediante el uso de la <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> métodos, o degradar en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="8d3eb-170">Actualización: En este estado, un subproceso ha entrado en el bloqueo para el acceso de lectura con la opción de actualización para acceso de escritura (es decir, en modo de actualización), y cero o más subprocesos han entrado en el bloqueo para el acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="8d3eb-171">No más de un subproceso a la vez puede entrar en el bloqueo con la opción de actualización; se bloquean los subprocesos adicionales que intenten entrar en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="8d3eb-172">Escritura: En este estado, un subproceso ha entrado en el bloqueo para el acceso de escritura al recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="8d3eb-173">Ese subproceso tiene posesión exclusiva del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="8d3eb-174">Ningún otro subproceso que intenta entrar en el bloqueo por cualquier razón está bloqueado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="8d3eb-175">La tabla siguiente describen las transiciones entre Estados de bloqueo, para los bloqueos que no permiten la recursividad, cuando un subproceso `t` toma la acción descrita en la columna izquierda.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="8d3eb-176">En el momento en toma las medidas, `t` no tiene ningún modo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="8d3eb-177">(El caso especial donde `t` está en modo de actualización se describe en las notas al pie de tabla.) La fila superior describe el estado inicial del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="8d3eb-178">Las celdas describen lo que ocurre al subproceso y mostrar los cambios en el estado de bloqueo entre paréntesis.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="8d3eb-179">No se ha introducido (N)</span><span class="sxs-lookup"><span data-stu-id="8d3eb-179">Not entered (N)</span></span>|<span data-ttu-id="8d3eb-180">Read (R)</span><span class="sxs-lookup"><span data-stu-id="8d3eb-180">Read (R)</span></span>|<span data-ttu-id="8d3eb-181">Actualización (U)</span><span class="sxs-lookup"><span data-stu-id="8d3eb-181">Upgrade (U)</span></span>|<span data-ttu-id="8d3eb-182">Escritura (W)</span><span class="sxs-lookup"><span data-stu-id="8d3eb-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="8d3eb-183">`t` entra en modo de lectura</span><span class="sxs-lookup"><span data-stu-id="8d3eb-183">`t` enters read mode</span></span>|<span data-ttu-id="8d3eb-184">`t` entra en (R).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-184">`t` enters (R).</span></span>|<span data-ttu-id="8d3eb-185">`t` se bloquea si hay subprocesos en espera para el modo de escritura; en caso contrario, `t` entra en.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="8d3eb-186">`t` se bloquea si hay subprocesos en espera para el modo de escritura; en caso contrario, `t` entra.<sup> 1</sup></span><span class="sxs-lookup"><span data-stu-id="8d3eb-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="8d3eb-187">`t` se bloquea.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-187">`t` blocks.</span></span>|  
|<span data-ttu-id="8d3eb-188">`t` entra en modo de actualización</span><span class="sxs-lookup"><span data-stu-id="8d3eb-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="8d3eb-189">`t` entra en (A).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-189">`t` enters (U).</span></span>|<span data-ttu-id="8d3eb-190">`t` se bloquea si hay subprocesos esperan a modo de escritura o modo de actualización; en caso contrario, `t` entra en (A).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="8d3eb-191">`t` se bloquea.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-191">`t` blocks.</span></span>|<span data-ttu-id="8d3eb-192">`t` se bloquea.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-192">`t` blocks.</span></span>|  
|<span data-ttu-id="8d3eb-193">`t` entra en modo de escritura</span><span class="sxs-lookup"><span data-stu-id="8d3eb-193">`t` enters write mode</span></span>|<span data-ttu-id="8d3eb-194">`t` entra en (W).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-194">`t` enters (W).</span></span>|<span data-ttu-id="8d3eb-195">`t` se bloquea.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-195">`t` blocks.</span></span>|<span data-ttu-id="8d3eb-196">`t` se bloquea. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="8d3eb-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="8d3eb-197">`t` se bloquea.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="8d3eb-198"><sup>1</sup> si `t` inicia alejar en modo de actualización, entra en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="8d3eb-199">Esta acción nunca se bloquea.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-199">This action never blocks.</span></span> <span data-ttu-id="8d3eb-200">No cambia el estado de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-200">The lock state does not change.</span></span> <span data-ttu-id="8d3eb-201">(El subproceso, a continuación, puede completar una degradación a modo de lectura y sale de en modo de actualización.)</span><span class="sxs-lookup"><span data-stu-id="8d3eb-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="8d3eb-202"><sup>2</sup> si `t` empieza en modo de actualización, se bloquea si hay subprocesos en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="8d3eb-203">En caso contrario, actualiza a modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="8d3eb-204">Los cambios de estado de bloqueo de escritura (W).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="8d3eb-205">Si `t` se bloquea porque hay subprocesos en modo de lectura, entra en modo de escritura en cuanto el último subproceso sale del modo de lectura, incluso si no hay subprocesos espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="8d3eb-206">Cuando se produce un cambio de estado porque un subproceso sale del bloqueo, el siguiente subproceso que debe activarse se selecciona como sigue:</span><span class="sxs-lookup"><span data-stu-id="8d3eb-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="8d3eb-207">En primer lugar, un subproceso que está esperando en modo de escritura y ya está en modo de actualización (puede haber a lo sumo un subproceso de este tipo).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="8d3eb-208">Si no es posible, un subproceso que está esperando para el modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="8d3eb-209">Si no es posible, un subproceso que espera en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="8d3eb-210">Si no es posible, todos los subprocesos que están esperando a modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="8d3eb-211">El estado posterior del bloqueo siempre es escritura (W) en los dos primeros casos y actualización (U) en el tercer caso, independientemente del estado del bloqueo cuando el subproceso que sale activa el cambio de estado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="8d3eb-212">En este último caso, el estado del bloqueo es actualización (A) si hay un subproceso en modo de actualización después del cambio de estado y Read (R) en caso contrario, con independencia del estado anterior.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-213">En el ejemplo siguiente se muestra una memoria caché sincronizada simple que contiene cadenas con claves de enteros.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="8d3eb-214">Una instancia de <xref:System.Threading.ReaderWriterLockSlim> se utiliza para sincronizar el acceso a la <xref:System.Collections.Generic.Dictionary%602> que actúa como la memoria caché interna.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="8d3eb-215">En el ejemplo se incluye métodos simples para agregar a la caché, elimine de la memoria caché y de lectura de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="8d3eb-216">Para mostrar los tiempos de espera, el ejemplo incluye un método que agrega a la memoria caché solo si puede hacerlo dentro de un tiempo de espera especificado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="8d3eb-217">Para mostrar en modo de actualización, el ejemplo incluye un método que recupera el valor asociado a una clave y lo compara con un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="8d3eb-218">Si el valor se ha modificado, el método devuelve un estado que indica ningún cambio.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="8d3eb-219">Se encuentra ningún valor para la clave, se inserta el par clave/valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-219">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="8d3eb-220">Si ha cambiado el valor, se actualiza.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="8d3eb-221">En modo de actualización permite al subproceso de actualización de acceso de lectura a acceso de escritura según sea necesario, sin el riesgo de interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="8d3eb-222">El ejemplo incluye una enumeración anidada que especifica los valores devueltos del método que se muestra en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="8d3eb-223">En el ejemplo se usa el constructor predeterminado para crear el bloqueo, por lo que no se permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-223">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="8d3eb-224">Programar la <xref:System.Threading.ReaderWriterLockSlim> es más sencillo y menos propenso a errores cuando el bloqueo no permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="8d3eb-225">El siguiente código a continuación, utiliza el `SynchronizedCache` objeto para almacenar un diccionario de nombres vegetales.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="8d3eb-226">Crea tres tareas.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-226">It creates three tasks.</span></span> <span data-ttu-id="8d3eb-227">La primera escribe los nombres de verduras almacenados en una matriz a un `SynchronizedCache` instancia.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="8d3eb-228">La tarea de segunda y tercer mostrar los nombres de las verduras, el primero en orden ascendente (de bajo índice de índice más alto), el segundo en orden descendente.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="8d3eb-229">La tarea final busca la cadena "vino" y, cuando lo encuentra, llama a la <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método sustituir la cadena "bean verde".</span><span class="sxs-lookup"><span data-stu-id="8d3eb-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="8d3eb-230">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8d3eb-230">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-231">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-232">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" /> con los valores de propiedad predeterminados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-233">Un <xref:System.Threading.ReaderWriterLockSlim> que se inicializa con este constructor no permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="8d3eb-234">Es decir, la propiedad <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> devuelve <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8d3eb-235">Para obtener más información acerca de la directiva de recursividad y sus efectos, consulte la <xref:System.Threading.LockRecursionPolicy> enumeración y <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-236">En el ejemplo siguiente se muestra una memoria caché sincronizada simple que contiene cadenas con claves de enteros.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="8d3eb-237">Una instancia de <xref:System.Threading.ReaderWriterLockSlim> se utiliza para sincronizar el acceso a la <xref:System.Collections.Generic.Dictionary%602> que actúa como la memoria caché interna.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="8d3eb-238">El constructor sin parámetros se utiliza para crear el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="8d3eb-239">En el ejemplo se incluye métodos simples para agregar a la caché, elimine de la memoria caché y de lectura de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="8d3eb-240">Para mostrar los tiempos de espera, el ejemplo incluye un método que agrega a la memoria caché solo si puede hacerlo dentro de un tiempo de espera especificado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="8d3eb-241">Para mostrar en modo de actualización, el ejemplo incluye un método que recupera el valor asociado a una clave y lo compara con un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="8d3eb-242">Si el valor se ha modificado, el método devuelve un estado que indica ningún cambio.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="8d3eb-243">Se encuentra ningún valor para la clave, se inserta el par clave/valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-243">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="8d3eb-244">Si ha cambiado el valor, se actualiza.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="8d3eb-245">En modo de actualización permite al subproceso de actualización de acceso de lectura a acceso de escritura según sea necesario, sin el riesgo de interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="8d3eb-246">El ejemplo incluye una enumeración anidada que especifica los valores devueltos del método que se muestra en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="8d3eb-247">En el ejemplo se usa el constructor predeterminado para crear el bloqueo, por lo que no se permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-247">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="8d3eb-248">Programar la <xref:System.Threading.ReaderWriterLockSlim> es más sencillo y menos propenso a errores cuando el bloqueo no permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="8d3eb-249">El siguiente código a continuación, utiliza el `SynchronizedCache` objeto para almacenar un diccionario de nombres vegetales.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="8d3eb-250">Crea tres tareas.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-250">It creates three tasks.</span></span> <span data-ttu-id="8d3eb-251">La primera escribe los nombres de verduras almacenados en una matriz a un `SynchronizedCache` instancia.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="8d3eb-252">La tarea de segunda y tercer mostrar los nombres de las verduras, el primero en orden ascendente (de bajo índice de índice más alto), el segundo en orden descendente.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="8d3eb-253">La tarea final busca la cadena "vino" y, cuando lo encuentra, llama a la <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método sustituir la cadena "bean verde".</span><span class="sxs-lookup"><span data-stu-id="8d3eb-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">
          <span data-ttu-id="8d3eb-254">Uno de los valores de enumeración que especifica la directiva de recursividad de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-254">One of the enumeration values that specifies the lock recursion policy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8d3eb-255">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" /> especificando la directiva de recursividad de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-256">La directiva de recursividad determina las restricciones en los subprocesos que entran en el bloqueo más de una vez.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="8d3eb-257">Por ejemplo, si se ha creado un bloqueo con <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> y un subproceso ha entrado en el bloqueo en modo de lectura, <xref:System.Threading.LockRecursionException> se produce si el subproceso intenta volver a escribir el bloqueo en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="8d3eb-258">De forma similar, si un subproceso ha entrado en el bloqueo en modo de escritura, <xref:System.Threading.LockRecursionException> se produce si el subproceso intenta volver a escribir el bloqueo en cualquier modo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-259">Un subproceso en modo de actualización puede actualizarse a modo de escritura o degradación modo independientemente de la configuración de directiva de recursividad de bloqueo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="8d3eb-260">Independientemente de la directiva de recursividad, un subproceso que entró inicialmente lee modo no se admite para actualizar a modo de actualización o en modo de escritura, porque ese modelo genera una gran probabilidad de interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="8d3eb-261">Para obtener más información acerca de la directiva de recursividad y sus efectos, consulte la <xref:System.Threading.LockRecursionPolicy> enumeración y <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-262">El ejemplo siguiente muestra dos escenarios de excepción, uno que depende el <xref:System.Threading.LockRecursionPolicy> configuración y otro que no lo hace.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="8d3eb-263">En el primer escenario, el subproceso entra en modo de lectura y, a continuación, intenta entrar en modo de lectura de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="8d3eb-264">Si el <xref:System.Threading.ReaderWriterLockSlim> se crea mediante el constructor predeterminado, que establece la directiva de recursividad en <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="8d3eb-265">Si <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> se utiliza para crear el <xref:System.Threading.ReaderWriterLockSlim>, se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="8d3eb-266">En el segundo escenario, el subproceso entra en modo de lectura y, a continuación, intenta entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="8d3eb-267"><xref:System.Threading.LockRecursionException> se produce independientemente de la directiva de recursividad de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="8d3eb-268">El siguiente código a continuación, utiliza el `SynchronizedCache` objeto para almacenar un diccionario de nombres vegetales.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="8d3eb-269">Crea tres tareas.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-269">It creates three tasks.</span></span> <span data-ttu-id="8d3eb-270">La primera escribe los nombres de verduras almacenados en una matriz a un `SynchronizedCache` instancia.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="8d3eb-271">La tarea de segunda y tercer mostrar los nombres de las verduras, el primero en orden ascendente (de bajo índice de índice más alto), el segundo en orden descendente.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="8d3eb-272">La tarea final busca la cadena "vino" y, cuando lo encuentra, llama a la <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método sustituir la cadena "bean verde".</span><span class="sxs-lookup"><span data-stu-id="8d3eb-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-273">Obtiene el número total de subprocesos únicos que han entrado en el bloqueo en modo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-273">Gets the total number of unique threads that have entered the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-274">Número de subprocesos únicos que han entrado en el bloqueo en modo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-274">The number of unique threads that have entered the lock in read mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-275">Un subproceso se cuenta una sola vez, incluso si el bloqueo permite la recursividad y el subproceso ha entrado en modo de lectura varias veces.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="8d3eb-276">Utilice esta propiedad solo para depurar, de generación de perfiles y con fines de registro y no para controlar el comportamiento de un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="8d3eb-277">Los resultados pueden cambiar en cuanto se hayan calculado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="8d3eb-278">Por lo tanto, no es seguro tomar decisiones basadas en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-279">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> propiedad que se va a generar una entrada de registro de eventos si el número de subprocesos en modo de lectura supera un umbral.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-280">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-281">Llame a <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> cuando haya terminado de usar <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="8d3eb-282">El método <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> deja el <xref:System.Threading.ReaderWriterLockSlim> en un estado no utilizable.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="8d3eb-283">Después de llamar a <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, debe liberar todas las referencias a la <xref:System.Threading.ReaderWriterLockSlim> para que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Threading.ReaderWriterLockSlim> estaba ocupando.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="8d3eb-284">Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="8d3eb-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-285">Llame siempre a <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> antes de liberar la última referencia a la <xref:System.Threading.ReaderWriterLockSlim> objeto.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="8d3eb-286">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> es mayor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-286">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span>
          </span>
          <span data-ttu-id="8d3eb-287">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-287">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-288">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> es mayor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-288">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span>
          </span>
          <span data-ttu-id="8d3eb-289">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-289">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-290">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> es mayor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-290">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-291">Intenta entrar en el bloqueo en modo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-291">Tries to enter the lock in read mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-292">Este método se bloquea hasta que el subproceso que realiza la llamada entra en el bloqueo y, por lo tanto, es posible que nunca se devuelve.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="8d3eb-293">Use la <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método bloquear durante un intervalo especificado y, a continuación, regrese si el subproceso que realiza la llamada no ha entrado en modo lectura durante ese intervalo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="8d3eb-294">Varios subprocesos pueden entrar en modo de lectura al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="8d3eb-295">Si uno o varios subprocesos en espera de entrar en modo de escritura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método se bloquea hasta que esos subprocesos agotó el tiempo o entró en modo de escritura y, a continuación, sale de ella.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-296">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de lectura puede entrar recursivamente de modo de lectura, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="8d3eb-297">A lo sumo un subproceso puede estar en modo de actualización mientras otros subprocesos están en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="8d3eb-298">Si los subprocesos adicionales se esperan de entrar en modo de actualización y no hay ningún subproceso esperando para entrar en el modo de escritura, los subprocesos que llaman los <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método entrar en modo de lectura inmediatamente y no se bloquean.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-299">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método para entrar en el bloqueo en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="8d3eb-300">El método mostrado en el ejemplo recupera el valor asociado a una clave.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="8d3eb-301">Si la clave no se encuentra, la excepción producida por interna <xref:System.Collections.Generic.Dictionary%602> puede finalizar el método.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="8d3eb-302">A `finally` bloque se usa para ejecutar el <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> método, lo que garantiza que el llamador sale del modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="8d3eb-303">Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-304">El subproceso actual no puede adquirir el bloqueo de escritura cuando tiene el bloqueo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-304">The current thread cannot acquire the write lock when it holds the read lock.</span>
          </span>
          <span data-ttu-id="8d3eb-305">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-305">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-306">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual intentó adquirir el bloqueo de lectura cuando ya tenía el bloqueo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span>
          </span>
          <span data-ttu-id="8d3eb-307">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-307">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-308">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual intentó adquirir el bloqueo de lectura cuando ya tenía el bloqueo de escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-308">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span>
          </span>
          <span data-ttu-id="8d3eb-309">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-309">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-310">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-310">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-311">Este límite es tan grande que en las aplicaciones no debe aparecer nunca esta excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-311">This limit is so large that applications should never encounter this exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-312">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-312">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-313">Intenta entrar en el bloqueo en modo de actualización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-313">Tries to enter the lock in upgradeable mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-314">Este método se bloquea hasta que el subproceso que realiza la llamada entra en el bloqueo y, por lo tanto, es posible que nunca se devuelve.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-314">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="8d3eb-315">Use la <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método bloquear durante un intervalo especificado y, a continuación, regrese si el subproceso que realiza la llamada no ha entrado en modo de actualización durante ese intervalo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-315">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="8d3eb-316">Use en modo de actualización cuando un subproceso suele tener acceso al recurso que está protegido por el <xref:System.Threading.ReaderWriterLockSlim> en el modo de lectura, pero que necesite escribir el modo de escritura si se cumplen determinadas condiciones.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-316">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="8d3eb-317">Un subproceso en modo de actualización puede cambiar para el modo de lectura o actualizar a modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-317">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="8d3eb-318">Sólo un subproceso puede entrar en modo de actualización en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-318">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="8d3eb-319">Si un subproceso está en modo de actualización y no hay ningún subproceso esperando para entrar en el modo de escritura, cualquier número de otros subprocesos puede entrar en modo de lectura, incluso si hay subprocesos a la espera de entrar en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-319">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="8d3eb-320">Si uno o varios subprocesos en espera de entrar en modo de escritura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método se bloquea hasta que esos subprocesos agotó el tiempo o entró en modo de escritura y, a continuación, sale de ella.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-320">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-321">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de actualización puede entrar en modo de actualización de forma recursiva, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-321">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-322">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> método para entrar en el bloqueo en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-322">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="8d3eb-323">A `finally` bloque se usa para ejecutar el <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método, lo que garantiza que el llamador sale del modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-323">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="8d3eb-324">El método mostrado en el ejemplo recupera el valor asociado a una clave y lo compara con un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-324">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="8d3eb-325">Si el valor se ha modificado, el método devuelve un estado que indica ningún cambio.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-325">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="8d3eb-326">Se encuentra ningún valor para la clave, se inserta el par clave/valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-326">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="8d3eb-327">Si ha cambiado el valor, se actualiza.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-327">If the value has changed, it is updated.</span></span> <span data-ttu-id="8d3eb-328">En modo de actualización permite al subproceso actualizar el bloqueo de lectura según sea necesario, sin riesgo de interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-328">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="8d3eb-329">En el ejemplo se usa el constructor predeterminado para crear el bloqueo, por lo que no se permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-329">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="8d3eb-330">Programar la <xref:System.Threading.ReaderWriterLockSlim> es más sencillo y menos propenso a errores cuando el bloqueo no permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-330">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="8d3eb-331">Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-331">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-332">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo en cualquier modo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-332">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          </span>
          <span data-ttu-id="8d3eb-333">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-333">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-334">El subproceso actual ha entrado en modo de lectura, por lo que, al intentar entrar en modo de actualización, existiría la posibilidad de interbloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-334">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="8d3eb-335">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-335">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-336">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-336">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-337">El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-337">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-338">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-338">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-339">Intenta entrar en el bloqueo en modo de escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-339">Tries to enter the lock in write mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-340">Este método se bloquea hasta que el subproceso que realiza la llamada entra en el bloqueo y, por lo tanto, es posible que nunca se devuelve.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-340">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="8d3eb-341">Use la <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método bloquear durante un intervalo especificado y, a continuación, devolver si el subproceso que realiza la llamada no ha entrado en modo de escritura durante ese intervalo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-341">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="8d3eb-342">Si otros subprocesos han entrado en el bloqueo en modo de lectura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> método se bloquea hasta que los subprocesos han salido del modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-342">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="8d3eb-343">Cuando hay subprocesos a la espera de entrar en modo de escritura, otros subprocesos que intenten entrar en modo de lectura o de bloque en modo de actualización hasta que todos los subprocesos en espera de entrar en modo de escritura agotó el tiempo o entró en modo de escritura y, a continuación, salgan de ella.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-343">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-344">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de escritura puede entrar recursivamente de modo de escritura, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-344">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-345">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> método para entrar en el bloqueo en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-345">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="8d3eb-346">El método mostrado en el ejemplo agrega un nuevo par clave/valor en la memoria caché sincronizada.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-346">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="8d3eb-347">Si la clave ya está en la memoria caché, la excepción producida por interna <xref:System.Collections.Generic.Dictionary%602> puede finalizar el método.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-347">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="8d3eb-348">A `finally` bloque se usa para ejecutar el <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, lo que garantiza que el llamador sale del modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-348">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="8d3eb-349">Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-349">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-350">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo en cualquier modo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-350">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          </span>
          <span data-ttu-id="8d3eb-351">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-351">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-352">El subproceso actual ha entrado en modo de lectura, por lo que, si se intenta entrar en el bloqueo en modo de escritura, existiría la posibilidad de un interbloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-352">The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="8d3eb-353">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-353">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-354">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-354">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-355">El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-355">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-356">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-356">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-357">Reduce el recuento de recursividad para el modo de lectura y sale del modo de lectura si el recuento resultante es 0 (cero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-357">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-358">Este método no es sensible al orden de recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-358">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="8d3eb-359">Por ejemplo, si un subproceso entra en un bloqueo en modo de actualización y, a continuación, entra en el bloqueo en modo de lectura, no importa el orden en el que el subproceso sale de los dos modos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-359">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="8d3eb-360">Si un bloqueo permite la recursividad, un subproceso puede entrar en el bloqueo en modo de escritura y, a continuación, escríbala de forma recursiva en modo de lectura; el orden en que el subproceso sale del modo de lectura y no importa el modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-360">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="8d3eb-361">Al salir del bloqueo, podría señalar otros subprocesos en espera.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-361">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-362">En el ejemplo siguiente se muestra cómo utilizar un `finally` bloque para ejecutar el <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> método, lo que garantiza que el llamador sale del modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-362">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="8d3eb-363">El método mostrado en el ejemplo recupera el valor asociado a una clave.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-363">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="8d3eb-364">Si la clave no se encuentra, la excepción producida por interna <xref:System.Collections.Generic.Dictionary%602> puede finalizar el método.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-364">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="8d3eb-365">El <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> método se usa para entrar en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-365">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="8d3eb-366">Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-366">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="8d3eb-367">El subproceso actual no ha entrado en el bloqueo en modo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-367">The current thread has not entered the lock in read mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-368">Reduce el recuento de recursividad para el modo de actualización y sale del modo de actualización si el recuento resultante es 0 (cero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-368">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-369">Este método no es sensible al orden de recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-369">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="8d3eb-370">Por ejemplo, si un subproceso entra en un bloqueo en modo de actualización y, a continuación, entra en el bloqueo en modo de escritura, no importa el orden en el que el subproceso sale de los dos modos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-370">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="8d3eb-371">Si un bloqueo permite la recursividad, un subproceso puede entrar en el bloqueo en modo de escritura y, a continuación, escríbala de forma recursiva en modo de actualización; No importa el orden en el que el subproceso sale en modo de modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-371">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="8d3eb-372">Al salir del bloqueo, podría señalar otros subprocesos en espera.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-372">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-373">En el ejemplo siguiente se muestra cómo utilizar un `finally` bloque para ejecutar el <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> método, lo que garantiza que el llamador sale del modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-373">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="8d3eb-374">El método mostrado en el ejemplo recupera el valor asociado a una clave y lo compara con un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-374">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="8d3eb-375">Si el valor se ha modificado, el método devuelve un estado que indica ningún cambio.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-375">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="8d3eb-376">Se encuentra ningún valor para la clave, se inserta el par clave/valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-376">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="8d3eb-377">Si ha cambiado el valor, se actualiza.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-377">If the value has changed, it is updated.</span></span> <span data-ttu-id="8d3eb-378">En modo de actualización permite al subproceso actualizar el bloqueo de lectura según sea necesario, sin riesgo de interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-378">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="8d3eb-379">En el ejemplo se usa el constructor predeterminado para crear el bloqueo, por lo que no se permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-379">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="8d3eb-380">Programar la <xref:System.Threading.ReaderWriterLockSlim> es más sencillo y menos propenso a errores cuando el bloqueo no permite la recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-380">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="8d3eb-381">Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-381">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="8d3eb-382">El subproceso actual no ha entrado en el bloqueo en modo de actualización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-382">The current thread has not entered the lock in upgradeable mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-383">Reduce el recuento de recursividad para el modo de escritura y sale del modo de escritura si el recuento resultante es 0 (cero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-383">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-384">Este método no es sensible al orden de recursividad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-384">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="8d3eb-385">Por ejemplo, si un subproceso entra en un bloqueo en modo de actualización y, a continuación, entra en el bloqueo en modo de escritura, no importa el orden en el que el subproceso sale de los dos modos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-385">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="8d3eb-386">Si un bloqueo permite la recursividad, un subproceso puede entrar en el bloqueo en modo de escritura y, a continuación, escríbala de forma recursiva en modo de lectura; el orden en que el subproceso sale del modo de lectura y no importa el modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-386">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="8d3eb-387">Al salir del bloqueo, podría señalar otros subprocesos en espera.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-387">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-388">En el ejemplo siguiente se muestra cómo utilizar un `finally` bloque para ejecutar el <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, lo que garantiza que el llamador sale del modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-388">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="8d3eb-389">El método mostrado en el ejemplo agrega un nuevo par clave/valor en la memoria caché sincronizada.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-389">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="8d3eb-390">Si la clave ya está en la memoria caché, la excepción producida por interna <xref:System.Collections.Generic.Dictionary%602> puede finalizar el método.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-390">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="8d3eb-391">El <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> método se usa para entrar en el bloqueo en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-391">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="8d3eb-392">Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-392">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="8d3eb-393">El subproceso actual no ha entrado en el bloqueo en modo de escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-393">The current thread has not entered the lock in write mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-394">Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-394">Gets a value that indicates whether the current thread has entered the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-395">
            <see langword="true" /> si el subproceso actual entró en modo Lectura; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-395">
              <see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-396">Esta propiedad está pensada para uso en las aserciones o para otros propósitos de depuración.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-396">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="8d3eb-397">No debe usarse para controlar el flujo de ejecución del programa.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-397">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-398">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> propiedad que se va a generar una aserción si el subproceso actual ha entrado en modo de lectura de forma inesperada.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-398">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-399">Obtiene un valor que indica si el subproceso actual entró en el bloqueo en modo de actualización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-399">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-400">
            <see langword="true" /> si el subproceso actual ha entrado en modo de actualización; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-400">
              <see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-401">Esta propiedad está pensada para uso en las aserciones o para otros propósitos de depuración.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-401">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="8d3eb-402">No debe usarse para controlar el flujo de ejecución del programa.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-402">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-403">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> propiedad que se va a generar una aserción si el subproceso actual entró en modo de forma inesperada.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-403">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-404">Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-404">Gets a value that indicates whether the current thread has entered the lock in write mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-405">
            <see langword="true" /> si el subproceso actual entró en modo de escritura; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-405">
              <see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-406">Esta propiedad está pensada para uso en las aserciones o para otros propósitos de depuración.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-406">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="8d3eb-407">No debe usarse para controlar el flujo de ejecución del programa.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-407">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-408">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> propiedad que se va a generar una aserción si el subproceso actual ha entrado en modo de escritura inesperadamente.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-408">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-409">Obtiene un valor que indica la directiva de recursividad del objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-409">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-410">Uno de los valores de enumeración que especifica la directiva de recursividad de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-410">One of the enumeration values that specifies the lock recursion policy.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-411">La directiva de recursividad determina las restricciones en los subprocesos que entran en el bloqueo más de una vez.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-411">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="8d3eb-412">Por ejemplo, si se ha creado un bloqueo con <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> y un subproceso ha entrado en el bloqueo en modo de lectura, <xref:System.Threading.LockRecursionException> se produce si el subproceso intenta volver a escribir el bloqueo en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-412">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-413">Un subproceso en modo de actualización puede actualizarse a modo de escritura o degradación modo independientemente de la configuración de directiva de recursividad de bloqueo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-413">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="8d3eb-414">Independientemente de la directiva de recursividad, un subproceso que entró inicialmente lee modo no se admite para actualizar a modo de actualización o en modo de escritura, porque ese modelo genera una gran probabilidad de interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-414">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="8d3eb-415">Para obtener más información acerca de la directiva de recursividad y sus efectos, consulte la <xref:System.Threading.LockRecursionPolicy> enumeración y <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-415">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-416">Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de lectura, como una indicación de recursividad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-416">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-417">0 (cero) si el subproceso actual no entró en modo lectura, 1 si el subproceso ha entrado en modo lectura pero no lo hizo de forma recursiva o *n* si el subproceso ha entrado en el bloqueo de forma recursiva *n* - 1 veces.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-417">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-418">Utilice esta propiedad solo para depurar, de generación de perfiles y con fines de registro y no para controlar el comportamiento de un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-418">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="8d3eb-419">Los resultados pueden cambiar en cuanto se hayan calculado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-419">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="8d3eb-420">Por lo tanto, no es seguro tomar decisiones basadas en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-420">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-421">Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de actualización, como una indicación de recursividad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-421">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-422">0 si el subproceso actual no entró en modo de actualización, 1 si el subproceso entró en modo pero no lo ha hecho, de forma recursiva o *n* si el subproceso ha entrado en modo de actualización de forma recursiva *n* - 1 veces.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-422">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-423">Utilice esta propiedad solo para depurar, de generación de perfiles y con fines de registro y no para controlar el comportamiento de un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-423">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="8d3eb-424">Los resultados pueden cambiar en cuanto se hayan calculado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-424">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="8d3eb-425">Por lo tanto, no es seguro tomar decisiones basadas en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-425">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-426">Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de escritura, como una indicación de recursividad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-426">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-427">0 si el subproceso actual no ha entrado en modo de escritura, 1 si el subproceso ha entrado en modo de escritura pero no se hizo de forma recursiva o *n* si el subproceso ha entrado en modo de escritura de forma recursiva *n* - 1 veces.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-427">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-428">Utilice esta propiedad solo para depurar, de generación de perfiles y con fines de registro y no para controlar el comportamiento de un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-428">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="8d3eb-429">Los resultados pueden cambiar en cuanto se hayan calculado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-429">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="8d3eb-430">Por lo tanto, no es seguro tomar decisiones basadas en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-430">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-431">Intenta entrar en el bloqueo en modo de lectura, con tiempo de espera opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-431">Tries to enter the lock in read mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="8d3eb-432">Número de milisegundos de espera o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-432">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8d3eb-433">Intenta entrar en el bloqueo en modo de lectura, con un tiempo de espera entero opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-433">Tries to enter the lock in read mode, with an optional integer time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8d3eb-434">
            <see langword="true" /> si el subproceso que realiza la llamada entró en modo Lectura; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-434">
              <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-435">Si `millisecondsTimeout` es 0 (cero), este método comprueba el estado de bloqueo y devuelve `false` inmediatamente si el estado deseado no está disponible.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-435">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="8d3eb-436">Varios subprocesos pueden entrar en modo de lectura al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-436">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="8d3eb-437">Si uno o varios subprocesos en espera de entrar en modo de escritura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método se bloquea hasta que esos subprocesos tengan marcas agotó el tiempo o entró en modo de escritura y, a continuación, sale de él, o hasta que expire el intervalo de tiempo de espera de subproceso de llamada propio.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-437">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-438">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de lectura puede entrar recursivamente de modo de lectura, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-438">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="8d3eb-439">Un subproceso puede estar en modo de actualización mientras otros subprocesos están en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-439">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="8d3eb-440">Si los subprocesos adicionales se esperan de entrar en modo de actualización y no hay ningún subproceso esperando para entrar en el modo de escritura, los subprocesos que llaman los <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método entrar en modo de lectura inmediatamente y no se bloquean.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-440">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-441">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-441">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="8d3eb-442">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-442">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-443">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-443">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-444">El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-444">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8d3eb-445">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-445">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-446">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-446">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="8d3eb-447">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-447">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8d3eb-448">Intenta entrar en el bloqueo en modo de lectura, con tiempo de espera opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-448">Tries to enter the lock in read mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8d3eb-449">
            <see langword="true" /> si el subproceso que realiza la llamada entró en modo Lectura; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-449">
              <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-450">Si `timeout` es 0 (cero), este método comprueba el estado de bloqueo y devuelve `false` inmediatamente si el estado deseado no está disponible.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-450">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="8d3eb-451">Varios subprocesos pueden entrar en el bloqueo en modo de lectura al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-451">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="8d3eb-452">Si uno o varios subprocesos están en cola para entrar en modo de escritura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método se bloquea hasta que esos subprocesos tengan marcas agotó el tiempo o entró en modo de escritura y, a continuación, sale de él, o hasta que expire el intervalo de tiempo de espera de subproceso de llamada propio.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-452">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-453">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de lectura puede entrar recursivamente de modo de lectura, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-453">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="8d3eb-454">Un subproceso puede estar en modo de actualización mientras otros subprocesos están en modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-454">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="8d3eb-455">Si los subprocesos adicionales se esperan de entrar en modo de actualización y no hay ningún subproceso esperando para entrar en el modo de escritura, los subprocesos que llaman los <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> método entrar en modo de lectura inmediatamente y no se bloquean.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-455">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-456">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-456">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="8d3eb-457">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-457">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-458">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-458">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-459">El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-459">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8d3eb-460">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-460">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="8d3eb-461">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-461">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-462">El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-462">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-463">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-463">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-464">Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="8d3eb-465">Número de milisegundos de espera o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-465">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8d3eb-466">Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-466">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8d3eb-467">
            <see langword="true" /> si el subproceso que realiza la llamada entró en modo de actualización; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-467">
              <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-468">Si `millisecondsTimeout` es 0 (cero), este método comprueba el estado de bloqueo y devuelve `false` inmediatamente si el estado deseado no está disponible.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-468">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="8d3eb-469">Use en modo de actualización cuando un subproceso suele tener acceso al recurso que está protegido por el <xref:System.Threading.ReaderWriterLockSlim> en el modo de lectura, pero que necesite escribir el modo de escritura si se cumplen determinadas condiciones.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-469">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="8d3eb-470">Un subproceso en modo de actualización puede actualizarse a modo de escritura o degradarse al modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-470">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="8d3eb-471">Solo un subproceso puede entrar en un bloqueo en modo de actualización en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-471">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="8d3eb-472">Si un subproceso está en modo de actualización y no hay ningún subproceso esperando para entrar en el modo de escritura, cualquier número de otros subprocesos puede entrar en modo de lectura, incluso si hay subprocesos a la espera de entrar en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-472">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="8d3eb-473">Si uno o varios subprocesos en espera de entrar en modo de escritura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método se bloquea hasta que esos subprocesos tengan marcas agotó el tiempo o entró en modo de escritura y, a continuación, sale de él, o hasta que expire el intervalo de tiempo de espera de subproceso de llamada propio.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-473">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-474">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de actualización puede entrar en modo de actualización de forma recursiva, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-474">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-475">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-475">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="8d3eb-476">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-476">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-477">El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de actualización, existiría la posibilidad de un interbloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-477">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="8d3eb-478">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-478">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-479">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-479">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-480">El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-480">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8d3eb-481">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-481">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-482">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-482">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="8d3eb-483">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-483">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8d3eb-484">Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-484">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8d3eb-485">
            <see langword="true" /> si el subproceso que realiza la llamada entró en modo de actualización; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-485">
              <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-486">Si `timeout` es 0 (cero), este método comprueba el estado de bloqueo y devuelve `false` inmediatamente si el estado deseado no está disponible.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-486">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="8d3eb-487">Use en modo de actualización cuando un subproceso suele tener acceso al recurso protegido por el <xref:System.Threading.ReaderWriterLockSlim> en el modo de lectura, pero que necesite escribir el modo de escritura si se cumplen determinadas condiciones.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-487">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="8d3eb-488">Un subproceso en modo de actualización puede actualizarse a modo de escritura o degradarse al modo de lectura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-488">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="8d3eb-489">Solo un subproceso puede entrar en un bloqueo en modo de actualización en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-489">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="8d3eb-490">Si un subproceso está en modo de actualización y no hay ningún subproceso esperando para entrar en el modo de escritura, cualquier número de otros subprocesos puede entrar en modo de lectura, incluso si hay subprocesos a la espera de entrar en modo de actualización.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-490">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="8d3eb-491">Si uno o varios subprocesos en espera de entrar en modo de escritura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> método se bloquea hasta que esos subprocesos tengan marcas agotó el tiempo o entró en modo de escritura y, a continuación, sale de él, o hasta que expire el intervalo de tiempo de espera de subproceso de llamada propio.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-491">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-492">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de actualización puede entrar en modo de actualización de forma recursiva, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-492">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-493">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-493">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="8d3eb-494">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-494">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-495">El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de actualización, existiría la posibilidad de un interbloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-495">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="8d3eb-496">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-496">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-497">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-497">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-498">El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-498">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8d3eb-499">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-499">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="8d3eb-500">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-500">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-501">El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-501">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-502">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-502">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-503">Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-503">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="8d3eb-504">Número de milisegundos de espera o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-504">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8d3eb-505">Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-505">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8d3eb-506">
            <see langword="true" /> si el subproceso que realiza la llamada entró en modo de escritura, de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-506">
              <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-507">Si `millisecondsTimeout` es 0 (cero), este método comprueba el estado de bloqueo y devuelve `false` inmediatamente si el estado deseado no está disponible.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-507">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="8d3eb-508">Si otros subprocesos han entrado en el bloqueo en modo de lectura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método se bloquea hasta que esos subprocesos han salido del modo de lectura o hasta que haya transcurrido el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-508">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="8d3eb-509">Mientras los subprocesos se bloquean en espera de entrar en modo de escritura, otros subprocesos que intenten entrar en modo de lectura o en modo de actualización se bloquean hasta que todos los subprocesos en espera de entrar en modo de escritura tengan cualquiera agotó el tiempo o entró en modo de escritura y, a continuación, sale de ella.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-509">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-510">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de escritura puede entrar recursivamente de modo de escritura, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-510">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-511">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método para entrar en el bloqueo en modo de escritura, con un tiempo de espera. El método mostrado en el ejemplo agrega un nuevo par clave/valor en la memoria caché sincronizada.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-511">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="8d3eb-512">Si transcurre el intervalo de tiempo de espera especificado antes de que el subproceso entra en el bloqueo, el método devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-512">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="8d3eb-513">El método devuelve `true` si se agrega el par clave/valor.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-513">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="8d3eb-514">Si la clave ya está en la memoria caché, la excepción producida por interna <xref:System.Collections.Generic.Dictionary%602> puede finalizar el método.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-514">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="8d3eb-515">A `finally` bloque se usa para ejecutar el <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> método, lo que garantiza que el llamador sale del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-515">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="8d3eb-516">Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLockSlim> clase.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-516">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-517">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-517">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="8d3eb-518">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-518">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-519">El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de escritura, existiría la posibilidad de un interbloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-519">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="8d3eb-520">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-520">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-521">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-521">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-522">El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-522">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8d3eb-523">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-523">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-524">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-524">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="8d3eb-525">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-525">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8d3eb-526">Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-526">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8d3eb-527">
            <see langword="true" /> si el subproceso que realiza la llamada entró en modo de escritura, de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-527">
              <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-528">Si `timeout` es 0 (cero), este método comprueba el estado de bloqueo y devuelve `false` inmediatamente si el estado deseado no está disponible.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-528">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="8d3eb-529">Si otros subprocesos han entrado en el bloqueo en modo de lectura, un subproceso que llama el <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> método se bloquea hasta que esos subprocesos han salido del modo de lectura o hasta que haya transcurrido el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-529">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="8d3eb-530">Mientras los subprocesos se bloquean en espera de entrar en modo de escritura, otros subprocesos que intenten entrar en modo de lectura o en modo de actualización se bloquean hasta que todos los subprocesos en espera de entrar en modo de escritura tengan cualquiera agotó el tiempo o entró en modo de escritura y, a continuación, sale de ella.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-530">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d3eb-531">Si un bloqueo permite la recursividad, un subproceso que ha entrado en el bloqueo en modo de escritura puede entrar recursivamente de modo de escritura, aun cuando otros subprocesos están a la espera de entrar en modo de escritura.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-531">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="8d3eb-532">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-532">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="8d3eb-533">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-533">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-534">El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de escritura, existiría la posibilidad de un interbloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-534">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="8d3eb-535">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-535">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-536">El número de recursividad superaría la capacidad del contador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-536">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="8d3eb-537">El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-537">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8d3eb-538">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-538">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="8d3eb-539">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-539">-or-</span>
          </span>
          <span data-ttu-id="8d3eb-540">El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-540">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="8d3eb-541">Se eliminó el objeto <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-541">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-542">Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-542">Gets the total number of threads that are waiting to enter the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-543">Número total de subprocesos que están a la espera de entrar en modo de lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-543">The total number of threads that are waiting to enter read mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-544">Utilice esta propiedad solo para depurar, de generación de perfiles y con fines de registro y no para controlar el comportamiento de un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-544">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="8d3eb-545">Los resultados pueden cambiar en cuanto se hayan calculado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-545">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="8d3eb-546">Por lo tanto, no es seguro tomar decisiones basadas en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-546">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-547">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> propiedad que se va a generar una entrada de registro de eventos si el número de subprocesos que se bloquean, a la espera de entrar en modo de lectura, supera un umbral.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-547">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-548">Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de actualización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-548">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-549">Número total de subprocesos que están a la espera de entrar en modo de actualización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-549">The total number of threads that are waiting to enter upgradeable mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-550">Utilice esta propiedad solo para depurar, de generación de perfiles y con fines de registro y no para controlar el comportamiento de un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-550">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="8d3eb-551">Los resultados pueden cambiar en cuanto se hayan calculado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-551">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="8d3eb-552">Por lo tanto, no es seguro tomar decisiones basadas en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-552">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-553">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> propiedad que se va a generar una entrada de registro de eventos si el número de subprocesos que se bloquean, a la espera de entrar en modo de actualización, supera un umbral.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-553">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8d3eb-554">Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-554">Gets the total number of threads that are waiting to enter the lock in write mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8d3eb-555">Número total de subprocesos que están a la espera de entrar en modo de escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8d3eb-555">The total number of threads that are waiting to enter write mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d3eb-556">Utilice esta propiedad solo para depurar, de generación de perfiles y con fines de registro y no para controlar el comportamiento de un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-556">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="8d3eb-557">Los resultados pueden cambiar en cuanto se hayan calculado.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-557">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="8d3eb-558">Por lo tanto, no es seguro tomar decisiones basadas en esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-558">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d3eb-559">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> propiedad que se va a generar una entrada de registro de eventos si el número de subprocesos que se bloquean, a la espera de entrar en modo de escritura, supera un umbral.</span><span class="sxs-lookup"><span data-stu-id="8d3eb-559">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>