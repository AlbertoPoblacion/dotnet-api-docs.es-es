<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="90a2111b4e95ea3ea80a469c06f7334a9e6eac2b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37549135" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un mecanismo que sincroniza el acceso a los objetos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Monitor> clase le permite sincronizar el acceso a una región de código mediante la obtención y liberación de un bloqueo en un objeto determinado mediante una llamada a la <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, y <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> métodos. Los bloqueos de objeto proporcionan la capacidad para restringir el acceso a un bloque de código, normalmente denominado una sección crítica. Mientras un subproceso posee el bloqueo de un objeto, ningún otro subproceso puede adquirir ese bloqueo. También puede usar el <xref:System.Threading.Monitor> clase para asegurarse de que ningún otro subproceso puede tener acceso a una sección de la aplicación de código que se está ejecutando por el propietario del bloqueo, a menos que el otro subproceso está ejecutando el código que usa un objeto bloqueado distinto.  
  
 En este artículo:  
  
 [La clase Monitor: información general](#Overview)   
 [El objeto de bloqueo](#Lock)   
 [La sección crítica](#CriticalSection)   
 [Pulse, PulseAll y espera](#Pulse)   
 [Monitores y los identificadores de espera](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>La clase Monitor: información general  
 <xref:System.Threading.Monitor> tiene las siguientes características:  
  
-   Está asociado con un objeto a petición.  
  
-   Es independiente, lo que significa que puede llamarse directamente desde cualquier contexto.  
  
-   Una instancia de la <xref:System.Threading.Monitor> no se puede crear la clase; los métodos de la <xref:System.Threading.Monitor> clase son todos estáticos. Cada método se pasa el objeto sincronizado que controla el acceso a la sección crítica.  
  
> [!NOTE]
>  Use la <xref:System.Threading.Monitor> clase para objetos de bloqueo que no sean cadenas (es decir, tipos de referencia distinto <xref:System.String>), no los tipos de valor. Para obtener más información, vea las sobrecargas de los <xref:System.Threading.Monitor.Enter%2A> método y [el objeto de bloqueo](#Lock) sección más adelante en este artículo.  
  
 En la tabla siguiente se describe las acciones que pueden realizarse por los subprocesos que tienen acceso a los objetos sincronizados:  
  
|Acción|Descripción|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Adquiere un bloqueo de un objeto. Esta acción también marca el principio de una sección crítica. Ningún otro subproceso puede entrar en la sección crítica, a menos que se ejecuta las instrucciones que aparecen en la sección crítica utilizando un objeto bloqueado distinto.|  
|<xref:System.Threading.Monitor.Wait%2A>|Libera el bloqueo en un objeto con el fin de permitir que otros subprocesos de bloqueo y obtener acceso al objeto. Espera a que el subproceso de llamada mientras otro subproceso tiene acceso al objeto. Las señales de pulsos se usan para notificar a los subprocesos en espera sobre los cambios en el estado de un objeto.|  
|<xref:System.Threading.Monitor.Pulse%2A> (señal), <xref:System.Threading.Monitor.PulseAll%2A>|Envía una señal a uno o varios subprocesos en espera. La señal notifica a un subproceso en espera que se ha cambiado el estado del objeto bloqueado, y el propietario del bloqueo está listo para liberar el bloqueo. El subproceso en espera se coloca en la cola del objeto listo para que pueda recibir el bloqueo para el objeto. Una vez que el subproceso tiene el bloqueo, puede comprobar el estado nueva del objeto para ver si se ha alcanzado el estado necesario.|  
|<xref:System.Threading.Monitor.Exit%2A>|Libera el bloqueo en un objeto. Esta acción también marca el final de una sección crítica protegida por el objeto bloqueado.|  
  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], hay dos conjuntos de sobrecargas para el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.TryEnter%2A> métodos. Un conjunto de sobrecargas tiene un `ref` (en C#) o `ByRef` (en Visual Basic) <xref:System.Boolean> parámetro que se establece de forma atómica en `true` si se adquiere el bloqueo, incluso si se produce una excepción al adquirir el bloqueo. Use estas sobrecargas si es fundamental para liberar el bloqueo en todos los casos, incluso cuando los recursos que se está protegiendo el bloqueo no esté en un estado coherente.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>El objeto de bloqueo  
 La clase Monitor consta de `static` (en C#) o `Shared` (en Visual Basic) entre los métodos que operan en un objeto que controla el acceso a la sección crítica.  La siguiente información se mantiene para cada objeto sincronizado:  
  
-   Una referencia al subproceso que actualmente mantiene el bloqueo.  
  
-   Una referencia a una cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo.  
  
-   Una referencia a una cola de espera, que contiene los subprocesos que esperan para recibir notificaciones de un cambio en el estado del objeto bloqueado.  
  
 <xref:System.Threading.Monitor> bloquea objetos (es decir, tipos de referencia), no tipos de valor. Aunque puede pasar un tipo de valor a <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A>, se somete a una conversión boxing independiente para cada llamada. Puesto que cada llamada crea un objeto independiente, <xref:System.Threading.Monitor.Enter%2A> nunca bloquea y el código al que supuestamente protege no está sincronizado realmente. Además, el objeto que se pasa a <xref:System.Threading.Monitor.Exit%2A> es diferente del objeto que se pasa a <xref:System.Threading.Monitor.Enter%2A>, por lo que <xref:System.Threading.Monitor> produce la excepción <xref:System.Threading.SynchronizationLockException> con el mensaje “El método de sincronización del objeto se ha llamado desde un bloque de códigos sin sincronizar.”.  
  
 El siguiente ejemplo ilustra este problema. Inicia diez tareas, cada una de los cuales solo se suspende durante 250 milisegundos. A continuación, cada tarea actualiza una variable de contador, `nTasks`, pensada para contar el número de tareas que realmente se iniciaron y ejecutaron. Dado que `nTasks` es una variable global que pueden actualizar varias tareas al mismo tiempo, se usa un monitor para protegerla frente a modificaciones simultáneas de varias tareas. Sin embargo, como muestra la salida del ejemplo, cada una de las tareas produce una excepción <xref:System.Threading.SynchronizationLockException>.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Cada tarea produce una excepción <xref:System.Threading.SynchronizationLockException> porque la variable `nTasks` es objeto de a una conversión boxing antes de llamar al método <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> en cada tarea. En otras palabras, a cada llamada al método se le pasa una variable independiente, que es independiente del resto. `nTasks` se vuelve a someter a una conversión boxing en la llamada al método <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. Una vez más, esto crea diez nuevas variables sometidas a conversión boxing, que son independientes entre sí, `nTasks`, y las diez variables creadas en la llamada al método <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> y sometidas a una conversión boxing. A continuación, se produce la excepción porque el código está intentando liberar un bloqueo en una variable recién creada que no se ha bloqueado anteriormente.  
  
 Aunque puede aplicar una conversión boxing a una variable de tipo de valor antes de llamar a <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A>, tal como se muestra en el siguiente ejemplo, y pasar el mismo objeto sometido a conversión boxing a ambos métodos, hacerlo no ofrece ninguna ventaja. Los cambios realizados en la variable sometida a conversión unboxing no se reflejan en la copia sometida a conversión boxing, y no hay ninguna forma de cambiar el valor de la copia de sometida a conversión boxing.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 Al seleccionar un objeto en el que se va a sincronizar, debe bloquear solo en objetos privados o internos. El bloqueo de objetos externos, se podría producir interbloqueos, porque el código relacionado con podría elegir los mismos objetos para bloquear para distintos fines.  
  
 Tenga en cuenta que puede sincronizar en un objeto en varios dominios de aplicación si el objeto usado para el bloqueo deriva <xref:System.MarshalByRefObject>.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>La sección crítica  
 Use la <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> métodos para marcar el principio y al final de una sección crítica.  
  
> [!NOTE]
>  La funcionalidad proporcionada por el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> métodos es idéntica a la que ofrece el [bloqueo](~/docs/csharp/language-reference/keywords/lock-statement.md) instrucción en C# y el [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instrucción en Visual Basic, salvo que el construcciones de lenguaje encapsulado el <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> sobrecarga del método y el <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> método en un `try`...`finally` bloque para asegurarse de que se libera el monitor.  
  
 Si la sección crítica es un conjunto de instrucciones contiguas, a continuación, el bloqueo adquirido por el <xref:System.Threading.Monitor.Enter%2A> método garantiza que solo un subproceso puede ejecutar el código delimitado con el objeto bloqueado. En este caso, se recomienda colocar ese código en un `try` bloquear y realizar una llamada a la <xref:System.Threading.Monitor.Exit%2A> método en un `finally` bloque. Esto garantiza la liberación del bloqueo aunque se produzca una excepción. El siguiente fragmento de código muestra este patrón.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Esta función normalmente se utiliza para sincronizar el acceso a ningún elemento estático o un método de instancia de una clase.  
  
 Si una sección crítica abarca todo un método, la utilidad de bloqueo puede lograrse mediante la colocación de la <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> en el método y especificando el <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> valor en el constructor de <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>. Cuando se utiliza este atributo, el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> no son necesarias las llamadas a métodos. El siguiente fragmento de código muestra este patrón:  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Tenga en cuenta que el atributo hace que el subproceso actual mantiene el bloqueo hasta que el método devuelve; Si el bloqueo puede liberarse antes, utilice la <xref:System.Threading.Monitor> clase C#, [bloqueo](~/docs/csharp/language-reference/keywords/lock-statement.md) instrucción o Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instrucción dentro del método en lugar del atributo.  
  
 Aunque es posible que el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> las instrucciones que bloquear y liberar un objeto determinado para cruzar los límites de clase y miembro, no se recomienda esta práctica.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse, PulseAll y espera  
 Una vez que un subproceso posee el bloqueo y ha entrado en la sección crítica que protege el bloqueo, puede llamar a la <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, y <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> métodos.  
  
 <xref:System.Threading.Monitor.Wait%2A> Libera el bloqueo si se mantiene, permite que un subproceso en espera o subprocesos para obtener el bloqueo y la sección crítica y espera a recibir una notificación mediante una llamada a la <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> o <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> método. Cuando <xref:System.Threading.Monitor.Wait%2A> recibe la notificación, devuelve y vuelve a obtener el bloqueo.  
  
 Tanto <xref:System.Threading.Monitor.Pulse%2A> como <xref:System.Threading.Monitor.PulseAll%2A> indican al siguiente subproceso de la cola de espera que proceda.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Monitores y los identificadores de espera  
 Es importante tener en cuenta la distinción entre el uso de la <xref:System.Threading.Monitor> clase y <xref:System.Threading.WaitHandle> objetos.  
  
-   La <xref:System.Threading.Monitor> clase es puramente administrados, son totalmente portátiles y podrían ser más eficaces en cuanto a los requisitos de recursos del sistema operativo.  
  
-   Los objetos <xref:System.Threading.WaitHandle> representan objetos del sistema operativo que pueden esperar, que son útiles para la sincronización entre el código administrado y el no administrado y exponen algunas características avanzadas del sistema operativo, como la capacidad de esperar muchos objetos a la vez.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Threading.Monitor> clase para sincronizar el acceso a una sola instancia de un generador de números aleatorios, representado por la <xref:System.Random> clase. El ejemplo crea diez tareas, cada uno de los cuales se ejecuta de forma asincrónica en un subproceso ThreadPool. Cada tarea genera números aleatorios 10.000, calcula su Media y actualiza dos variables de nivel de procedimiento que mantienen un total acumulado del número de números aleatorios generados y su suma. Después de que se han ejecutado todas las tareas, estos dos valores, a continuación, se utilizan para calcular la media general.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Dado que se pueden acceder desde cualquier tarea que se ejecuta en un subproceso ThreadPool, acceder a las variables `total` y `n` también deben estar sincronizadas. El <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> método se usa para este propósito.  
  
 En el ejemplo siguiente se muestra el uso combinado de la <xref:System.Threading.Monitor> clase (implementada con el `lock` o `SyncLock` construcción de lenguaje), el <xref:System.Threading.Interlocked> (clase) y el <xref:System.Threading.AutoResetEvent> clase. Define dos `internal` (en C#) o `Friend` (en Visual Basic), las clases de `SyncResource` y `UnSyncResource`, que proporcionan respectivamente acceso sincronizado y sin sincronizar a un recurso. Para asegurarse de que el ejemplo ilustra la diferencia entre el acceso sincronizado y sin sincronizar (que podría ser el caso si cada llamada al método se realiza rápidamente), el método incluye un retraso aleatorio: para subprocesos cuya <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> propiedad es par, el las llamadas al método <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> para insertar un retraso de 2.000 milisegundos. Tenga en cuenta que, dado el `SyncResource` clase no es pública, ninguno de los códigos de cliente toma un bloqueo en el recurso sincronizado, la propia clase interna que adopta el bloqueo. Esto evita que cualquier código malintencionado se haga cargo de un bloqueo en un objeto público.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 El ejemplo define una variable, `numOps`, que define el número de subprocesos que intentarán tener acceso al recurso. El subproceso de la aplicación llama a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> método sincronizado y no sincronizadas tener acceso a cinco veces cada uno. El <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> método tiene un único parámetro, un delegado que no acepta parámetros y no devuelve ningún valor. Para obtener acceso sincronizado, invoca el `SyncUpdateResource` método; para el acceso sincronizado, invoca el `UnSyncUpdateResource` método. Después de cada conjunto de llamadas de método, el subproceso de la aplicación llama a la [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) método para que así se bloquee hasta que la <xref:System.Threading.AutoResetEvent> se señala la instancia.  
  
 Cada llamada a la `SyncUpdateResource` llamadas de método interno `SyncResource.Access` método y, a continuación, llama a la <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> método para reducir el `numOps` contador. El <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> método se usa para reducir el contador, porque de lo contrario, no puede estar seguro de que un segundo subproceso acceso al valor reducido del primer subproceso antes de valor se ha almacenado en la variable. Cuando el último sincroniza disminuye de subproceso de trabajo en el contador a cero, que indica que todos los subprocesos sincronizados han accedido al recurso, el `SyncUpdateResource` llamadas al método el <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> método, que indica al subproceso principal para continuar ejecución.  
  
 Cada llamada a la `UnSyncUpdateResource` llamadas de método interno `UnSyncResource.Access` método y, a continuación, llama a la <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> método para reducir el `numOps` contador. Una vez más, la <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> método se usa para reducir el contador para asegurarse de que un segundo subproceso no tiene acceso el valor antes de que se ha asignado el valor reducido del primer subproceso a la variable. Cuando el último no sincronizadas disminuye de subproceso de trabajo que el contador a cero, que indica que no hay más subprocesos no sincronizados necesita tener acceso al recurso, el `UnSyncUpdateResource` llamadas al método el <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> método, que indica al subproceso principal para continuar la ejecución .  
  
 Como se muestra en el resultado del ejemplo, el acceso sincronizado garantiza que el subproceso de llamada saldrá del recurso protegido antes de que otro subproceso pueda tener acceso a él; así pues, cada subproceso esperará a su predecesor. Por otro lado, sin bloqueo, el `UnSyncResource.Access` se llama al método en el orden en que los subprocesos accedan a él.  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adquiere un bloqueo exclusivo en un objeto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a adquirir el bloqueo de monitor.</param>
        <summary>Adquiere un bloqueo exclusivo en el objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use `Enter` para adquirir el <xref:System.Threading.Monitor> en el objeto pasado como parámetro. Si otro subproceso ha ejecutado un `Enter` en el objeto, pero no se ha ejecutado el correspondiente <xref:System.Threading.Monitor.Exit%2A>, se bloqueará el subproceso actual hasta que el otro subproceso libere el objeto. Es válido para el mismo subproceso que invoca `Enter` más de una vez sin bloquearse; sin embargo, un número igual de `Exit` se deben invocar las llamadas antes de que se desbloqueen otros subprocesos en espera en el objeto.  
  
 Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor. Cuando se pasa una variable de tipo de valor a `Enter`, se aplica como un objeto. Si se pasa a la misma variable a `Enter` nuevo, se aplica como un objeto independiente y no bloquea el subproceso. En este caso, el código que `Monitor` es supuestamente protege no está protegido. Además, al pasar la variable a `Exit`, se crea otro objeto independiente. Puesto que el objeto pasado a `Exit` es diferente del objeto pasado a `Enter`, `Monitor` produce <xref:System.Threading.SynchronizationLockException>. Para obtener más información, vea el tema conceptual [monitores](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> puede interrumpir los subprocesos que esperan para escribir un `Monitor` en un objeto. Un <xref:System.Threading.ThreadInterruptedException> se iniciará.  
  
 Uso de C# `try`...`finally` bloque (`Try`...`Finally` en Visual Basic) para asegurarse de que el monitor de versión o utilizar el C# `lock` instrucción (`SyncLock` instrucción en Visual Basic), que encapsula el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> métodos en un `try`...`finally` bloque.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método `Enter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a esperar.</param>
        <param name="lockTaken">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.  Nota   Si no se produce ninguna excepción, el resultado de este método siempre es <see langword="true" />.</param>
        <summary>Adquiere un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use `Enter` para adquirir el <xref:System.Threading.Monitor> en el objeto pasado como el `obj` parámetro. Si otro subproceso ha ejecutado un `Enter` en el objeto, pero no se ha ejecutado el correspondiente <xref:System.Threading.Monitor.Exit%2A>, se bloqueará el subproceso actual hasta que el otro subproceso libere el objeto. Es válido para el mismo subproceso que invoca `Enter` más de una vez sin bloquearse; sin embargo, un número igual de `Exit` se deben invocar las llamadas antes de que se desbloqueen otros subprocesos en espera en el objeto.  
  
 Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el `lockTaken` parámetro es `false` cuando este método finalice. Esto permite que el programa determinar, en todos los casos, si es necesario para liberar el bloqueo. Si este método devuelve sin producir una excepción, la variable especificada para el `lockTaken` parámetro siempre es `true`, y no es necesario para probarla.  
  
 Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor. Cuando se pasa una variable de tipo de valor a `Enter`, se aplica como un objeto. Si se pasa a la misma variable a `Enter` nuevo, se aplica como un objeto independiente y no bloquea el subproceso. En este caso, el código que `Monitor` es supuestamente protege no está protegido. Además, al pasar la variable a `Exit`, se crea otro objeto independiente. Puesto que el objeto pasado a `Exit` es diferente del objeto pasado a `Enter`, `Monitor` produce <xref:System.Threading.SynchronizationLockException>. Para obtener más información, vea el tema conceptual [monitores](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> puede interrumpir los subprocesos que esperan para escribir un `Monitor` en un objeto. Un <xref:System.Threading.ThreadInterruptedException> se iniciará.  
  
   
  
## Examples  
 El código siguiente muestra el patrón básico para usar el <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> sobrecarga del método. Esta sobrecarga siempre establece el valor de la variable que se pasa a la `ref` parámetro (`ByRef` en Visual Basic) `lockTaken`, incluso si el método produce una excepción, por lo que el valor de la variable es un método confiable para probar si el bloqueo debe ser publicado.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a liberar el bloqueo.</param>
        <summary>Libera un bloqueo exclusivo en el objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El subproceso que realiza la llamada debe tener el bloqueo en el `obj` parámetro. Si el subproceso de llamada posee el bloqueo en el objeto especificado y ha realizado un número igual de `Exit` y <xref:System.Threading.Monitor.Enter%2A> llama para el objeto, a continuación, se libera el bloqueo. Si el subproceso de llamada no se ha invocado `Exit` tantas veces como `Enter`, no se libera el bloqueo.  
  
 Si se libera el bloqueo y otros subprocesos están en la cola de subprocesos listos para el objeto, uno de los subprocesos adquiere el bloqueo. Si hay otros subprocesos en la cola de espera para adquirir el bloqueo, no pasan automáticamente a la cola lista cuando el propietario del bloqueo llama `Exit`. Para mover uno o varios subprocesos en espera en la cola de subprocesos listos, llame a <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> antes de invocar `Exit`.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método `Exit`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">El subproceso actual no posee el bloqueo para el objeto especificado.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">El objeto que se va a probar.</param>
        <summary>Determina si el subproceso actual mantiene el bloqueo en el objeto especificado.</summary>
        <returns>Es <see langword="true" /> si el subproceso actual mantiene el bloqueo en <paramref name="obj" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo funciona para los bloqueos adquiridos mediante el uso de los métodos de la <xref:System.Threading.Monitor> clase, o mediante C# `lock` instrucción o Visual Basic `SyncLock` instrucción, que se implementan con <xref:System.Threading.Monitor>.  
  
 Utilice este método con las herramientas de diagnóstico, como la <xref:System.Diagnostics.Debug.Assert%2A> método y el <xref:System.Diagnostics.Contracts.Contract> (clase), para depurar problemas de bloqueo que implican la <xref:System.Threading.Monitor> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que está esperando un subproceso.</param>
        <summary>Notifica un cambio de estado del objeto bloqueado al subproceso que se encuentra en la cola de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo el propietario actual del bloqueo puede señalar a un objeto de espera mediante `Pulse`.  
  
 El subproceso que actualmente posee el bloqueo en el objeto especificado invoca este método para señalar el siguiente subproceso en línea para adquirir el bloqueo. Al recibir el pulso, el subproceso en espera se mueve a la cola de subprocesos listos. Cuando el subproceso que invoca `Pulse` libera el bloqueo, el siguiente subproceso en la cola de subprocesos listos (que no es necesariamente el subproceso que ha recibido el pulso) adquiere el bloqueo.  
  
> [!IMPORTANT]
>  El <xref:System.Threading.Monitor> clase mantienen el estado que indica que el <xref:System.Threading.Monitor.Pulse%2A> ha llamado al método. Por lo tanto, si se llama a <xref:System.Threading.Monitor.Pulse%2A> cuando no hay ningún subproceso en espera, el siguiente subproceso que llama a <xref:System.Threading.Monitor.Wait%2A> bloques como si <xref:System.Threading.Monitor.Pulse%2A> nunca hubiera llamado. Si usan dos subprocesos <xref:System.Threading.Monitor.Pulse%2A> y <xref:System.Threading.Monitor.Wait%2A> para interactuar, esto podría provocar un interbloqueo. Compare esto con el comportamiento de la <xref:System.Threading.AutoResetEvent> clase: si señalar un <xref:System.Threading.AutoResetEvent> mediante una llamada a su <xref:System.Threading.EventWaitHandle.Set%2A> método y no hay ningún subproceso en espera, el <xref:System.Threading.AutoResetEvent> permanece en un estado señalado hasta que un subproceso llama <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, o <xref:System.Threading.WaitHandle.WaitAll%2A>. El <xref:System.Threading.AutoResetEvent> libera ese subproceso y vuelve al estado no señalizado.  
  
 Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que esperan para recibir notificaciones de un cambio en el estado del objeto.  
  
 El `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, y <xref:System.Threading.Monitor.Wait%2A> métodos deben invocarse desde dentro de un bloque de código sincronizado.  
  
 Para marcar varios subprocesos, utilice el <xref:System.Threading.Monitor.PulseAll%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que envía el pulso.</param>
        <summary>Notifica un cambio de estado del objeto a todos los subprocesos que se encuentran en espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para indicar todos los subprocesos en espera para adquirir el bloqueo en el objeto. Una vez que se envía una señal, los subprocesos en espera se mueven a la cola de subprocesos listos. Cuando el subproceso que invoca `PulseAll` libera el bloqueo, el siguiente subproceso en la cola de subprocesos listos adquiere el bloqueo.  
  
 Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que esperan para recibir notificaciones de un cambio en el estado del objeto.  
  
 El <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, y <xref:System.Threading.Monitor.Wait%2A> métodos deben invocarse desde dentro de un bloque de código sincronizado.  
  
 Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.  
  
 Para marcar un único subproceso, utilice el `Pulse` método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
        <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado.</summary>
        <returns>Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si es correcto, este método adquiere un bloqueo exclusivo en el `obj` parámetro. Este método devuelve inmediatamente, si el bloqueo esté disponible.  
  
 Este método es similar a <xref:System.Threading.Monitor.Enter%2A>, pero nunca se bloqueará el subproceso actual. Si el subproceso no se puede escribir sin bloqueo, el método devuelve `false,`.  
  
> [!NOTE]
>  Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor. Para obtener más información, consulte el <xref:System.Threading.Monitor> artículo.  
  
 Para asegurarse de que el subproceso no entrar en la sección crítica, debe examinar el valor devuelto del método y ejecutar código en la sección crítica solo si su valor devuelto es `true`. El fragmento de código siguiente muestra el patrón utilizado para llamar a este método. Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el método `TryEnter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
        <param name="lockTaken">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
        <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si es correcto, este método adquiere un bloqueo exclusivo en el `obj` parámetro. Este método devuelve inmediatamente, si el bloqueo esté disponible.  
  
 Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el `lockTaken` parámetro es `false` cuando este método finalice. Esto permite que el programa determinar, en todos los casos, si es necesario para liberar el bloqueo.  
  
 Este método es similar a <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, pero nunca se bloqueará el subproceso actual. Si el subproceso no se puede escribir sin bloqueo, el `lockTaken` argumento está establecido en `false` cuando el método devuelve.  
  
> [!NOTE]
>  Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor. Para obtener más información, vea el artículo <xref:System.Threading.Monitor>.  
  
 Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de `lockTaken` y ejecutar código en la sección crítica solo si su valor es `true`. El fragmento de código siguiente muestra el patrón utilizado para llamar a este método. Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 El código siguiente muestra el patrón básico para usar el <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> sobrecarga del método. Esta sobrecarga siempre establece el valor de la variable que se pasa a la `ref` parámetro (`ByRef` en Visual Basic) `lockTaken`, incluso si el método produce una excepción, por lo que el valor de la variable es un método confiable para probar si el bloqueo debe ser publicado.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
        <param name="millisecondsTimeout">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</param>
        <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el número de segundos especificado.</summary>
        <returns>Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `millisecondsTimeout` parámetro es igual a <xref:System.Threading.Timeout.Infinite>, este método es equivalente a <xref:System.Threading.Monitor.Enter%2A>. Si `millisecondsTimeout` es igual a 0, este método es equivalente a <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor. Para obtener más información, consulte el <xref:System.Threading.Monitor> artículo.  
  
 Para asegurarse de que el subproceso no entrar en la sección crítica, debe examinar el valor devuelto del método y ejecutar código en la sección crítica solo si su valor devuelto es `true`. El fragmento de código siguiente muestra el patrón utilizado para llamar a este método. Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que representa el período de tiempo que se va a esperar para adquirir el bloqueo. Un valor de –1 milisegundo especifica una espera infinita.</param>
        <summary>Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el período de tiempo especificado.</summary>
        <returns>Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de la `timeout` convierte a milisegundos del parámetro es igual a – 1, este método es equivalente a <xref:System.Threading.Monitor.Enter%2A>. Si el valor de `timeout` es igual a 0, este método es equivalente a <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor. Para obtener más información, consulte el <xref:System.Threading.Monitor> tema de la clase.  
  
 Para asegurarse de que el subproceso no entrar en la sección crítica, debe examinar el valor devuelto del método y ejecutar código en la sección crítica solo si su valor devuelto es `true`. El fragmento de código siguiente muestra el patrón utilizado para llamar a este método. Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> en milisegundos es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundos), o es superior a <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
        <param name="millisecondsTimeout">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</param>
        <param name="lockTaken">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
        <summary>Intenta, durante el número especificado de milisegundos, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `millisecondsTimeout` parámetro es igual a <xref:System.Threading.Timeout.Infinite>, este método es equivalente a <xref:System.Threading.Monitor.Enter%28System.Object%29>. Si `millisecondsTimeout` es igual a 0, este método es equivalente a <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el `lockTaken` parámetro es `false` cuando este método finalice. Esto permite que el programa determinar, en todos los casos, si es necesario para liberar el bloqueo.  
  
> [!NOTE]
>  Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor. Para obtener más información, consulte el <xref:System.Threading.Monitor> tema de la clase.  
  
 Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de `lockTaken` y ejecutar código en la sección crítica solo si su valor es `true`. El fragmento de código siguiente muestra el patrón utilizado para llamar a este método. Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 El código siguiente muestra el patrón básico para usar el <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> sobrecarga del método. Esta sobrecarga siempre establece el valor de la variable que se pasa a la `ref` parámetro (`ByRef` en Visual Basic) `lockTaken`, incluso si el método produce una excepción, por lo que el valor de la variable es un método confiable para probar si el bloqueo debe ser publicado.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a adquirir el bloqueo.</param>
        <param name="timeout">Tiempo que se va a esperar el bloqueo. Un valor de –1 milisegundo especifica una espera infinita.</param>
        <param name="lockTaken">Resultado del intento de adquirir el bloqueo, pasado por referencia. La entrada debe ser <see langword="false" />. El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />. El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</param>
        <summary>Intenta, durante el periodo de tiempo indicado, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de la `timeout` convierte a milisegundos del parámetro es igual a – 1, este método es equivalente a <xref:System.Threading.Monitor.Enter%28System.Object%29>. Si el valor de `timeout` es igual a 0, este método es equivalente a <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el `lockTaken` parámetro es `false` cuando este método finalice. Esto permite que el programa determinar, en todos los casos, si es necesario para liberar el bloqueo.  
  
> [!NOTE]
>  Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor. Para obtener más información, consulte el <xref:System.Threading.Monitor> tema de la clase.  
  
 Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de `lockTaken` y ejecutar código en la sección crítica solo si su valor es `true`. El fragmento de código siguiente muestra el patrón utilizado para llamar a este método. Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> en milisegundos es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundos), o es superior a <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a esperar.</param>
        <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</summary>
        <returns>
          <see langword="true" /> si la llamada fue devuelta porque el llamador volvió a adquirir el bloqueo para el objeto especificado. Este método no devuelve ningún resultado si el bloqueo no vuelve a adquirirse.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él. El autor de la llamada se bloquea mientras espera a adquirir el bloqueo. Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.  
  
 Cuando un subproceso llama `Wait`, libera el bloqueo en el objeto y entra en cola de espera del objeto. El siguiente subproceso en la cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto. Todos los subprocesos que llaman a `Wait` permanecen en la cola de espera hasta que reciben una señal de <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>, enviada por el propietario del bloqueo. Si `Pulse` se envía, sólo el subproceso en el encabezado de la cola de espera se ve afectado. Si `PulseAll` se envía, se ven afectados todos los subprocesos que están esperando el objeto. Cuando se recibe la señal, uno o varios subprocesos deja la cola de espera y especifique la cola de subprocesos listos. Se permite un subproceso en la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
 Este método devuelve cuando el subproceso que realiza la llamada vuelve a adquirir el bloqueo en el objeto. Tenga en cuenta que este método se bloquea indefinidamente si el propietario del bloqueo no llama a `Pulse` o `PulseAll`.  
  
 El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado. Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado `Enter` en el objeto e invoca `Exit` tantas veces como sea necesario para liberar completamente el objeto bloqueado. El llamador, a continuación, se bloquea mientras espera para adquirir el objeto. Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama `Enter` tantas veces como sea necesario para restaurar el guardado `Enter` recuento para el llamador. Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.  
  
 Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que esperan para recibir notificaciones de un cambio en el estado del objeto.  
  
 El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.  
  
 Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a esperar.</param>
        <param name="millisecondsTimeout">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</param>
        <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</summary>
        <returns>Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el `obj` parámetro.  
  
 El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él. El autor de la llamada se bloquea mientras espera a adquirir el bloqueo. Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.  
  
 El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin llamar primero a la <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método. También se mueve el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos por delante de él en la cola de espera, por lo que puede volver a adquirir el bloqueo antes. El subproceso puede probar el valor devuelto de la <xref:System.Threading.Monitor.Wait%2A> método para determinar si volvió a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que ha provocado que entre en espera, y si es necesario llamada la <xref:System.Threading.Monitor.Wait%2A> nuevo al método.  
  
 Cuando un subproceso llama `Wait`, libera el bloqueo en el objeto y entra en cola de espera del objeto. El siguiente subproceso en la cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto. El subproceso que invocó `Wait` permanece en la cola de espera hasta que un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.PulseAll%2A>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.Pulse%2A>. Sin embargo, si `millisecondsTimeout` transcurre antes de que otro subproceso llama a este objeto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
> [!NOTE]
>  Si <xref:System.Threading.Timeout.Infinite> se especifica para el `millisecondsTimeout` parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Si `millisecondsTimeout` es igual a 0, el subproceso que llama `Wait` libera el bloqueo y, a continuación, escribe inmediatamente la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
 El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado. Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado <xref:System.Threading.Monitor.Enter%2A> en el objeto e invoca <xref:System.Threading.Monitor.Exit%2A> tantas veces como sea necesario para liberar completamente el objeto bloqueado. El llamador, a continuación, se bloquea mientras espera para adquirir el objeto. Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama <xref:System.Threading.Monitor.Enter%2A> tantas veces como sea necesario para restaurar el guardado <xref:System.Threading.Monitor.Enter%2A> recuento para el llamador. Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.  
  
> [!NOTE]
>  Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene el subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto.  
  
 El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.  
  
 Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="millisecondsTimeout" /> es negativo, y no igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a esperar.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</param>
        <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</summary>
        <returns>Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el `obj` parámetro.  
  
 El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él. El autor de la llamada se bloquea mientras espera a adquirir el bloqueo. Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.  
  
 El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin llamar primero a la <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método. También se mueve el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos por delante de él en la cola de espera, por lo que puede volver a adquirir el bloqueo antes. El subproceso puede probar el valor devuelto de la <xref:System.Threading.Monitor.Wait%2A> método para determinar si volvió a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que ha provocado que entre en espera, y si es necesario llamada la <xref:System.Threading.Monitor.Wait%2A> nuevo al método.  
  
 Cuando un subproceso llama `Wait`, libera el bloqueo en el objeto y entra en cola de espera del objeto. El siguiente subproceso en la cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto. El subproceso que invocó `Wait` permanece en la cola de espera hasta que un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.PulseAll%2A>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.Pulse%2A>. Sin embargo, si `timeout` transcurre antes de que otro subproceso llama a este objeto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
> [!NOTE]
>  Si un <xref:System.TimeSpan> se ha especificado que representa-1 milisegundos para la `timeout` parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Si `timeout` es 0 milisegundos, el subproceso que llama `Wait` libera el bloqueo y, a continuación, escribe inmediatamente la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
 El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado. Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado <xref:System.Threading.Monitor.Enter%2A> en el objeto e invoca <xref:System.Threading.Monitor.Exit%2A> tantas veces como sea necesario para liberar completamente el objeto bloqueado. El llamador, a continuación, se bloquea mientras espera para adquirir el objeto. Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama <xref:System.Threading.Monitor.Enter%2A> tantas veces como sea necesario para restaurar el guardado <xref:System.Threading.Monitor.Enter%2A> recuento para el llamador. Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.  
  
> [!NOTE]
>  Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene el subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto.  
  
 El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.  
  
 Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="timeout" /> en milisegundos es negativo y no representa <see cref="F:System.Threading.Timeout.Infinite" /> (–1 milisegundo) o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a esperar.</param>
        <param name="millisecondsTimeout">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</param>
        <param name="exitContext">
          <see langword="true" /> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <see langword="false" />.</param>
        <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos. Este método también especifica si el dominio de sincronización del contexto (si se trata de un contexto sincronizado) sale antes de la espera y vuelve a adquirir el bloqueo después.</summary>
        <returns>Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el `obj` parámetro.  
  
 El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él. El autor de la llamada se bloquea mientras espera a adquirir el bloqueo. Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.  
  
 El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin llamar primero a la <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método. También se mueve el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos por delante de él en la cola de espera, por lo que puede volver a adquirir el bloqueo antes. El subproceso puede probar el valor devuelto de la <xref:System.Threading.Monitor.Wait%2A> método para determinar si volvió a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que ha provocado que entre en espera, y si es necesario llamada la <xref:System.Threading.Monitor.Wait%2A> nuevo al método.  
  
 Cuando un subproceso llama `Wait`, libera el bloqueo y entra en la cola de espera. En este momento, el siguiente subproceso en la cola de subprocesos listos (si existe) se permite tomar el control del bloqueo. El subproceso que invocó `Wait` permanece en la cola de espera hasta que un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.PulseAll%2A>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.Pulse%2A>. Sin embargo, si `millisecondsTimeout` transcurre antes de que otro subproceso llama a este objeto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
> [!NOTE]
>  Si <xref:System.Threading.Timeout.Infinite> se especifica para el `millisecondsTimeout` parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Si `millisecondsTimeout` es igual a 0, el subproceso que llama `Wait` libera el bloqueo y, a continuación, escribe inmediatamente la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
 El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado. Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado <xref:System.Threading.Monitor.Enter%2A> en el objeto e invoca <xref:System.Threading.Monitor.Exit%2A> tantas veces como sea necesario para liberar completamente el objeto bloqueado. El llamador, a continuación, se bloquea mientras espera para adquirir el objeto. Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama <xref:System.Threading.Monitor.Enter%2A> tantas veces como sea necesario para restaurar el guardado <xref:System.Threading.Monitor.Enter%2A> recuento para el llamador. Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.  
  
> [!NOTE]
>  Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene el subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto.  
  
 El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.  
  
 Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El`exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.Monitor.Wait%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.Monitor.Wait%2A> método. Devuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.Monitor.Wait%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene el <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo aplicado. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.Monitor.Wait%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.Monitor.Wait%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> no se invoca desde dentro de un bloque de código sincronizado.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="millisecondsTimeout" /> es negativo, y no igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a esperar.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</param>
        <param name="exitContext">
          <see langword="true" /> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <see langword="false" />.</param>
        <summary>Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo. Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos. De modo opcional, sale del dominio de sincronización del contexto sincronizado antes de la espera y vuelve a adquirir el dominio después.</summary>
        <returns>Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado. El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el `obj` parámetro.  
  
 El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él. El autor de la llamada se bloquea mientras espera a adquirir el bloqueo. Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.  
  
 El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin llamar primero a la <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método. También se mueve el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos por delante de él en la cola de espera, por lo que puede volver a adquirir el bloqueo antes. El subproceso puede probar el valor devuelto de la <xref:System.Threading.Monitor.Wait%2A> método para determinar si volvió a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que ha provocado que entre en espera, y si es necesario llamada la <xref:System.Threading.Monitor.Wait%2A> nuevo al método.  
  
 Cuando un subproceso llama `Wait`, libera el bloqueo y entra en la cola de espera. En este momento, el siguiente subproceso en la cola de subprocesos listos (si existe) se permite tomar el control del bloqueo. El subproceso que invocó `Wait` permanece en la cola de espera hasta que un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.PulseAll%2A>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.Pulse%2A>. Sin embargo, si `timeout` milisegundos que deben transcurrir antes de que otro subproceso llama a este objeto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
> [!NOTE]
>  Si un <xref:System.TimeSpan> que representa-1 milisegundo se especifica para el `timeout` parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Si `timeout` es 0 milisegundos, el subproceso que llama `Wait` libera el bloqueo y, a continuación, escribe inmediatamente la cola de subprocesos listos para volver a adquirir el bloqueo.  
  
 El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado. Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado <xref:System.Threading.Monitor.Enter%2A> en el objeto e invoca <xref:System.Threading.Monitor.Exit%2A> tantas veces como sea necesario para liberar completamente el objeto bloqueado. El llamador, a continuación, se bloquea mientras espera para adquirir el objeto. Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama <xref:System.Threading.Monitor.Enter%2A> tantas veces como sea necesario para restaurar el guardado <xref:System.Threading.Monitor.Enter%2A> recuento para el llamador. Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.  
  
> [!NOTE]
>  Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene el subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto.  
  
 El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.  
  
 Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.  
  
## <a name="notes-on-exiting-the-context"></a>Notas sobre la salida del contexto  
 El`exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.Monitor.Wait%2A> método se llama desde dentro de un contexto administrado no predeterminado. Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>. Incluso si se están ejecutando un método en una clase que no se deriva <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.  
  
 Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.Monitor.Wait%2A> método. Devuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.Monitor.Wait%2A> método se completa.  
  
 Esto puede ser útil cuando la clase de contexto enlazado tiene el <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo aplicado. En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase. Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.Monitor.Wait%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar. Cuando el <xref:System.Threading.Monitor.Wait%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="obj" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> no se invoca desde dentro de un bloque de código sincronizado.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso que invoca a Wait se interrumpe más adelante desde el estado de espera. Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="timeout" /> es negativo y no representa <see cref="F:System.Threading.Timeout.Infinite" /> (– 1 milisegundo), o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>