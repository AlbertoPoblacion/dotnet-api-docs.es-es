<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Monitor.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Provides a mechanism that synchronizes access to objects.</source>
          <target state="translated">Proporciona un mecanismo que sincroniza el acceso a los objetos.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase le permite sincronizar el acceso a una región de código mediante la obtención y liberación de un bloqueo en un objeto determinado mediante una llamada a la <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType&gt;</ph>, y <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</source>
          <target state="translated">Bloqueos de objeto proporcionan la capacidad para restringir el acceso a un bloque de código, que suele conocerse como una sección crítica.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While a thread owns the lock for an object, no other thread can acquire that lock.</source>
          <target state="translated">Mientras que un subproceso posee el bloqueo de un objeto, ningún otro subproceso puede adquirir ese bloqueo.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</source>
          <target state="translated">También puede usar el <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase para asegurar que ningún otro subproceso tiene permiso para tener acceso a una sección de aplicación de código que se está ejecutando por el propietario del bloqueo, a menos que el otro subproceso está ejecutando el código utilizando un objeto bloqueado distinto.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In this article:</source>
          <target state="translated">En este artículo:</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The Monitor class: An overview<ept id="p1">](#Overview)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>La clase de Monitor: información general<ept id="p1">](#Overview)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The lock object<ept id="p1">](#Lock)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>El objeto de bloqueo<ept id="p1">](#Lock)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>The critical section<ept id="p1">](#CriticalSection)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>La sección crítica<ept id="p1">](#CriticalSection)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>Pulse, PulseAll, and Wait<ept id="p1">](#Pulse)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Pulse y PulseAll, espera<ept id="p1">](#Pulse)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><bpt id="p1">[</bpt>Monitors and wait handles<ept id="p1">](#WaitHandles)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Monitores y controladores de espera<ept id="p1">](#WaitHandles)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The Monitor class: An overview</source>
          <target state="translated">La clase de Monitor: información general</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> has the following features:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> tiene las siguientes características:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is associated with an object on demand.</source>
          <target state="translated">Está asociado a un objeto a petición.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is unbound, which means it can be called directly from any context.</source>
          <target state="translated">Es independiente, lo que significa que puede llamarse directamente desde cualquier contexto.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class cannot be created; the methods of the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> class are all static.</source>
          <target state="translated">Una instancia de la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> no se puede crear la clase; los métodos de la <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> clase son todos estáticos.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each method is passed the synchronized object that controls access to the critical section.</source>
          <target state="translated">Cada método se le pasa el objeto sincronizado que controla el acceso a la sección crítica.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to lock objects other than strings (that is, reference types other than <ph id="ph2">&lt;xref:System.String&gt;</ph>), not value types.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase a los objetos de bloqueo que no son cadenas (es decir, tipos de referencia distintos de <ph id="ph2">&lt;xref:System.String&gt;</ph>), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>For details, see the overloads of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method and <bpt id="p1">[</bpt>The lock object<ept id="p1">](#Lock)</ept> section later in this article.</source>
          <target state="translated">Para obtener más información, vea las sobrecargas de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> método y <bpt id="p1">[</bpt>el objeto de bloqueo<ept id="p1">](#Lock)</ept> sección más adelante en este artículo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following table describes the actions that can be taken by threads that access synchronized objects:</source>
          <target state="translated">En la tabla siguiente se describe las acciones que pueden realizarse por subprocesos que tienen acceso a objetos sincronizados:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Action</source>
          <target state="translated">Acción</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Acquires a lock for an object.</source>
          <target state="translated">Adquiere un bloqueo de un objeto.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This action also marks the beginning of a critical section.</source>
          <target state="translated">Esta acción también marca el principio de una sección crítica.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</source>
          <target state="translated">Ningún otro subproceso puede entrar en la sección crítica, a menos que se ejecuta las instrucciones que aparecen en la sección crítica utilizando un objeto bloqueado distinto.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object in order to permit other threads to lock and access the object.</source>
          <target state="translated">Libera el bloqueo en un objeto con el fin de permitir a otros subprocesos bloquear y obtener acceso al objeto.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The calling thread waits while another thread accesses the object.</source>
          <target state="translated">El subproceso que realiza la llamada espera mientras otro subproceso tiene acceso al objeto.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Pulse signals are used to notify waiting threads about changes to an object's state.</source>
          <target state="translated">Las señales de pulsos se utilizan para notificar a los subprocesos en espera sobre los cambios en el estado de un objeto.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> (signal), <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> (señal) <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Sends a signal to one or more waiting threads.</source>
          <target state="translated">Envía una señal a uno o varios subprocesos en espera.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</source>
          <target state="translated">La señal notifica a un subproceso en espera que cambió el estado del objeto bloqueado, y el propietario del bloqueo está listo para liberar el bloqueo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</source>
          <target state="translated">El subproceso en espera se coloca en la cola de subprocesos listos del objeto para que pueda recibir el bloqueo para el objeto.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</source>
          <target state="translated">Una vez que el subproceso tiene el bloqueo, puede comprobar el nuevo estado del objeto para ver si se ha alcanzado el estado necesario.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object.</source>
          <target state="translated">Libera el bloqueo en un objeto.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This action also marks the end of a critical section protected by the locked object.</source>
          <target state="translated">Esta acción también marca el final de una sección crítica protegida por el objeto bloqueado.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, there are two sets of overloads for the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph> methods.</source>
          <target state="translated">A partir del <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, hay dos conjuntos de sobrecargas para el <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>One set of overloads has a <ph id="ph1">`ref`</ph> (in C#) or <ph id="ph2">`ByRef`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Boolean&gt;</ph> parameter that is atomically set to <ph id="ph4">`true`</ph> if the lock is acquired, even if an exception is thrown when acquiring the lock.</source>
          <target state="translated">Un conjunto de sobrecargas tiene un <ph id="ph1">`ref`</ph> (en C#) o <ph id="ph2">`ByRef`</ph> (en Visual Basic) <ph id="ph3">&lt;xref:System.Boolean&gt;</ph> parámetro que se establece de forma atómica en <ph id="ph4">`true`</ph> si se adquiere el bloqueo, incluso si se produce una excepción al adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</source>
          <target state="translated">Use estas sobrecargas si es crítico para liberar el bloqueo en todos los casos, incluso cuando los recursos que está protegiendo el bloqueo no estén en un estado coherente.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The lock object</source>
          <target state="translated">El objeto de bloqueo</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The Monitor class consists of <ph id="ph1">`static`</ph> (in C#) or  <ph id="ph2">`Shared`</ph> (in Visual Basic) methods that operate on an object that controls access to the critical section.</source>
          <target state="translated">La clase Monitor consta de <ph id="ph1">`static`</ph> (en C#) o <ph id="ph2">`Shared`</ph> (en Visual Basic) métodos que operan en un objeto que controla el acceso a la sección crítica.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following information is maintained for each synchronized object:</source>
          <target state="translated">Para cada objeto sincronizado, se mantiene la información siguiente:</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to the thread that currently holds the lock.</source>
          <target state="translated">Una referencia al subproceso que actualmente tiene el bloqueo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to a ready queue, which contains the threads that are ready to obtain the lock.</source>
          <target state="translated">Una referencia a una cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</source>
          <target state="translated">Una referencia a una cola de espera, que contiene los subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto bloqueado.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> locks objects (that is, reference types), not value types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> bloquea objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While you can pass a value type to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, it is boxed separately for each call.</source>
          <target state="translated">Aunque puede pasar un tipo de valor a <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, se somete a una conversión boxing independiente para cada llamada.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Since each call creates a separate object, <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> never blocks, and the code it is supposedly protecting is not really synchronized.</source>
          <target state="translated">Puesto que cada llamada crea un objeto independiente, <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> nunca bloquea y el código al que supuestamente protege no está sincronizado realmente.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In addition, the object passed to <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> is different from the object passed to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, so <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception with the message "Object synchronization method was called from an unsynchronized block of code."</source>
          <target state="translated">Además, el objeto que se pasa a <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> es diferente del objeto que se pasa a <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, por lo que <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> produce la excepción <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> con el mensaje “El método de sincronización del objeto se ha llamado desde un bloque de códigos sin sincronizar.”.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example illustrates this problem.</source>
          <target state="translated">El siguiente ejemplo ilustra este problema.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It launches ten tasks, each of which just sleeps for 250 milliseconds.</source>
          <target state="translated">Inicia diez tareas, cada una de los cuales solo se suspende durante 250 milisegundos.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task then updates a counter variable, <ph id="ph1">`nTasks`</ph>, which is intended to count the number of tasks that actually launched and executed.</source>
          <target state="translated">A continuación, cada tarea actualiza una variable de contador, <ph id="ph1">`nTasks`</ph>, pensada para contar el número de tareas que realmente se iniciaron y ejecutaron.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Because <ph id="ph1">`nTasks`</ph> is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</source>
          <target state="translated">Dado que <ph id="ph1">`nTasks`</ph> es una variable global que pueden actualizar varias tareas al mismo tiempo, se usa un monitor para protegerla frente a modificaciones simultáneas de varias tareas.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>However, as the output from the example shows, each of the tasks throws a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception.</source>
          <target state="translated">Sin embargo, como muestra la salida del ejemplo, cada una de las tareas produce una excepción <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task throws a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception because the <ph id="ph2">`nTasks`</ph> variable is boxed before the call to the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> method in each task.</source>
          <target state="translated">Cada tarea produce una excepción <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> porque la variable <ph id="ph2">`nTasks`</ph> es objeto de a una conversión boxing antes de llamar al método <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> en cada tarea.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In other words, each method call is passed a separate variable that is independent of the others.</source>
          <target state="translated">En otras palabras, a cada llamada al método se le pasa una variable independiente, que es independiente del resto.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">`nTasks`</ph> is boxed again in the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`nTasks`</ph> se vuelve a someter a una conversión boxing en la llamada al método <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once again, this creates ten new boxed variables, which are independent of each other, <ph id="ph1">`nTasks`</ph>, and the ten boxed variables created in the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Una vez más, esto crea diez nuevas variables sometidas a conversión boxing, que son independientes entre sí, <ph id="ph1">`nTasks`</ph>, y las diez variables creadas en la llamada al método <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> y sometidas a una conversión boxing.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</source>
          <target state="translated">A continuación, se produce la excepción porque el código está intentando liberar un bloqueo en una variable recién creada que no se ha bloqueado anteriormente.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Although you can box a value type variable before calling <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</source>
          <target state="translated">Aunque puede aplicar una conversión boxing a una variable de tipo de valor antes de llamar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, tal como se muestra en el siguiente ejemplo, y pasar el mismo objeto sometido a conversión boxing a ambos métodos, hacerlo no ofrece ninguna ventaja.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</source>
          <target state="translated">Los cambios realizados en la variable sometida a conversión unboxing no se reflejan en la copia sometida a conversión boxing, y no hay ninguna forma de cambiar el valor de la copia de sometida a conversión boxing.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When selecting an object on which to synchronize, you should lock only on private or internal objects.</source>
          <target state="translated">Cuando se selecciona un objeto en el que se va a sincronizar, debe bloquear solo en objetos internos o privados.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</source>
          <target state="translated">El bloqueo en objetos externos, se podría producir interbloqueos, porque el código relacionado con podría elegir los mismos objetos desea bloquear en para propósitos diferentes.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>.</source>
          <target state="translated">Tenga en cuenta que puede sincronizar en un objeto en varios dominios de aplicación si el objeto utilizado para el bloqueo deriva de <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The critical section</source>
          <target state="translated">La sección crítica</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods to mark the beginning and end of a critical section.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> métodos para marcar el principio y al final de una sección crítica.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The functionality provided by the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods is identical to that provided by the <bpt id="p1">[</bpt>lock<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement in C# and the <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement in Visual Basic, except that the language constructs wrap the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType&gt;</ph> method overload and the <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> method in a <ph id="ph5">`try`</ph>…<ph id="ph6">`finally`</ph></source>
          <target state="translated">La funcionalidad proporcionada por el <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> métodos es idéntica a la que ofrece el <bpt id="p1">[</bpt>bloqueo<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> instrucción en C# y la <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> instrucción en Visual Basic, salvo que el construcciones del lenguaje encapsulado el <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType&gt;</ph> sobrecarga del método y la <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType&gt;</ph> método en un <ph id="ph5">`try`</ph>...<ph id="ph6">`finally`</ph></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>block to ensure that the monitor is released.</source>
          <target state="translated">bloque para asegurarse de que se libere el monitor.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>If the critical section is a set of contiguous instructions, then the lock acquired by the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method guarantees that only a single thread can execute the enclosed code with the locked object.</source>
          <target state="translated">Si la sección crítica es un conjunto de instrucciones contiguas, el bloqueo adquirido por el <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> método garantiza que un único subproceso pueda ejecutar el código delimitado con el objeto bloqueado.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>In this case, we recommend that you place that code in a <ph id="ph1">`try`</ph> block and place the call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> method in a <ph id="ph3">`finally`</ph> block.</source>
          <target state="translated">En este caso, se recomienda colocar ese código en un <ph id="ph1">`try`</ph> bloquear y realizar una llamada a la <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> método en un <ph id="ph3">`finally`</ph> bloque.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This ensures that the lock is released even if an exception occurs.</source>
          <target state="translated">Esto garantiza la liberación del bloqueo aunque se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following code fragment illustrates this pattern.</source>
          <target state="translated">El siguiente fragmento de código muestra este patrón.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This facility is typically used to synchronize access to a static or instance method of a class.</source>
          <target state="translated">Esta función normalmente se utiliza para sincronizar el acceso a una variable static o un método de instancia de una clase.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>If a critical section spans an entire method, the locking facility can be achieved by placing the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph> on the method, and specifying the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized&gt;</ph> value in the constructor of <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si una sección crítica abarca todo un método, la utilidad de bloqueo se puede lograr mediante la colocación de la <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph> en el método y especificando el <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized&gt;</ph> valor en el constructor de <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When you use this attribute, the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> method calls are not needed.</source>
          <target state="translated">Cuando se utiliza este atributo, el <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> no son necesarias las llamadas a métodos.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following code fragment illustrates this pattern:</source>
          <target state="translated">El siguiente fragmento de código muestra este patrón:</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class, the C# <bpt id="p1">[</bpt>lock<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement, or the Visual Basic <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement inside of the method instead of the attribute.</source>
          <target state="translated">Tenga en cuenta que el atributo hace que el subproceso actual mantener el bloqueo hasta que el método devuelve; Si el bloqueo puede liberarse antes, utilice la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase C#, <bpt id="p1">[</bpt>bloqueo<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> instrucción o Visual Basic <bpt id="p2">[</bpt>SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> instrucción dentro del método en lugar del atributo.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>While it is possible for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</source>
          <target state="translated">Aunque es posible que el <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> instrucciones que bloquear y liberar un objeto determinado puedan atravesar los límites de clase y miembro, no se recomienda esta práctica.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Pulse, PulseAll, and Wait</source>
          <target state="translated">Pulse y PulseAll, espera</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Una vez que un subproceso posee el bloqueo y ha entrado en la sección crítica que protege el bloqueo, puede llamar a la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> Libera el bloqueo si se mantiene, permite que un subproceso en espera o subprocesos para obtener el bloqueo y entrar en la sección crítica y espera a ser notificado por una llamada a la <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> is notified, it returns and obtains the lock again.</source>
          <target state="translated">Cuando <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> recibe la notificación, devuelve y vuelve a obtener el bloqueo.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Both <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> signal for the next thread in the wait queue to proceed.</source>
          <target state="translated">Tanto <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> como <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> indican al siguiente subproceso de la cola de espera que proceda.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Monitors and wait handles</source>
          <target state="translated">Monitores y controladores de espera</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It is important to note the distinction between the use of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class and <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> objects.</source>
          <target state="translated">Es importante tener en cuenta la distinción entre el uso de la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase y <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase es puramente administrados, son totalmente portátiles y podrían ser más eficaces en cuanto a requisitos de recursos del sistema operativo.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source><ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</source>
          <target state="translated">Los objetos <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> representan objetos del sistema operativo que pueden esperar, que son útiles para la sincronización entre el código administrado y el no administrado y exponen algunas características avanzadas del sistema operativo, como la capacidad de esperar muchos objetos a la vez.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class to synchronize access to a single instance of a random number generator represented by the <ph id="ph2">&lt;xref:System.Random&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase para sincronizar el acceso a una sola instancia de un generador de números aleatorios representado por la <ph id="ph2">&lt;xref:System.Random&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</source>
          <target state="translated">El ejemplo crea diez tareas, cada uno de los cuales se ejecuta de forma asincrónica en un subproceso del grupo.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</source>
          <target state="translated">Cada tarea genera números aleatorios 10.000, calcula su Media y dos variables de nivel de procedimiento que mantienen un total acumulado del número de números aleatorios generados y la suma actualiza.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>After all tasks have executed, these two values are then used to calculate the overall mean.</source>
          <target state="translated">Después de que se han ejecutado todas las tareas, estos dos valores, a continuación, se utilizan para calcular la media general.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Because they can be accessed from any task running on a thread pool thread, access to the variables <ph id="ph1">`total`</ph> and <ph id="ph2">`n`</ph> must also be synchronized.</source>
          <target state="translated">Dado que puede tener acceso desde cualquier tarea que se ejecuta en un subproceso del grupo, el acceso a las variables <ph id="ph1">`total`</ph> y <ph id="ph2">`n`</ph> también debe estar sincronizada.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType&gt;</ph> method is used for this purpose.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType&gt;</ph> método se usa para este propósito.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The following example demonstrates the combined use of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class (implemented with the <ph id="ph2">`lock`</ph> or <ph id="ph3">`SyncLock`</ph> language construct), the <ph id="ph4">&lt;xref:System.Threading.Interlocked&gt;</ph> class, and the <ph id="ph5">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> class.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso combinado de la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase (implementada con el <ph id="ph2">`lock`</ph> o <ph id="ph3">`SyncLock`</ph> construcción de lenguaje), el <ph id="ph4">&lt;xref:System.Threading.Interlocked&gt;</ph> (clase) y la <ph id="ph5">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>It defines two <ph id="ph1">`internal`</ph> (in C#) or <ph id="ph2">`Friend`</ph> (in Visual Basic) classes, <ph id="ph3">`SyncResource`</ph> and <ph id="ph4">`UnSyncResource`</ph>, that respectively provide synchronized and unsynchronized access to a resource.</source>
          <target state="translated">Define dos <ph id="ph1">`internal`</ph> (en C#) o <ph id="ph2">`Friend`</ph> (en Visual Basic) de las clases, <ph id="ph3">`SyncResource`</ph> y <ph id="ph4">`UnSyncResource`</ph>, que proporcionan respectivamente acceso sincronizado y a un recurso.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> property is even, the method calls <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> to introduce a delay of 2,000 milliseconds.</source>
          <target state="translated">Para asegurarse de que el ejemplo ilustra la diferencia entre el acceso sincronizado y sin sincronizar (lo que podría darse el caso si cada llamada al método se realiza rápidamente), el método incluye un retraso aleatorio: para subprocesos cuya <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> propiedad es par, el llamadas al método <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> para insertar un retraso de 2.000 milisegundos.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Note that, because the <ph id="ph1">`SyncResource`</ph> class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</source>
          <target state="translated">Tenga en cuenta que, dado el <ph id="ph1">`SyncResource`</ph> clase no es pública, ninguno de los códigos de cliente tiene un bloqueo en el recurso sincronizado; la propia clase interna cargo del bloqueo.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This prevents malicious code from taking a lock on a public object.</source>
          <target state="translated">Esto evita que cualquier código malintencionado se haga cargo de un bloqueo en un objeto público.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The example defines a variable, <ph id="ph1">`numOps`</ph>, that defines the number of threads that will attempt to access the resource.</source>
          <target state="translated">En el ejemplo se define una variable, <ph id="ph1">`numOps`</ph>, que define el número de subprocesos que intentarán tener acceso al recurso.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The application thread calls the <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> method for synchronized and unsynchronized access five times each.</source>
          <target state="translated">El subproceso de la aplicación llama el <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> método sincronizado y que no esté sincronizado tener acceso a cinco veces cada uno.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> method has a single parameter, a delegate that accepts no parameters and returns no value.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType&gt;</ph> método tiene un único parámetro, un delegado que no acepta parámetros y no devuelve ningún valor.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>For synchronized access, it invokes the <ph id="ph1">`SyncUpdateResource`</ph> method; for unsynchronized access, it invokes the <ph id="ph2">`UnSyncUpdateResource`</ph> method.</source>
          <target state="translated">Para obtener acceso sincronizado, invoca el <ph id="ph1">`SyncUpdateResource`</ph> método; para el acceso sincronizado, invoca el <ph id="ph2">`UnSyncUpdateResource`</ph> método.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>After each set of method calls, the application thread calls the <bpt id="p1">[</bpt>AutoResetEvent.WaitOne<ept id="p1">](xref:System.Threading.WaitHandle.WaitOne*)</ept> method so that it blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> instance is signaled.</source>
          <target state="translated">Después de cada conjunto de llamadas de método, el subproceso de la aplicación llama a la <bpt id="p1">[</bpt>AutoResetEvent.WaitOne<ept id="p1">](xref:System.Threading.WaitHandle.WaitOne*)</ept> método para que así se bloquee hasta que la <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> se señala la instancia.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each call to the <ph id="ph1">`SyncUpdateResource`</ph> method calls the internal <ph id="ph2">`SyncResource.Access`</ph> method and then calls the <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method to decrement the <ph id="ph4">`numOps`</ph> counter.</source>
          <target state="translated">Cada llamada a la <ph id="ph1">`SyncUpdateResource`</ph> llamadas de método interno <ph id="ph2">`SyncResource.Access`</ph> método y, a continuación, llama el <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> método para reducir el <ph id="ph4">`numOps`</ph> contador.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> método se usa para disminuir el contador, porque de lo contrario, no podrá saber que un segundo subproceso acceso al valor antes de reducido del primer subproceso valor se ha almacenado en la variable.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the <ph id="ph1">`SyncUpdateResource`</ph> method calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> method, which signals the main thread to continue execution.</source>
          <target state="translated">Cuando el último trabajo subproceso sincronizado disminuya el contador a cero, que indica que todos los subprocesos sincronizados finalizaron obtener acceso al recurso, el <ph id="ph1">`SyncUpdateResource`</ph> llamadas al método el <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> método, que indica al subproceso principal para continuar ejecución.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Each call to the <ph id="ph1">`UnSyncUpdateResource`</ph> method calls the internal <ph id="ph2">`UnSyncResource.Access`</ph> method and then calls the <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method to decrement the <ph id="ph4">`numOps`</ph> counter.</source>
          <target state="translated">Cada llamada a la <ph id="ph1">`UnSyncUpdateResource`</ph> llamadas de método interno <ph id="ph2">`UnSyncResource.Access`</ph> método y, a continuación, llama el <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> método para reducir el <ph id="ph4">`numOps`</ph> contador.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>Once again, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</source>
          <target state="translated">Una vez más, la <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType&gt;</ph> método se usa para disminuir el contador para asegurarse de que un segundo subproceso no tiene acceso el valor antes de que se ha asignado el valor reducido del primer subproceso a la variable.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the <ph id="ph1">`UnSyncUpdateResource`</ph> method calls the <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> method, which signals the main thread to continue execution.</source>
          <target state="translated">Cuando el último no sincronizados disminuye de subprocesos de trabajo que el contador a cero, que indica que no hay más subprocesos no sincronizados necesita tener acceso al recurso, el <ph id="ph1">`UnSyncUpdateResource`</ph> llamadas al método el <ph id="ph2">&lt;xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType&gt;</ph> método, que indica al subproceso principal para continuar la ejecución .</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</source>
          <target state="translated">Como se muestra en el resultado del ejemplo, el acceso sincronizado garantiza que el subproceso de llamada saldrá del recurso protegido antes de que otro subproceso pueda tener acceso a él; así pues, cada subproceso esperará a su predecesor.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>On the other hand, without the lock, the <ph id="ph1">`UnSyncResource.Access`</ph> method is called in the order in which threads reach it.</source>
          <target state="translated">Por otro lado, sin el bloqueo, el <ph id="ph1">`UnSyncResource.Access`</ph> método se llama en el orden en que los subprocesos accedan a él.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Monitor">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo es seguro para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Acquires an exclusive lock on a specified object.</source>
          <target state="translated">Adquiere un bloqueo exclusivo en un objeto especificado.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The object on which to acquire the monitor lock.</source>
          <target state="translated">Objeto en el que se va a adquirir el bloqueo de monitor.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Acquires an exclusive lock on the specified object.</source>
          <target state="translated">Adquiere un bloqueo exclusivo en el objeto especificado.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use <ph id="ph1">`Enter`</ph> to acquire the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> on the object passed as the parameter.</source>
          <target state="translated">Use <ph id="ph1">`Enter`</ph> para adquirir el <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> en el objeto pasado como parámetro.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>If another thread has executed an <ph id="ph1">`Enter`</ph> on the object but has not yet executed the corresponding <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, the current thread will block until the other thread releases the object.</source>
          <target state="translated">Si otro subproceso ha ejecutado un <ph id="ph1">`Enter`</ph> en el objeto, pero no se ha ejecutado todavía el correspondiente <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, se bloqueará el subproceso actual hasta que el otro subproceso libera el objeto.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>It is legal for the same thread to invoke <ph id="ph1">`Enter`</ph> more than once without it blocking; however, an equal number of <ph id="ph2">`Exit`</ph> calls must be invoked before other threads waiting on the object will unblock.</source>
          <target state="translated">Es válido para el mismo subproceso invocar <ph id="ph1">`Enter`</ph> más de una vez sin bloquearse; sin embargo, un número igual de <ph id="ph2">`Exit`</ph> se deben invocar llamadas antes de que se desbloqueen otros subprocesos en espera en el objeto.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> para bloquear objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>When you pass a value type variable to <ph id="ph1">`Enter`</ph>, it is boxed as an object.</source>
          <target state="translated">Cuando se pasa una variable de tipo de valor a <ph id="ph1">`Enter`</ph>, se encuadra como un objeto.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>If you pass the same variable to <ph id="ph1">`Enter`</ph> again, it is boxed as a separate object, and the thread does not block.</source>
          <target state="translated">Si se pasa la misma variable a <ph id="ph1">`Enter`</ph> nuevo, es una conversión boxing como objeto independiente y no bloquea el subproceso.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>In this case, the code that <ph id="ph1">`Monitor`</ph> is supposedly protecting is not protected.</source>
          <target state="translated">En este caso, el código que <ph id="ph1">`Monitor`</ph> es supuestamente protege no está protegido.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Furthermore, when you pass the variable to <ph id="ph1">`Exit`</ph>, still another separate object is created.</source>
          <target state="translated">Además, al pasar la variable a <ph id="ph1">`Exit`</ph>, se crea otro objeto independiente.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Because the object passed to <ph id="ph1">`Exit`</ph> is different from the object passed to <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</source>
          <target state="translated">Puesto que el objeto pasado a <ph id="ph1">`Exit`</ph> es diferente del objeto pasado a <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> produce <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>For more information, see the conceptual topic <bpt id="p1">[</bpt>Monitors<ept id="p1">](xref:System.Threading.Monitor)</ept>.</source>
          <target state="translated">Para obtener más información, vea el tema conceptual <bpt id="p1">[</bpt>monitores<ept id="p1">](xref:System.Threading.Monitor)</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> can interrupt threads that are waiting to enter a <ph id="ph2">`Monitor`</ph> on an object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> puede interrumpir subprocesos que están esperando para escribir un <ph id="ph2">`Monitor`</ph> en un objeto.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> will be thrown.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> se iniciará.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>Use a C# <ph id="ph1">`try`</ph>…<ph id="ph2">`finally`</ph></source>
          <target state="translated">Usar C# <ph id="ph1">`try`</ph>...<ph id="ph2">`finally`</ph></target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>block (<ph id="ph1">`Try`</ph>…<ph id="ph2">`Finally`</ph></source>
          <target state="translated">bloque (<ph id="ph1">`Try`</ph>...<ph id="ph2">`Finally`</ph></target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>in Visual Basic) to ensure that you release the monitor, or use the C# <ph id="ph1">`lock`</ph> statement (<ph id="ph2">`SyncLock`</ph> statement in Visual Basic), which wraps the <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods in a <ph id="ph5">`try`</ph>…<ph id="ph6">`finally`</ph></source>
          <target state="translated">en Visual Basic) para asegurarse de que el monitor de la versión o utilizar el C# <ph id="ph1">`lock`</ph> instrucción (<ph id="ph2">`SyncLock`</ph> instrucción en Visual Basic), que encapsula el <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> y <ph id="ph4">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> métodos en un <ph id="ph5">`try`</ph>...<ph id="ph6">`finally`</ph></target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>block.</source>
          <target state="translated">bloque.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">`Enter`</ph> method.</source>
          <target state="translated">En el siguiente ejemplo se muestra cómo se utiliza el método <ph id="ph1">`Enter`</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The object on which to wait.</source>
          <target state="translated">Objeto en el que se va a esperar.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Resultado del intento de adquirir el bloqueo, pasado por referencia.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La entrada debe ser <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El resultado es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se adquiere el bloqueo; en caso contrario, el resultado es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Note   If no exception occurs, the output of this method is always <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Nota   Si no se produce ninguna excepción, el resultado de este método siempre es <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Adquiere un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">`Enter`</ph> to acquire the <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> on the object passed as the <ph id="ph3">`obj`</ph> parameter.</source>
          <target state="translated">Use <ph id="ph1">`Enter`</ph> para adquirir el <ph id="ph2">&lt;xref:System.Threading.Monitor&gt;</ph> en el objeto pasado como el <ph id="ph3">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If another thread has executed an <ph id="ph1">`Enter`</ph> on the object but has not yet executed the corresponding <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, the current thread will block until the other thread releases the object.</source>
          <target state="translated">Si otro subproceso ha ejecutado un <ph id="ph1">`Enter`</ph> en el objeto, pero no se ha ejecutado todavía el correspondiente <ph id="ph2">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, se bloqueará el subproceso actual hasta que el otro subproceso libera el objeto.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>It is legal for the same thread to invoke <ph id="ph1">`Enter`</ph> more than once without it blocking; however, an equal number of <ph id="ph2">`Exit`</ph> calls must be invoked before other threads waiting on the object will unblock.</source>
          <target state="translated">Es válido para el mismo subproceso invocar <ph id="ph1">`Enter`</ph> más de una vez sin bloquearse; sin embargo, un número igual de <ph id="ph2">`Exit`</ph> se deben invocar llamadas antes de que se desbloqueen otros subprocesos en espera en el objeto.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el <ph id="ph1">`lockTaken`</ph> parámetro es <ph id="ph2">`false`</ph> una vez finalizado este método.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Esto permite que el programa determinar, en todos los casos, si es necesario liberar el bloqueo.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If this method returns without throwing an exception, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is always <ph id="ph2">`true`</ph>, and there is no need to test it.</source>
          <target state="translated">Si este método devuelve sin producir una excepción, la variable especificada para el <ph id="ph1">`lockTaken`</ph> parámetro siempre es <ph id="ph2">`true`</ph>, y no es necesario para probarla.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> para bloquear objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>When you pass a value type variable to <ph id="ph1">`Enter`</ph>, it is boxed as an object.</source>
          <target state="translated">Cuando se pasa una variable de tipo de valor a <ph id="ph1">`Enter`</ph>, se encuadra como un objeto.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>If you pass the same variable to <ph id="ph1">`Enter`</ph> again, it is boxed as a separate object, and the thread does not block.</source>
          <target state="translated">Si se pasa la misma variable a <ph id="ph1">`Enter`</ph> nuevo, es una conversión boxing como objeto independiente y no bloquea el subproceso.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>In this case, the code that <ph id="ph1">`Monitor`</ph> is supposedly protecting is not protected.</source>
          <target state="translated">En este caso, el código que <ph id="ph1">`Monitor`</ph> es supuestamente protege no está protegido.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Furthermore, when you pass the variable to <ph id="ph1">`Exit`</ph>, another separate object is created.</source>
          <target state="translated">Además, al pasar la variable a <ph id="ph1">`Exit`</ph>, se crea otro objeto independiente.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>Because the object passed to <ph id="ph1">`Exit`</ph> is different from the object passed to <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> throws <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</source>
          <target state="translated">Puesto que el objeto pasado a <ph id="ph1">`Exit`</ph> es diferente del objeto pasado a <ph id="ph2">`Enter`</ph>, <ph id="ph3">`Monitor`</ph> produce <ph id="ph4">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>For more information, see the conceptual topic <bpt id="p1">[</bpt>Monitors<ept id="p1">](xref:System.Threading.Monitor)</ept>.</source>
          <target state="translated">Para obtener más información, vea el tema conceptual <bpt id="p1">[</bpt>monitores<ept id="p1">](xref:System.Threading.Monitor)</ept>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> can interrupt threads that are waiting to enter a <ph id="ph2">`Monitor`</ph> on an object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> puede interrumpir subprocesos que están esperando para escribir un <ph id="ph2">`Monitor`</ph> en un objeto.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> will be thrown.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> se iniciará.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">El código siguiente muestra el patrón básico para el uso de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Esta sobrecarga siempre establece el valor de la variable que se pasa a la <ph id="ph1">`ref`</ph> parámetro (<ph id="ph2">`ByRef`</ph> en Visual Basic) <ph id="ph3">`lockTaken`</ph>, incluso si el método produce una excepción, por lo que el valor de la variable es una manera fiable para comprobar si el bloqueo tiene que ser publicado.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La entrada a <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The object on which to release the lock.</source>
          <target state="translated">Objeto en el que se va a liberar el bloqueo.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>Releases an exclusive lock on the specified object.</source>
          <target state="translated">Libera un bloqueo exclusivo en el objeto especificado.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The calling thread must own the lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">El subproceso que realiza la llamada debe tener el bloqueo en el <ph id="ph1">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the calling thread owns the lock on the specified object, and has made an equal number of <ph id="ph1">`Exit`</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> calls for the object, then the lock is released.</source>
          <target state="translated">Si el subproceso que realiza la llamada posee el bloqueo en el objeto especificado y se ha realizado un número igual de <ph id="ph1">`Exit`</ph> y <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> llama para el objeto, a continuación, se libera el bloqueo.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the calling thread has not invoked <ph id="ph1">`Exit`</ph> as many times as <ph id="ph2">`Enter`</ph>, the lock is not released.</source>
          <target state="translated">Si el subproceso que realiza la llamada no ha invocado <ph id="ph1">`Exit`</ph> tantas veces como <ph id="ph2">`Enter`</ph>, no se libera el bloqueo.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</source>
          <target state="translated">Si el bloqueo se libera y otros subprocesos están en la cola de subprocesos listos para el objeto, uno de los subprocesos adquiere el bloqueo.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls <ph id="ph1">`Exit`</ph>.</source>
          <target state="translated">Si hay otros subprocesos en la cola de espera para adquirir el bloqueo, no se mueven automáticamente a la cola de subprocesos listos cuando el propietario del bloqueo llama <ph id="ph1">`Exit`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>To move one or more waiting threads into the ready queue, call <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> before invoking <ph id="ph3">`Exit`</ph>.</source>
          <target state="translated">Para mover uno o varios subprocesos en espera en la cola de subprocesos listos, llame a <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> antes de invocar <ph id="ph3">`Exit`</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">`Exit`</ph> method.</source>
          <target state="translated">En el siguiente ejemplo se muestra cómo se utiliza el método <ph id="ph1">`Exit`</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Exit(System.Object)">
          <source>The current thread does not own the lock for the specified object.</source>
          <target state="translated">El subproceso actual no posee el bloqueo para el objeto especificado.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>The object to test.</source>
          <target state="translated">El objeto que se va a probar.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>Determines whether the current thread holds the lock on the specified object.</source>
          <target state="translated">Determina si el subproceso actual mantiene el bloqueo en el objeto especificado.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread holds the lock on <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso actual mantiene el bloqueo en <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>This method works only for locks that are acquired by using the methods of the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class, or by using the C# <ph id="ph2">`lock`</ph> statement or the Visual Basic <ph id="ph3">`SyncLock`</ph> statement, which are implemented with <ph id="ph4">&lt;xref:System.Threading.Monitor&gt;</ph>.</source>
          <target state="translated">Este método solo funciona para los bloqueos adquiridos mediante los métodos de la <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase o usando C# <ph id="ph2">`lock`</ph> instrucción o Visual Basic <ph id="ph3">`SyncLock`</ph> instrucción, que se implementan con <ph id="ph4">&lt;xref:System.Threading.Monitor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source>Use this method with diagnostic tools, such as the <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> class, to debug locking issues that involve the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class.</source>
          <target state="translated">Utilice este método con herramientas de diagnóstico, como la <ph id="ph1">&lt;xref:System.Diagnostics.Debug.Assert%2A&gt;</ph> método y la <ph id="ph2">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> (clase), para depurar problemas de bloqueo que implican la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.IsEntered(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The object a thread is waiting for.</source>
          <target state="translated">Objeto que está esperando un subproceso.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Notifies a thread in the waiting queue of a change in the locked object's state.</source>
          <target state="translated">Notifica un cambio de estado del objeto bloqueado al subproceso que se encuentra en la cola de espera.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Only the current owner of the lock can signal a waiting object using <ph id="ph1">`Pulse`</ph>.</source>
          <target state="translated">Solo el propietario actual del bloqueo puede señalar a un objeto de espera mediante <ph id="ph1">`Pulse`</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</source>
          <target state="translated">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para notificar el siguiente subproceso en línea para adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Upon receiving the pulse, the waiting thread is moved to the ready queue.</source>
          <target state="translated">Tras recibir el pulso, el subproceso en espera se mueve a la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>When the thread that invoked <ph id="ph1">`Pulse`</ph> releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</source>
          <target state="translated">Cuando el subproceso que invocó <ph id="ph1">`Pulse`</ph> libera el bloqueo, el siguiente subproceso de la cola de subprocesos listos (que no es necesariamente el subproceso que ha recibido el pulso) adquiere el bloqueo.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class does not maintain state indicating that the <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method has been called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> clase mantienen el estado que indica que el <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> ha llamado al método.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Thus, if you call <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> when no threads are waiting, the next thread that calls <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> blocks as if <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> had never been called.</source>
          <target state="translated">Por lo tanto, si se llama a <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> cuando no hay ningún subproceso en espera, el siguiente subproceso que llama a <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> bloques como si <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> nunca se hubiera llamado.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>If two threads are using <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> to interact, this could result in a deadlock.</source>
          <target state="translated">Si están usando dos subprocesos <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> para interactuar, esto podría provocar un interbloqueo.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> class: If you signal an <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> by calling its <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, and there are no threads waiting, the <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> remains in a signaled state until a thread calls <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.</source>
          <target state="translated">Contrastar esto con el comportamiento de la <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> clase: si indican una <ph id="ph2">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> mediante una llamada a su <ph id="ph3">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> método y no hay ningún subproceso en espera, el <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> permanece en un estado señalado hasta que un subproceso llama a <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, o <ph id="ph7">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> releases that thread and returns to the unsignaled state.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> libera ese subproceso y vuelve al estado no señalado.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que actualmente tiene el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que están esperando recibir notificación de un cambio en el estado del objeto.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">`Pulse`</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">El <ph id="ph1">`Pulse`</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> métodos se deben invocar desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>To signal multiple threads, use the <ph id="ph1">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">Para indicar varios subprocesos, utilice el <ph id="ph1">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Pulse(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The object that sends the pulse.</source>
          <target state="translated">Objeto que envía el pulso.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>Notifies all waiting threads of a change in the object's state.</source>
          <target state="translated">Notifica un cambio de estado del objeto a todos los subprocesos que se encuentran en espera.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</source>
          <target state="translated">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para notificar todos los subprocesos en espera para adquirir el bloqueo en el objeto.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>After the signal is sent, the waiting threads are moved to the ready queue.</source>
          <target state="translated">Una vez enviada la señal, los subprocesos en espera se mueven a la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>When the thread that invoked <ph id="ph1">`PulseAll`</ph> releases the lock, the next thread in the ready queue acquires the lock.</source>
          <target state="translated">Cuando el subproceso que invocó <ph id="ph1">`PulseAll`</ph> libera el bloqueo, el siguiente subproceso de la cola de subprocesos listos adquiere el bloqueo.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que actualmente tiene el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que están esperando recibir notificación de un cambio en el estado del objeto.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">`PulseAll`</ph>, and <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">`PulseAll`</ph>, y <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> métodos se deben invocar desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La sección Comentarios para el <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> método se explica qué ocurre si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> se llama cuando no hay ningún subproceso en espera.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>To signal a single thread, use the <ph id="ph1">`Pulse`</ph> method.</source>
          <target state="translated">Para indicar un único subproceso, utilice el <ph id="ph1">`Pulse`</ph> método.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.PulseAll(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Attempts to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Intenta adquirir un bloqueo exclusivo en el objeto especificado.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objeto en el que se va a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Attempts to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Intenta adquirir un bloqueo exclusivo en el objeto especificado.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso actual adquiere el bloqueo; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>If successful, this method acquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Si realiza correctamente, este método adquiere un bloqueo exclusivo en el <ph id="ph1">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>This method returns immediately, whether or not the lock is available.</source>
          <target state="translated">Este método vuelve inmediatamente, si el bloqueo está disponible o no.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, but it will never block the current thread.</source>
          <target state="translated">Este método es similar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, pero nunca se bloqueará el subproceso actual.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>If the thread cannot enter without blocking, the method returns <ph id="ph1">`false,`</ph>.</source>
          <target state="translated">Si el subproceso no puede entrar sin bloquearse, el método devuelve <ph id="ph1">`false,`</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> para bloquear objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Para obtener más información, consulte el <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> artículo.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor devuelto del método y ejecutan código en la sección crítica solo si su valor devuelto es <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">El siguiente fragmento de código muestra la trama usada para llamar a este método.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Tenga en cuenta que debe llamar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> en un <ph id="ph2">`finally`</ph> bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica, si se produce una excepción.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The following code example demonstrates how to use the <ph id="ph1">`TryEnter`</ph> method.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo utilizar el método <ph id="ph1">`TryEnter`</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objeto en el que se va a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Resultado del intento de adquirir el bloqueo, pasado por referencia.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La entrada debe ser <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El resultado es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se adquiere el bloqueo; en caso contrario, el resultado es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Intenta adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If successful, this method acquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Si realiza correctamente, este método adquiere un bloqueo exclusivo en el <ph id="ph1">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This method returns immediately, whether or not the lock is available.</source>
          <target state="translated">Este método vuelve inmediatamente, si el bloqueo está disponible o no.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el <ph id="ph1">`lockTaken`</ph> parámetro es <ph id="ph2">`false`</ph> una vez finalizado este método.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Esto permite que el programa determinar, en todos los casos, si es necesario liberar el bloqueo.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This method is similar to <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph>, but it will never block the current thread.</source>
          <target state="translated">Este método es similar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph>, pero nunca se bloqueará el subproceso actual.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>If the thread cannot enter without blocking, the <ph id="ph1">`lockTaken`</ph> argument is set to <ph id="ph2">`false`</ph> when the method returns.</source>
          <target state="translated">Si el subproceso no puede entrar sin bloquearse, el <ph id="ph1">`lockTaken`</ph> argumento está establecido en <ph id="ph2">`false`</ph> cuando el método devuelve.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> para bloquear objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Para obtener más información, vea el artículo <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de <ph id="ph1">`lockTaken`</ph> y ejecutar el código en la sección crítica solo si su valor es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">El siguiente fragmento de código muestra la trama usada para llamar a este método.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Tenga en cuenta que debe llamar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> en un <ph id="ph2">`finally`</ph> bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica, si se produce una excepción.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">El código siguiente muestra el patrón básico para el uso de la <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Esta sobrecarga siempre establece el valor de la variable que se pasa a la <ph id="ph1">`ref`</ph> parámetro (<ph id="ph2">`ByRef`</ph> en Visual Basic) <ph id="ph3">`lockTaken`</ph>, incluso si el método produce una excepción, por lo que el valor de la variable es una manera fiable para comprobar si el bloqueo tiene que ser publicado.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La entrada a <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objeto en el que se va a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The number of milliseconds to wait for the lock.</source>
          <target state="translated">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el número de segundos especificado.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso actual adquiere el bloqueo; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>If the <ph id="ph1">`millisecondsTimeout`</ph> parameter equals <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, this method is equivalent to <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</source>
          <target state="translated">Si el <ph id="ph1">`millisecondsTimeout`</ph> parámetro es igual a <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, este método es equivalente a <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> es igual a 0, este método es equivalente a <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> para bloquear objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> article.</source>
          <target state="translated">Para obtener más información, consulte el <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> artículo.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor devuelto del método y ejecutan código en la sección crítica solo si su valor devuelto es <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">El siguiente fragmento de código muestra la trama usada para llamar a este método.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Tenga en cuenta que debe llamar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> en un <ph id="ph2">`finally`</ph> bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica, si se produce una excepción.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, and not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es negativo y no es igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objeto en el que se va a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait for the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa el período de tiempo que se va a esperar para adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>A value of –1 millisecond specifies an infinite wait.</source>
          <target state="translated">Un valor de –1 milisegundo especifica una espera infinita.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</source>
          <target state="translated">Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el período de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread acquires the lock; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso actual adquiere el bloqueo; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>If the value of the <ph id="ph1">`timeout`</ph> parameter converted to milliseconds equals –1, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</source>
          <target state="translated">Si el valor de la <ph id="ph1">`timeout`</ph> parámetro convertido a milisegundos es igual a -1, este método es equivalente a <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>If the value of <ph id="ph1">`timeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</source>
          <target state="translated">Si el valor de <ph id="ph1">`timeout`</ph> es igual a 0, este método es equivalente a <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> para bloquear objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>For details, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Para obtener más información, consulte el <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> tema de la clase.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor devuelto del método y ejecutan código en la sección crítica solo si su valor devuelto es <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">El siguiente fragmento de código muestra la trama usada para llamar a este método.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Tenga en cuenta que debe llamar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> en un <ph id="ph2">`finally`</ph> bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica, si se produce una excepción.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> in milliseconds is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> en milisegundos es negativo y no es igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1 milisegundos), o es superior a <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objeto en el que se va a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The number of milliseconds to wait for the lock.</source>
          <target state="translated">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Resultado del intento de adquirir el bloqueo, pasado por referencia.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La entrada debe ser <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El resultado es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se adquiere el bloqueo; en caso contrario, el resultado es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Intenta, durante el número especificado de milisegundos, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If the <ph id="ph1">`millisecondsTimeout`</ph> parameter equals <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, this method is equivalent to <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si el <ph id="ph1">`millisecondsTimeout`</ph> parámetro es igual a <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, este método es equivalente a <ph id="ph3">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> es igual a 0, este método es equivalente a <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el <ph id="ph1">`lockTaken`</ph> parámetro es <ph id="ph2">`false`</ph> una vez finalizado este método.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Esto permite que el programa determinar, en todos los casos, si es necesario liberar el bloqueo.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> para bloquear objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Para obtener más información, consulte el <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> tema de la clase.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de <ph id="ph1">`lockTaken`</ph> y ejecutar el código en la sección crítica solo si su valor es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">El siguiente fragmento de código muestra la trama usada para llamar a este método.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Tenga en cuenta que debe llamar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> en un <ph id="ph2">`finally`</ph> bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica, si se produce una excepción.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The following code shows the basic pattern for using the <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> method overload.</source>
          <target state="translated">El código siguiente muestra el patrón básico para el uso de la <ph id="ph1">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>This overload always sets the value of the variable that is passed to the <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic) <ph id="ph3">`lockTaken`</ph>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</source>
          <target state="translated">Esta sobrecarga siempre establece el valor de la variable que se pasa a la <ph id="ph1">`ref`</ph> parámetro (<ph id="ph2">`ByRef`</ph> en Visual Basic) <ph id="ph3">`lockTaken`</ph>, incluso si el método produce una excepción, por lo que el valor de la variable es una manera fiable para comprobar si el bloqueo tiene que ser publicado.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La entrada a <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, and not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es negativo y no es igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The object on which to acquire the lock.</source>
          <target state="translated">Objeto en el que se va a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The amount of time to wait for the lock.</source>
          <target state="translated">Tiempo que se va a esperar el bloqueo.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>A value of –1 millisecond specifies an infinite wait.</source>
          <target state="translated">Un valor de –1 milisegundo especifica una espera infinita.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The result of the attempt to acquire the lock, passed by reference.</source>
          <target state="translated">Resultado del intento de adquirir el bloqueo, pasado por referencia.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The input must be <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La entrada debe ser <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The output is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock is acquired; otherwise, the output is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El resultado es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se adquiere el bloqueo; en caso contrario, el resultado es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The output is set even if an exception occurs during the attempt to acquire the lock.</source>
          <target state="translated">El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</source>
          <target state="translated">Intenta, durante el periodo de tiempo indicado, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the value of the <ph id="ph1">`timeout`</ph> parameter converted to milliseconds equals –1, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si el valor de la <ph id="ph1">`timeout`</ph> parámetro convertido a milisegundos es igual a -1, este método es equivalente a <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the value of <ph id="ph1">`timeout`</ph> equals 0, this method is equivalent to <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Si el valor de <ph id="ph1">`timeout`</ph> es igual a 0, este método es equivalente a <ph id="ph2">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>If the lock was not taken because an exception was thrown, the variable specified for the <ph id="ph1">`lockTaken`</ph> parameter is <ph id="ph2">`false`</ph> after this method ends.</source>
          <target state="translated">Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el <ph id="ph1">`lockTaken`</ph> parámetro es <ph id="ph2">`false`</ph> una vez finalizado este método.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>This allows the program to determine, in all cases, whether it is necessary to release the lock.</source>
          <target state="translated">Esto permite que el programa determinar, en todos los casos, si es necesario liberar el bloqueo.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> para bloquear objetos (es decir, tipos de referencia), no tipos de valor.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.</source>
          <target state="translated">Para obtener más información, consulte el <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> tema de la clase.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>To ensure that the thread does not enter the critical section, you should examine the value of <ph id="ph1">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de <ph id="ph1">`lockTaken`</ph> y ejecutar el código en la sección crítica solo si su valor es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The following code fragment shows the pattern used to call this method.</source>
          <target state="translated">El siguiente fragmento de código muestra la trama usada para llamar a este método.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>Note that you should call <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id="ph2">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</source>
          <target state="translated">Tenga en cuenta que debe llamar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> en un <ph id="ph2">`finally`</ph> bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica, si se produce una excepción.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The input to <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">La entrada a <ph id="ph1">&lt;paramref name="lockTaken" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> in milliseconds is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> en milisegundos es negativo y no es igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1 milisegundos), o es superior a <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="T:System.Threading.Monitor">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The object on which to wait.</source>
          <target state="translated">Objeto en el que se va a esperar.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the call returned because the caller reacquired the lock for the specified object.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la llamada fue devuelta porque el llamador volvió a adquirir el bloqueo para el objeto especificado.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method does not return if the lock is not reacquired.</source>
          <target state="translated">Este método no devuelve ningún resultado si el bloqueo no vuelve a adquirirse.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para liberar el objeto para que otro subproceso puede obtener acceso a él.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Se llama a este método cuando el llamador debe esperar para que un cambio de estado que se producirá como resultado de las operaciones de otro subproceso.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Cuando un subproceso llama a <ph id="ph1">`Wait`</ph>, se libera el bloqueo en el objeto y entra en cola de espera del objeto.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">El siguiente subproceso de cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>All threads that call <ph id="ph1">`Wait`</ph> remain in the waiting queue until they receive a signal from <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, sent by the owner of the lock.</source>
          <target state="translated">Todos los subprocesos que llaman a <ph id="ph1">`Wait`</ph> permanecen en la cola de espera hasta que reciben una señal de <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, enviada por el propietario del bloqueo.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>If <ph id="ph1">`Pulse`</ph> is sent, only the thread at the head of the waiting queue is affected.</source>
          <target state="translated">Si <ph id="ph1">`Pulse`</ph> se envía, sólo el subproceso en el encabezado de la cola de espera se ve afectado.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>If <ph id="ph1">`PulseAll`</ph> is sent, all threads that are waiting for the object are affected.</source>
          <target state="translated">Si <ph id="ph1">`PulseAll`</ph> se envía, se ven afectados todos los subprocesos que están esperando el objeto.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</source>
          <target state="translated">Cuando se recibe la señal, uno o varios subprocesos deje la cola de espera y la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>A thread in the ready queue is permitted to reacquire the lock.</source>
          <target state="translated">Se permite un subproceso en la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This method returns when the calling thread reacquires the lock on the object.</source>
          <target state="translated">Este método devuelve cuando el subproceso que realiza la llamada vuelve a adquirir el bloqueo en el objeto.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Note that this method blocks indefinitely if the holder of the lock does not call <ph id="ph1">`Pulse`</ph> or <ph id="ph2">`PulseAll`</ph>.</source>
          <target state="translated">Tenga en cuenta que este método se bloquea indefinidamente si el propietario del bloqueo no llama a <ph id="ph1">`Pulse`</ph> o <ph id="ph2">`PulseAll`</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">El llamador ejecuta <ph id="ph1">`Wait`</ph> una vez, independientemente del número de veces que <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> se ha invocado para el objeto especificado.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">`Enter`</ph> on the object and invokes <ph id="ph3">`Exit`</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Conceptualmente, la <ph id="ph1">`Wait`</ph> método almacena el número de veces que el llamador ha invocado <ph id="ph2">`Enter`</ph> en el objeto e invoca <ph id="ph3">`Exit`</ph> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">El autor de la llamada, a continuación, se bloquea mientras espera a adquirir el objeto.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">`Enter`</ph> as many times as necessary to restore the saved <ph id="ph2">`Enter`</ph> count for the caller.</source>
          <target state="translated">Cuando el llamador vuelve a adquirir el bloqueo, el sistema llama <ph id="ph1">`Enter`</ph> tantas veces como sea necesario para restaurar el guardado <ph id="ph2">`Enter`</ph> recuento para el llamador.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Al llamar a <ph id="ph1">`Wait`</ph> libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos sobre otros objetos, estos bloqueos no se liberan.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que actualmente tiene el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que están esperando recibir notificación de un cambio en el estado del objeto.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, y <ph id="ph3">`Wait`</ph> métodos se deben invocar desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La sección Comentarios para el <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> método se explica qué ocurre si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> se llama cuando no hay ningún subproceso en espera.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">El subproceso que invoca a <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> se interrumpe más adelante desde el estado de espera.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Esto ocurre cuando otro subproceso llama al método <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de este subproceso.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The object on which to wait.</source>
          <target state="translated">Objeto en el que se va a esperar.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The number of milliseconds to wait before the thread enters the ready queue.</source>
          <target state="translated">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el <ph id="ph1">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para liberar el objeto para que otro subproceso puede obtener acceso a él.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Se llama a este método cuando el llamador debe esperar para que un cambio de estado que se producirá como resultado de las operaciones de otro subproceso.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin antes de llamar a la <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">También se desplaza el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos que estén antes en la cola de espera, por lo que puede volver a adquirir el bloqueo antes.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">El subproceso puede probar el valor devuelto de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método para determinar si vuelven a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que han producido que entre en espera, y si es necesario llamada la <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> nuevo al método.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Cuando un subproceso llama a <ph id="ph1">`Wait`</ph>, se libera el bloqueo en el objeto y entra en cola de espera del objeto.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">El siguiente subproceso de cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">El subproceso que invocó <ph id="ph1">`Wait`</ph> permanece en la cola de espera hasta que se invoca un subproceso que tiene el bloqueo de <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo, se invoca <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>However, if <ph id="ph1">`millisecondsTimeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Sin embargo, si <ph id="ph1">`millisecondsTimeout`</ph> transcurre antes de que otro subproceso llama a este objeto <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> se especifica para el <ph id="ph2">`millisecondsTimeout`</ph> parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> es igual a 0, el subproceso que llama <ph id="ph2">`Wait`</ph> libera el bloqueo y, a continuación, inmediatamente después entra en la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">El llamador ejecuta <ph id="ph1">`Wait`</ph> una vez, independientemente del número de veces que <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> se ha invocado para el objeto especificado.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Conceptualmente, la <ph id="ph1">`Wait`</ph> método almacena el número de veces que el llamador ha invocado <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> en el objeto e invoca <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">El autor de la llamada, a continuación, se bloquea mientras espera a adquirir el objeto.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Cuando el llamador vuelve a adquirir el bloqueo, el sistema llama <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> tantas veces como sea necesario para restaurar el guardado <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> recuento para el llamador.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Al llamar a <ph id="ph1">`Wait`</ph> libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos sobre otros objetos, estos bloqueos no se liberan.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que actualmente tiene el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que están esperando recibir notificación de un cambio en el estado del objeto.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, y <ph id="ph3">`Wait`</ph> métodos se deben invocar desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La sección Comentarios para el <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> método se explica qué ocurre si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> se llama cuando no hay ningún subproceso en espera.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">El subproceso que invoca a <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> se interrumpe más adelante desde el estado de espera.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Esto ocurre cuando otro subproceso llama al método <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de este subproceso.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
          <source>The value of the <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter is negative, and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es negativo, y no igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The object on which to wait.</source>
          <target state="translated">Objeto en el que se va a esperar.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait before the thread enters the ready queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el <ph id="ph1">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para liberar el objeto para que otro subproceso puede obtener acceso a él.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Se llama a este método cuando el llamador debe esperar para que un cambio de estado que se producirá como resultado de las operaciones de otro subproceso.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin antes de llamar a la <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">También se desplaza el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos que estén antes en la cola de espera, por lo que puede volver a adquirir el bloqueo antes.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">El subproceso puede probar el valor devuelto de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método para determinar si vuelven a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que han producido que entre en espera, y si es necesario llamada la <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> nuevo al método.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.</source>
          <target state="translated">Cuando un subproceso llama a <ph id="ph1">`Wait`</ph>, se libera el bloqueo en el objeto y entra en cola de espera del objeto.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</source>
          <target state="translated">El siguiente subproceso de cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">El subproceso que invocó <ph id="ph1">`Wait`</ph> permanece en la cola de espera hasta que se invoca un subproceso que tiene el bloqueo de <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo, se invoca <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>However, if <ph id="ph1">`timeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Sin embargo, si <ph id="ph1">`timeout`</ph> transcurre antes de que otro subproceso llama a este objeto <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> representing –1 millisecond is specified for the <ph id="ph2">`timeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> que representa-1 milisegundo se especifica para el <ph id="ph2">`timeout`</ph> parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 milliseconds, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> es 0 milisegundos, el subproceso que llama <ph id="ph2">`Wait`</ph> libera el bloqueo y, a continuación, inmediatamente después entra en la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">El llamador ejecuta <ph id="ph1">`Wait`</ph> una vez, independientemente del número de veces que <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> se ha invocado para el objeto especificado.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Conceptualmente, la <ph id="ph1">`Wait`</ph> método almacena el número de veces que el llamador ha invocado <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> en el objeto e invoca <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">El autor de la llamada, a continuación, se bloquea mientras espera a adquirir el objeto.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Cuando el llamador vuelve a adquirir el bloqueo, el sistema llama <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> tantas veces como sea necesario para restaurar el guardado <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> recuento para el llamador.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Al llamar a <ph id="ph1">`Wait`</ph> libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos sobre otros objetos, estos bloqueos no se liberan.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que actualmente tiene el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que están esperando recibir notificación de un cambio en el estado del objeto.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, y <ph id="ph3">`Wait`</ph> métodos se deben invocar desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La sección Comentarios para el <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> método se explica qué ocurre si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> se llama cuando no hay ningún subproceso en espera.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The calling thread does not own the lock for the specified object.</source>
          <target state="translated">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">El subproceso que invoca a <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> se interrumpe más adelante desde el estado de espera.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Esto ocurre cuando otro subproceso llama al método <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de este subproceso.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
          <source>The value of the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter in milliseconds is negative and does not represent <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> en milisegundos es negativo y no representa <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 milisegundo) o es mayor que <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The object on which to wait.</source>
          <target state="translated">Objeto en el que se va a esperar.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The number of milliseconds to wait before the thread enters the ready queue.</source>
          <target state="translated">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</source>
          <target state="translated">Este método también especifica si el dominio de sincronización del contexto (si se trata de un contexto sincronizado) sale antes de la espera y vuelve a adquirir el bloqueo después.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el <ph id="ph1">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para liberar el objeto para que otro subproceso puede obtener acceso a él.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Se llama a este método cuando el llamador debe esperar para que un cambio de estado que se producirá como resultado de las operaciones de otro subproceso.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin antes de llamar a la <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">También se desplaza el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos que estén antes en la cola de espera, por lo que puede volver a adquirir el bloqueo antes.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">El subproceso puede probar el valor devuelto de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método para determinar si vuelven a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que han producido que entre en espera, y si es necesario llamada la <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> nuevo al método.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock and enters the waiting queue.</source>
          <target state="translated">Cuando un subproceso llama a <ph id="ph1">`Wait`</ph>, se libera el bloqueo y entra en la cola de espera.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</source>
          <target state="translated">En este momento, el siguiente subproceso de la cola de subprocesos listos (si existe) se permite controlar el bloqueo.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">El subproceso que invocó <ph id="ph1">`Wait`</ph> permanece en la cola de espera hasta que se invoca un subproceso que tiene el bloqueo de <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo, se invoca <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>However, if <ph id="ph1">`millisecondsTimeout`</ph> elapses before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Sin embargo, si <ph id="ph1">`millisecondsTimeout`</ph> transcurre antes de que otro subproceso llama a este objeto <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> se especifica para el <ph id="ph2">`millisecondsTimeout`</ph> parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> equals 0, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Si <ph id="ph1">`millisecondsTimeout`</ph> es igual a 0, el subproceso que llama <ph id="ph2">`Wait`</ph> libera el bloqueo y, a continuación, inmediatamente después entra en la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">El llamador ejecuta <ph id="ph1">`Wait`</ph> una vez, independientemente del número de veces que <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> se ha invocado para el objeto especificado.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Conceptualmente, la <ph id="ph1">`Wait`</ph> método almacena el número de veces que el llamador ha invocado <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> en el objeto e invoca <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">El autor de la llamada, a continuación, se bloquea mientras espera a adquirir el objeto.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Cuando el llamador vuelve a adquirir el bloqueo, el sistema llama <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> tantas veces como sea necesario para restaurar el guardado <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> recuento para el llamador.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Al llamar a <ph id="ph1">`Wait`</ph> libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos sobre otros objetos, estos bloqueos no se liberan.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que actualmente tiene el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que están esperando recibir notificación de un cambio en el estado del objeto.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, y <ph id="ph3">`Wait`</ph> métodos se deben invocar desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La sección Comentarios para el <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> método se explica qué ocurre si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> se llama cuando no hay ningún subproceso en espera.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Notas sobre la salida del contexto</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The<ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">El<ph id="ph1">`exitContext`</ph> parámetro no tiene ningún efecto a menos que el <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método se llama desde dentro de un contexto administrado no predeterminado.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>Even if you are currently executing a method on a class that is not derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, como <ph id="ph2">&lt;xref:System.String&gt;</ph>, puede estar en un contexto no predeterminado si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> en la pila en el dominio de aplicación actual.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method.</source>
          <target state="translated">Cuando el código se ejecuta en un contexto no predeterminado, especificar <ph id="ph1">`true`</ph> para <ph id="ph2">`exitContext`</ph> hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>It returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method completes.</source>
          <target state="translated">Se devuelve al contexto no predeterminado original después de la llamada a la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método se completa.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This can be useful when the context-bound class has the <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute applied.</source>
          <target state="translated">Esto puede ser útil cuando la clase enlazadas a un contexto tiene la <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> atributo aplicado.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si el código de la pila de llamadas de un miembro llama el <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método y especifica <ph id="ph2">`true`</ph> para <ph id="ph3">`exitContext`</ph>, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is not invoked from within a synchronized block of code.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> no se invoca desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The thread that invokes <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is later interrupted from the waiting state.</source>
          <target state="translated">El subproceso que invoca a <ph id="ph1">&lt;see langword="Wait" /&gt;</ph> se interrumpe más adelante desde el estado de espera.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Esto ocurre cuando otro subproceso llama al método <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de este subproceso.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
          <source>The value of the <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter is negative, and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es negativo, y no igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The object on which to wait.</source>
          <target state="translated">Objeto en el que se va a esperar.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to wait before the thread enters the ready queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Releases the lock on an object and blocks the current thread until it reacquires the lock.</source>
          <target state="translated">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If the specified time-out interval elapses, the thread enters the ready queue.</source>
          <target state="translated">Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</source>
          <target state="translated">De modo opcional, sale del dominio de sincronización del contexto sincronizado antes de la espera y vuelve a adquirir el dominio después.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the lock was reacquired before the specified time elapsed; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the lock was reacquired after the specified time elapsed.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The method does not return until the lock is reacquired.</source>
          <target state="translated">El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This method does not return until it reacquires an exclusive lock on the <ph id="ph1">`obj`</ph> parameter.</source>
          <target state="translated">Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el <ph id="ph1">`obj`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</source>
          <target state="translated">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para liberar el objeto para que otro subproceso puede obtener acceso a él.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller is blocked while waiting to reacquire the lock.</source>
          <target state="translated">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</source>
          <target state="translated">Se llama a este método cuando el llamador debe esperar para que un cambio de estado que se producirá como resultado de las operaciones de otro subproceso.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.</source>
          <target state="translated">El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin antes de llamar a la <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</source>
          <target state="translated">También se desplaza el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos que estén antes en la cola de espera, por lo que puede volver a adquirir el bloqueo antes.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread can test the return value of the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.</source>
          <target state="translated">El subproceso puede probar el valor devuelto de la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método para determinar si vuelven a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que han producido que entre en espera, y si es necesario llamada la <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> nuevo al método.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When a thread calls <ph id="ph1">`Wait`</ph>, it releases the lock and enters the waiting queue.</source>
          <target state="translated">Cuando un subproceso llama a <ph id="ph1">`Wait`</ph>, se libera el bloqueo y entra en la cola de espera.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</source>
          <target state="translated">En este momento, el siguiente subproceso de la cola de subprocesos listos (si existe) se permite controlar el bloqueo.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that invoked <ph id="ph1">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</source>
          <target state="translated">El subproceso que invocó <ph id="ph1">`Wait`</ph> permanece en la cola de espera hasta que se invoca un subproceso que tiene el bloqueo de <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo, se invoca <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>However, if <ph id="ph1">`timeout`</ph> milliseconds elapse before another thread invokes this object's <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.</source>
          <target state="translated">Sin embargo, si <ph id="ph1">`timeout`</ph> milisegundos transcurran antes de que otro subproceso llama a este objeto <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If a <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> representing -1 millisecond is specified for the <ph id="ph2">`timeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> que representa-1 milisegundo se especifica para el <ph id="ph2">`timeout`</ph> parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <ph id="ph3">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> o <ph id="ph4">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 milliseconds, the thread that calls <ph id="ph2">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.</source>
          <target state="translated">Si <ph id="ph1">`timeout`</ph> es 0 milisegundos, el subproceso que llama <ph id="ph2">`Wait`</ph> libera el bloqueo y, a continuación, inmediatamente después entra en la cola de subprocesos listos para volver a adquirir el bloqueo.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller executes <ph id="ph1">`Wait`</ph> once, regardless of the number of times <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.</source>
          <target state="translated">El llamador ejecuta <ph id="ph1">`Wait`</ph> una vez, independientemente del número de veces que <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> se ha invocado para el objeto especificado.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Conceptually, the <ph id="ph1">`Wait`</ph> method stores the number of times the caller invoked <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.</source>
          <target state="translated">Conceptualmente, la <ph id="ph1">`Wait`</ph> método almacena el número de veces que el llamador ha invocado <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> en el objeto e invoca <ph id="ph3">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The caller then blocks while waiting to reacquire the object.</source>
          <target state="translated">El autor de la llamada, a continuación, se bloquea mientras espera a adquirir el objeto.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When the caller reacquires the lock, the system calls <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.</source>
          <target state="translated">Cuando el llamador vuelve a adquirir el bloqueo, el sistema llama <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> tantas veces como sea necesario para restaurar el guardado <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> recuento para el llamador.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Calling <ph id="ph1">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</source>
          <target state="translated">Al llamar a <ph id="ph1">`Wait`</ph> libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos sobre otros objetos, estos bloqueos no se liberan.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</source>
          <target state="translated">Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que actualmente tiene el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que están esperando recibir notificación de un cambio en el estado del objeto.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id="ph3">`Wait`</ph> methods must be invoked from within a synchronized block of code.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, y <ph id="ph3">`Wait`</ph> métodos se deben invocar desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The remarks for the <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.</source>
          <target state="translated">La sección Comentarios para el <ph id="ph1">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> método se explica qué ocurre si <ph id="ph2">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> se llama cuando no hay ningún subproceso en espera.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Notes on Exiting the Context</source>
          <target state="translated">Notas sobre la salida del contexto</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The<ph id="ph1">`exitContext`</ph> parameter has no effect unless the <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called from inside a nondefault managed context.</source>
          <target state="translated">El<ph id="ph1">`exitContext`</ph> parámetro no tiene ningún efecto a menos que el <ph id="ph2">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método se llama desde dentro de un contexto administrado no predeterminado.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This can happen if your thread is inside a call to an instance of a class derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>Even if you are currently executing a method on a class that is not derived from <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id="ph2">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.</source>
          <target state="translated">Incluso si está ejecutando actualmente un método en una clase que no se deriva de <ph id="ph1">&lt;xref:System.ContextBoundObject&gt;</ph>, como <ph id="ph2">&lt;xref:System.String&gt;</ph>, puede estar en un contexto no predeterminado si un <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph> en la pila en el dominio de aplicación actual.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When your code is executing in a nondefault context, specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method.</source>
          <target state="translated">Cuando el código se ejecuta en un contexto no predeterminado, especificar <ph id="ph1">`true`</ph> para <ph id="ph2">`exitContext`</ph> hace que el subproceso salga del contexto administrado no predeterminado (es decir, pase al contexto predeterminado) antes de ejecutar el <ph id="ph3">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>It returns to the original nondefault context after the call to the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method completes.</source>
          <target state="translated">Se devuelve al contexto no predeterminado original después de la llamada a la <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método se completa.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This can be useful when the context-bound class has the <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute applied.</source>
          <target state="translated">Esto puede ser útil cuando la clase enlazadas a un contexto tiene la <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> atributo aplicado.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</source>
          <target state="translated">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es el cuerpo completo del código de la clase.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>If code in the call stack of a member calls the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method and specifies <ph id="ph2">`true`</ph> for <ph id="ph3">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</source>
          <target state="translated">Si el código de la pila de llamadas de un miembro llama el <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método y especifica <ph id="ph2">`true`</ph> para <ph id="ph3">`exitContext`</ph>, el subproceso sale del dominio de sincronización, permitiendo la continuación un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>When the <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> método vuelve, el subproceso que realiza la llamada debe esperar para volver a escribir el dominio de sincronización.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> is not invoked from within a synchronized block of code.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Wait" /&gt;</ph> no se invoca desde dentro de un bloque de código sincronizado.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The thread that invokes Wait is later interrupted from the waiting state.</source>
          <target state="translated">El subproceso que invoca a Wait se interrumpe más adelante desde el estado de espera.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>This happens when another thread calls this thread's <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> method.</source>
          <target state="translated">Esto ocurre cuando otro subproceso llama al método <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Interrupt" /&gt;</ph> de este subproceso.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is negative and does not represent <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (–1 millisecond), or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es negativo y no representa <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (– 1 milisegundo), o es mayor que <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>