<Type Name="Timer" FullName="System.Threading.Timer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7a10d27fe59488846e0b5c3bb6556dbb25ec3701" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58453662" /></Metadata><TypeSignature Language="C#" Value="public sealed class Timer : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Timer extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Timer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Timer&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Timer</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-uwp-10.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un mecanismo para ejecutar un método en un subproceso del grupo de subprocesos en intervalos especificados. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use un <xref:System.Threading.TimerCallback> delegado para especificar el método que desee el <xref:System.Threading.Timer> para ejecutar. La firma de la <xref:System.Threading.TimerCallback> delegado es:  
  
```csharp  
void TimerCallback(Object state)  
```  
  
```cpp  
void TimerCallback(Object state)  
```  
  
```vb  
Sub TimerCallback(state As Object)  
```  
  
 El delegado de temporizador se especifica cuando se construye el temporizador y no se puede cambiar. El método no se ejecuta en el subproceso que creó el temporizador; ejecuta en un <xref:System.Threading.ThreadPool> subproceso proporcionado por el sistema.  
  
> [!TIP]
> .NET incluye cuatro clases denominadas `Timer`, cada uno de los que ofrece una funcionalidad diferente:  
>
> - <xref:System.Timers.Timer?displayProperty=nameWithType>, que activa un evento y el código ejecuta en uno o más eventos receptores a intervalos regulares. La clase está diseñada para usarla como basada en un servidor o componente del servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no está visible en tiempo de ejecución.
> - <xref:System.Threading.Timer?displayProperty=nameWithType>, que ejecuta un método de devolución de llamada única en un subproceso de grupo a intervalos regulares. Se define el método de devolución de llamada cuando el temporizador se crea una instancia y no se puede cambiar. Al igual que el <xref:System.Timers.Timer?displayProperty=nameWithType> (clase), esta clase está pensada para su uso como un componente basado en servidor o servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no está visible en tiempo de ejecución.
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Solo en .NET framework,) un componente de Windows Forms que se activa un evento y el código se ejecuta en uno o varios receptores de eventos a intervalos regulares. El componente no tiene ninguna interfaz de usuario y está diseñado para su uso en un entorno de un solo subproceso; ejecuta en el subproceso de interfaz de usuario.
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Solo en .NET framework,) un componente de ASP.NET que realiza el postback de página web asincrónicas o sincrónicas a intervalos regulares.
  
 Cuando se crea un temporizador, puede especificar una cantidad de tiempo de espera antes de la primera ejecución del método (tiempo de expiración) y una cantidad de tiempo de espera entre las ejecuciones posteriores (período). La <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema. Esto significa que si el período es menor que la resolución del reloj del sistema, el <xref:System.Threading.TimerCallback> delegado se ejecutará a intervalos definidos por la resolución del reloj del sistema, que es aproximadamente de 15 milisegundos en los sistemas Windows 7 y Windows 8. Puede cambiar el debido tiempo y período o deshabilitar el temporizador, utilizando el <xref:System.Threading.Timer.Change%2A> método.  
  
> [!NOTE]
>  Siempre y cuando usas una <xref:System.Threading.Timer>, debe mantener una referencia a él. Al igual que con cualquier objeto administrado, un <xref:System.Threading.Timer> está sujeta a la colección de elementos no utilizados cuando no hay ninguna referencia a ella. El hecho de que un <xref:System.Threading.Timer> está aún activo no impide que se están recopilando.  
  
 Cuando ya no se necesita un temporizador, utilice el <xref:System.Threading.Timer.Dispose%2A> método para liberar los recursos mantenidos por el temporizador. Tenga en cuenta que las devoluciones de llamada pueden producir tras el <xref:System.Threading.Timer.Dispose> sobrecarga del método se ha llamado, dado que el temporizador pone en cola devoluciones de llamada para su ejecución por subprocesos de grupo. Puede usar el <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga del método para esperar hasta que se completen todas las devoluciones de llamada.  
  
 El método de devolución de llamada ejecutado por el temporizador debe ser reentrante, porque se llama en <xref:System.Threading.ThreadPool> subprocesos. La devolución de llamada se puede ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar la devolución de llamada, o si todos los subprocesos del grupo de subprocesos están en uso y la devolución de llamada se pone en cola varias veces.  
  
> [!NOTE]
>  <xref:System.Threading.Timer?displayProperty=nameWithType> es un temporizador sencillo y ligero que utiliza métodos de devolución de llamada y se proporciona mediante subprocesos de grupo. No se recomienda para su uso con Windows Forms, ya que las devoluciones de llamada no se producen en el subproceso de interfaz de usuario. <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> es una opción mejor para su uso con Windows Forms. Para la funcionalidad del temporizador basado en servidor, podría usar <xref:System.Timers.Timer?displayProperty=nameWithType>, que genera eventos y tiene características adicionales.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `StatusChecker` clase que incluya un `CheckStatus` método cuya firma es el mismo como el <xref:System.Threading.TimerCallback> delegar. El `state` argumento de la `CheckStatus` método es un <xref:System.Threading.AutoResetEvent> objeto que se utiliza para sincronizar el subproceso de la aplicación y el subproceso del grupo que se ejecuta el delegado de devolución de llamada. La `StatusChecker` clase también incluye dos variables de estado:  
  
 `invokeCount`  
 Indica el número de veces que se ha invocado el método de devolución de llamada.  
  
 `maxCount`  
 Determina el número máximo de veces que se debe invocar el método de devolución de llamada.  
  
 El subproceso de la aplicación crea el temporizador, que espera un segundo y, a continuación, ejecuta el `CheckStatus` el método de devolución de llamada cada 250 milisegundos. El subproceso de la aplicación, a continuación, se bloquea hasta que el <xref:System.Threading.AutoResetEvent> se señaliza el objeto. Cuando el `CheckStatus` ejecuta el método de devolución de llamada `maxCount` veces, llama a la `AutoResetEvent.Set` método para establecer el estado de la <xref:System.Threading.AutoResetEvent> objeto marcado. La primera vez que esto sucede, el subproceso de la aplicación llama a la <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> método para que el método de devolución de llamada ejecuta ahora cada medio segundo. Una vez más se bloquea hasta que el <xref:System.Threading.AutoResetEvent> se señaliza el objeto. Cuando esto sucede, se destruye el temporizador mediante una llamada a su <xref:System.Threading.Timer.Dispose%2A> método y la aplicación finaliza.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.Threading.TimerCallback" />
    <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see langword="Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback -&gt; System.Threading.Timer" Usage="new System.Threading.Timer callback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.Threading.TimerCallback" /> que representa un método que se debe ejecutar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Timer" /> con un período y un tiempo límite infinitos, utilizando el objeto <see cref="T:System.Threading.Timer" /> recién creado como objeto de estado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este constructor cuando desee utilizar el <xref:System.Threading.Timer> propio objeto como objeto de estado. Después de crear el temporizador, utilice el <xref:System.Threading.Timer.Change%2A> método para establecer el intervalo y tiempo de expiración.  
  
 Este constructor especifica un límite infinitos tiempo antes de la primera devolución de llamada y un intervalo infinito entre devoluciones de llamada, con el fin de evitar que la primera devolución de llamada que se producen antes de la <xref:System.Threading.Timer> objeto se asigna al objeto de estado.  
  
 El método especificado para `callback` debe ser reentrante, porque se llama en <xref:System.Threading.ThreadPool> subprocesos. El método se puede ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo temporizador, utilizando el propio temporizador como objeto de estado. El <xref:System.Threading.Timer.Change%2A> método se utiliza para iniciar el temporizador. Cuando se produzca la devolución de llamada del temporizador, se usa el objeto de estado para desactivar el temporizador.  
  
 [!code-csharp[TimerSelfCtor#1](~/samples/snippets/csharp/VS_Snippets_Misc/timerSelfCtor/CS/source.cs#1)]
 [!code-vb[TimerSelfCtor#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/timerSelfCtor/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Integer, period As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, int dueTime, int period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int * int -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.Threading.TimerCallback" /> que representa un método que se debe ejecutar.</param>
        <param name="state">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <see langword="null" />.</param>
        <param name="dueTime">Período de tiempo de retraso, en milisegundos, antes de que se invoque a <paramref name="callback" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que se inicie el temporizador. Especifique cero (0) para iniciar inmediatamente el temporizador.</param>
        <param name="period">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <paramref name="callback" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</param>
        <summary>Inicializa una nueva instancia de la clase <see langword="Timer" /> utilizando un entero de 32 bits con signo para medir los intervalos de tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El delegado especificado por el `callback` parámetro se invoca una vez después de `dueTime` transcurre y, a partir de entonces cada vez el `period` intervalo finaliza el tiempo.  
  
 Si `dueTime` es cero (0), `callback` se invoca de inmediato. Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` no se invoca; el temporizador está deshabilitado, pero se puede volver a habilitar mediante una llamada a la <xref:System.Threading.Timer.Change%2A> método.  
  
 Dado que el <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente de 15 milisegundos en los sistemas Windows 7 y Windows 8, el `callback` delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si `period`es menor que la resolución del reloj del sistema. Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` se invoca una vez; el comportamiento del temporizador periódico está deshabilitado, pero se puede volver a habilitar mediante el <xref:System.Threading.Timer.Change%2A> método.  
  
 El método especificado para `callback` debe ser reentrante, porque se llama en <xref:System.Threading.ThreadPool> subprocesos. El método se puede ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear un `TimerCallback` delegado e inicializar una nueva instancia de la `Timer` clase.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="callback" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Long, period As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, long dueTime, long period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int64 * int64 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="dueTime" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="period" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.Threading.TimerCallback" /> que representa un método que se debe ejecutar.</param>
        <param name="state">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <see langword="null" />.</param>
        <param name="dueTime">Período de tiempo de retraso, en milisegundos, antes de que se invoque a <paramref name="callback" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que se inicie el temporizador. Especifique cero (0) para iniciar inmediatamente el temporizador.</param>
        <param name="period">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <paramref name="callback" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</param>
        <summary>Inicializa una nueva instancia de la clase <see langword="Timer" /> utilizando un entero de 64 bits con signo para medir los intervalos de tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El delegado especificado por el `callback` parámetro se invoca una vez después de `dueTime` transcurre y, a partir de entonces cada vez el `period` intervalo finaliza el tiempo.  
  
 Si `dueTime` es cero (0), `callback` se invoca de inmediato. Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` no se invoca; el temporizador está deshabilitado, pero se puede volver a habilitar mediante una llamada a la <xref:System.Threading.Timer.Change%2A> método.  
  
 Dado que el <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente de 15 milisegundos en los sistemas Windows 7 y Windows 8, el `callback` delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si `period`es menor que la resolución del reloj del sistema. Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` se invoca una vez; el comportamiento del temporizador periódico está deshabilitado, pero se puede volver a habilitar mediante el <xref:System.Threading.Timer.Change%2A> método.  
  
 El método especificado para `callback` debe ser reentrante, porque se llama en <xref:System.Threading.ThreadPool> subprocesos. El método se puede ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es mayor que 4294967294.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As TimeSpan, period As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * TimeSpan * TimeSpan -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado que representa un método que se va a ejecutar.</param>
        <param name="state">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <see langword="null" />.</param>
        <param name="dueTime">Cantidad de tiempo de espera antes de que el parámetro <paramref name="callback" /> invoque a sus métodos. Especifique menos un (-1) milisegundo para evitar que se inicie el temporizador. Especifique cero (0) para iniciar inmediatamente el temporizador.</param>
        <param name="period">Intervalo de tiempo entre las distintas invocaciones de los métodos a los que hace referencia <paramref name="callback" />. Especifique menos un (-1) milisegundo para deshabilitar la señalización periódica.</param>
        <summary>Inicializa una nueva instancia de la clase <see langword="Timer" />, utilizando valores de <see cref="T:System.TimeSpan" /> para medir los intervalos de tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El delegado especificado por el `callback` parámetro se invoca una vez después de `dueTime` transcurre y, a partir de entonces cada vez el `period` intervalo finaliza el tiempo.  
  
 Si `dueTime` es cero (0), `callback` se invoca de inmediato. Si `dueTime` es menos uno (-1) milisegundo, `callback` no se invoca; el temporizador está deshabilitado, pero se puede volver a habilitar mediante una llamada a la <xref:System.Threading.Timer.Change%2A> método.  
  
 Dado que el <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente de 15 milisegundos en los sistemas Windows 7 y Windows 8, el `callback` delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si `period`es menor que la resolución del reloj del sistema. Si `period` es cero (0) o menos (-1) milisegundo y `dueTime` es positivo, `callback` se invoca una vez; el comportamiento del temporizador periódico está deshabilitado, pero se puede volver a habilitar mediante el <xref:System.Threading.Timer.Change%2A> método.  
  
 El método especificado para `callback` debe ser reentrante, porque se llama en <xref:System.Threading.ThreadPool> subprocesos. El método se puede ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear un `TimerCallback` delegado e inicializar una nueva instancia de la `Timer` clase.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de milisegundos del valor de <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />, o es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="callback" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As UInteger, period As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * uint32 * uint32 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="dueTime" Type="System.UInt32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="period" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado que representa un método que se va a ejecutar.</param>
        <param name="state">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <see langword="null" />.</param>
        <param name="dueTime">Período de tiempo de retraso, en milisegundos, antes de que se invoque a <paramref name="callback" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que se inicie el temporizador. Especifique cero (0) para iniciar inmediatamente el temporizador.</param>
        <param name="period">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <paramref name="callback" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</param>
        <summary>Inicializa una nueva instancia de la clase <see langword="Timer" /> utilizando un entero de 32 bits sin signo para medir los intervalos de tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El delegado especificado por el `callback` parámetro se invoca una vez después de `dueTime` transcurre y, a partir de entonces cada vez el `period` intervalo finaliza el tiempo.  
  
 Si `dueTime` es cero (0), `callback` se invoca de inmediato. Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` no se invoca; el temporizador está deshabilitado, pero se puede volver a habilitar mediante una llamada a la <xref:System.Threading.Timer.Change%2A> método.  
  
 Dado que el <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente de 15 milisegundos en los sistemas Windows 7 y Windows 8, el `callback` delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si `period`es menor que la resolución del reloj del sistema. Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` se invoca una vez; el comportamiento del temporizador periódico está deshabilitado, pero se puede volver a habilitar mediante el <xref:System.Threading.Timer.Change%2A> método.  
  
 El método especificado para `callback` debe ser reentrante, porque se llama en <xref:System.Threading.ThreadPool> subprocesos. El método se puede ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="callback" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Change">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Integer, period As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(int dueTime, int period);" />
      <MemberSignature Language="F#" Value="member this.Change : int * int -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dueTime">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <see cref="T:System.Threading.Timer" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que el temporizador se reinicie. Especifique cero (0) para reiniciar inmediatamente el temporizador.</param>
        <param name="period">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <see cref="T:System.Threading.Timer" />, en milisegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</param>
        <summary>Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 32 bits con signo para medir los intervalos de tiempo.</summary>
        <returns><see langword="true" /> si el temporizador se actualizó correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se invoca el método de devolución de llamada una vez después de `dueTime` transcurre y, a partir de entonces cada vez el intervalo de tiempo especificado por `period` transcurre.  
  
 Si `dueTime` es cero (0), el método de devolución de llamada se invoca inmediatamente. Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `dueTime`.  
  
 Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, el método de devolución de llamada se invoca una vez; se deshabilita el comportamiento del temporizador periódico, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `period`.  
  
 El <xref:System.Threading.Timer.Change%2A> método puede llamarse desde el <xref:System.Threading.TimerCallback> delegar.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo iniciar un `Timer` y, después de un número establecido de llamadas, cambiar su período.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Timer" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Long, period As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(long dueTime, long period);" />
      <MemberSignature Language="F#" Value="member this.Change : int64 * int64 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="period" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dueTime">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <see cref="T:System.Threading.Timer" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que el temporizador se reinicie. Especifique cero (0) para reiniciar inmediatamente el temporizador.</param>
        <param name="period">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <see cref="T:System.Threading.Timer" />, en milisegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</param>
        <summary>Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 64 bits con signo para medir los intervalos de tiempo.</summary>
        <returns><see langword="true" /> si el temporizador se actualizó correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se invoca el método de devolución de llamada una vez después de `dueTime` transcurre y, a partir de entonces cada vez el intervalo de tiempo especificado por `period` transcurre.  
  
 Si `dueTime` es cero (0), el método de devolución de llamada se invoca inmediatamente. Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `dueTime`.  
  
 Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, el método de devolución de llamada se invoca una vez; se deshabilita el comportamiento del temporizador periódico, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `period`.  
  
 El <xref:System.Threading.Timer.Change%2A> método puede llamarse desde el <xref:System.Threading.TimerCallback> delegar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Timer" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es menor que -1.</exception>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es mayor que 4294967294.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As TimeSpan, period As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="member this.Change : TimeSpan * TimeSpan -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dueTime"><see cref="T:System.TimeSpan" /> que representa el período tiempo de retraso antes de que se llame al método de devolución de llamada que se especificó cuando se creó <see cref="T:System.Threading.Timer" />. Especifique menos un (-1) milisegundo para evitar que se reinicie el temporizador. Especifique cero (0) para reiniciar inmediatamente el temporizador.</param>
        <param name="period">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <see cref="T:System.Threading.Timer" />. Especifique menos un (-1) milisegundo para deshabilitar la señalización periódica.</param>
        <summary>Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones del método para un temporizador, utilizando los valores de <see cref="T:System.TimeSpan" /> para medir los intervalos de tiempo.</summary>
        <returns><see langword="true" /> si el temporizador se actualizó correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se invoca el método de devolución de llamada una vez después de `dueTime` transcurre y, a partir de entonces cada vez el intervalo de tiempo especificado por `period` transcurre.  
  
 Si `dueTime` es cero (0), el método de devolución de llamada se invoca inmediatamente. Si `dueTime` es menos uno (-1) milisegundo, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `dueTime`.  
  
 Si `period` es cero (0) o negativo (-1) milisegundo, y `dueTime` es positivo, se invoca el método de devolución de llamada una vez; el comportamiento del temporizador periódico está deshabilitado, pero se puede volver a habilitar mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor mayor que cero para `period`.  
  
 El <xref:System.Threading.Timer.Change%2A> método puede llamarse desde el <xref:System.Threading.TimerCallback> delegar.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo iniciar un `Timer` y, después de un número establecido de llamadas, cambiar su período.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Timer" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es menor que -1, en milisegundos.</exception>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es mayor que 4294967294, en milisegundos.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As UInteger, period As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="member this.Change : uint32 * uint32 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.UInt32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="period" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dueTime">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <see cref="T:System.Threading.Timer" />. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que el temporizador se reinicie. Especifique cero (0) para reiniciar inmediatamente el temporizador.</param>
        <param name="period">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <see cref="T:System.Threading.Timer" />, en milisegundos. Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</param>
        <summary>Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 32 bits sin signo para medir los intervalos de tiempo.</summary>
        <returns><see langword="true" /> si el temporizador se actualizó correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se invoca el método de devolución de llamada una vez después de `dueTime` transcurre y, a partir de entonces cada vez el intervalo de tiempo especificado por `period` transcurre.  
  
 Si `dueTime` es cero (0), el método de devolución de llamada se invoca inmediatamente. Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `dueTime`.  
  
 Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, el método de devolución de llamada se invoca una vez; se deshabilita el comportamiento del temporizador periódico, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `period`.  
  
 El <xref:System.Threading.Timer.Change%2A> método puede llamarse desde el <xref:System.Threading.TimerCallback> delegar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Timer" /> ya se ha eliminado.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos utilizados por la instancia de <see cref="T:System.Threading.Timer" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="timer.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por la instancia de <see cref="T:System.Threading.Timer" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `Dispose` permite a los recursos utilizados por el <xref:System.Threading.Timer> que reasignarse para otros fines. Para obtener más información acerca de `Dispose`, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).  
  
> [!NOTE]
>  Las devoluciones de llamada se pueden producir tras el <xref:System.Threading.Timer.Dispose> sobrecarga del método se ha llamado, dado que el temporizador pone en cola devoluciones de llamada para su ejecución por subprocesos de grupo. Puede usar el <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga del método para esperar hasta que se completen todas las devoluciones de llamada.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo liberar los recursos mantenidos por un `Timer`.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public bool Dispose (System.Threading.WaitHandle notifyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Dispose(class System.Threading.WaitHandle notifyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dispose (notifyObject As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Dispose(System::Threading::WaitHandle ^ notifyObject);" />
      <MemberSignature Language="F#" Value="member this.Dispose : System.Threading.WaitHandle -&gt; bool" Usage="timer.Dispose notifyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notifyObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="notifyObject"><see cref="T:System.Threading.WaitHandle" /> que se va a señalar cuando <see langword="Timer" /> se haya eliminado.</param>
        <summary>Libera todos los recursos utilizados por la instancia de <see cref="T:System.Threading.Timer" /> actual e indica el momento en el que se ha eliminado el temporizador.</summary>
        <returns><see langword="true" /> si la función se realiza correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `Dispose` permite a los recursos utilizados por el <xref:System.Threading.Timer> que reasignarse para otros fines. Para obtener más información acerca de `Dispose`, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).  
  
 Cuando este método finaliza, indica el <xref:System.Threading.WaitHandle> especificado por el `notifyObject` parámetro. Utilice esta sobrecarga de la <xref:System.Threading.Timer.Dispose%2A> método si desea poder bloquear hasta que esté seguro de que se ha eliminado el temporizador. El temporizador no se elimina hasta que se completen todas las devoluciones de llamada actualmente en cola.  
  
> [!NOTE]
>  Si la devolución de llamada usa el <xref:System.Threading.Timer.Change%2A> método para establecer el `dueTime` en cero el parámetro, puede producirse una condición de carrera cuando la <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> se llama a la sobrecarga del método: Si el temporizador pone en cola una devolución de llamada nuevo antes de la <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga del método detecta que hay en cola ninguna devolución de llamada, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> seguirá bloqueando; en caso contrario, el temporizador se elimina mientras se está poniendo en cola la devolución de llamada nuevo y un <xref:System.ObjectDisposedException> se produce cuando las nuevas llamadas de devolución de llamada la <xref:System.Threading.Timer.Change%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="notifyObject" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/timers.md">Temporizadores</related>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="abstract member DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask&#xA;override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="timer.DisposeAsync " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IAsyncDisposable.DisposeAsync</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Timer ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="timer.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>