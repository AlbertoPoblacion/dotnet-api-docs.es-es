<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Timer.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac567fe19429800288028bf5585c9bd4f03134790db.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67fe19429800288028bf5585c9bd4f03134790db</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Provides a mechanism for executing a method on a thread pool thread at specified intervals.</source>
          <target state="translated">Proporciona un mecanismo para ejecutar un método en un subproceso del grupo de subprocesos en intervalos especificados.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>This class cannot be inherited.</source>
          <target state="translated">Esta clase no puede heredarse.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Use a <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate to specify the method you want the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to execute.</source>
          <target state="translated">Use un <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegado para especificar el método que desee el <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> para ejecutar.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The signature of the <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate is:</source>
          <target state="translated">La firma de la <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegado es:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The timer delegate is specified when the timer is constructed, and cannot be changed.</source>
          <target state="translated">El delegado de temporizador se especifica cuando se construye el temporizador y no se puede cambiar.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The method does not execute on the thread that created the timer; it executes on a <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread supplied by the system.</source>
          <target state="translated">El método no se ejecuta en el subproceso que creó el temporizador; en él se ejecuta en un <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> subproceso proporcionado por el sistema.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>.NET includes four classes named <ph id="ph1">`Timer`</ph>, each of which offers different functionality:</source>
          <target state="translated">.NET incluye cuatro clases denominadas <ph id="ph1">`Timer`</ph>, cada una de la que ofrece una funcionalidad diferente:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, which fires an event and executes the code in one or more event sinks at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, que desencadena un evento y ejecuta el código en uno o más eventos receptores a intervalos regulares.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">La clase está diseñada para usarla como basada en un servidor o componente del servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no es visible en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>, which executes a single callback method on a thread pool thread at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>, que ejecuta un método de devolución de llamada solo en un subproceso del grupo a intervalos regulares.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback method is defined when the timer is instantiated and cannot be changed.</source>
          <target state="translated">Se define el método de devolución de llamada cuando el temporizador se crea una instancia y no se puede cambiar.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Like the <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> class, this class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">Al igual que el <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> (clase), esta clase está pensada para su uso como un componente basado en servidor o el servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no es visible en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only), a Windows Forms component that fires an event and executes the code in one or more event sinks at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (Solo en .NET framework,) un componente de Windows Forms que se desencadena un evento y se ejecuta el código en uno o varios receptores de eventos a intervalos regulares.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The component has no user interface and is designed for use in a single-threaded environment; it executes on the UI thread.</source>
          <target state="translated">El componente no tiene ninguna interfaz de usuario y está diseñado para su uso en un entorno de un único subproceso; ejecuta en el subproceso de interfaz de usuario.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only), an ASP.NET component that performs asynchronous or synchronous web page postbacks at a regular interval.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (Solo en .NET framework,) un componente ASP.NET que realiza postback de página web asincrónicos o sincrónicos a intervalos regulares.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When you create a timer, you can specify an amount of time to wait before the first execution of the method (due time), and an amount of time to wait between subsequent executions (period).</source>
          <target state="translated">Cuando se crea un temporizador, puede especificar una cantidad de tiempo de espera antes de la primera ejecución del método (tiempo de expiración) y una cantidad de tiempo de espera entre las ejecuciones posteriores (período).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> clase tiene la misma resolución que el reloj del sistema.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>This means that if the period is less than the resolution of the system clock, the <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate will execute at intervals defined by the resolution of the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems.</source>
          <target state="translated">Esto significa que si el período es menor que la resolución del reloj del sistema, la <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegado se ejecutará a intervalos definidos por la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>You can change the due time and period, or disable the timer, by using the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Puede cambiar el vencimiento tiempo y un punto o deshabilitar el temporizador, utilizando el <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>As long as you are using a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph>, you must keep a reference to it.</source>
          <target state="translated">Siempre y cuando usa un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph>, debe mantener una referencia a él.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>As with any managed object, a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> is subject to garbage collection when there are no references to it.</source>
          <target state="translated">Al igual que con cualquier objeto administrado, un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> está sujeta a la colección de elementos no utilizados cuando no hay ninguna referencia a ella.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The fact that a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> is still active does not prevent it from being collected.</source>
          <target state="translated">El hecho de que un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> está todavía activo no impide se recopilan.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When a timer is no longer needed, use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method to free the resources held by the timer.</source>
          <target state="translated">Cuando ya no se necesita un temporizador, utilice el <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> método para liberar los recursos mantenidos por el temporizador.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Note that callbacks can occur after the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</source>
          <target state="translated">Tenga en cuenta que las devoluciones de llamada pueden producirse después de la <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> sobrecarga del método se ha llamado, porque el temporizador pone en cola las devoluciones de llamada para su ejecución por grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload to wait until all callbacks have completed.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> sobrecarga del método para esperar hasta que se completen todas las devoluciones de llamada.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback method executed by the timer should be reentrant, because it is called on <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">El método de devolución de llamada ejecutado por el temporizador debe ser de reentrada, porque se llama en <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> subprocesos.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the callback, or if all thread pool threads are in use and the callback is queued multiple times.</source>
          <target state="translated">La devolución de llamada se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar la devolución de llamada, o si todos los subprocesos del grupo de subprocesos están en uso y la devolución de llamada se pone en cola varias veces.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> is a simple, lightweight timer that uses callback methods and is served by thread pool threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> es un temporizador sencillo y ligero que utiliza métodos de devolución de llamada y se envía al grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>It is not recommended for use with Windows Forms, because its callbacks do not occur on the user interface thread.</source>
          <target state="translated">No se recomienda para su uso con Windows Forms, porque las devoluciones de llamada no se producen en el subproceso de interfaz de usuario.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> is a better choice for use with Windows Forms.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> es una opción mejor para su uso con Windows Forms.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>For server-based timer functionality, you might consider using <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, which raises events and has additional features.</source>
          <target state="translated">Para obtener funcionalidades de temporizador basadas en servidor, puede ser interesante usar <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, que genera eventos y tiene características adicionales.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The following example defines a <ph id="ph1">`StatusChecker`</ph> class  that includes a <ph id="ph2">`CheckStatus`</ph> method whose signature is the same as the <ph id="ph3">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">En el ejemplo siguiente se define un <ph id="ph1">`StatusChecker`</ph> clase que incluya un <ph id="ph2">`CheckStatus`</ph> método cuya firma es el mismo como el <ph id="ph3">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The  <ph id="ph1">`state`</ph> argument of the <ph id="ph2">`CheckStatus`</ph> method is an <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object that is used to synchronize the application thread and the thread pool thread that executes the callback delegate.</source>
          <target state="translated">El <ph id="ph1">`state`</ph> argumento de la <ph id="ph2">`CheckStatus`</ph> método es un <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objeto que se utiliza para sincronizar el subproceso de la aplicación y el subproceso del grupo que ejecuta el delegado de devolución de llamada.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The <ph id="ph1">`StatusChecker`</ph> class also includes two state variables:</source>
          <target state="translated">La <ph id="ph1">`StatusChecker`</ph> clase también incluye dos variables de estado:</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Indicates the number of times the callback method has been invoked.</source>
          <target state="translated">Indica el número de veces que se ha invocado el método de devolución de llamada.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Determines the maximum number of times the callback method should be invoked.</source>
          <target state="translated">Determina el número máximo de veces que se debe invocar el método de devolución de llamada.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The application thread creates the timer, which waits one second and then executes  the <ph id="ph1">`CheckStatus`</ph> callback method every 250 milliseconds.</source>
          <target state="translated">El subproceso de la aplicación crea el temporizador, que espera un segundo y, a continuación, ejecuta el <ph id="ph1">`CheckStatus`</ph> método de devolución de llamada cada 250 milisegundos.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The application thread then blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object is signaled.</source>
          <target state="translated">El subproceso de la aplicación, a continuación, se bloquea hasta que el <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> se señaliza el objeto.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When the <ph id="ph1">`CheckStatus`</ph> callback method executes <ph id="ph2">`maxCount`</ph> times, it calls the <ph id="ph3">`AutoResetEvent.Set`</ph> method to set the state of the <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object to signaled.</source>
          <target state="translated">Cuando el <ph id="ph1">`CheckStatus`</ph> el método de devolución de llamada se ejecuta <ph id="ph2">`maxCount`</ph> veces, llama a la <ph id="ph3">`AutoResetEvent.Set`</ph> método para establecer el estado de la <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> objeto que se va a señalar.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The first time this happens, the application thread calls the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29&gt;</ph> method so that the callback method now executes every half second.</source>
          <target state="translated">La primera vez que esto ocurre, el subproceso de la aplicación llama el <ph id="ph1">&lt;xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29&gt;</ph> método para que el método de devolución de llamada ejecutará cada medio segundo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>It once again blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object is signaled.</source>
          <target state="translated">Una vez más se bloquea hasta que el <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> se señaliza el objeto.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When this happens, the timer is destroyed by calling its <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method, and the application terminates.</source>
          <target state="translated">Cuando esto sucede, se destruye el temporizador mediante una llamada a su <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> método y la aplicación finaliza.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo es seguro para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Delegado de <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> que representa un método que se debe ejecutar.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> class with an infinite period and an infinite due time, using the newly created <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> object as the state object.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> con un período y un tiempo límite infinitos, utilizando el objeto <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> recién creado como objeto de estado.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>Call this constructor when you want to use the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> object itself as the state object.</source>
          <target state="translated">Llamar a este constructor cuando desee utilizar el <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> propio objeto como el objeto de estado.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>After creating the timer, use the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method to set the interval and due time.</source>
          <target state="translated">Después de crear el temporizador, utilice el <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método para establecer el intervalo y tiempo de expiración.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>This constructor specifies an infinite due time before the first callback and an infinite interval between callbacks, in order to prevent the first callback from occurring before the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> object is assigned to the state object.</source>
          <target state="translated">Este constructor especifica un límite infinitos tiempo antes de la primera devolución de llamada y un intervalo infinito entre devoluciones de llamada, para evitar que la primera devolución de llamada que se producen antes de la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> objeto se asigna al objeto de estado.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">El método especificado para <ph id="ph1">`callback`</ph> debe ser de reentrada, porque se llama en <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> subprocesos.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The following code example creates a new timer, using the timer itself as the state object.</source>
          <target state="translated">En el ejemplo de código siguiente se crea un nuevo temporizador, utilizando el propio temporizador como objeto de estado.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method is used to start the timer.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método se usa para iniciar el temporizador.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>When the timer callback occurs, the state object is used to turn the timer off.</source>
          <target state="translated">Cuando se produce la devolución de llamada de temporizador, se utiliza el objeto de estado para desactivar el temporizador.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Delegado de <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> que representa un método que se debe ejecutar.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Cantidad de tiempo de retraso, en milisegundos, antes de que se invoque <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para evitar que se inicie el temporizador.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Especifique cero (0) para iniciar inmediatamente el temporizador.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para deshabilitar la señalización periódica.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using a 32-bit signed integer to specify the time interval.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilizando un entero de 32 bits con signo para medir los intervalos de tiempo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">El delegado especificado por la <ph id="ph1">`callback`</ph> parámetro se invoca una vez después de <ph id="ph2">`dueTime`</ph> transcurre y posteriormente cada vez que la <ph id="ph3">`period`</ph> transcurra de intervalo de tiempo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es cero (0), <ph id="ph2">`callback`</ph> se invoca de inmediato.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> no se invoca; el temporizador está deshabilitado, pero puede volver a habilitarse mediante una llamada a la <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8, el <ph id="ph2">`callback`</ph> delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si <ph id="ph3">`period`</ph> es menor que la resolución del reloj del sistema.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> es cero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">`dueTime`</ph> no <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> se invoca una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar con el <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">El método especificado para <ph id="ph1">`callback`</ph> debe ser de reentrada, porque se llama en <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> subprocesos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to create a <ph id="ph1">`TimerCallback`</ph> delegate and initialize a new instance of the <ph id="ph2">`Timer`</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear un <ph id="ph1">`TimerCallback`</ph> delegar e inicializar una nueva instancia de la <ph id="ph2">`Timer`</ph> clase.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es negativo y no es igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Delegado de <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> que representa un método que se debe ejecutar.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Cantidad de tiempo de retraso, en milisegundos, antes de que se invoque <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para evitar que se inicie el temporizador.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Especifique cero (0) para iniciar inmediatamente el temporizador.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para deshabilitar la señalización periódica.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using 64-bit signed integers to measure time intervals.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilizando un entero de 64 bits con signo para medir los intervalos de tiempo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">El delegado especificado por la <ph id="ph1">`callback`</ph> parámetro se invoca una vez después de <ph id="ph2">`dueTime`</ph> transcurre y posteriormente cada vez que la <ph id="ph3">`period`</ph> transcurra de intervalo de tiempo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es cero (0), <ph id="ph2">`callback`</ph> se invoca de inmediato.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> no se invoca; el temporizador está deshabilitado, pero puede volver a habilitarse mediante una llamada a la <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8, el <ph id="ph2">`callback`</ph> delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si <ph id="ph3">`period`</ph> es menor que la resolución del reloj del sistema.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> es cero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">`dueTime`</ph> no <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> se invoca una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar con el <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">El método especificado para <ph id="ph1">`callback`</ph> debe ser de reentrada, porque se llama en <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> subprocesos.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es negativo y no es igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is greater than 4294967294.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es mayor que 4294967294.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>A delegate representing a method to be executed.</source>
          <target state="translated">Delegado que representa un método que se va a ejecutar.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The amount of time to delay before the <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> parameter invokes its methods.</source>
          <target state="translated">Cantidad de tiempo de retraso antes de que el parámetro <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> invoque sus métodos.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to prevent the timer from starting.</source>
          <target state="translated">Especifique menos un (-1) milisegundo para evitar que se inicie el temporizador.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Especifique cero (0) para iniciar inmediatamente el temporizador.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The time interval between invocations of the methods referenced by <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Intervalo de tiempo entre las distintas invocaciones de los métodos a los que hace referencia <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to disable periodic signaling.</source>
          <target state="translated">Especifique menos un (-1) milisegundo para deshabilitar la señalización periódica.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> values to measure time intervals.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>, utilizando valores de <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> para medir los intervalos de tiempo.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">El delegado especificado por la <ph id="ph1">`callback`</ph> parámetro se invoca una vez después de <ph id="ph2">`dueTime`</ph> transcurre y posteriormente cada vez que la <ph id="ph3">`period`</ph> transcurra de intervalo de tiempo.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es cero (0), <ph id="ph2">`callback`</ph> se invoca de inmediato.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is negative one (-1) milliseconds, <ph id="ph2">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es menos uno (-1) milisegundo, <ph id="ph2">`callback`</ph> no se invoca; el temporizador está deshabilitado, pero puede volver a habilitarse mediante una llamada a la <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8, el <ph id="ph2">`callback`</ph> delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si <ph id="ph3">`period`</ph> es menor que la resolución del reloj del sistema.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or negative one (-1) milliseconds and <ph id="ph2">`dueTime`</ph> is positive, <ph id="ph3">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> es cero (0) o menos (-1) milisegundo y <ph id="ph2">`dueTime`</ph> es positivo, <ph id="ph3">`callback`</ph> se invoca una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar con el <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">El método especificado para <ph id="ph1">`callback`</ph> debe ser de reentrada, porque se llama en <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> subprocesos.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The following code example shows how to create a <ph id="ph1">`TimerCallback`</ph> delegate and initialize a new instance of the <ph id="ph2">`Timer`</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear un <ph id="ph1">`TimerCallback`</ph> delegar e inicializar una nueva instancia de la <ph id="ph2">`Timer`</ph> clase.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The number of milliseconds in the value of <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> is negative and not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>, or is greater than <ph id="ph4">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">El número de milisegundos del valor de <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es negativo y no es igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>, o es mayor que <ph id="ph4">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>A delegate representing a method to be executed.</source>
          <target state="translated">Delegado que representa un método que se va a ejecutar.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Cantidad de tiempo de retraso, en milisegundos, antes de que se invoque <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para evitar que se inicie el temporizador.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Especifique cero (0) para iniciar inmediatamente el temporizador.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para deshabilitar la señalización periódica.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using 32-bit unsigned integers to measure time intervals.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilizando un entero de 32 bits sin signo para medir los intervalos de tiempo.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">El delegado especificado por la <ph id="ph1">`callback`</ph> parámetro se invoca una vez después de <ph id="ph2">`dueTime`</ph> transcurre y posteriormente cada vez que la <ph id="ph3">`period`</ph> transcurra de intervalo de tiempo.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es cero (0), <ph id="ph2">`callback`</ph> se invoca de inmediato.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> no se invoca; el temporizador está deshabilitado, pero puede volver a habilitarse mediante una llamada a la <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8, el <ph id="ph2">`callback`</ph> delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si <ph id="ph3">`period`</ph> es menor que la resolución del reloj del sistema.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> es cero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">`dueTime`</ph> no <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> se invoca una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar con el <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">El método especificado para <ph id="ph1">`callback`</ph> debe ser de reentrada, porque se llama en <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> subprocesos.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es negativo y no es igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Changes the start time and the interval between method invocations for a timer.</source>
          <target state="translated">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para evitar que el temporizador se reinicie.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Especifique cero (0) para reiniciar inmediatamente el temporizador.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>, en milisegundos.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para deshabilitar la señalización periódica.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Changes the start time and the interval between method invocations for a timer, using 32-bit signed integers to measure time intervals.</source>
          <target state="translated">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 32 bits con signo para medir los intervalos de tiempo.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el temporizador se actualizó correctamente; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">Se invoca el método de devolución de llamada una vez después de <ph id="ph1">`dueTime`</ph> transcurra y posteriormente cada vez que el intervalo de tiempo especificado por <ph id="ph2">`period`</ph> transcurre.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es cero (0), se invoca el método de devolución de llamada inmediatamente.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> y especificando un valor positivo para <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> es cero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">`dueTime`</ph> no <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, se invoca el método de devolución de llamada una vez; el comportamiento periódico del temporizador se deshabilita, pero puede volver a habilitarse mediante una llamada a <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> y especificando un valor positivo para <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método puede llamarse desde el <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to start a <ph id="ph1">`Timer`</ph> and, after a set number of invocations, change its period.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo iniciar un <ph id="ph1">`Timer`</ph> y, después de un número establecido de llamadas, cambiar su período.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es negativo y no es igual a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para evitar que el temporizador se reinicie.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Especifique cero (0) para reiniciar inmediatamente el temporizador.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>, en milisegundos.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para deshabilitar la señalización periódica.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Changes the start time and the interval between method invocations for a timer, using 64-bit signed integers to measure time intervals.</source>
          <target state="translated">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 64 bits con signo para medir los intervalos de tiempo.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el temporizador se actualizó correctamente; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">Se invoca el método de devolución de llamada una vez después de <ph id="ph1">`dueTime`</ph> transcurra y posteriormente cada vez que el intervalo de tiempo especificado por <ph id="ph2">`period`</ph> transcurre.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es cero (0), se invoca el método de devolución de llamada inmediatamente.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> y especificando un valor positivo para <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> es cero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">`dueTime`</ph> no <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, se invoca el método de devolución de llamada una vez; el comportamiento periódico del temporizador se deshabilita, pero puede volver a habilitarse mediante una llamada a <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> y especificando un valor positivo para <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método puede llamarse desde el <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is less than -1.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es menor que -1.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is greater than 4294967294.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es mayor que 4294967294.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to delay before invoking the callback method specified when the <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa el período tiempo de retraso antes de que se llame al método de devolución de llamada que se especificó cuando se creó <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to prevent the timer from restarting.</source>
          <target state="translated">Especifique menos un (-1) milisegundo para evitar que se reinicie el temporizador.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Especifique cero (0) para reiniciar inmediatamente el temporizador.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed.</source>
          <target state="translated">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to disable periodic signaling.</source>
          <target state="translated">Especifique menos un (-1) milisegundo para deshabilitar la señalización periódica.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Changes the start time and the interval between method invocations for a timer, using <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> values to measure time intervals.</source>
          <target state="translated">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones del método para un temporizador, utilizando los valores de <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> para medir los intervalos de tiempo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el temporizador se actualizó correctamente; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">Se invoca el método de devolución de llamada una vez después de <ph id="ph1">`dueTime`</ph> transcurra y posteriormente cada vez que el intervalo de tiempo especificado por <ph id="ph2">`period`</ph> transcurre.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es cero (0), se invoca el método de devolución de llamada inmediatamente.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is negative one (-1) milliseconds, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph2">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph3">`dueTime`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es menos uno (-1) milisegundo, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <ph id="ph2">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> y especificando un valor positivo para <ph id="ph3">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or negative one (-1) milliseconds, and <ph id="ph2">`dueTime`</ph> is positive, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a value greater than zero for <ph id="ph4">`period`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> es cero (0) o menos uno (-1) milisegundo, y <ph id="ph2">`dueTime`</ph> es positivo, se invoca el método de devolución de llamada una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar mediante una llamada a <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> y especifique un valor mayor que cero para <ph id="ph4">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método puede llamarse desde el <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The following code example demonstrates how to start a <ph id="ph1">`Timer`</ph> and, after a set number of invocations, change its period.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo iniciar un <ph id="ph1">`Timer`</ph> y, después de un número establecido de llamadas, cambiar su período.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter, in milliseconds, is less than -1.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es menor que -1, en milisegundos.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter, in milliseconds, is greater than 4294967294.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> es mayor que 4294967294, en milisegundos.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para evitar que el temporizador se reinicie.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Especifique cero (0) para reiniciar inmediatamente el temporizador.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>, en milisegundos.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Especifique <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> para deshabilitar la señalización periódica.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Changes the start time and the interval between method invocations for a timer, using 32-bit unsigned integers to measure time intervals.</source>
          <target state="translated">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 32 bits sin signo para medir los intervalos de tiempo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el temporizador se actualizó correctamente; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">Se invoca el método de devolución de llamada una vez después de <ph id="ph1">`dueTime`</ph> transcurra y posteriormente cada vez que el intervalo de tiempo especificado por <ph id="ph2">`period`</ph> transcurre.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es cero (0), se invoca el método de devolución de llamada inmediatamente.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`dueTime`</ph> es <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> y especificando un valor positivo para <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`period`</ph> es cero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">`dueTime`</ph> no <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, se invoca el método de devolución de llamada una vez; el comportamiento periódico del temporizador se deshabilita, pero puede volver a habilitarse mediante una llamada a <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> y especificando un valor positivo para <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método puede llamarse desde el <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</source>
          <target state="translated">Libera todos los recursos utilizados por la instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</source>
          <target state="translated">Libera todos los recursos utilizados por la instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">Al llamar a <ph id="ph1">`Dispose`</ph> permite que los recursos utilizados por el <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> se reasignen para otros fines.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de <ph id="ph1">`Dispose`</ph>, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>Callbacks can occur after the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</source>
          <target state="translated">Las devoluciones de llamada pueden producirse después de la <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> sobrecarga del método se ha llamado, porque el temporizador pone en cola las devoluciones de llamada para su ejecución por grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload to wait until all callbacks have completed.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> sobrecarga del método para esperar hasta que se completen todas las devoluciones de llamada.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>The following code example shows how to free the resources held by a <ph id="ph1">`Timer`</ph>.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo liberar los recursos mantenidos por un <ph id="ph1">`Timer`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to be signaled when the <ph id="ph2">&lt;see langword="Timer" /&gt;</ph> has been disposed of.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> que se va a señalar cuando <ph id="ph2">&lt;see langword="Timer" /&gt;</ph> se haya eliminado.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> and signals when the timer has been disposed of.</source>
          <target state="translated">Libera todos los recursos utilizados por la instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> actual e indica el momento en el que se ha eliminado el temporizador.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the function succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la función se realiza correctamente; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">Al llamar a <ph id="ph1">`Dispose`</ph> permite que los recursos utilizados por el <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> se reasignen para otros fines.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de <ph id="ph1">`Dispose`</ph>, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>When this method completes, it signals the <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> specified by the <ph id="ph2">`notifyObject`</ph> parameter.Use this overload of the <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method if you want to be able to block until you are certain that the timer has been disposed.</source>
          <target state="translated">Cuando este método finaliza, indica el <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> especificado por el <ph id="ph2">`notifyObject`</ph> parámetro. Utilice esta sobrecarga de la <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> método si desea poder bloquear hasta que esté seguro de que se ha eliminado el temporizador.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The timer is not disposed until all currently queued callbacks have completed.</source>
          <target state="translated">No se eliminó el temporizador hasta que se completen todas las devoluciones de llamada actualmente en cola.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>If the callback uses the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method to set the <ph id="ph2">`dueTime`</ph> parameter to zero, a race condition can occur when the <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload is called: If the timer queues a new callback before the <ph id="ph4">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload detects that there are no callbacks queued, <ph id="ph5">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> continues to block; otherwise, the timer is disposed while the new callback is being queued, and an <ph id="ph6">&lt;xref:System.ObjectDisposedException&gt;</ph> is thrown when the new callback calls the <ph id="ph7">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Si utiliza la devolución de llamada la <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> método para establecer el <ph id="ph2">`dueTime`</ph> en cero el parámetro, puede producirse una condición de carrera cuando la <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> sobrecarga del método se llama: si el temporizador pone en cola una devolución de llamada nueva antes de la <ph id="ph4">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> sobrecarga del método detecta que no hay ningún devoluciones de llamada en cola, <ph id="ph5">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> seguirá bloqueando; en caso contrario, el temporizador se elimina mientras se está poniendo en cola la devolución de llamada nueva y un <ph id="ph6">&lt;xref:System.ObjectDisposedException&gt;</ph> se produce cuando se llama a la devolución de llamada nuevo el <ph id="ph7">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;paramref name="notifyObject" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="notifyObject" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>