<Type Name="CancellationToken" FullName="System.Threading.CancellationToken">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5c5fac7bdec18fbbf1ea2804c8637088b9838920" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52224601" /></Metadata><TypeSignature Language="C#" Value="public struct CancellationToken" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit CancellationToken extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Threading.CancellationToken" />
  <TypeSignature Language="VB.NET" Value="Public Structure CancellationToken" />
  <TypeSignature Language="C++ CLI" Value="public value class CancellationToken" />
  <TypeSignature Language="F#" Value="type CancellationToken = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("IsCancellationRequested = {IsCancellationRequested}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Propaga la notificación de que las operaciones deberían cancelarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Threading.CancellationToken> permite la cancelación cooperativa entre subprocesos, elementos de trabajo de grupo de subprocesos, o <xref:System.Threading.Tasks.Task> objetos. Crear un token de cancelación creando un <xref:System.Threading.CancellationTokenSource> recupera el objeto que administra los tokens de cancelación de su <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> propiedad. A continuación, que se pase el token de cancelación a cualquier número de subprocesos, tareas u operaciones que deben recibir una notificación de cancelación. El token no se puede usar para iniciar la cancelación. Cuando el objeto propietario llama <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>, <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propiedad de todas las copias del token de cancelación se establece en `true`. Los objetos que reciben la notificación pueden responder de manera adecuada.  
  
 Para obtener más información y ejemplos de código vea [cancelación en subprocesos administrados](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 El ejemplo siguiente utiliza un generador de números aleatorios para emular una aplicación de recopilación de datos que lee los 10 valores enteros de once instruments diferentes. Un valor de cero indica que ha fallado la medida para un instrumento, en cuyo caso se debe cancelar la operación y no Media general se deben calcular.  
  
 Para controlar la cancelación posibles de la operación, el ejemplo crea un <xref:System.Threading.CancellationTokenSource> objeto que genera un token de cancelación que se pasa a un <xref:System.Threading.Tasks.TaskFactory> objeto. La <xref:System.Threading.Tasks.TaskFactory> objeto a su vez pasa el token de cancelación a cada una de las tareas responsable de recopilar lecturas para un método determinado. El <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%60%602%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2CSystem.Func%7BSystem.Threading.Tasks.Task%7B%60%600%7D%5B%5D%2C%60%601%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método se llama para asegurarse de que se calcula la media solo después de que haya recopilado correctamente todas las lecturas. Si una tarea tiene no porque se ha cancelado, la llamada a la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> método produce una excepción.  
  
 [!code-csharp[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/cs/cancel1.cs#1)]
 [!code-vb[System.Threading.CancellationTokenSource.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.cancellationtokensource.class/vb/cancel1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros públicos y protegidos de <see cref="T:System.Threading.CancellationToken" /> son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CancellationToken (bool canceled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool canceled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (canceled As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CancellationToken(bool canceled);" />
      <MemberSignature Language="F#" Value="new System.Threading.CancellationToken : bool -&gt; System.Threading.CancellationToken" Usage="new System.Threading.CancellationToken canceled" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="canceled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="canceled">El estado cancelado para el token.</param>
        <summary>Inicializa el <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los tokens creados con este constructor permanecerán en el estado cancelado, especificado por el `canceled` parámetro. Si `canceled` es `false`, ambos <xref:System.Threading.CancellationToken.CanBeCanceled%2A> y <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> será `false`.  
  
 Si `canceled` es `true`, ambos <xref:System.Threading.CancellationToken.CanBeCanceled%2A> y <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> será `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="CanBeCanceled">
      <MemberSignature Language="C#" Value="public bool CanBeCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanBeCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.CanBeCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanBeCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanBeCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanBeCanceled : bool" Usage="System.Threading.CancellationToken.CanBeCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si este token es capaz de existir en el estado cancelado.</summary>
        <value><see langword="true" /> si este token puede estar en estado cancelado; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Threading.CancellationToken.CanBeCanceled%2A> devuelve `false`, se garantiza que el token nunca pasará a un estado cancelado, lo que significa que <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> nunca devolverá `true`. Devuelve un token de cancelación que no se puede cancelar estático <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType> propiedad.  
  
 También puede usar esta propiedad para determinar si puede ser un token de cancelación cancela antes de examinar el valor de la <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propiedad para determinar si se ha cancelado.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si la instancia de <see cref="T:System.Threading.CancellationToken" /> actual es igual que el token especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (other As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cancellationToken.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="other">Se trata del otro objeto que se comparará con esta instancia.</param>
        <summary>Determina si la instancia de <see cref="T:System.Threading.CancellationToken" /> actual es igual que la instancia de <see cref="T:System.Object" /> especificada.</summary>
        <returns><see langword="true" /> si <paramref name="other" /> es <see cref="T:System.Threading.CancellationToken" /> y si las dos instancias son iguales; en caso contrario, <see langword="false" />. Vea la sección Comentarios para obtener más información.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Dos tokens de cancelación son iguales si cualquiera de las siguientes condiciones es verdadera: 

- Están asociados con el mismo <xref:System.Threading.CancellationTokenSource>.

- Ambos se construyeron público <xref:System.Threading.CancellationToken> constructores y sus <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valores son iguales.

- El valor de ambos tokens de cancelación es <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó un <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Threading.CancellationToken other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Threading.CancellationToken other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Threading::CancellationToken other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Threading.CancellationToken -&gt; bool" Usage="cancellationToken.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="other">Se trata del otro elemento <see cref="T:System.Threading.CancellationToken" /> que se comparará con esta instancia.</param>
        <summary>Determina si la instancia de <see cref="T:System.Threading.CancellationToken" /> actual es igual que el token especificado.</summary>
        <returns><see langword="true" /> si las instancias son iguales; en caso contrario, <see langword="false" />. Vea la sección Comentarios para obtener más información.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Dos tokens de cancelación son iguales si cualquiera de las siguientes condiciones es verdadera: 

- Están asociados con el mismo <xref:System.Threading.CancellationTokenSource>.

- Ambos se construyeron público <xref:System.Threading.CancellationToken> constructores y sus <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valores son iguales.

- El valor de ambos tokens de cancelación es <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.

       ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cancellationToken.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sirve como función hash de un objeto <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Código hash de la instancia de <see cref="T:System.Threading.CancellationToken" /> actual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCancellationRequested">
      <MemberSignature Language="C#" Value="public bool IsCancellationRequested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCancellationRequested" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.IsCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCancellationRequested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCancellationRequested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCancellationRequested : bool" Usage="System.Threading.CancellationToken.IsCancellationRequested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si se ha solicitado la cancelación para este token.</summary>
        <value><see langword="true" /> si se solicitó la cancelación de este token; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad indica si se ha solicitado la cancelación para este token, ya sea a través del token que se construye inicialmente en un estado cancelado o llamando a <xref:System.Threading.CancellationTokenSource.Cancel%2A> en el token asociado a la <xref:System.Threading.CancellationTokenSource>.  
  
 Si esta propiedad es `true`, solo garantiza que se ha solicitado la cancelación. No se garantiza que cada controlador registrado ha terminado de ejecutar, ni que las solicitudes de cancelación han acabado de propagarse a todos los controladores registrados. Una sincronización adicional puede ser necesaria, especialmente en situaciones donde se cancelan los objetos relacionados al mismo tiempo.  
  
   
  
## Examples  
 El siguiente es un ejemplo sencillo que se ejecuta un proceso de servidor hasta que el <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propiedad devuelve `true`.  
  
 [!code-csharp[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/cs/cancellation.cs#12)]
 [!code-vb[System.Threading.Tasks.CancellationToken.IsCancellationRequested#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.CancellationToken.IsCancellationRequested/vb/cancelthreads.vb#12)]  
  
 El ejemplo crea un <xref:System.Threading.CancellationTokenSource> objeto, que controla el acceso al token de cancelación. A continuación, define dos procedimientos de subproceso. El primero se define como una expresión lambda que agrupa el teclado y, cuando se presiona la tecla "C", se llama a <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> para establecer el token de cancelación al estado cancelado. El segundo es un método con parámetros, `ServerClass.StaticMethod`, que ejecuta un bucle hasta que el <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propiedad es `true`.  
  
 El subproceso principal, a continuación, inicia los dos subprocesos y bloques hasta que el subproceso que se ejecuta el `ServerClass.StaticMethod` finaliza el método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationToken None { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Threading.CancellationToken None" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.None" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property None As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::CancellationToken None { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.None : System.Threading.CancellationToken" Usage="System.Threading.CancellationToken.None" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve un valor <see cref="T:System.Threading.CancellationToken" /> vacío.</summary>
        <value>Token de cancelación vacío.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El token de cancelación devuelve esta propiedad no se puede cancelar; es decir, su <xref:System.Threading.CancellationToken.CanBeCanceled%2A> propiedad es `false`.  
  
 También puede usar C# [default(CancellationToken)](~/docs/csharp/language-reference/keywords/default.md) instrucción para crear un token de cancelación vacío. 

 Dos tokens de cancelación vacío siempre son iguales.
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Threading.CancellationToken * System.Threading.CancellationToken -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Primera instancia.</param>
        <param name="right">Segunda instancia.</param>
        <summary>Determina si dos instancias de <see cref="T:System.Threading.CancellationToken" /> son iguales.</summary>
        <returns><see langword="true" /> si las instancias son iguales; de lo contrario, <see langword="false" />. Para más información, vea la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Dos tokens de cancelación son iguales si cualquiera de las siguientes condiciones es verdadera: 

- Están asociados con el mismo <xref:System.Threading.CancellationTokenSource>.

- Ambos se construyeron público <xref:System.Threading.CancellationToken> constructores y sus <xref:System.Threading.CancellationToken.IsCancellationRequested?displayProperty=nameWithType> valores son iguales.

- El valor de ambos tokens de cancelación es <xref:System.Threading.CancellationToken.None?displayProperty=nameWithType>.
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó un <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Threading.CancellationToken left, System.Threading.CancellationToken right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Threading.CancellationToken left, valuetype System.Threading.CancellationToken right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As CancellationToken, right As CancellationToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Threading::CancellationToken left, System::Threading::CancellationToken right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Threading.CancellationToken * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.CancellationToken.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Threading.CancellationToken" />
        <Parameter Name="right" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="left">Primera instancia.</param>
        <param name="right">Segunda instancia.</param>
        <summary>Determina si dos instancias de <see cref="T:System.Threading.CancellationToken" /> no son iguales.</summary>
        <returns><see langword="true" /> si las instancias no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  

Para la definición de igualdad, consulte el <xref:System.Threading.CancellationToken.Equals%2A> método. 
       ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó un <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un delegado que se invocará cuando se cancele este objeto <see cref="T:System.Threading.CancellationToken" />.</summary>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Register : Action -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado que se va a ejecutar cuando se cancele <see cref="T:System.Threading.CancellationToken" />.</param>
        <summary>Registra un delegado que se invocará cuando se cancele este objeto <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instancia de <see cref="T:System.Threading.CancellationTokenRegistration" /> que se puede usar para anular el registro de la devolución de llamada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este token ya está en el estado cancelado, se ejecutará el delegado de forma inmediata y sincrónicamente. Cualquier excepción que genera el delegado se propagará fuera de esta llamada al método.  
  
 Actual <xref:System.Threading.ExecutionContext> se captura junto con el delegado y se utilizará al ejecutarlo. 

 Actual <xref:System.Threading.SynchronizationContext> no se captura.
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó el <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> es null.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
        <related type="Article" href="https://msdn.microsoft.com/library/8838dd75-18ed-4b8b-b322-cd4531faac64">Cómo: Registrar devoluciones de llamadas de solicitudes de cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action callback, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action callback, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action ^ callback, bool useSynchronizationContext);" />
      <MemberSignature Language="F#" Value="member this.Register : Action * bool -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, useSynchronizationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado que se va a ejecutar cuando se cancele <see cref="T:System.Threading.CancellationToken" />.</param>
        <param name="useSynchronizationContext">Un valor que indica si se va a capturar el <see cref="T:System.Threading.SynchronizationContext" /> actual y si se va a usar al invocar <paramref name="callback" />.</param>
        <summary>Registra un delegado que se invocará cuando se cancele este objeto <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instancia de <see cref="T:System.Threading.CancellationTokenRegistration" /> que se puede usar para anular el registro de la devolución de llamada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este token ya está en el estado cancelado, se ejecutará el delegado de forma inmediata y sincrónicamente. Cualquier excepción que genera el delegado se propagará fuera de esta llamada al método.  
  
 Actual <xref:System.Threading.ExecutionContext> se captura junto con el delegado y se utilizará al ejecutarlo. 

 Si `useSynchronizationContext` es `true`, actual <xref:System.Threading.SynchronizationContext>, si uno existe, también se captura junto con el delegado y se utilizará al ejecutarlo. En caso contrario, <xref:System.Threading.SynchronizationContext> no se captura.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó el <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> es null.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
        <related type="Article" href="https://msdn.microsoft.com/library/8838dd75-18ed-4b8b-b322-cd4531faac64">Cómo: Registrar devoluciones de llamadas de solicitudes de cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.Register : Action&lt;obj&gt; * obj -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado que se va a ejecutar cuando se cancele <see cref="T:System.Threading.CancellationToken" />.</param>
        <param name="state">El estado que se va a pasar a <paramref name="callback" /> cuando se invoque al delegado. Puede ser null.</param>
        <summary>Registra un delegado que se invocará cuando se cancele este objeto <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instancia de <see cref="T:System.Threading.CancellationTokenRegistration" /> que se puede usar para anular el registro de la devolución de llamada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este token ya está en el estado cancelado, se ejecutará el delegado de forma inmediata y sincrónicamente. Cualquier excepción que genera el delegado se propagará fuera de esta llamada al método.  
  
 Actual <xref:System.Threading.ExecutionContext> se captura junto con el delegado y se utilizará al ejecutarlo. 

 Actual <xref:System.Threading.SynchronizationContext> no se captura.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó el <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> es null.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
        <related type="Article" href="https://msdn.microsoft.com/library/8838dd75-18ed-4b8b-b322-cd4531faac64">Cómo: Registrar devoluciones de llamadas de solicitudes de cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationTokenRegistration Register (Action&lt;object&gt; callback, object state, bool useSynchronizationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.CancellationTokenRegistration Register(class System.Action`1&lt;object&gt; callback, object state, bool useSynchronizationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Register (callback As Action(Of Object), state As Object, useSynchronizationContext As Boolean) As CancellationTokenRegistration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CancellationTokenRegistration Register(Action&lt;System::Object ^&gt; ^ callback, System::Object ^ state, bool useSynchronizationContext);" />
      <MemberSignature Language="F#" Value="member this.Register : Action&lt;obj&gt; * obj * bool -&gt; System.Threading.CancellationTokenRegistration" Usage="cancellationToken.Register (callback, state, useSynchronizationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationTokenRegistration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="useSynchronizationContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado que se va a ejecutar cuando se cancele <see cref="T:System.Threading.CancellationToken" />.</param>
        <param name="state">El estado que se va a pasar a <paramref name="callback" /> cuando se invoque al delegado. Puede ser null.</param>
        <param name="useSynchronizationContext">Un valor booleano que indica si se va a capturar el <see cref="T:System.Threading.SynchronizationContext" /> actual y si se va a usar al invocar <paramref name="callback" />.</param>
        <summary>Registra un delegado que se invocará cuando se cancele este objeto <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Instancia de <see cref="T:System.Threading.CancellationTokenRegistration" /> que se puede usar para anular el registro de la devolución de llamada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este token ya está en el estado cancelado, se ejecutará el delegado de forma inmediata y sincrónicamente. Cualquier excepción que genera el delegado se propagará fuera de esta llamada al método.  
  
 Actual <xref:System.Threading.ExecutionContext> se captura junto con el delegado y se utilizará al ejecutarlo. 

 Si `useSynchronizationContext` es `true`, actual <xref:System.Threading.SynchronizationContext>, si uno existe, también se captura junto con el delegado y se utilizará al ejecutarlo. En caso contrario, <xref:System.Threading.SynchronizationContext> no se captura.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó el <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> es null.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
        <related type="Article" href="https://msdn.microsoft.com/library/8838dd75-18ed-4b8b-b322-cd4531faac64">Cómo: Registrar devoluciones de llamadas de solicitudes de cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="ThrowIfCancellationRequested">
      <MemberSignature Language="C#" Value="public void ThrowIfCancellationRequested ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ThrowIfCancellationRequested() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.CancellationToken.ThrowIfCancellationRequested" />
      <MemberSignature Language="VB.NET" Value="Public Sub ThrowIfCancellationRequested ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ThrowIfCancellationRequested();" />
      <MemberSignature Language="F#" Value="member this.ThrowIfCancellationRequested : unit -&gt; unit" Usage="cancellationToken.ThrowIfCancellationRequested " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Produce <see cref="T:System.OperationCanceledException" /> si este token ha tenido una solicitud de cancelación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona la funcionalidad equivalente para:  
  
 C#  
  
```csharp  
if (token.IsCancellationRequested)   
    throw new OperationCanceledException(token);  
```  
  
```vb  
If token.IsCancellationRequested Then  
    Throw New OperationCanceledException(token)  
End If  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se solicitó la cancelación del token.</exception>
        <exception cref="T:System.ObjectDisposedException">Se eliminó el <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md">Cómo: Cancelar una tarea y sus elementos secundarios</related>
      </Docs>
    </Member>
    <Member MemberName="WaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle WaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle WaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.CancellationToken.WaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ WaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitHandle : System.Threading.WaitHandle" Usage="System.Threading.CancellationToken.WaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un <see cref="T:System.Threading.WaitHandle" /> que se señala cuando el token se cancela.</summary>
        <value><see cref="T:System.Threading.WaitHandle" /> que se señala cuando el token se cancela.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Acceso a esta propiedad provoca un <xref:System.Threading.WaitHandle> creación de instancias. Es preferible utilizar solo esta propiedad cuando sea necesario y, a continuación, eliminar el asociado <xref:System.Threading.CancellationTokenSource> instancia a la primera oportunidad (eliminando el origen se eliminará el controlador asignado). El identificador no debe cerrado o desechado directamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó el <see cref="T:System.Threading.CancellationTokenSource" /> asociado.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
        <related type="Article" href="https://msdn.microsoft.com/library/6e2aa49b-fc84-4bcf-962b-17db98b7edcb">Cómo: Realizar escuchas de solicitudes de cancelación cuando tienen controladores de espera</related>
      </Docs>
    </Member>
  </Members>
</Type>