<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6bce0feaf14f66f8608164cfa777620d7f3b329f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530999" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Primitiva de sincronización que puede usarse también para la sincronización entre procesos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando dos o más subprocesos deben tener acceso a un recurso compartido al mismo tiempo, el sistema necesita un mecanismo de sincronización para asegurarse de que solo un subproceso a la vez utiliza el recurso. <xref:System.Threading.Mutex> es una sincronización primitiva que conceda acceso exclusivo al recurso compartido a un solo subproceso. Si un subproceso adquiere una exclusión mutua, el segundo subproceso que desea adquirir dicha exclusión mutua se suspende hasta que el primer subproceso libera la exclusión mutua.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 Puede usar el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método que solicite la propiedad de una exclusión mutua. El subproceso que realiza la llamada se bloquea hasta que se produzca uno de los siguientes:  
  
-   La exclusión mutua se señala para indicar que no pertenece. Cuando esto sucede, el <xref:System.Threading.WaitHandle.WaitOne%2A> método `true`, y el subproceso que realiza la llamada asume la propiedad de la exclusión mutua y tiene acceso al recurso protegido por la exclusión mutua. Cuando ha terminado de obtener acceso al recurso, el subproceso debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar la propiedad de la exclusión mutua. El primer ejemplo en la sección de ejemplos muestra este patrón.  
  
-   El intervalo de tiempo de espera especificado en la llamada a un <xref:System.Threading.WaitHandle.WaitOne%2A> método que tiene un `millisecondsTimeout` o `timeout` parámetro ha transcurrido. Cuando esto sucede, el <xref:System.Threading.WaitHandle.WaitOne%2A> método `false`, y el subproceso que realiza la llamada no realizará ningún intento adicional para adquirir la propiedad de la exclusión mutua. En este caso, debe estructurar el código para que se deniega el acceso al recurso que está protegido por la exclusión mutua al subproceso que realiza la llamada. Dado que el subproceso haya adquirido nunca la propiedad del mutex, no deben llamar el <xref:System.Threading.Mutex.ReleaseMutex%2A> método. El segundo ejemplo en la sección de ejemplos muestra este modelo.  
  
 La <xref:System.Threading.Mutex> clase exige la identidad del subproceso, por lo que se pueden liberar una exclusión mutua solo por el subproceso que lo adquirió. Por el contrario, la <xref:System.Threading.Semaphore> clase no exige la identidad del subproceso. Una exclusión mutua también se puede pasar a través de los límites del dominio de aplicación.  
  
 El subproceso que posee una exclusión mutua puede solicitar la misma exclusión mutua en llamadas repetidas a <xref:System.Threading.WaitHandle.WaitOne%2A> sin bloquear su ejecución. Sin embargo, el subproceso debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método el mismo número de veces para liberar la propiedad de la exclusión mutua.  
  
 Dado que la <xref:System.Threading.Mutex> clase hereda de <xref:System.Threading.WaitHandle>, también puede llamar el método estático <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> y <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos para sincronizar el acceso a un recurso protegido.  
  
 Si un subproceso finaliza mientras posee una exclusión mutua, la exclusión mutua se considera abandonada. El estado de la exclusión mutua se establece en señalado y el siguiente subproceso en espera obtiene la propiedad. A partir de la versión 2.0 de .NET Framework, un <xref:System.Threading.AbandonedMutexException> se produce en el siguiente subproceso que adquiere la exclusión mutua abandonada. Antes de la versión 2.0 de .NET Framework, se inicia ninguna excepción.  
  
> [!CAUTION]
>  A menudo, un mutex abandonado indica un error grave en el código. Cuando un subproceso sale sin liberar la exclusión mutua, las estructuras de datos protegidas por el mutex no estén en un estado coherente. El siguiente subproceso que solicite la propiedad de la exclusión mutua puede controlar esta excepción y continuar si se puede comprobar la integridad de las estructuras de datos.  
  
 En el caso de una exclusión mutua en todo el sistema, una exclusión mutua abandonada podría indicar que una aplicación finalizó inesperadamente (por ejemplo, con el Administrador de tareas de Windows).  
  
 Las exclusiones mutuas son de dos tipos: exclusiones mutuas locales, sin nombre y con nombre exclusiones mutuas del sistema. Una exclusión mutua local solo existe dentro del proceso. Se puede utilizar con cualquier subproceso en el proceso que tiene una referencia a la <xref:System.Threading.Mutex> objeto que representa la exclusión mutua. Cada uno de ellos sin nombre <xref:System.Threading.Mutex> objeto representa una exclusión mutua local independiente.  
  
 Las exclusiones mutuas son visibles en todo el sistema operativo y pueden utilizarse para sincronizar las actividades de procesos de sistema con nombre. Puede crear un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre mediante un constructor que acepta un nombre. Se puede crear el objeto de sistema operativo al mismo tiempo, o puede existir antes de la creación de la <xref:System.Threading.Mutex> objeto. Puede crear varios objetos <xref:System.Threading.Mutex> que representen la misma exclusión mutua del sistema con nombre y puede usar el método <xref:System.Threading.Mutex.OpenExisting%2A> para abrir una exclusión mutua del sistema con nombre existente.  
  
> [!NOTE]
>  En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad. Si su nombre empieza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server. Si su nombre empieza con el prefijo "Local\\", la exclusión mutua sólo es visible en la sesión de terminal server donde se creó. En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor. Si no especifica ningún prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\". Dentro de una sesión de servidor de terminal server, dos exclusiones mutuas cuyos nombres se diferencien sólo por sus prefijos son exclusiones mutuas independientes y ambos son visibles para todos los procesos en la sesión de servidor de terminal server. Es decir, los nombres de prefijo "Global\\" y "Local\\" describen el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Este ejemplo se muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido. Dado que cada subproceso que realiza la llamada se bloquea hasta que adquiere la propiedad del mutex, debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar la propiedad del subproceso.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 En el ejemplo siguiente, cada subproceso llama a la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> método para adquirir la exclusión mutua. Si transcurre el intervalo de tiempo de espera, el método devuelve `false`, y el subproceso no adquiere la exclusión mutua ni obtiene acceso al recurso que protege la exclusión mutua. El <xref:System.Threading.Mutex.ReleaseMutex%2A> método se llama solo por el subproceso que adquiere la exclusión mutua.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con propiedades predeterminadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a esta sobrecarga del constructor es igual que llamar a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> sobrecarga de constructor y especificando `false` para la propiedad inicial de la exclusión mutua. Es decir, el subproceso que realiza la llamada no posee la exclusión mutua.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido. El subproceso que crea la exclusión mutua no posee la exclusión inicialmente.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> para otorgar la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada, en caso contrario, <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido. El subproceso que crea el <xref:System.Threading.Mutex> posee la exclusión inicialmente.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</param>
        <param name="name">Nombre del objeto <see cref="T:System.Threading.Mutex" />. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua y una cadena que representa el nombre de la exclusión mutua.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` no `null` y `initiallyOwned` es `true`, el subproceso que realiza la llamada posee la exclusión mutua sólo si la exclusión mutua del sistema con nombre se creó como resultado de esta llamada. Puesto que no hay ningún mecanismo para determinar si se creó la exclusión mutua del sistema con nombre, es mejor especificar `false` para `initiallyOwned` al llamar a esta sobrecarga del constructor. Puede usar el <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor si tiene que determinar la propiedad inicial.  
  
 Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre. Puede crear varias <xref:System.Threading.Mutex> los objetos que representan el mismo nombre exclusión mutua del sistema.  
  
 Si la exclusión mutua con nombre ya se ha creado con seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, se produce una excepción. Para abrir una exclusión mutua con nombre con únicamente los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si se hubiera llamado el <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. En este caso, `createdNew` siempre es `true`.  
  
 Dado que son para todo el sistema, exclusiones mutuas con nombre se pueden utilizar para coordinar el uso de recursos en los límites del proceso.  
  
> [!NOTE]
>  En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad. Si su nombre empieza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server. Si su nombre empieza con el prefijo "Local\\", la exclusión mutua sólo es visible en la sesión de terminal server donde se creó. En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor. Si no especifica ningún prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\". Dentro de una sesión de servidor de terminal server, dos exclusiones mutuas cuyos nombres se diferencien sólo por sus prefijos son exclusiones mutuas independientes y ambos son visibles para todos los procesos en la sesión de servidor de terminal server. Es decir, los nombres de prefijo "Global\\" y "Local\\" describen el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 En el ejemplo siguiente se muestra cómo se utiliza una exclusión mutua con nombre para señalar los subprocesos que se ejecutan en dos procesos separados.  
  
 Ejecutar este programa desde dos o más ventanas de comandos. Cada proceso crea un <xref:System.Threading.Mutex> objeto que representa la exclusión mutua con nombre `MyMutex`. La exclusión mutua con nombre es un objeto de sistema cuya duración está limitada por las duraciones de los <xref:System.Threading.Mutex> objetos que se representan. La exclusión mutua con nombre se crea cuando el primer proceso crea su <xref:System.Threading.Mutex> objeto; en este ejemplo, la exclusión mutua con nombre es propiedad del primer proceso que ejecuta el programa. La exclusión mutua con nombre se destruye cuando todos los <xref:System.Threading.Mutex> objetos que representan se han liberado.  
  
 La sobrecarga de constructor utilizada en este ejemplo no puede indicar al subproceso que realiza la llamada si se ha concedido la propiedad inicial de la exclusión mutua con nombre. No debe usar este constructor para solicitar la propiedad inicial, a menos que esté seguro de que el subproceso va a crear la exclusión mutua con nombre.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</param>
        <param name="name">Nombre del objeto <see cref="T:System.Threading.Mutex" />. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
        <param name="createdNew">Cuando este método devuelve un resultado, contiene un valor booleano que es <see langword="true" /> si se ha creado una exclusión mutua local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se ha creado la exclusión mutua del sistema con nombre especificada; el valor es <see langword="false" /> si la exclusión mutua del sistema con nombre especificada ya existía. Este parámetro se pasa sin inicializar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua, una cadena que es el nombre de la exclusión mutua y un valor booleano que, cuando se devuelva el método, indicará si se concedió la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` no `null` y `initiallyOwned` es `true`, el subproceso que realiza la llamada posee la exclusión mutua con nombre solo si `createdNew` es `true` después de la llamada. En caso contrario, el subproceso puede solicitar la exclusión mutua mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.  
  
 Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre. Puede crear varias <xref:System.Threading.Mutex> los objetos que representan el mismo nombre exclusión mutua del sistema.  
  
 Si la exclusión mutua con nombre ya se ha creado con seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> derechos, que se produce una excepción. Para abrir una exclusión mutua con nombre con únicamente los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si se hubiera llamado el <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. En este caso, `createdNew` siempre es `true`.  
  
 Dado que son para todo el sistema, exclusiones mutuas con nombre se pueden utilizar para coordinar el uso de recursos en los límites del proceso.  
  
> [!NOTE]
>  En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad. Si su nombre empieza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server. Si su nombre empieza con el prefijo "Local\\", la exclusión mutua sólo es visible en la sesión de terminal server donde se creó. En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor. Si no especifica ningún prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\". Dentro de una sesión de servidor de terminal server, dos exclusiones mutuas cuyos nombres se diferencien sólo por sus prefijos son exclusiones mutuas independientes y ambos son visibles para todos los procesos en la sesión de servidor de terminal server. Es decir, los nombres de prefijo "Global\\" y "Local\\" describen el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se utiliza una exclusión mutua con nombre para señalar los distintos procesos o subprocesos. Ejecutar este programa desde dos o más ventanas de comandos. Cada proceso crea un <xref:System.Threading.Mutex> objeto que representa la exclusión mutua con nombre "MyMutex". La exclusión mutua con nombre es un objeto del sistema. En este ejemplo, su duración está limitado por las duraciones de los <xref:System.Threading.Mutex> objetos que se representan. La exclusión mutua con nombre se crea cuando el primer proceso crea su local <xref:System.Threading.Mutex> objeto y se destruye cuando todos los <xref:System.Threading.Mutex> objetos que representan se han liberado. El primer proceso posee inicialmente la exclusión mutua con nombre. El segundo proceso y todos los procesos posteriores esperan para que otros procesos anteriores liberar la exclusión mutua con nombre.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</param>
        <param name="name">Nombre de la exclusión mutua del sistema. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
        <param name="createdNew">Cuando este método devuelve un resultado, contiene un valor booleano que es <see langword="true" /> si se ha creado una exclusión mutua local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se ha creado la exclusión mutua del sistema con nombre especificada; el valor es <see langword="false" /> si la exclusión mutua del sistema con nombre especificada ya existía. Este parámetro se pasa sin inicializar.</param>
        <param name="mutexSecurity">Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad del control de acceso que se va a aplicar a la exclusión mutua del sistema con nombre.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua; una cadena que es el nombre de la exclusión mutua; una variable booleana que, cuando se devuelva el método, indicará si se le concedió la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada; y la seguridad del control de acceso que se va a aplicar a la exclusión mutua con nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` no `null` y `initiallyOwned` es `true`, el subproceso que realiza la llamada posee la exclusión mutua con nombre solo si `createdNew` es `true` después de la llamada. En caso contrario, el subproceso puede solicitar la exclusión mutua mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.  
  
 Utilice este constructor para aplicar la seguridad de control de acceso a una exclusión mutua del sistema con nombre cuando se crea, impide que otro código tome el control de la exclusión mutua.  
  
 Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre. Puede crear varias <xref:System.Threading.Mutex> los objetos que representan el mismo nombre exclusión mutua del sistema.  
  
 Si la exclusión mutua del sistema con nombre no existe, se crea con la seguridad de control de acceso especificada. Si la exclusión mutua con nombre existe, se omite la seguridad de control de acceso especificada.  
  
> [!NOTE]
>  El llamador tiene control total sobre el recién creado <xref:System.Threading.Mutex> objeto incluso si `mutexSecurity` deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual. Sin embargo, si el usuario actual intenta obtener otro <xref:System.Threading.Mutex> representar la misma exclusión mutua con nombre, utilizando un constructor de objeto o el <xref:System.Threading.Mutex.OpenExisting%2A> método, se aplica la seguridad de control de acceso de Windows.  
  
 Si la exclusión mutua con nombre ya se ha creado con seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, se produce una excepción. Para abrir una exclusión mutua con nombre con únicamente los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si se hubiera llamado el <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. En este caso, `createdNew` siempre es `true`.  
  
 Dado que son para todo el sistema, exclusiones mutuas con nombre se pueden utilizar para coordinar el uso de recursos en los límites del proceso.  
  
> [!NOTE]
>  En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad. Si su nombre empieza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server. Si su nombre empieza con el prefijo "Local\\", la exclusión mutua sólo es visible en la sesión de terminal server donde se creó. En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor. Si no especifica ningún prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\". Dentro de una sesión de servidor de terminal server, dos exclusiones mutuas cuyos nombres se diferencien sólo por sus prefijos son exclusiones mutuas independientes y ambos son visibles para todos los procesos en la sesión de servidor de terminal server. Es decir, los nombres de prefijo "Global\\" y "Local\\" describen el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.  
  
 Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad de control de acceso para la exclusión mutua con nombre.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad de control de acceso para la exclusión mutua con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Mutex.GetAccessControl%2A> método utiliza la siguiente combinación de indicadores (combinados mediante la operación OR bit a bit) para buscar los permisos: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, y <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 El usuario debe tener <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> llamar a este método y la exclusión mutua debe haberse abierto con <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos, usando la <xref:System.Threading.Mutex.GetAccessControl%2A> y <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.  
  
 Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El objeto <see cref="T:System.Threading.Mutex" /> actual representa una exclusión mutua del sistema con nombre, pero el usuario no dispone de derechos <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
 O bien  
  
 El objeto <see cref="T:System.Threading.Mutex" /> actual representa una exclusión mutua del sistema con nombre y no se abrió con derechos <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite para Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre una exclusión mutua con nombre especificada, si ya existe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la exclusión mutua del sistema que se va a abrir.</param>
        <summary>Abre la exclusión mutua con nombre especificada, si ya existe.</summary>
        <returns>Objeto que representa la exclusión mutua del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Mutex.OpenExisting%2A> método intenta abrir especificado con el nombre de exclusión mutua del sistema. Si la exclusión mutua del sistema no existe, este método produce una excepción en lugar de crear el objeto del sistema. Para crear la exclusión mutua del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tenga un `name` parámetro.  
  
 Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Mutex> objeto, incluso si los objetos devueltos representan la misma exclusión mutua del sistema con nombre.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.  
  
 Especificar el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso a la espera de la exclusión mutua y especificando el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 Este método no solicita la propiedad de la exclusión mutua.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.  
  
 Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
 O bien  
  
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">La excepción mutua con nombre no existe.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la exclusión mutua del sistema que se va a abrir.</param>
        <param name="rights">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</param>
        <summary>Abre la exclusión mutua con nombre especificada, si ya existe, con el acceso de seguridad deseado.</summary>
        <returns>Objeto que representa la exclusión mutua del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos a la espera de la exclusión mutua y el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> (método).  
  
 El <xref:System.Threading.Mutex.OpenExisting%2A> método intenta abrir una exclusión mutua con nombre existente. Si la exclusión mutua del sistema no existe, este método produce una excepción en lugar de crear el objeto del sistema. Para crear la exclusión mutua del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tenga un `name` parámetro.  
  
 Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Mutex> objeto, incluso si los objetos devueltos representan la misma exclusión mutua del sistema con nombre.  
  
 Este método no solicita la propiedad de la exclusión mutua.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.  
  
 Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
 O bien  
  
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">La excepción mutua con nombre no existe.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no dispone del acceso de seguridad deseado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera una vez la instancia de <see cref="T:System.Threading.Mutex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada vez que un subproceso adquiere una exclusión mutua (por ejemplo, mediante una llamada a su <xref:System.Threading.WaitHandle.WaitOne%2A> método), debe llamar posteriormente <xref:System.Threading.Mutex.ReleaseMutex%2A> para ceder la propiedad del mutex y desbloquear otro subproceso que intenta obtener la propiedad de la exclusión mutua. Si se produce un error al intentar obtener la propiedad del mutex (por ejemplo, cuando una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método con un `millisecondsTimeout` o un `timeout` parámetro devuelve `false` porque agota el tiempo de espera de la solicitud), el subproceso no debe llamar a <xref:System.Threading.Mutex.ReleaseMutex%2A>, en este caso, el subproceso debe también no puedan tener acceso al recurso protegido por la exclusión mutua, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Un subproceso que posee una exclusión mutua puede especificar la misma exclusión mutua en espera repetidas llamadas a funciones sin bloquear su ejecución. El número de llamadas se mantiene por common language runtime. El subproceso debe llamar a <xref:System.Threading.Mutex.ReleaseMutex%2A> el mismo número de veces para liberar la propiedad de la exclusión mutua.  
  
 Si un subproceso finaliza mientras posee una exclusión mutua, la exclusión mutua se considera abandonada. El estado de la exclusión mutua se establece en señalado y el siguiente subproceso en espera obtiene la propiedad. Si ninguna persona que posee la exclusión mutua, el estado de la exclusión mutua se señala. A partir de la versión 2.0 de .NET Framework, un <xref:System.Threading.AbandonedMutexException> se produce en el siguiente subproceso que adquiere la exclusión mutua. Antes de la versión 2.0 de .NET Framework, se inicia ninguna excepción.  
  
> [!CAUTION]
>  A menudo, un mutex abandonado indica un error grave en el código. Cuando un subproceso sale sin liberar la exclusión mutua, las estructuras de datos protegidas por el mutex no estén en un estado coherente. El siguiente subproceso que solicite la propiedad de la exclusión mutua puede controlar esta excepción y continuar si se puede comprobar la integridad de las estructuras de datos.  
  
 En el caso de una exclusión mutua en todo el sistema, una exclusión mutua abandonada podría indicar que una aplicación finalizó inesperadamente (por ejemplo, con el Administrador de tareas de Windows).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido. El subproceso que crea la exclusión mutua no posee la exclusión inicialmente. El <xref:System.Threading.Mutex.ReleaseMutex%2A> método se utiliza para liberar la exclusión mutua cuando ya no es necesario.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">El subproceso que realiza la llamada no posee la exclusión mutua.</exception>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad del control de acceso que se va a aplicar a la exclusión mutua del sistema con nombre.</param>
        <summary>Establece la seguridad de control de acceso para una exclusión mutua del sistema con nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe tener <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> derechos para llamar a este método y la exclusión mutua deben haberse abiertos con <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos, usando la <xref:System.Threading.Mutex.GetAccessControl%2A> y <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.  
  
 Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no dispone de permisos <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
 O bien  
  
 La exclusión mutua no se abrió con permisos <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">El objeto <see cref="T:System.Threading.Mutex" /> actual no representa una exclusión mutua del sistema con nombre.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre una exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la exclusión mutua del sistema que se va a abrir.</param>
        <param name="result">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <see langword="null" /> si se produjo un error en la llamada. Este parámetro se trata como sin inicializar.</param>
        <summary>Abre la exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
        <returns>
          <see langword="true" /> si la exclusión mutua con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la exclusión mutua con nombre no existe, este método no la crea. Para crear la exclusión mutua del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tenga un `name` parámetro.  
  
 Si no está seguro de si existe una exclusión mutua con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método que produce una excepción si la exclusión mutua no existe.  
  
 Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Mutex> objeto, incluso si los objetos devueltos representan la misma exclusión mutua del sistema con nombre.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit. Especificar el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso a la espera de la exclusión mutua y especificando el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 Este método no solicita la propiedad de la exclusión mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
 O bien  
  
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la exclusión mutua del sistema que se va a abrir.</param>
        <param name="rights">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</param>
        <param name="result">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <see langword="null" /> si se produjo un error en la llamada. Este parámetro se trata como sin inicializar.</param>
        <summary>Abre la exclusión mutua con nombre especificada, si ya existe, con el acceso de seguridad deseado y devuelve un valor que indica si la operación se realizó correctamente.</summary>
        <returns>
          <see langword="true" /> si la exclusión mutua con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la exclusión mutua con nombre no existe, este método no la crea. Para crear la exclusión mutua del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tenga un `name` parámetro.  
  
 Si no está seguro de si existe una exclusión mutua con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método que produce una excepción si la exclusión mutua no existe.  
  
 El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos a la espera de la exclusión mutua y el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> (método).  
  
 Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.Mutex> objeto, incluso si los objetos devueltos representan la misma exclusión mutua del sistema con nombre.  
  
 Este método no solicita la propiedad de la exclusión mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
 O bien  
  
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>