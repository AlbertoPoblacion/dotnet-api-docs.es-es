<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7de03c355dd0d74e383476a827f9b04199da1cf4" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48748915" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Primitiva de sincronización que puede usarse también para la sincronización entre procesos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando dos o más subprocesos deben tener acceso a un recurso compartido al mismo tiempo, el sistema necesita un mecanismo de sincronización para asegurarse de que solo un subproceso a la vez usa el recurso. <xref:System.Threading.Mutex> es una sincronización primitiva que concede acceso exclusivo al recurso compartido a un solo subproceso. Si un subproceso adquiere una exclusión mutua, el segundo subproceso que desea adquirir la exclusión mutua del que se suspende hasta que el primer subproceso libera la exclusión mutua.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 Puede usar el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método para solicitar la propiedad de una exclusión mutua. El subproceso que realiza la llamada se bloquea hasta que se produzca uno de los siguientes:  
  
-   La exclusión mutua se señala para indicar que no pertenece. Cuando esto sucede, el <xref:System.Threading.WaitHandle.WaitOne%2A> devuelve del método `true`, y el subproceso de llamada asume la propiedad de la exclusión mutua y accede al recurso protegido por la exclusión mutua. Cuando haya terminado de obtener acceso al recurso, el subproceso debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar la propiedad de la exclusión mutua. El primer ejemplo en la sección de ejemplos muestra este modelo.  
  
-   El intervalo de tiempo de espera especificado en la llamada a un <xref:System.Threading.WaitHandle.WaitOne%2A> método que tiene un `millisecondsTimeout` o `timeout` parámetro ha transcurrido. Cuando esto sucede, el <xref:System.Threading.WaitHandle.WaitOne%2A> devuelve del método `false`, y el subproceso que realiza la llamada realiza ningún intento adicional para adquirir posesión de la exclusión mutua. En este caso, debe estructurar el código para que se deniega el acceso al recurso protegido por la exclusión mutua al subproceso que realiza la llamada. Dado que el subproceso nunca haya adquirido la propiedad de la exclusión mutua, no debe llamar el <xref:System.Threading.Mutex.ReleaseMutex%2A> método. El segundo ejemplo en la sección de ejemplos muestra este modelo.  
  
 La <xref:System.Threading.Mutex> clase exige la identidad del subproceso, por lo que se puede liberar una exclusión mutua sólo por el subproceso que lo adquirió. Por el contrario, el <xref:System.Threading.Semaphore> clase no exige la identidad del subproceso. Una exclusión mutua también se puede pasar entre los límites del dominio de aplicación.  
  
 El subproceso que posee una exclusión mutua puede solicitar la misma exclusión mutua en llamadas repetidas a <xref:System.Threading.WaitHandle.WaitOne%2A> sin bloquear su ejecución. Sin embargo, el subproceso debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método el mismo número de veces para liberar la propiedad de la exclusión mutua.  
  
 Dado que el <xref:System.Threading.Mutex> clase hereda de <xref:System.Threading.WaitHandle>, también se puede llamar a estático <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> y <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos para sincronizar el acceso a un recurso protegido.  
  
 Si un subproceso finaliza mientras posee una exclusión mutua, se dice que la exclusión mutua abandonada. El estado de la exclusión mutua se establece en señalado y el siguiente subproceso en espera obtiene la propiedad. A partir de la versión 2.0 de .NET Framework, un <xref:System.Threading.AbandonedMutexException> se produce en el subproceso siguiente que adquiere la exclusión mutua abandonada. Antes de la versión 2.0 de .NET Framework, se produjo ninguna excepción.  
  
> [!CAUTION]
>  A menudo, un mutex abandonado indica un error grave en el código. Cuando un subproceso sale sin liberar la exclusión mutua, las estructuras de datos protegidas por el mutex no esté en un estado coherente. El siguiente subproceso que solicita la propiedad de la exclusión mutua puede controlar esta excepción y continuar si se puede comprobar la integridad de las estructuras de datos.  
  
 En el caso de una exclusión mutua en todo el sistema, una exclusión mutua abandonada podría indicar que una aplicación finalizó inesperadamente (por ejemplo, con el Administrador de tareas de Windows).  
  
 Las exclusiones mutuas son de dos tipos: exclusiones mutuas locales, que son y sin nombre exclusiones mutuas del sistema. Una exclusión mutua local solo existe dentro del proceso. Se puede usar cualquier subproceso del proceso que tenga una referencia a la <xref:System.Threading.Mutex> objeto que representa la exclusión mutua. Cada uno sin nombre <xref:System.Threading.Mutex> objeto representa una exclusión mutua local independiente.  
  
 Las exclusiones mutuas son visibles en todo el sistema operativo y pueden utilizarse para sincronizar las actividades de procesos de sistema con nombre. Puede crear un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre mediante un constructor que acepta un nombre. Se puede crear el objeto del sistema operativo al mismo tiempo, o puede existir antes de la creación de la <xref:System.Threading.Mutex> objeto. Puede crear varios objetos <xref:System.Threading.Mutex> que representen la misma exclusión mutua del sistema con nombre y puede usar el método <xref:System.Threading.Mutex.OpenExisting%2A> para abrir una exclusión mutua del sistema con nombre existente.  
  
> [!NOTE]
>  En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad. Si su nombre comienza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server. Si su nombre comienza con el prefijo "Local\\", la exclusión mutua solo es visible en la sesión de terminal server donde se creó. En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor. Si no especifica un prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\". Dentro de una sesión de terminal server, dos exclusiones mutuas cuyos nombres difieren solo por sus prefijos son independientes de las exclusiones mutuas y ambos son visibles para todos los procesos en la sesión de terminal server. Es decir, los nombres de prefijo "Global\\" y "Local\\" describe el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Este ejemplo se muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido. Dado que cada subproceso que realiza la llamada se bloquea hasta que obtiene la propiedad de la exclusión mutua, debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar la propiedad del subproceso.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 En el ejemplo siguiente, cada subproceso llama a la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> método para adquirir la exclusión mutua. Si transcurre el intervalo de tiempo de espera, el método devuelve `false`, y el subproceso no adquiere la exclusión mutua ni obtiene acceso al recurso que protege la exclusión mutua. El <xref:System.Threading.Mutex.ReleaseMutex%2A> se llama al método sólo por el subproceso que adquiere la exclusión mutua.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con propiedades predeterminadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a esta sobrecarga del constructor es igual que llamar a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> sobrecarga de constructor y especificando `false` para la propiedad inicial de la exclusión mutua. Es decir, el subproceso que realiza la llamada no posee la exclusión mutua.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido. El subproceso que crea la exclusión mutua no posee lo inicialmente.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> para otorgar la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada, en caso contrario, <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido. El subproceso que crea el <xref:System.Threading.Mutex> inicialmente lo posee.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si ésta se crea como resultado de dicha llamada; en caso contrario, <see langword="false" />.</param>
        <param name="name">Nombre del objeto <see cref="T:System.Threading.Mutex" />. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua, y una cadena que representa el nombre de la exclusión mutua.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` no `null` y `initiallyOwned` es `true`, el subproceso de llamada posee la exclusión mutua sólo si la exclusión mutua del sistema con nombre se creó como resultado de esta llamada. Dado que no hay ningún mecanismo para determinar si se creó la exclusión mutua del sistema con nombre, es mejor especificar `false` para `initiallyOwned` al llamar a esta sobrecarga del constructor. Puede usar el <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor si tiene que determinar la propiedad inicial.  
  
 Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre. Puede crear varias <xref:System.Threading.Mutex> objetos que representan el mismo nombre de exclusión mutua del sistema.  
  
 Si la exclusión mutua con nombre ya se ha creado con la seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, se produce una excepción. Para abrir una exclusión mutua con nombre sólo con los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si hubiera llamado a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. En este caso, `createdNew` siempre `true`.  
  
 Dado que todo el sistema, exclusiones mutuas pueden utilizarse para coordinar el uso de recursos a través de los límites del proceso.  
  
> [!NOTE]
>  En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad. Si su nombre comienza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server. Si su nombre comienza con el prefijo "Local\\", la exclusión mutua solo es visible en la sesión de terminal server donde se creó. En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor. Si no especifica un prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\". Dentro de una sesión de terminal server, dos exclusiones mutuas cuyos nombres difieren solo por sus prefijos son independientes de las exclusiones mutuas y ambos son visibles para todos los procesos en la sesión de terminal server. Es decir, los nombres de prefijo "Global\\" y "Local\\" describe el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 El ejemplo siguiente muestra cómo se usa una exclusión mutua con nombre para señalar los subprocesos que se ejecutan en dos procesos separados.  
  
 Ejecutar este programa desde dos o más ventanas de comandos. Cada proceso crea un <xref:System.Threading.Mutex> objeto que representa la exclusión mutua con nombre `MyMutex`. La exclusión mutua con nombre es un objeto de sistema cuya duración está limitada por la duración de la <xref:System.Threading.Mutex> objetos que representan a él. La exclusión mutua con nombre se crea cuando el primer proceso crea su <xref:System.Threading.Mutex> objeto; en este ejemplo, la exclusión mutua con nombre es propiedad del primer proceso que ejecuta el programa. La exclusión mutua con nombre se destruye cuando todas la <xref:System.Threading.Mutex> objetos que representan lo que se han liberado.  
  
 En este ejemplo utilizada la sobrecarga del constructor no puede determinar el subproceso que realiza la llamada si se ha concedido la propiedad inicial de la exclusión mutua con nombre. No debe utilizar este constructor para solicitar la propiedad inicial a menos que puede estar seguro de que el subproceso va a crear la exclusión mutua con nombre.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe y dispone de seguridad de control de acceso, pero el usuario no dispone de derechos <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear la exclusión mutua con nombre; posiblemente porque un identificador de espera de otro tipo tiene el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si ésta se crea como resultado de dicha llamada; en caso contrario, <see langword="false" />.</param>
        <param name="name">Nombre del objeto <see cref="T:System.Threading.Mutex" />. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
        <param name="createdNew">Cuando este método devuelve un resultado, contiene un valor booleano que es <see langword="true" /> si se ha creado una exclusión mutua local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se ha creado la exclusión mutua del sistema con nombre especificada; el valor es <see langword="false" /> si la exclusión mutua del sistema con nombre especificada ya existía. Este parámetro se pasa sin inicializar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua, una cadena que es el nombre de la exclusión mutua y un valor booleano que, cuando se devuelva el método, indicará si se le ha concedido la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` no `null` y `initiallyOwned` es `true`, el subproceso que realiza la llamada posee la exclusión mutua con nombre sólo si `createdNew` es `true` después de la llamada. En caso contrario, el subproceso puede solicitar la exclusión mutua mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.  
  
 Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre. Puede crear varias <xref:System.Threading.Mutex> objetos que representan el mismo nombre de exclusión mutua del sistema.  
  
 Si la exclusión mutua con nombre ya se ha creado con la seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> derechos, que se produce una excepción. Para abrir una exclusión mutua con nombre sólo con los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si hubiera llamado a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. En este caso, `createdNew` siempre `true`.  
  
 Dado que todo el sistema, exclusiones mutuas pueden utilizarse para coordinar el uso de recursos a través de los límites del proceso.  
  
> [!NOTE]
>  En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad. Si su nombre comienza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server. Si su nombre comienza con el prefijo "Local\\", la exclusión mutua solo es visible en la sesión de terminal server donde se creó. En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor. Si no especifica un prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\". Dentro de una sesión de terminal server, dos exclusiones mutuas cuyos nombres difieren solo por sus prefijos son independientes de las exclusiones mutuas y ambos son visibles para todos los procesos en la sesión de terminal server. Es decir, los nombres de prefijo "Global\\" y "Local\\" describe el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 El ejemplo de código siguiente muestra cómo se usa una exclusión mutua con nombre para señalar entre procesos o subprocesos. Ejecutar este programa desde dos o más ventanas de comandos. Cada proceso crea un <xref:System.Threading.Mutex> objeto que representa la exclusión mutua con nombre "MyMutex". La exclusión mutua con nombre es un objeto del sistema. En este ejemplo, su duración está limitada por la duración de la <xref:System.Threading.Mutex> objetos que representan a él. La exclusión mutua con nombre se crea cuando el primer proceso crea su local <xref:System.Threading.Mutex> objeto y se destruye cuando todas la <xref:System.Threading.Mutex> objetos que representan lo que se han liberado. El primer proceso posee inicialmente la exclusión mutua con nombre. El segundo proceso y todos los procesos posteriores esperan procesos anteriores liberar la exclusión mutua con nombre.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe y dispone de seguridad de control de acceso, pero el usuario no dispone de derechos <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear la exclusión mutua con nombre; posiblemente porque un identificador de espera de otro tipo tiene el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si ésta se crea como resultado de dicha llamada; en caso contrario, <see langword="false" />.</param>
        <param name="name">Nombre de la exclusión mutua del sistema. Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</param>
        <param name="createdNew">Cuando este método devuelve un resultado, contiene un valor booleano que es <see langword="true" /> si se ha creado una exclusión mutua local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se ha creado la exclusión mutua del sistema con nombre especificada; el valor es <see langword="false" /> si la exclusión mutua del sistema con nombre especificada ya existía. Este parámetro se pasa sin inicializar.</param>
        <param name="mutexSecurity">Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad del control de acceso que se va a aplicar a la exclusión mutua del sistema con nombre.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua, una cadena que es el nombre de la exclusión mutua y una variable booleana que, cuando se devuelva el método, indicará si se le ha concedido la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` no `null` y `initiallyOwned` es `true`, el subproceso que realiza la llamada posee la exclusión mutua con nombre sólo si `createdNew` es `true` después de la llamada. En caso contrario, el subproceso puede solicitar la exclusión mutua mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.  
  
 Utilice este constructor para aplicar la seguridad de control de acceso a una exclusión mutua del sistema con nombre cuando se crea, impide que otro código tome el control de la exclusión mutua.  
  
 Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre. Puede crear varias <xref:System.Threading.Mutex> objetos que representan el mismo nombre de exclusión mutua del sistema.  
  
 Si la exclusión mutua del sistema con nombre no existe, se crea con la seguridad de control de acceso especificada. Si la exclusión mutua con nombre existe, se omite la seguridad de control de acceso especificada.  
  
> [!NOTE]
>  El llamador tiene control total sobre el recién creado <xref:System.Threading.Mutex> objeto incluso si `mutexSecurity` deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual. Sin embargo, si el usuario actual intenta obtener otro <xref:System.Threading.Mutex> representar la misma exclusión mutua con nombre, ya sea mediante un constructor de objeto o el <xref:System.Threading.Mutex.OpenExisting%2A> método, se aplica la seguridad de control de acceso de Windows.  
  
 Si la exclusión mutua con nombre ya se ha creado con la seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, se produce una excepción. Para abrir una exclusión mutua con nombre sólo con los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si hubiera llamado a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor. En este caso, `createdNew` siempre `true`.  
  
 Dado que todo el sistema, exclusiones mutuas pueden utilizarse para coordinar el uso de recursos a través de los límites del proceso.  
  
> [!NOTE]
>  En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad. Si su nombre comienza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server. Si su nombre comienza con el prefijo "Local\\", la exclusión mutua solo es visible en la sesión de terminal server donde se creó. En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor. Si no especifica un prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\". Dentro de una sesión de terminal server, dos exclusiones mutuas cuyos nombres difieren solo por sus prefijos son independientes de las exclusiones mutuas y ambos son visibles para todos los procesos en la sesión de terminal server. Es decir, los nombres de prefijo "Global\\" y "Local\\" describe el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se ha producido un error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad de control de acceso para la exclusión mutua con nombre.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad de control de acceso para la exclusión mutua con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Mutex.GetAccessControl%2A> método utiliza la siguiente combinación de indicadores (combinados con la operación OR bit a bit) para buscar los permisos: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, y <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 El usuario debe tener <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> llamar a este método y la exclusión mutua debe haberse abierto con <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos, mediante el <xref:System.Threading.Mutex.GetAccessControl%2A> y <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.  
  
 Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El objeto <see cref="T:System.Threading.Mutex" /> actual representa una exclusión mutua del sistema con nombre, pero el usuario no dispone de derechos <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
O bien 
El objeto <see cref="T:System.Threading.Mutex" /> actual representa una exclusión mutua del sistema con nombre y no se abrió con derechos <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite para Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre una exclusión mutua con nombre especificada, si ya existe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la mutua del sistema que se va a abrir.</param>
        <summary>Abre la exclusión mutua con nombre especificada, si ya existe.</summary>
        <returns>Objeto que representa la exclusión mutua del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Mutex.OpenExisting%2A> método intenta abrir especificado con el nombre de exclusión mutua del sistema. Si la exclusión mutua del sistema no existe, este método produce una excepción en lugar de crear el objeto del sistema. Para crear la exclusión mutua del sistema cuando no existe, use uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Mutex> objeto, aunque los objetos devueltos representan la misma exclusión mutua del sistema con nombre.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.  
  
 Especificar el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso espere en la exclusión mutua y especificando el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 Este método no solicitar la propiedad de la exclusión mutua.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">La excepción mutua con nombre no existe.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no dispone del acceso de seguridad exigido para utilizarla.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la mutua del sistema que se va a abrir.</param>
        <param name="rights">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</param>
        <summary>Abre la exclusión mutua con nombre especificada, si ya existe, con el acceso de seguridad deseado.</summary>
        <returns>Objeto que representa la exclusión mutua del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos esperen en la exclusión mutua y el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 El <xref:System.Threading.Mutex.OpenExisting%2A> método intenta abrir una exclusión mutua con nombre existente. Si la exclusión mutua del sistema no existe, este método produce una excepción en lugar de crear el objeto del sistema. Para crear la exclusión mutua del sistema cuando no existe, use uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Mutex> objeto, aunque los objetos devueltos representan la misma exclusión mutua del sistema con nombre.  
  
 Este método no solicitar la propiedad de la exclusión mutua.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">La excepción mutua con nombre no existe.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no dispone del acceso de seguridad deseado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera <see cref="T:System.Threading.Mutex" /> una sola vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada vez que un subproceso adquiere una exclusión mutua (por ejemplo, mediante una llamada a su <xref:System.Threading.WaitHandle.WaitOne%2A> método), debe llamar posteriormente a <xref:System.Threading.Mutex.ReleaseMutex%2A> para ceder la propiedad de la exclusión mutua y desbloquear los otros subprocesos que intentan obtener la propiedad de la exclusión mutua. Si se produce un error al intentar obtener la propiedad de la exclusión mutua (por ejemplo, cuando una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método con un `millisecondsTimeout` o un `timeout` parámetro devuelve `false` porque la solicitud agota el tiempo), el subproceso no debería llamar a <xref:System.Threading.Mutex.ReleaseMutex%2A>, en este caso, el subproceso también no debería poder tener acceso al recurso protegido por la exclusión mutua, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Un subproceso que posee una exclusión mutua puede especificar la misma exclusión mutua en espera repetidas llamadas a funciones sin bloquear su ejecución. El número de llamadas se mantiene por common language runtime. El subproceso debe llamar a <xref:System.Threading.Mutex.ReleaseMutex%2A> el mismo número de veces para liberar la propiedad de la exclusión mutua.  
  
 Si un subproceso finaliza mientras posee una exclusión mutua, se dice que la exclusión mutua abandonada. El estado de la exclusión mutua se establece en señalado y el siguiente subproceso en espera obtiene la propiedad. Si nadie posee la exclusión mutua, el estado de la exclusión mutua se señala. A partir de la versión 2.0 de .NET Framework, un <xref:System.Threading.AbandonedMutexException> se produce en el subproceso siguiente que adquiere la exclusión mutua. Antes de la versión 2.0 de .NET Framework, se produjo ninguna excepción.  
  
> [!CAUTION]
>  A menudo, un mutex abandonado indica un error grave en el código. Cuando un subproceso sale sin liberar la exclusión mutua, las estructuras de datos protegidas por el mutex no esté en un estado coherente. El siguiente subproceso que solicita la propiedad de la exclusión mutua puede controlar esta excepción y continuar si se puede comprobar la integridad de las estructuras de datos.  
  
 En el caso de una exclusión mutua en todo el sistema, una exclusión mutua abandonada podría indicar que una aplicación finalizó inesperadamente (por ejemplo, con el Administrador de tareas de Windows).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido. El subproceso que crea la exclusión mutua no posee lo inicialmente. El <xref:System.Threading.Mutex.ReleaseMutex%2A> método se utiliza para liberar la exclusión mutua cuando ya no es necesaria.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">El subproceso que realiza la llamada no posee la exclusión mutua.</exception>
        <exception cref="T:System.ObjectDisposedException">La instancia actual ya se ha eliminado.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad del control de acceso que se va a aplicar a la exclusión mutua del sistema con nombre.</param>
        <summary>Establece la seguridad de control de acceso para una exclusión mutua del sistema con nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe tener <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> derechos para llamar a este método y la exclusión mutua deben haberse abiertos con <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.  
  
 Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos, mediante el <xref:System.Threading.Mutex.GetAccessControl%2A> y <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.  
  
 Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no dispone de permisos <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
O bien 
La exclusión mutua no se abrió con permisos <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">El objeto <see cref="T:System.Threading.Mutex" /> actual no representa una exclusión mutua del sistema con nombre.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre una exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la mutua del sistema que se va a abrir.</param>
        <param name="result">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <see langword="null" /> si se produjo un error en la llamada. Este parámetro se trata como sin inicializar.</param>
        <summary>Abre la exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
        <returns>
          <see langword="true" /> si la exclusión mutua con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la exclusión mutua con nombre no existe, este método no la crea. Para crear la exclusión mutua del sistema cuando no existe, use uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Si no está seguro de si existe una exclusión mutua con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método que produce una excepción si la exclusión mutua no existe.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Mutex> objeto, aunque los objetos devueltos representan la misma exclusión mutua del sistema con nombre.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit. Especificar el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso espere en la exclusión mutua y especificando el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 Este método no solicitar la propiedad de la exclusión mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no dispone del acceso de seguridad exigido para utilizarla.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la mutua del sistema que se va a abrir.</param>
        <param name="rights">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</param>
        <param name="result">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <see langword="null" /> si se produjo un error en la llamada. Este parámetro se trata como sin inicializar.</param>
        <summary>Abre la exclusión mutua con nombre especificada, si ya existe, con el acceso de seguridad deseado, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
        <returns>
          <see langword="true" /> si la exclusión mutua con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la exclusión mutua con nombre no existe, este método no la crea. Para crear la exclusión mutua del sistema cuando no existe, use uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Si no está seguro de si existe una exclusión mutua con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método que produce una excepción si la exclusión mutua no existe.  
  
 El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos esperen en la exclusión mutua y el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Mutex> objeto, aunque los objetos devueltos representan la misma exclusión mutua del sistema con nombre.  
  
 Este método no solicitar la propiedad de la exclusión mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La exclusión mutua con nombre existe, pero el usuario no dispone del acceso de seguridad exigido para utilizarla.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>