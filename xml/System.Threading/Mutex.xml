<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Mutex.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac56bce0feaf14f66f8608164cfa777620d7f3b329f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6bce0feaf14f66f8608164cfa777620d7f3b329f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>A synchronization primitive that can also be used for interprocess synchronization.</source>
          <target state="translated">Primitiva de sincronización que puede usarse también para la sincronización entre procesos.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</source>
          <target state="translated">Cuando dos o más subprocesos deben tener acceso a un recurso compartido al mismo tiempo, el sistema necesita un mecanismo de sincronización para asegurarse de que solo un subproceso a la vez utiliza el recurso.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> es una sincronización primitiva que conceda acceso exclusivo al recurso compartido a un solo subproceso.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</source>
          <target state="translated">Si un subproceso adquiere una exclusión mutua, el segundo subproceso que desea adquirir dicha exclusión mutua se suspende hasta que el primer subproceso libera la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Este tipo implementa la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Para deshacerse del tipo directamente, llame a su <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> método en un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloque.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Para deshacerse de él indirectamente, use una construcción de lenguaje como <ph id="ph1">`using`</ph> (en C#) o <ph id="ph2">`Using`</ph> (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> tema de la interfaz.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method to request ownership of a mutex.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> método que solicite la propiedad de una exclusión mutua.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The calling thread blocks until one of the following occurs:</source>
          <target state="translated">El subproceso que realiza la llamada se bloquea hasta que se produzca uno de los siguientes:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The mutex is signaled to indicate that it is not owned.</source>
          <target state="translated">La exclusión mutua se señala para indicar que no pertenece.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`true`</ph>, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</source>
          <target state="translated">Cuando esto sucede, el <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método <ph id="ph2">`true`</ph>, y el subproceso que realiza la llamada asume la propiedad de la exclusión mutua y tiene acceso al recurso protegido por la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When it has finished accessing the resource, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the mutex.</source>
          <target state="translated">Cuando ha terminado de obtener acceso al recurso, el subproceso debe llamar a la <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> método para liberar la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The first example in the Examples section illustrates this pattern.</source>
          <target state="translated">El primer ejemplo en la sección de ejemplos muestra este patrón.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The time-out interval specified in the call to a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method that has a <ph id="ph2">`millisecondsTimeout`</ph> or <ph id="ph3">`timeout`</ph> parameter has elapsed.</source>
          <target state="translated">El intervalo de tiempo de espera especificado en la llamada a un <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método que tiene un <ph id="ph2">`millisecondsTimeout`</ph> o <ph id="ph3">`timeout`</ph> parámetro ha transcurrido.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When this happens, the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id="ph2">`false`</ph>, and the calling thread makes no further attempt to acquire ownership of the mutex.</source>
          <target state="translated">Cuando esto sucede, el <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método <ph id="ph2">`false`</ph>, y el subproceso que realiza la llamada no realizará ningún intento adicional para adquirir la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</source>
          <target state="translated">En este caso, debe estructurar el código para que se deniega el acceso al recurso que está protegido por la exclusión mutua al subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the thread never acquired ownership of the mutex, it must not call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Dado que el subproceso haya adquirido nunca la propiedad del mutex, no deben llamar el <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The second example in the Examples section illustrates this pattern.</source>
          <target state="translated">El segundo ejemplo en la sección de ejemplos muestra este modelo.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> clase exige la identidad del subproceso, por lo que se pueden liberar una exclusión mutua solo por el subproceso que lo adquirió.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>By contrast, the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity.</source>
          <target state="translated">Por el contrario, la <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> clase no exige la identidad del subproceso.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A mutex can also be passed across application domain boundaries.</source>
          <target state="translated">Una exclusión mutua también se puede pasar a través de los límites del dominio de aplicación.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The thread that owns a mutex can request the same mutex in repeated calls to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> without blocking its execution.</source>
          <target state="translated">El subproceso que posee una exclusión mutua puede solicitar la misma exclusión mutua en llamadas repetidas a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> sin bloquear su ejecución.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>However, the thread must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method the same number of times to release ownership of the mutex.</source>
          <target state="translated">Sin embargo, el subproceso debe llamar a la <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> método el mismo número de veces para liberar la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> class inherits from <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, you can also call the static <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> methods to synchronize access to a protected resource.</source>
          <target state="translated">Dado que la <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> clase hereda de <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph>, también puede llamar el método estático <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph4">&lt;xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType&gt;</ph> métodos para sincronizar el acceso a un recurso protegido.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">Si un subproceso finaliza mientras posee una exclusión mutua, la exclusión mutua se considera abandonada.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The state of the mutex is set to signaled, and the next waiting thread gets ownership.</source>
          <target state="translated">El estado de la exclusión mutua se establece en señalado y el siguiente subproceso en espera obtiene la propiedad.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the abandoned mutex.</source>
          <target state="translated">A partir de la versión 2.0 de .NET Framework, un <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> se produce en el siguiente subproceso que adquiere la exclusión mutua abandonada.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Before version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">Antes de la versión 2.0 de .NET Framework, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">A menudo, un mutex abandonado indica un error grave en el código.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">Cuando un subproceso sale sin liberar la exclusión mutua, las estructuras de datos protegidas por el mutex no estén en un estado coherente.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">El siguiente subproceso que solicite la propiedad de la exclusión mutua puede controlar esta excepción y continuar si se puede comprobar la integridad de las estructuras de datos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">En el caso de una exclusión mutua en todo el sistema, una exclusión mutua abandonada podría indicar que una aplicación finalizó inesperadamente (por ejemplo, con el Administrador de tareas de Windows).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</source>
          <target state="translated">Las exclusiones mutuas son de dos tipos: exclusiones mutuas locales, sin nombre y con nombre exclusiones mutuas del sistema.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>A local mutex exists only within your process.</source>
          <target state="translated">Una exclusión mutua local solo existe dentro del proceso.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>It can be used by any thread in your process that has a reference to the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the mutex.</source>
          <target state="translated">Se puede utilizar con cualquier subproceso en el proceso que tiene una referencia a la <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto que representa la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Each unnamed <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object represents a separate local mutex.</source>
          <target state="translated">Cada uno de ellos sin nombre <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto representa una exclusión mutua local independiente.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">Las exclusiones mutuas son visibles en todo el sistema operativo y pueden utilizarse para sincronizar las actividades de procesos de sistema con nombre.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex by using a constructor that accepts a name.</source>
          <target state="translated">Puede crear un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto que representa una exclusión mutua del sistema con nombre mediante un constructor que acepta un nombre.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The operating-system object can be created at the same time, or it can exist before the creation of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object.</source>
          <target state="translated">Se puede crear el objeto de sistema operativo al mismo tiempo, o puede existir antes de la creación de la <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex, and you can use the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method to open an existing named system mutex.</source>
          <target state="translated">Puede crear varios objetos <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> que representen la misma exclusión mutua del sistema con nombre y puede usar el método <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> para abrir una exclusión mutua del sistema con nombre existente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Si su nombre empieza con el prefijo "Global<ph id="ph1">\\</ph>", la exclusión mutua está visible en todas las sesiones de terminal server.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Si su nombre empieza con el prefijo "Local<ph id="ph1">\\</ph>", la exclusión mutua sólo es visible en la sesión de terminal server donde se creó.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Si no especifica ningún prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">Dentro de una sesión de servidor de terminal server, dos exclusiones mutuas cuyos nombres se diferencien sólo por sus prefijos son exclusiones mutuas independientes y ambos son visibles para todos los procesos en la sesión de servidor de terminal server.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Es decir, los nombres de prefijo "Global<ph id="ph1">\\</ph>" y "Local<ph id="ph2">\\</ph>" describen el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">Este ejemplo se muestra cómo una variable local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto se usa para sincronizar el acceso a un recurso protegido.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method to release ownership of the thread.</source>
          <target state="translated">Dado que cada subproceso que realiza la llamada se bloquea hasta que adquiere la propiedad del mutex, debe llamar a la <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> método para liberar la propiedad del subproceso.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>In the following example, each thread calls the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> method to acquire the mutex.</source>
          <target state="translated">En el ejemplo siguiente, cada subproceso llama a la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29&gt;</ph> método para adquirir la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>If the time-out interval elapses, the method returns <ph id="ph1">`false`</ph>, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</source>
          <target state="translated">Si transcurre el intervalo de tiempo de espera, el método devuelve <ph id="ph1">`false`</ph>, y el subproceso no adquiere la exclusión mutua ni obtiene acceso al recurso que protege la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is called only by the thread that acquires the mutex.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> método se llama solo por el subproceso que adquiere la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Mutex">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo es seguro para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with default properties.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> con propiedades predeterminadas.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>Calling this constructor overload is the same as calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor overload and specifying <ph id="ph2">`false`</ph> for initial ownership of the mutex.</source>
          <target state="translated">Llamar a esta sobrecarga del constructor es igual que llamar a la <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> sobrecarga de constructor y especificando <ph id="ph2">`false`</ph> para la propiedad inicial de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>That is, the calling thread does not own the mutex.</source>
          <target state="translated">Es decir, el subproceso que realiza la llamada no posee la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">El siguiente ejemplo de código muestra cómo una variable local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto se usa para sincronizar el acceso a un recurso protegido.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">El subproceso que crea la exclusión mutua no posee la exclusión inicialmente.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the mutex; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para otorgar la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada, en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The following code example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">El siguiente ejemplo de código muestra cómo una variable local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto se usa para sincronizar el acceso a un recurso protegido.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean)">
          <source>The thread that creates the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> owns it initially.</source>
          <target state="translated">El subproceso que crea el <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> posee la exclusión inicialmente.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          <target state="translated">Nombre del objeto <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Si el valor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> no tiene nombre.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua y una cadena que representa el nombre de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> no <ph id="ph2">`null`</ph> y <ph id="ph3">`initiallyOwned`</ph> es <ph id="ph4">`true`</ph>, el subproceso que realiza la llamada posee la exclusión mutua sólo si la exclusión mutua del sistema con nombre se creó como resultado de esta llamada.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <ph id="ph1">`false`</ph> for <ph id="ph2">`initiallyOwned`</ph> when calling this constructor overload.</source>
          <target state="translated">Puesto que no hay ningún mecanismo para determinar si se creó la exclusión mutua del sistema con nombre, es mejor especificar <ph id="ph1">`false`</ph> para <ph id="ph2">`initiallyOwned`</ph> al llamar a esta sobrecarga del constructor.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor if you need to determine initial ownership.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor si tiene que determinar la propiedad inicial.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Este constructor inicializa un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto que representa una exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Puede crear varias <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> los objetos que representan el mismo nombre exclusión mutua del sistema.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Si la exclusión mutua con nombre ya se ha creado con seguridad de control de acceso y el llamador no tiene <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Para abrir una exclusión mutua con nombre con únicamente los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Si especifica <ph id="ph1">`null`</ph> o una cadena vacía para <ph id="ph2">`name`</ph>, se crea una exclusión mutua local, como si se hubiera llamado el <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">En este caso, <ph id="ph1">`createdNew`</ph> siempre es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Dado que son para todo el sistema, exclusiones mutuas con nombre se pueden utilizar para coordinar el uso de recursos en los límites del proceso.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Si su nombre empieza con el prefijo "Global<ph id="ph1">\\</ph>", la exclusión mutua está visible en todas las sesiones de terminal server.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Si su nombre empieza con el prefijo "Local<ph id="ph1">\\</ph>", la exclusión mutua sólo es visible en la sesión de terminal server donde se creó.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Si no especifica ningún prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">Dentro de una sesión de servidor de terminal server, dos exclusiones mutuas cuyos nombres se diferencien sólo por sus prefijos son exclusiones mutuas independientes y ambos son visibles para todos los procesos en la sesión de servidor de terminal server.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Es decir, los nombres de prefijo "Global<ph id="ph1">\\</ph>" y "Local<ph id="ph2">\\</ph>" describen el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The following example shows how a named mutex is used to signal between threads running in two separate processes.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo se utiliza una exclusión mutua con nombre para señalar los subprocesos que se ejecutan en dos procesos separados.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">Ejecutar este programa desde dos o más ventanas de comandos.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex <ph id="ph2">`MyMutex`</ph>.</source>
          <target state="translated">Cada proceso crea un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto que representa la exclusión mutua con nombre <ph id="ph2">`MyMutex`</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is a system object whose lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">La exclusión mutua con nombre es un objeto de sistema cuya duración está limitada por las duraciones de los <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objetos que se representan.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is created when the first process creates its <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object; in this example, the named mutex is owned by the first process that runs the program.</source>
          <target state="translated">La exclusión mutua con nombre se crea cuando el primer proceso crea su <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto; en este ejemplo, la exclusión mutua con nombre es propiedad del primer proceso que ejecuta el programa.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex is destroyed when all the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">La exclusión mutua con nombre se destruye cuando todos los <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objetos que representan se han liberado.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</source>
          <target state="translated">La sobrecarga de constructor utilizada en este ejemplo no puede indicar al subproceso que realiza la llamada si se ha concedido la propiedad inicial de la exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</source>
          <target state="translated">No debe usar este constructor para solicitar la propiedad inicial, a menos que esté seguro de que el subproceso va a crear la exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Error de Win32.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene más de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The name of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</source>
          <target state="translated">Nombre del objeto <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Si el valor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> no tiene nombre.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          <target state="translated">Cuando este método devuelve un resultado, contiene un valor booleano que es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se ha creado una exclusión mutua local (es decir, si <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> o una cadena vacía) o si se ha creado la exclusión mutua del sistema con nombre especificada; el valor es <ph id="ph3">&lt;see langword="false" /&gt;</ph> si la exclusión mutua del sistema con nombre especificada ya existía.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parámetro se pasa sin inicializar.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua, una cadena que es el nombre de la exclusión mutua y un valor booleano que, cuando se devuelva el método, indicará si se concedió la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> no <ph id="ph2">`null`</ph> y <ph id="ph3">`initiallyOwned`</ph> es <ph id="ph4">`true`</ph>, el subproceso que realiza la llamada posee la exclusión mutua con nombre solo si <ph id="ph5">`createdNew`</ph> es <ph id="ph6">`true`</ph> después de la llamada.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">En caso contrario, el subproceso puede solicitar la exclusión mutua mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Este constructor inicializa un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto que representa una exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Puede crear varias <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> los objetos que representan el mismo nombre exclusión mutua del sistema.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> rights, an exception is thrown.</source>
          <target state="translated">Si la exclusión mutua con nombre ya se ha creado con seguridad de control de acceso y el llamador no tiene <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph> derechos, que se produce una excepción.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Para abrir una exclusión mutua con nombre con únicamente los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Si especifica <ph id="ph1">`null`</ph> o una cadena vacía para <ph id="ph2">`name`</ph>, se crea una exclusión mutua local, como si se hubiera llamado el <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">En este caso, <ph id="ph1">`createdNew`</ph> siempre es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Dado que son para todo el sistema, exclusiones mutuas con nombre se pueden utilizar para coordinar el uso de recursos en los límites del proceso.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Si su nombre empieza con el prefijo "Global<ph id="ph1">\\</ph>", la exclusión mutua está visible en todas las sesiones de terminal server.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Si su nombre empieza con el prefijo "Local<ph id="ph1">\\</ph>", la exclusión mutua sólo es visible en la sesión de terminal server donde se creó.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Si no especifica ningún prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">Dentro de una sesión de servidor de terminal server, dos exclusiones mutuas cuyos nombres se diferencien sólo por sus prefijos son exclusiones mutuas independientes y ambos son visibles para todos los procesos en la sesión de servidor de terminal server.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Es decir, los nombres de prefijo "Global<ph id="ph1">\\</ph>" y "Local<ph id="ph2">\\</ph>" describen el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The following code example shows how a named mutex is used to signal between processes or threads.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo se utiliza una exclusión mutua con nombre para señalar los distintos procesos o subprocesos.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Run this program from two or more command windows.</source>
          <target state="translated">Ejecutar este programa desde dos o más ventanas de comandos.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Each process creates a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents the named mutex "MyMutex".</source>
          <target state="translated">Cada proceso crea un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto que representa la exclusión mutua con nombre "MyMutex".</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is a system object.</source>
          <target state="translated">La exclusión mutua con nombre es un objeto del sistema.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>In this example, its lifetime is bounded by the lifetimes of the <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it.</source>
          <target state="translated">En este ejemplo, su duración está limitado por las duraciones de los <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objetos que se representan.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is created when the first process creates its local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object, and destroyed when all the <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent it have been released.</source>
          <target state="translated">La exclusión mutua con nombre se crea cuando el primer proceso crea su local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto y se destruye cuando todos los <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objetos que representan se han liberado.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex is initially owned by the first process.</source>
          <target state="translated">El primer proceso posee inicialmente la exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The second process and any subsequent processes wait for earlier processes to release the named mutex.</source>
          <target state="translated">El segundo proceso y todos los procesos posteriores esperan para que otros procesos anteriores liberar la exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Error de Win32.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene más de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The name of the system mutex.</source>
          <target state="translated">Nombre de la exclusión mutua del sistema.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> is unnamed.</source>
          <target state="translated">Si el valor es <ph id="ph1">&lt;see langword="null" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> no tiene nombre.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>When this method returns, contains a Boolean that is <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local mutex was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system mutex was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system mutex already existed.</source>
          <target state="translated">Cuando este método devuelve un resultado, contiene un valor booleano que es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se ha creado una exclusión mutua local (es decir, si <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> es <ph id="ph2">&lt;see langword="null" /&gt;</ph> o una cadena vacía) o si se ha creado la exclusión mutua del sistema con nombre especificada; el valor es <ph id="ph3">&lt;see langword="false" /&gt;</ph> si la exclusión mutua del sistema con nombre especificada ya existía.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Este parámetro se pasa sin inicializar.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> que representa la seguridad del control de acceso que se va a aplicar a la exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua; una cadena que es el nombre de la exclusión mutua; una variable booleana que, cuando se devuelva el método, indicará si se le concedió la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada; y la seguridad del control de acceso que se va a aplicar a la exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If <ph id="ph1">`name`</ph> is not <ph id="ph2">`null`</ph> and <ph id="ph3">`initiallyOwned`</ph> is <ph id="ph4">`true`</ph>, the calling thread owns the named mutex only if <ph id="ph5">`createdNew`</ph> is <ph id="ph6">`true`</ph> after the call.</source>
          <target state="translated">Si <ph id="ph1">`name`</ph> no <ph id="ph2">`null`</ph> y <ph id="ph3">`initiallyOwned`</ph> es <ph id="ph4">`true`</ph>, el subproceso que realiza la llamada posee la exclusión mutua con nombre solo si <ph id="ph5">`createdNew`</ph> es <ph id="ph6">`true`</ph> después de la llamada.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Otherwise the thread can request the mutex by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">En caso contrario, el subproceso puede solicitar la exclusión mutua mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</source>
          <target state="translated">Utilice este constructor para aplicar la seguridad de control de acceso a una exclusión mutua del sistema con nombre cuando se crea, impide que otro código tome el control de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object that represents a named system mutex.</source>
          <target state="translated">Este constructor inicializa un <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto que representa una exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objects that represent the same named system mutex.</source>
          <target state="translated">Puede crear varias <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> los objetos que representan el mismo nombre exclusión mutua del sistema.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named system mutex does not exist, it is created with the specified access control security.</source>
          <target state="translated">Si la exclusión mutua del sistema con nombre no existe, se crea con la seguridad de control de acceso especificada.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex exists, the specified access control security is ignored.</source>
          <target state="translated">Si la exclusión mutua con nombre existe, se omite la seguridad de control de acceso especificada.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object even if <ph id="ph2">`mutexSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">El llamador tiene control total sobre el recién creado <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto incluso si <ph id="ph2">`mutexSecurity`</ph> deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object to represent the same named mutex, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">Sin embargo, si el usuario actual intenta obtener otro <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> representar la misma exclusión mutua con nombre, utilizando un constructor de objeto o el <ph id="ph2">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> método, se aplica la seguridad de control de acceso de Windows.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the named mutex has already been created with access control security, and the caller does not have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Si la exclusión mutua con nombre ya se ha creado con seguridad de control de acceso y el llamador no tiene <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType&gt;</ph>, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Para abrir una exclusión mutua con nombre con únicamente los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local mutex is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Si especifica <ph id="ph1">`null`</ph> o una cadena vacía para <ph id="ph2">`name`</ph>, se crea una exclusión mutua local, como si se hubiera llamado el <ph id="ph3">&lt;xref:System.Threading.Mutex.%23ctor%28System.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">En este caso, <ph id="ph1">`createdNew`</ph> siempre es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Dado que son para todo el sistema, exclusiones mutuas con nombre se pueden utilizar para coordinar el uso de recursos en los límites del proceso.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</source>
          <target state="translated">En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Global<ph id="ph1">\\</ph>", the mutex is visible in all terminal server sessions.</source>
          <target state="translated">Si su nombre empieza con el prefijo "Global<ph id="ph1">\\</ph>", la exclusión mutua está visible en todas las sesiones de terminal server.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If its name begins with the prefix "Local<ph id="ph1">\\</ph>", the mutex is visible only in the terminal server session where it was created.</source>
          <target state="translated">Si su nombre empieza con el prefijo "Local<ph id="ph1">\\</ph>", la exclusión mutua sólo es visible en la sesión de terminal server donde se creó.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</source>
          <target state="translated">En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you do not specify a prefix when you create a named mutex, it takes the prefix "Local<ph id="ph1">\\</ph>".</source>
          <target state="translated">Si no especifica ningún prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local<ph id="ph1">\\</ph>".</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</source>
          <target state="translated">Dentro de una sesión de servidor de terminal server, dos exclusiones mutuas cuyos nombres se diferencien sólo por sus prefijos son exclusiones mutuas independientes y ambos son visibles para todos los procesos en la sesión de servidor de terminal server.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>That is, the prefix names "Global<ph id="ph1">\\</ph>" and "Local<ph id="ph2">\\</ph>" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</source>
          <target state="translated">Es decir, los nombres de prefijo "Global<ph id="ph1">\\</ph>" y "Local<ph id="ph2">\\</ph>" describen el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Se detectó la excepción y el ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Error de Win32.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex exists and has access control security, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene más de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          <target state="translated">Obtiene un objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> que representa la seguridad de control de acceso para la exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security for the named mutex.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> que representa la seguridad de control de acceso para la exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> método utiliza la siguiente combinación de indicadores (combinados mediante la operación OR bit a bit) para buscar los permisos: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, y <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">El usuario debe tener <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> llamar a este método y la exclusión mutua debe haberse abierto con <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Se detectó la excepción y el ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos, usando la <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, but the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> actual representa una exclusión mutua del sistema con nombre, pero el usuario no dispone de derechos <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object represents a named system mutex, and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> actual representa una exclusión mutua del sistema con nombre y no se abrió con derechos <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">No se admite para Windows 98 o Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists.</source>
          <target state="translated">Abre una exclusión mutua con nombre especificada, si ya existe.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Nombre de la exclusión mutua del sistema que se va a abrir.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Opens the specified named mutex, if it already exists.</source>
          <target state="translated">Abre la exclusión mutua con nombre especificada, si ya existe.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>An object that represents the named system mutex.</source>
          <target state="translated">Objeto que representa la exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open the specified named system mutex.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> método intenta abrir especificado con el nombre de exclusión mutua del sistema.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">Si la exclusión mutua del sistema no existe, este método produce una excepción en lugar de crear el objeto del sistema.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para crear la exclusión mutua del sistema cuando aún no existe, utilice uno de los <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructores que tenga un <ph id="ph2">`name`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Varias llamadas a este método que utilizan el mismo valor para <ph id="ph1">`name`</ph> no devuelven necesariamente el mismo <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objeto, incluso si los objetos devueltos representan la misma exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Esta sobrecarga del método es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> sobrecarga del método y especificando <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> derechos, que se combinan mediante la operación OR bit a bit.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Especificar el <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> marca permite que un subproceso a la espera de la exclusión mutua y especificando el <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> marca permite que un subproceso llamar a la <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Este método no solicita la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Se detectó la excepción y el ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene más de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex does not exist.</source>
          <target state="translated">La excepción mutua con nombre no existe.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Error de Win32.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Nombre de la exclusión mutua del sistema que se va a abrir.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access.</source>
          <target state="translated">Abre la exclusión mutua con nombre especificada, si ya existe, con el acceso de seguridad deseado.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>An object that represents the named system mutex.</source>
          <target state="translated">Objeto que representa la exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">`rights`</ph> parámetro debe incluir el <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> marca para permitir que los subprocesos a la espera de la exclusión mutua y el <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> marca para permitir que los subprocesos llamar a la <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> method tries to open an existing named mutex.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%2A&gt;</ph> método intenta abrir una exclusión mutua con nombre existente.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the system mutex does not exist, this method throws an exception instead of creating the system object.</source>
          <target state="translated">Si la exclusión mutua del sistema no existe, este método produce una excepción en lugar de crear el objeto del sistema.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para crear la exclusión mutua del sistema cuando aún no existe, utilice uno de los <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructores que tenga un <ph id="ph2">`name`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Varias llamadas a este método que utilizan el mismo valor para <ph id="ph1">`name`</ph> no devuelven necesariamente el mismo <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objeto, incluso si los objetos devueltos representan la misma exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Este método no solicita la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions.</source>
          <target state="translated">Se detectó la excepción y el ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene más de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex does not exist.</source>
          <target state="translated">La excepción mutua con nombre no existe.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Error de Win32.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>The named mutex exists, but the user does not have the desired security access.</source>
          <target state="translated">La exclusión mutua con nombre existe, pero el usuario no dispone del acceso de seguridad deseado.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Releases the <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> once.</source>
          <target state="translated">Libera una vez la instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Whenever a thread acquires a mutex (for example, by calling its <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method), it must subsequently call <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</source>
          <target state="translated">Cada vez que un subproceso adquiere una exclusión mutua (por ejemplo, mediante una llamada a su <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método), debe llamar posteriormente <ph id="ph2">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> para ceder la propiedad del mutex y desbloquear otro subproceso que intenta obtener la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If the attempt to get ownership of the mutex fails (for example, when a call to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method with a <ph id="ph2">`millisecondsTimeout`</ph> or a <ph id="ph3">`timeout`</ph> parameter returns <ph id="ph4">`false`</ph> because the request times out), the thread shouldn't call <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</source>
          <target state="translated">Si se produce un error al intentar obtener la propiedad del mutex (por ejemplo, cuando una llamada a la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> método con un <ph id="ph2">`millisecondsTimeout`</ph> o un <ph id="ph3">`timeout`</ph> parámetro devuelve <ph id="ph4">`false`</ph> porque agota el tiempo de espera de la solicitud), el subproceso no debe llamar a <ph id="ph5">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph>, en este caso, el subproceso debe también no puedan tener acceso al recurso protegido por la exclusión mutua, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</source>
          <target state="translated">Un subproceso que posee una exclusión mutua puede especificar la misma exclusión mutua en espera repetidas llamadas a funciones sin bloquear su ejecución.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The number of calls is kept by the common language runtime.</source>
          <target state="translated">El número de llamadas se mantiene por common language runtime.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread must call <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> the same number of times to release ownership of the mutex.</source>
          <target state="translated">El subproceso debe llamar a <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> el mismo número de veces para liberar la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If a thread terminates while owning a mutex, the mutex is said to be abandoned.</source>
          <target state="translated">Si un subproceso finaliza mientras posee una exclusión mutua, la exclusión mutua se considera abandonada.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The state of the mutex is set to signaled and the next waiting thread gets ownership.</source>
          <target state="translated">El estado de la exclusión mutua se establece en señalado y el siguiente subproceso en espera obtiene la propiedad.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>If no one owns the mutex, the state of the mutex is signaled.</source>
          <target state="translated">Si ninguna persona que posee la exclusión mutua, el estado de la exclusión mutua se señala.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Beginning in version 2.0 of the .NET Framework, an <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is thrown in the next thread that acquires the mutex.</source>
          <target state="translated">A partir de la versión 2.0 de .NET Framework, un <ph id="ph1">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> se produce en el siguiente subproceso que adquiere la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>Prior to version 2.0 of the .NET Framework, no exception was thrown.</source>
          <target state="translated">Antes de la versión 2.0 de .NET Framework, se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>An abandoned mutex often indicates a serious error in the code.</source>
          <target state="translated">A menudo, un mutex abandonado indica un error grave en el código.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</source>
          <target state="translated">Cuando un subproceso sale sin liberar la exclusión mutua, las estructuras de datos protegidas por el mutex no estén en un estado coherente.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</source>
          <target state="translated">El siguiente subproceso que solicite la propiedad de la exclusión mutua puede controlar esta excepción y continuar si se puede comprobar la integridad de las estructuras de datos.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</source>
          <target state="translated">En el caso de una exclusión mutua en todo el sistema, una exclusión mutua abandonada podría indicar que una aplicación finalizó inesperadamente (por ejemplo, con el Administrador de tareas de Windows).</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The following example shows how a local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> object is used to synchronize access to a protected resource.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo una variable local <ph id="ph1">&lt;xref:System.Threading.Mutex&gt;</ph> objeto se usa para sincronizar el acceso a un recurso protegido.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The thread that creates the mutex does not own it initially.</source>
          <target state="translated">El subproceso que crea la exclusión mutua no posee la exclusión inicialmente.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method is used to release the mutex when it is no longer needed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> método se utiliza para liberar la exclusión mutua cuando ya no es necesario.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The calling thread does not own the mutex.</source>
          <target state="translated">El subproceso que realiza la llamada no posee la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.ReleaseMutex">
          <source>The current instance has already been disposed.</source>
          <target state="translated">Ya se ha eliminado la instancia actual.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system mutex.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.MutexSecurity" /&gt;</ph> que representa la seguridad del control de acceso que se va a aplicar a la exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>Sets the access control security for a named system mutex.</source>
          <target state="translated">Establece la seguridad de control de acceso para una exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the mutex must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">El usuario debe tener <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> derechos para llamar a este método y la exclusión mutua deben haberse abiertos con <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named mutex with access control security.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named mutex.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> sobrecarga del método para comprobar la existencia de una exclusión mutua con nombre.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</source>
          <target state="translated">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a utilizar la exclusión mutua, pero le concede el derecho a leer y cambiar los permisos en la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload to open the mutex with the rights needed to read and change the permissions, using the <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Se detectó la excepción y el ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos, usando la <ph id="ph2">&lt;xref:System.Threading.Mutex.GetAccessControl%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Threading.Mutex.SetAccessControl%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>After the permissions are changed, the mutex is opened with the rights required to enter and release it.</source>
          <target state="translated">Una vez cambiados los permisos, la exclusión mutua se abre con los derechos necesarios para entrada y liberación.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta utilizando los nuevos permisos.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mutexSecurity" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">El usuario no dispone de permisos <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The mutex was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</source>
          <target state="translated">La exclusión mutua no se abrió con permisos <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object does not represent a named system mutex.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> actual no representa una exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Mutex">
          <source>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Abre una exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Nombre de la exclusión mutua del sistema que se va a abrir.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Cuando este método vuelve, contiene un objeto <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si se produjo un error en la llamada.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Este parámetro se trata como sin inicializar.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Abre la exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la exclusión mutua con nombre se abrió correctamente; si no, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">Si la exclusión mutua con nombre no existe, este método no la crea.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para crear la exclusión mutua del sistema cuando aún no existe, utilice uno de los <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructores que tenga un <ph id="ph2">`name`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">Si no está seguro de si existe una exclusión mutua con nombre, utilice esta sobrecarga del método en lugar de la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%29&gt;</ph> sobrecarga del método que produce una excepción si la exclusión mutua no existe.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Varias llamadas a este método que utilizan el mismo valor para <ph id="ph1">`name`</ph> no devuelven necesariamente el mismo <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objeto, incluso si los objetos devueltos representan la misma exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Esta sobrecarga del método es equivalente a llamar a la <ph id="ph1">&lt;xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29&gt;</ph> sobrecarga del método y especificando <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> derechos, que se combinan mediante la operación OR bit a bit.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to wait on the mutex, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">Especificar el <ph id="ph1">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> marca permite que un subproceso a la espera de la exclusión mutua y especificando el <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> marca permite que un subproceso llamar a la <ph id="ph3">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Este método no solicita la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene más de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Error de Win32.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The name of the system mutex to open.</source>
          <target state="translated">Nombre de la exclusión mutua del sistema que se va a abrir.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> object that represents the named mutex if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Cuando este método vuelve, contiene un objeto <ph id="ph1">&lt;see cref="T:System.Threading.Mutex" /&gt;</ph> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> si se produjo un error en la llamada.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Este parámetro se trata como sin inicializar.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Abre la exclusión mutua con nombre especificada, si ya existe, con el acceso de seguridad deseado y devuelve un valor que indica si la operación se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named mutex was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la exclusión mutua con nombre se abrió correctamente; si no, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If the named mutex does not exist, this method does not create it.</source>
          <target state="translated">Si la exclusión mutua con nombre no existe, este método no la crea.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>To create the system mutex when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Para crear la exclusión mutua del sistema cuando aún no existe, utilice uno de los <ph id="ph1">&lt;xref:System.Threading.Mutex.%23ctor%2A&gt;</ph> constructores que tenga un <ph id="ph2">`name`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>If you are uncertain whether a named mutex exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> method overload, which throws an exception if the mutex does not exist.</source>
          <target state="translated">Si no está seguro de si existe una exclusión mutua con nombre, utilice esta sobrecarga del método en lugar de la <ph id="ph1">&lt;xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29&gt;</ph> sobrecarga del método que produce una excepción si la exclusión mutua no existe.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to wait on the mutex, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">`rights`</ph> parámetro debe incluir el <ph id="ph2">&lt;xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType&gt;</ph> marca para permitir que los subprocesos a la espera de la exclusión mutua y el <ph id="ph3">&lt;xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType&gt;</ph> marca para permitir que los subprocesos llamar a la <ph id="ph4">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> object, even though the objects that are returned represent the same named system mutex.</source>
          <target state="translated">Varias llamadas a este método que utilizan el mismo valor para <ph id="ph1">`name`</ph> no devuelven necesariamente el mismo <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph> objeto, incluso si los objetos devueltos representan la misma exclusión mutua del sistema con nombre.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This method does not request ownership of the mutex.</source>
          <target state="translated">Este método no solicita la propiedad de la exclusión mutua.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es una cadena vacía.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> tiene más de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Error de Win32.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>The named mutex exists, but the user does not have the security access required to use it.</source>
          <target state="translated">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>