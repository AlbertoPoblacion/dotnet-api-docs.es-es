<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ad9f6d866494c9ca0078200940a3feafc462189e" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67243306" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona un grupo de subprocesos que pueden usarse para ejecutar tareas, exponer elementos de trabajo, procesar la E/S asincrónica, esperar en nombre de otros subprocesos y procesar temporizadores.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Muchas aplicaciones crean subprocesos que pasan mucho tiempo en estado inactivo, esperando a que se produzca un evento. Otros subprocesos pueden entrar en estado de inactividad y activarse periódicamente para sondear en busca de un cambio o actualizar la información de estado. El grupo de subprocesos permite usar subprocesos más eficaz, ya que proporciona la aplicación con un grupo de subprocesos de trabajo que están administrados por el sistema. Ejemplos de operaciones que usan los subprocesos de grupo incluyen lo siguiente:  
  
-   Cuando creas un <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> objeto para realizar alguna tarea de forma asincrónica, de forma predeterminada, la tarea está programada para ejecutarse en un subproceso ThreadPool.  
  
-   Los temporizadores asincrónicos usar el grupo de subprocesos. Subprocesos de grupo ejecutarán devoluciones de llamada de la <xref:System.Threading.Timer?displayProperty=nameWithType> clase y provocar eventos desde el <xref:System.Timers.Timer?displayProperty=nameWithType> clase.  
  
-   Al usar identificadores de espera registrada, un subproceso del sistema supervisa el estado de los identificadores de espera. Cuando se completa una operación de espera, un subproceso del grupo de subprocesos de trabajo ejecuta la función de devolución de llamada correspondiente.  
  
-   Cuando se llama a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método para poner en cola un método para su ejecución en un subproceso ThreadPool. Para ello, pasando al método un <xref:System.Threading.WaitCallback> delegar.   El delegado tiene la firma  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     donde `state` es un objeto que contiene datos para su uso por el delegado. Los datos reales se pueden pasar al delegado mediante una llamada a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> método.  
  
> [!NOTE]
>  Los subprocesos en el grupo de subprocesos administrados son subprocesos en segundo plano. Es decir, sus <xref:System.Threading.Thread.IsBackground%2A> propiedades son `true`. Esto significa que un <xref:System.Threading.ThreadPool> subproceso no mantendrá una aplicación que se ejecuta después de que han salido de todos los subprocesos de primer plano.  
  
> [!IMPORTANT]
>  Cuando el grupo de subprocesos reutiliza un subproceso, no elimina los datos de almacenamiento local de subprocesos o en los campos que se marcan con el <xref:System.ThreadStaticAttribute> atributo. Por lo tanto, cuando un método examina el almacenamiento local de subprocesos o campos que se marcan con el <xref:System.ThreadStaticAttribute> atributo, los valores que encuentra podrían quedar a través de un uso anterior de subproceso de grupo.  
  
 También puede poner en cola los elementos de trabajo que no están relacionadas con una operación de espera para el grupo de subprocesos. Para solicitar que un subproceso en el grupo de subprocesos controle un elemento de trabajo, llame a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método. Este método toma como parámetro una referencia al método o delegado que llamará el subproceso seleccionado del grupo de subprocesos. No hay ninguna manera de cancelar un elemento de trabajo después de que se ha puesto en cola.  
  
 Los temporizadores de la cola del temporizador y operaciones de espera registradas también utilizan el grupo de subprocesos. Sus funciones de devolución de llamada se ponen en cola para el grupo de subprocesos.  
  
 Hay un grupo de subprocesos por proceso. A partir de [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el tamaño predeterminado del grupo de subprocesos de un proceso depende de varios factores, como el tamaño del espacio de direcciones virtuales. Un proceso puede llamar al método <xref:System.Threading.ThreadPool.GetMaxThreads%2A> para determinar el número de subprocesos. Se puede cambiar el número de subprocesos en el grupo de subprocesos mediante el uso de la <xref:System.Threading.ThreadPool.SetMaxThreads%2A> método. Cada subproceso utiliza el tamaño de pila predeterminado y se ejecuta con la prioridad predeterminada.  
  
> [!NOTE]
>  Código no administrado que hospeda .NET Framework puede cambiar el tamaño del grupo de subprocesos mediante la `CorSetMaxThreads` función definida en el archivo mscoree.h.  
  
 El grupo de subprocesos proporciona nuevos subprocesos de trabajo o subprocesos de finalización de E/S a petición hasta que alcanza el valor mínimo para cada categoría. Cuando se alcanza el mínimo, el grupo de subprocesos puede crear subprocesos adicionales en esa categoría o espere hasta que se completen algunas tareas. A partir de [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el grupo de subprocesos crea y destruye subprocesos de trabajo para optimizar el rendimiento, definido como el número de tareas que se completan por unidad de tiempo. Si hay demasiados pocos subprocesos, puede que los recursos disponibles no se usen de manera óptima, mientras que si hay demasiados subprocesos, puede aumentar la contención de recursos.  
  
> [!NOTE]
>  Cuando la demanda es baja, el número real de subprocesos del grupo de subprocesos puede descender por debajo de los valores mínimos.  
  
 Puede utilizar el método <xref:System.Threading.ThreadPool.GetMinThreads%2A> para obtener estos valores mínimos.  
  
> [!CAUTION]
>  Puede usar el <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar el número mínimo de subprocesos. Sin embargo, aumentar innecesariamente estos valores puede causar problemas de rendimiento. Si se inician demasiadas tareas al mismo tiempo, puede que todas ellas parezcan funcionar con lentitud. En la mayoría de los casos, el grupo de subprocesos funciona mejor con su propio algoritmo de asignación de subprocesos.  
  
   
  
## Examples  
 En el ejemplo siguiente, el subproceso principal de la aplicación pone en cola un método denominado `ThreadProc` para ejecutar en un subproceso ThreadPool, se suspende durante un segundo y, a continuación, sale. El `ThreadProc` método simplemente muestra un mensaje.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Si el comentario de la llamada a la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método, el subproceso principal finaliza antes de método se ejecuta en el subproceso del grupo.  El grupo de subprocesos usa subprocesos en segundo plano, que no mantienen la aplicación en ejecución si han finalizado todos los subprocesos de primer plano.  (Esto es un ejemplo sencillo de una condición de carrera).  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Subprocesos y subprocesamiento</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">La agrupación de subprocesos administrados</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Enlaza un identificador del sistema operativo a <see cref="T:System.Threading.ThreadPool" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="osHandle"><see cref="T:System.IntPtr" /> que contiene el controlador. El identificador debe haberse abierto para la E/S superpuesta en la parte no administrada.</param>
        <summary>Enlaza un identificador del sistema operativo a <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>Es <see langword="true" /> si el identificador está enlazado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle">Propiedad <see cref="T:System.Runtime.InteropServices.SafeHandle" /> que contiene el identificador del sistema operativo. El identificador debe haberse abierto para la E/S superpuesta en la parte no administrada.</param>
        <summary>Enlaza un identificador del sistema operativo a <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>Es <see langword="true" /> si el identificador está enlazado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `osHandle` parámetro debe ser un <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, que se deriva de la clase abstracta <xref:System.Runtime.InteropServices.SafeHandle> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="osHandle" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Número de subprocesos de trabajo disponibles.</param>
        <param name="completionPortThreads">Número de subprocesos de E/S asincrónicos disponibles.</param>
        <summary>Recupera la diferencia entre el número máximo de subprocesos de grupo de subprocesos devuelto por el método <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> y el número activo actualmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> devuelve la variable especificada por `workerThreads` contiene el número de subprocesos de trabajo adicionales que pueden iniciarse y la variable especificada por `completionPortThreads` contiene el número de subprocesos de E/S asincrónicos adicionales que puede ser se inició.  
  
 Si no hay ningún subproceso disponible, las solicitudes de grupo de subprocesos adicionales permanecen en la cola hasta que haya disponibles subprocesos de grupo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el número de subprocesos de trabajo y subprocesos de E/S disponibles cuando se inicia una aplicación sencilla.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Número máximo de subprocesos de trabajo en el grupo de subprocesos.</param>
        <param name="completionPortThreads">Número máximo de subprocesos de E/S asincrónicos en el grupo de subprocesos.</param>
        <summary>Recupera el número de solicitudes al grupo de subprocesos que pueden estar activas al mismo tiempo. Todas las solicitudes que pasen de ese número permanecen en la cola hasta que haya disponibles subprocesos de grupo de subprocesos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Threading.ThreadPool.GetMaxThreads%2A> devuelve la variable especificada por `workerThreads` contiene el número máximo de subprocesos de trabajo permitidos en el grupo de subprocesos y la variable especificada por `completionPortThreads` contiene el número máximo de subprocesos de E/S asincrónicos permitidos en el grupo de subprocesos.  
  
 Puede usar el <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> método para determinar el número real de subprocesos en el grupo de subprocesos en un momento dado.  
  
 Puede usar el <xref:System.Threading.ThreadPool.SetMaxThreads%2A> para establecer el número máximo de subprocesos de trabajo y subprocesos de E/S asincrónicos en el grupo de subprocesos.  
  
 Puede poner en cola como muchas solicitudes del grupo de subprocesos como permita la memoria del sistema. Si hay más solicitudes que subprocesos de grupo, las solicitudes adicionales permanecen en la cola hasta que haya disponibles subprocesos de grupo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo recuperar un recuento del número de subprocesos en el grupo de subprocesos máximo y está disponible. Un elemento de trabajo se pone en cola que usa `FileStream` para escribir en dos archivos de forma asincrónica. Se superó el tiempo de los métodos de devolución de llamada se superpongan. Un subproceso de trabajo controla el elemento de trabajo y, según la velocidad y el número de procesadores del equipo, uno o dos subprocesos de puerto de finalización controlan las operaciones de escritura.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Cuando este método vuelve, contiene el número mínimo de subprocesos de trabajo que el grupo de subprocesos crea a petición.</param>
        <param name="completionPortThreads">Cuando este método vuelve, contiene el número mínimo de subprocesos de E/S asincrónicos que el grupo de subprocesos crea a petición.</param>
        <summary>Recupera el número mínimo de subprocesos que el grupo de subprocesos crea a petición, según se realizan nuevas solicitudes, antes de conmutar a un algoritmo para administrar la creación y destrucción de subprocesos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El grupo de subprocesos proporciona nuevos subprocesos de trabajo o subprocesos de finalización de E/S a petición hasta que alcanza el valor mínimo para cada categoría. De forma predeterminada, el número mínimo de subprocesos se establece en el número de procesadores en un sistema. Cuando se alcanza el mínimo, el grupo de subprocesos puede crear subprocesos adicionales en esa categoría o espere hasta que se completen algunas tareas. A partir del [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el grupo de subprocesos crea y destruye subprocesos con el fin de optimizar el rendimiento, que se define como el número de tareas que se completan por unidad de tiempo. Si hay demasiados pocos subprocesos, puede que los recursos disponibles no se usen de manera óptima, mientras que si hay demasiados subprocesos, puede aumentar la contención de recursos.  
  
> [!NOTE]
>  Cuando la demanda es baja, el número real de subprocesos del grupo de subprocesos puede descender por debajo de los valores mínimos.  
  
   
  
## Examples  
 El siguiente ejemplo establece el número mínimo de subprocesos de trabajo a cuatro y conserva el valor original para el número mínimo de subprocesos de finalización de E/S asincrónicos.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pone en cola un método para su ejecución. El método se ejecuta cuando hay disponible un subproceso de grupo de subprocesos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><see cref="T:System.Threading.WaitCallback" /> que representa el método que se va a ejecutar.</param>
        <summary>Pone en cola un método para su ejecución. El método se ejecuta cuando hay disponible un subproceso de grupo de subprocesos.</summary>
        <returns><see langword="true" /> si el método se pone en la cola correctamente; se produce la excepción <see cref="T:System.NotSupportedException" /> si no se puede poner en la cola el elemento de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede colocar datos requeridos por el método en cola en los campos de instancia de la clase en el que se define el método, o puede usar el <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> sobrecarga que acepta un objeto que contiene los datos necesarios.  
  
> [!NOTE]
>  Los usuarios de Visual Basic pueden omitir el <xref:System.Threading.WaitCallback> constructor y basta con usar el `AddressOf` operador al pasar el método de devolución de llamada a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic llama automáticamente al constructor de delegado correcto.  
  
## <a name="version-information"></a>Información de versión  
 En .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método. En versiones anteriores, no se propaga la información de la entidad.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> sobrecarga del método para poner en cola una tarea, que viene representado por la `ThreadProc` método, se debe ejecutar cuando un subproceso esté disponible. No hay información de la tarea se suministra con esta sobrecarga. Por lo tanto, la información que está disponible para el `ThreadProc` método se limita a la que pertenece el método de objeto.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Common Language Runtime (CLR) está en un host y el host no admite esta acción.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><see cref="T:System.Threading.WaitCallback" /> que representa el método que se va a ejecutar.</param>
        <param name="state">Objeto que contiene los datos que va a usar el método.</param>
        <summary>Pone un método en cola para su ejecución y especifica un objeto que contiene los datos que debe usar el método. El método se ejecuta cuando hay disponible un subproceso de grupo de subprocesos.</summary>
        <returns><see langword="true" /> si el método se pone en la cola correctamente; se produce la excepción <see cref="T:System.NotSupportedException" /> si no se puede poner en la cola el elemento de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el método de devolución de llamada requiere datos complejos, puede definir una clase que contenga los datos.  
  
> [!NOTE]
>  Los usuarios de Visual Basic pueden omitir el <xref:System.Threading.WaitCallback> constructor y basta con usar el `AddressOf` operador al pasar el método de devolución de llamada a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic llama automáticamente al constructor de delegado correcto.  
  
## <a name="version-information"></a>Información de versión  
 En .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método. En versiones anteriores, no se propaga la información de la entidad.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el grupo de subprocesos de .NET para calcular el `Fibonacci` resultado para cinco números entre 20 y 40. Cada resultado de `Fibonacci` se representa mediante la clase `Fibonacci`, que proporciona un método denominado `ThreadPoolCallback` que realiza el cálculo. Se crea un objeto que representa cada valor de `Fibonacci` y el método `ThreadPoolCallback` se pasa a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, que asigna un subproceso disponible en el grupo para ejecutar el método.  
  
 Dado que cada `Fibonacci` objeto se asigna un valor semialeatorio para calcular y dado que cada subproceso compite para obtener tiempo de procesador, no puede saber de antemano cuánto tardará cinco calcular todos los resultados. Por eso se pasa a cada objeto `Fibonacci` una instancia de la clase <xref:System.Threading.ManualResetEvent> durante la construcción. Cada objeto indica que el objeto de evento proporcionado cuando su cálculo está completo, que permite que el subproceso principal bloquee la ejecución con <xref:System.Threading.WaitHandle.WaitAll%2A> hasta los cinco `Fibonacci` objetos hayan calculado un resultado. El método `Main` muestra entonces cada resultado de `Fibonacci`.
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Common Language Runtime (CLR) está en un host y el host no admite esta acción.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Tipo de elementos de <paramref name="state" />.</typeparam>
        <param name="callBack"><see cref="T:System.Action`1" /> que representa el método que se va a ejecutar.</param>
        <param name="state">Objeto que contiene los datos que va a usar el método.</param>
        <param name="preferLocal">A diferencia de otros métodos de QueueUserWorkItem, prefiere la ejecución en el grupo local de subprocesos y no en el grupo global de subprocesos.</param>
        <summary>Pone un método en cola para su ejecución especificado por un delegado de <see cref="T:System.Action`1" /> y proporciona los datos que debe usar el método. El método se ejecuta cuando hay disponible un subproceso de grupo de subprocesos.</summary>
        <returns><see langword="true" /> si el método se pone en la cola correctamente; se produce la excepción <see cref="T:System.NotSupportedException" /> si no se puede poner en la cola el elemento de trabajo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un delegado que está esperando a una clase <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar. Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegado de <see cref="T:System.Threading.WaitOrTimerCallback" /> al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</param>
        <param name="state">Objeto que se pasa al delegado.</param>
        <param name="millisecondsTimeOutInterval">Tiempo de espera en milisegundos. Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</param>
        <param name="executeOnlyOnce">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</param>
        <summary>Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 32 bits con signo como tiempo de espera, en milisegundos.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula el identificador nativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera. Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`. Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.  
  
 El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método pone en cola el delegado especificado en el grupo de subprocesos. Un subproceso de trabajo ejecutará al delegado cuando se produce uno de los siguientes:  
  
-   El objeto especificado está en el estado señalado.  
  
-   Transcurre el intervalo de tiempo de espera.  
  
 El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método comprueba el estado actual del objeto especificado <xref:System.Threading.WaitHandle>. Si el estado del objeto no esté señalizado, el método registra una operación de espera. La operación de espera se realiza mediante un subproceso del grupo de subprocesos. El delegado se ejecuta un subproceso de trabajo cuando se señaliza el estado del objeto o transcurre el intervalo de tiempo de espera. Si el `timeOutInterval` parámetro no es 0 (cero) y el `executeOnlyOnce` parámetro es `false`, el temporizador se restablece cada vez que el evento está señalado o transcurre el intervalo de tiempo de espera.  
  
> [!IMPORTANT]
>  Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Windows subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo. En lugar de un <xref:System.Threading.Mutex>, utilice un <xref:System.Threading.Semaphore> con un recuento máximo de 1.  
  
 Para cancelar la operación de espera, llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.  
  
 El subproceso espera usa Win32 `WaitForMultipleObjects` función para supervisar las operaciones de espera registrada. Por lo tanto, si se debe utilizar el mismo identificador de sistema operativo nativo en varias llamadas a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, debe duplicar el identificador de Win32 `DuplicateHandle` función. Tenga en cuenta que no se debe marcar un objeto de evento que se pasa a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ya que el subproceso de espera podría no detectar que el evento está señalado antes de restablecerse.  
  
 La función modifica el estado de algunos tipos de objetos de sincronización antes de devolverse. Modificación se produce sólo para el objeto cuyo estado señalado provocó que se debe cumplir la condición de espera. Por ejemplo, el recuento de un semáforo se reduce en uno.  
  
## <a name="version-information"></a>Información de versión  
 A partir de .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método. En versiones anteriores, no se propaga la información de la entidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar. Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegado de <see cref="T:System.Threading.WaitOrTimerCallback" /> al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</param>
        <param name="state">Objeto que se ha pasado al delegado.</param>
        <param name="millisecondsTimeOutInterval">Tiempo de espera en milisegundos. Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</param>
        <param name="executeOnlyOnce">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</param>
        <summary>Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 64 bits con signo como tiempo de espera, en milisegundos.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula el identificador nativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera. Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`. Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.  
  
 El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método pone en cola el delegado especificado en el grupo de subprocesos. Un subproceso de trabajo ejecutará al delegado cuando se produce uno de los siguientes:  
  
-   El objeto especificado está en el estado señalado.  
  
-   Transcurre el intervalo de tiempo de espera.  
  
 El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método comprueba el estado actual del objeto especificado <xref:System.Threading.WaitHandle>. Si el estado del objeto no esté señalizado, el método registra una operación de espera. La operación de espera se realiza mediante un subproceso del grupo de subprocesos. El delegado se ejecuta un subproceso de trabajo cuando se señaliza el estado del objeto o transcurre el intervalo de tiempo de espera. Si el `timeOutInterval` parámetro no es 0 (cero) y el `executeOnlyOnce` parámetro es `false`, el temporizador se restablece cada vez que el evento está señalado o transcurre el intervalo de tiempo de espera.  
  
> [!IMPORTANT]
>  Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Windows subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo. En lugar de un <xref:System.Threading.Mutex>, utilice un <xref:System.Threading.Semaphore> con un recuento máximo de 1.  
  
 Para cancelar la operación de espera, llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.  
  
 El subproceso espera usa Win32 `WaitForMultipleObjects` función para supervisar las operaciones de espera registrada. Por lo tanto, si se debe utilizar el mismo identificador de sistema operativo nativo en varias llamadas a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, debe duplicar el identificador de Win32 `DuplicateHandle` función. Tenga en cuenta que no se debe marcar un objeto de evento que se pasa a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ya que el subproceso de espera podría no detectar que el evento está señalado antes de restablecerse.  
  
 La función modifica el estado de algunos tipos de objetos de sincronización antes de devolverse. Modificación se produce sólo para el objeto cuyo estado señalado provocó que se debe cumplir la condición de espera. Por ejemplo, el recuento de un semáforo se reduce en uno.  
  
## <a name="version-information"></a>Información de versión  
 A partir de .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método. En versiones anteriores, no se propaga la información de la entidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar. Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegado de <see cref="T:System.Threading.WaitOrTimerCallback" /> al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</param>
        <param name="state">Objeto que se ha pasado al delegado.</param>
        <param name="timeout">Tiempo de espera representado por <see cref="T:System.TimeSpan" />. Si <paramref name="timeout" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. Si <paramref name="timeout" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</param>
        <param name="executeOnlyOnce">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</param>
        <summary>Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un valor <see cref="T:System.TimeSpan" /> como tiempo de espera.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula el identificador nativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera. Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`. Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.  
  
 El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método pone en cola el delegado especificado en el grupo de subprocesos. Un subproceso de trabajo ejecutará al delegado cuando se produce uno de los siguientes:  
  
-   El objeto especificado está en el estado señalado.  
  
-   Transcurre el intervalo de tiempo de espera.  
  
 El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método comprueba el estado actual del objeto especificado <xref:System.Threading.WaitHandle>. Si el estado del objeto no esté señalizado, el método registra una operación de espera. La operación de espera se realiza mediante un subproceso del grupo de subprocesos. El delegado se ejecuta un subproceso de trabajo cuando se señaliza el estado del objeto o transcurre el intervalo de tiempo de espera. Si el `timeOutInterval` parámetro no es 0 (cero) y el `executeOnlyOnce` parámetro es `false`, el temporizador se restablece cada vez que el evento está señalado o transcurre el intervalo de tiempo de espera.  
  
> [!IMPORTANT]
>  Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Windows subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo. En lugar de un <xref:System.Threading.Mutex>, utilice un <xref:System.Threading.Semaphore> con un recuento máximo de 1.  
  
 Para cancelar la operación de espera, llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.  
  
 El subproceso espera usa Win32 `WaitForMultipleObjects` función para supervisar las operaciones de espera registrada. Por lo tanto, si se debe utilizar el mismo identificador de sistema operativo nativo en varias llamadas a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, debe duplicar el identificador de Win32 `DuplicateHandle` función. Tenga en cuenta que no se debe marcar un objeto de evento que se pasa a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ya que el subproceso de espera podría no detectar que el evento está señalado antes de restablecerse.  
  
 La función modifica el estado de algunos tipos de objetos de sincronización antes de devolverse. Modificación se produce sólo para el objeto cuyo estado señalado provocó que se debe cumplir la condición de espera. Por ejemplo, el recuento de un semáforo se reduce en uno.  
  
## <a name="version-information"></a>Información de versión  
 A partir de .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método. En versiones anteriores, no se propaga la información de la entidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="timeout" /> es menor que -1.</exception>
        <exception cref="T:System.NotSupportedException">El valor del parámetro <paramref name="timeout" /> es mayor que el valor de la propiedad <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar. Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegado de <see cref="T:System.Threading.WaitOrTimerCallback" /> al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</param>
        <param name="state">Objeto que se ha pasado al delegado.</param>
        <param name="millisecondsTimeOutInterval">Tiempo de espera en milisegundos. Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</param>
        <param name="executeOnlyOnce">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</param>
        <summary>Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 32 bits sin signo como tiempo de espera, en milisegundos.</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera. Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`. Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.  
  
 El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método pone en cola el delegado especificado en el grupo de subprocesos. Un subproceso de trabajo ejecutará al delegado cuando se produce uno de los siguientes:  
  
-   El objeto especificado está en el estado señalado.  
  
-   Transcurre el intervalo de tiempo de espera.  
  
 El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método comprueba el estado actual del objeto especificado <xref:System.Threading.WaitHandle>. Si el estado del objeto no esté señalizado, el método registra una operación de espera. La operación de espera se realiza mediante un subproceso del grupo de subprocesos. El delegado se ejecuta un subproceso de trabajo cuando se señaliza el estado del objeto o transcurre el intervalo de tiempo de espera. Si el `timeOutInterval` parámetro no es 0 (cero) y el `executeOnlyOnce` parámetro es `false`, el temporizador se restablece cada vez que el evento está señalado o transcurre el intervalo de tiempo de espera.  
  
> [!IMPORTANT]
>  Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Windows subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo. En lugar de un <xref:System.Threading.Mutex>, utilice un <xref:System.Threading.Semaphore> con un recuento máximo de 1.  
  
 Para cancelar la operación de espera, llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.  
  
 El subproceso espera usa Win32 `WaitForMultipleObjects` función para supervisar las operaciones de espera registrada. Por lo tanto, si se debe utilizar el mismo identificador de sistema operativo nativo en varias llamadas a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, debe duplicar el identificador de Win32 `DuplicateHandle` función. Tenga en cuenta que no se debe marcar un objeto de evento que se pasa a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ya que el subproceso de espera podría no detectar que el evento está señalado antes de restablecerse.  
  
 La función modifica el estado de algunos tipos de objetos de sincronización antes de devolverse. Modificación se produce sólo para el objeto cuyo estado señalado provocó que se debe cumplir la condición de espera. Por ejemplo, el recuento de un semáforo se reduce en uno.  
  
## <a name="version-information"></a>Información de versión  
 A partir de .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método. En versiones anteriores, no se propaga la información de la entidad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método para ejecutar un método de devolución de llamada especificada cuando se señala un identificador de espera especificado. En este ejemplo, el método de devolución de llamada es `WaitProc`, y el identificador de espera es un <xref:System.Threading.AutoResetEvent>.  
  
 El ejemplo define un `TaskInfo` clase para contener la información que se pasa a la devolución de llamada cuando se ejecuta. El ejemplo se crea un `TaskInfo` de objeto y lo asigna algunos datos de cadena. El <xref:System.Threading.RegisteredWaitHandle> devuelta por la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método se asigna a la `Handle` campo de la `TaskInfo` objeto para que el método de devolución de llamada tiene acceso a la <xref:System.Threading.RegisteredWaitHandle>.  
  
 Además de especificar `TaskInfo` como el objeto debe pasar al método de devolución de llamada, la llamada a la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método especifica el <xref:System.Threading.AutoResetEvent> que esperará la tarea, un <xref:System.Threading.WaitOrTimerCallback> delegado que representa el `WaitProc` el método de devolución de llamada, un intervalo de tiempo de espera un segundo y varias devoluciones de llamada.  
  
 Cuando el subproceso principal señala el <xref:System.Threading.AutoResetEvent> mediante una llamada a su <xref:System.Threading.EventWaitHandle.Set%2A> método, el <xref:System.Threading.WaitOrTimerCallback> se invoca el delegado. El `WaitProc` método pruebas <xref:System.Threading.RegisteredWaitHandle> para determinar si se ha producido un tiempo de espera. Si la devolución de llamada se invocó porque se señaló el identificador de espera, el `WaitProc` anula el registro de método la <xref:System.Threading.RegisteredWaitHandle>, deteniendo las devoluciones de llamada adicionales. En el caso de un tiempo de espera, la tarea sigue esperando. El `WaitProc` método termina con la impresión de un mensaje en la consola.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Número máximo de subprocesos de trabajo en el grupo de subprocesos.</param>
        <param name="completionPortThreads">Número máximo de subprocesos de E/S asincrónicos en el grupo de subprocesos.</param>
        <summary>Establece el número de solicitudes al grupo de subprocesos que pueden estar activas al mismo tiempo. Todas las solicitudes que pasen de ese número permanecen en la cola hasta que haya disponibles subprocesos de grupo de subprocesos.</summary>
        <returns>Es <see langword="true" /> si el cambio se realiza correctamente; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede establecer el número máximo de subprocesos de trabajo o subprocesos de finalización de E/S en un número menor que el número de procesadores del equipo. Para determinar cuántos procesadores están presentes, recuperar el valor de la <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> propiedad. Además, no se puede establecer el número máximo de subprocesos de trabajo o subprocesos de finalización de E/S en un número menor que el correspondiente número mínimo de subprocesos de trabajo o subprocesos de finalización de E/S. Para determinar el tamaño mínimo de subprocesos del grupo, llame a la <xref:System.Threading.ThreadPool.GetMinThreads%2A> método.  
  
 Si se hospeda common language runtime, por ejemplo mediante Internet Information Services (IIS) o SQL Server, el host puede limitar o evitar cambios en el tamaño del grupo de subprocesos.  
  
 Tenga cuidado al cambiar el número máximo de subprocesos en el grupo de subprocesos. Mientras que podría beneficiarse del código, los cambios podrían tener un efecto adverso en bibliotecas de código que usar.  
  
 Establecer el tamaño del grupo de subprocesos demasiado grande puede provocar problemas de rendimiento. Si se están ejecutando demasiados subprocesos al mismo tiempo, sobrecarga la conmutación de tareas se vuelve un factor importante.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad para controlar los subprocesos. Valor de permiso: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Número mínimo de subprocesos de trabajo que el grupo de subprocesos crea a petición.</param>
        <param name="completionPortThreads">Número mínimo de subprocesos de E/S asincrónicos que el grupo de subprocesos crea a petición.</param>
        <summary>Establece el número mínimo de subprocesos que el grupo de subprocesos crea a petición, según se realizan nuevas solicitudes, antes de conmutar a un algoritmo para administrar la creación y destrucción de subprocesos.</summary>
        <returns>Es <see langword="true" /> si el cambio se realiza correctamente; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El grupo de subprocesos proporciona nuevos subprocesos de trabajo o subprocesos de finalización de E/S a petición hasta que alcanza el valor mínimo para cada categoría. Cuando se alcanza el mínimo, el grupo de subprocesos puede crear subprocesos adicionales en esa categoría o espere hasta que se completen algunas tareas. A partir del [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el grupo de subprocesos crea y destruye subprocesos con el fin de optimizar el rendimiento, que se define como el número de tareas que se completan por unidad de tiempo. Si hay demasiados pocos subprocesos, puede que los recursos disponibles no se usen de manera óptima, mientras que si hay demasiados subprocesos, puede aumentar la contención de recursos.  
  
 Cuando la demanda es baja, el número real de subprocesos del grupo de subprocesos puede descender por debajo de los valores mínimos.  
  
 Si especifica un número negativo o un número mayor que el número máximo de subprocesos de ThreadPool active (obtenidos mediante <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> devuelve `false` y no cambia ninguno de los valores mínimos.  
  
> [!CAUTION]
>  De forma predeterminada, el número mínimo de subprocesos se establece en el número de procesadores en un sistema. Puede usar el <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar el número mínimo de subprocesos. Sin embargo, aumentar innecesariamente estos valores puede causar problemas de rendimiento. Si se inician demasiadas tareas al mismo tiempo, puede que todas ellas parezcan funcionar con lentitud. En la mayoría de los casos, el grupo de subprocesos funcionará mejor con su propio algoritmo de asignación de subprocesos. A menos que el número de procesadores también puede afectar negativamente al rendimiento, lo que reduce al mínimo.  
  
   
  
## Examples  
 El siguiente ejemplo establece el número mínimo de subprocesos de trabajo a cuatro y conserva el valor original para el número mínimo de subprocesos de finalización de E/S asincrónicos.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad para controlar los subprocesos. Valor de permiso: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="overlapped">Estructura <see cref="T:System.Threading.NativeOverlapped" /> que se va a poner en cola.</param>
        <summary>Pone en cola una operación de E/S superpuesta para que se ejecute.</summary>
        <returns>Es <see langword="true" /> si la operación se puso correctamente en la cola de un puerto de finalización de E/S; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información acerca de cómo utilizar Win32 nativa superpuesta E/S, vea el <xref:System.Threading.Overlapped> (clase), el <xref:System.Threading.NativeOverlapped> estructura y el `OVERLAPPED` estructura en Platform SDK de Win32.  
  
> [!CAUTION]
>  Mediante el <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> método podría abrir accidentalmente un agujero de seguridad. Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila. Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, la pila del subproceso de grupo no tiene el contexto de los llamadores reales. Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><see cref="T:System.Threading.WaitCallback" /> que representa el delegado al que se va a invocar cuando un subproceso del grupo de subprocesos seleccione el elemento de trabajo.</param>
        <param name="state">Objeto que se pasa al delegado cuando se atiende desde el grupo de subprocesos.</param>
        <summary>Pone en cola el delegado especificado en el grupo de subprocesos, pero no propaga la pila de llamadas al subproceso de trabajo.</summary>
        <returns><see langword="true" /> si el método se ejecuta correctamente; se produce la excepción <see cref="T:System.OutOfMemoryException" /> si el elemento de trabajo no se puede poner en la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> no propaga la pila de llamadas al subproceso de trabajo. Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.  
  
> [!CAUTION]
>  Uso de <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> podría abrir accidentalmente un agujero de seguridad. Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila. Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales. Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ApplicationException">Se ha encontrado una condición de falta de memoria.</exception>
        <exception cref="T:System.OutOfMemoryException">No se pudo poner en la cola el elemento de trabajo.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Tipo de elementos de <paramref name="state" />.</typeparam>
        <param name="callBack">Un delegado que representa el método que se va a ejecutar.</param>
        <param name="state">Objeto que contiene los datos que va a usar el método.</param>
        <param name="preferLocal">`true` para ejecutar en el conjunto local de subprocesos; `false` para ejecutar en el grupo global de subprocesos.</param>
        <summary>Pone un método en cola para su ejecución especificado por un delegado de <see cref="T:System.Action`1" /> y especifica un objeto que contiene los datos que debe usar el método. El método se ejecuta cuando hay disponible un subproceso de grupo de subprocesos.</summary>
        <returns><see langword="true" /> si el método se pone en la cola correctamente; se produce la excepción <see cref="T:System.NotSupportedException" /> si no se puede poner en la cola el elemento de trabajo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un delegado para que espere a <see cref="T:System.Threading.WaitHandle" />, pero no propaga la pila de llamadas al subproceso de trabajo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar. Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegado al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</param>
        <param name="state">Objeto que se pasa al delegado.</param>
        <param name="millisecondsTimeOutInterval">Tiempo de espera en milisegundos. Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</param>
        <param name="executeOnlyOnce">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</param>
        <summary>Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y usa un entero de 32 bits con signo como tiempo de espera, en milisegundos. Este método no propaga la pila de llamadas al subproceso de trabajo.</summary>
        <returns>Objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> no propaga la pila de llamadas al subproceso de trabajo. Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.  
  
> [!CAUTION]
>  Uso de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> podría abrir accidentalmente un agujero de seguridad. Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila. Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales. Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.  
  
 Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Windows subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.  
  
 Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera. Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`. Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar. Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegado al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</param>
        <param name="state">Objeto que se pasa al delegado.</param>
        <param name="millisecondsTimeOutInterval">Tiempo de espera en milisegundos. Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</param>
        <param name="executeOnlyOnce">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</param>
        <summary>Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 64 bits con signo como tiempo de espera, en milisegundos. Este método no propaga la pila de llamadas al subproceso de trabajo.</summary>
        <returns>Objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> no propaga la pila de llamadas al subproceso de trabajo. Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.  
  
> [!CAUTION]
>  Uso de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> podría abrir accidentalmente un agujero de seguridad. Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila. Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales. Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.  
  
 Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Windows subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.  
  
 Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera. Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`. Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar. Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegado al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</param>
        <param name="state">Objeto que se pasa al delegado.</param>
        <param name="timeout">Tiempo de espera representado por <see cref="T:System.TimeSpan" />. Si <paramref name="timeout" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. Si <paramref name="timeout" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</param>
        <param name="executeOnlyOnce">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</param>
        <summary>Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un valor <see cref="T:System.TimeSpan" /> como tiempo de espera. Este método no propaga la pila de llamadas al subproceso de trabajo.</summary>
        <returns>Objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> no propaga la pila de llamadas al subproceso de trabajo. Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.  
  
> [!CAUTION]
>  Uso de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> podría abrir accidentalmente un agujero de seguridad. Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila. Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales. Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.  
  
 Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Windows subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.  
  
 Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera. Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`. Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="timeout" /> es menor que -1.</exception>
        <exception cref="T:System.NotSupportedException">El valor del parámetro <paramref name="timeout" /> es mayor que el valor de la propiedad <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar. Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegado al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</param>
        <param name="state">Objeto que se pasa al delegado.</param>
        <param name="millisecondsTimeOutInterval">Tiempo de espera en milisegundos. Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</param>
        <param name="executeOnlyOnce">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</param>
        <summary>Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 32 bits sin signo como tiempo de espera, en milisegundos. Este método no propaga la pila de llamadas al subproceso de trabajo.</summary>
        <returns>Objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> no propaga la pila de llamadas al subproceso de trabajo. Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.  
  
> [!CAUTION]
>  Uso de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> podría abrir accidentalmente un agujero de seguridad. Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila. Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales. Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.  
  
 Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Windows subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.  
  
 Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera. Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`. Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Grupo de subprocesos administrados</related>
      </Docs>
    </Member>
  </Members>
</Type>