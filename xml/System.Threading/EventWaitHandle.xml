<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04ca1c444cfd772670659b4609b267628b38c728" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="98773-101">Representa un evento de sincronización de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="98773-101">Represents a thread synchronization event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-102">La <xref:System.Threading.EventWaitHandle> clase permite que los subprocesos se comuniquen entre sí mediante señales.</span><span class="sxs-lookup"><span data-stu-id="98773-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="98773-103">Normalmente, uno o varios subprocesos se bloquean en un <xref:System.Threading.EventWaitHandle> hasta que un subproceso desbloqueado llama el <xref:System.Threading.EventWaitHandle.Set%2A> método, liberando uno o varios de los subprocesos bloqueados.</span><span class="sxs-lookup"><span data-stu-id="98773-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="98773-104">Un subproceso puede señalar un <xref:System.Threading.EventWaitHandle> y, a continuación, bloquearse en ella, mediante una llamada a la `static` (`Shared` en Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="98773-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98773-105">La <xref:System.Threading.EventWaitHandle> clase proporciona acceso a los eventos de sincronización de sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="98773-106">El comportamiento de un <xref:System.Threading.EventWaitHandle> que se haya señalado depende de su modo de restablecimiento.</span><span class="sxs-lookup"><span data-stu-id="98773-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="98773-107">Un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca se restablece automáticamente cuando se señala, después de liberar un único subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="98773-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="98773-108">Un <xref:System.Threading.EventWaitHandle> creado con la <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca permanece señalada hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="98773-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="98773-109">Eventos de restablecimiento automático proporcionan un acceso exclusivo a un recurso.</span><span class="sxs-lookup"><span data-stu-id="98773-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="98773-110">Si un evento de restablecimiento automático se señaliza cuando no hay ningún subproceso en espera, permanece señalado hasta que un subproceso intenta esperar en él.</span><span class="sxs-lookup"><span data-stu-id="98773-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="98773-111">El evento libera el subproceso y lo restablece inmediatamente, bloqueando los subprocesos subsiguientes.</span><span class="sxs-lookup"><span data-stu-id="98773-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="98773-112">Los eventos son como puertas de restablecimiento manual.</span><span class="sxs-lookup"><span data-stu-id="98773-112">Manual reset events are like gates.</span></span> <span data-ttu-id="98773-113">Cuando no se señala el evento, se bloquean los subprocesos que esperan en él.</span><span class="sxs-lookup"><span data-stu-id="98773-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="98773-114">Cuando se señala el evento, se liberan todos los subprocesos en espera y el evento permanece señalado (es decir, las esperas subsiguientes no se bloquean) hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="98773-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="98773-115">Eventos de restablecimiento manual son útiles cuando un subproceso debe finalizar una actividad antes de que puedan continuar otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="98773-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="98773-116"><xref:System.Threading.EventWaitHandle> objetos que se puedan usar con la `static`(`Shared` en Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> y <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="98773-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="98773-117">Para obtener más información acerca de los mecanismos de sincronización de subprocesos, vea [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="98773-117">For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98773-118">El siguiente ejemplo de código utiliza el <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga del método para permitir que el subproceso principal indicar un subproceso bloqueado y, a continuación, espere a que el subproceso finalice una tarea.</span><span class="sxs-lookup"><span data-stu-id="98773-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="98773-119">El ejemplo inicia cinco subprocesos y se les permite bloquearse en un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca, a continuación, en vez de un subproceso de versiones el usuario presiona la tecla ENTRAR.</span><span class="sxs-lookup"><span data-stu-id="98773-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="98773-120">En el ejemplo, a continuación, pone en cola otros cinco subprocesos y se liberan todos ellos utilizando una <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="98773-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="98773-121">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="98773-121">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="98773-122">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-122">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="98773-123">Es <see langword="true" /> para establecer el estado inicial en señalado; es <see langword="false" /> para establecerlo en no señalado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-123">
              <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="98773-124">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-124">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-125">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente y si se restablece automática o manualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-125">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-126">Si el estado inicial del evento es no señalado, los subprocesos que esperan en el evento se bloquean.</span><span class="sxs-lookup"><span data-stu-id="98773-126">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="98773-127">Si se señala el estado inicial y la <xref:System.Threading.EventResetMode.ManualReset> marca se especifica para `mode`, no bloqueará los subprocesos que esperan en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-127">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="98773-128">Si se señala el estado inicial, y `mode` es <xref:System.Threading.EventResetMode.AutoReset>, el primer subproceso que espera en el evento se publican inmediatamente, después del cual se restablecerá el evento, y los subprocesos posteriores se bloquean.</span><span class="sxs-lookup"><span data-stu-id="98773-128">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98773-129">El siguiente ejemplo de código utiliza el <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga del método para permitir que el subproceso principal indicar un subproceso bloqueado y, a continuación, espere a que el subproceso finalice una tarea.</span><span class="sxs-lookup"><span data-stu-id="98773-129">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="98773-130">El ejemplo inicia cinco subprocesos y se les permite bloquearse en un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca, a continuación, en vez de un subproceso de versiones el usuario presiona la tecla ENTRAR.</span><span class="sxs-lookup"><span data-stu-id="98773-130">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="98773-131">En el ejemplo, a continuación, pone en cola otros cinco subprocesos y se liberan todos ellos utilizando una <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="98773-131">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="98773-132">
            <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-132">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="98773-133">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-133">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="98773-134">Nombre de un evento de sincronización de todo el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-134">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-135">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente cuando se crea como resultado de esta llamada, si se restablece automática o manualmente y el nombre de un evento de sincronización del sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-135">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-136">Si `name` es `null` o una cadena vacía, una variable local <xref:System.Threading.EventWaitHandle> se crea.</span><span class="sxs-lookup"><span data-stu-id="98773-136">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="98773-137">Si un evento del sistema con el nombre especificado para la `name` ya existe un parámetro, el `initialState` parámetro se ignora.</span><span class="sxs-lookup"><span data-stu-id="98773-137">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="98773-138">Cuando se utiliza este constructor para eventos del sistema con nombre, especifique `false` para `initialState`.</span><span class="sxs-lookup"><span data-stu-id="98773-138">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="98773-139">Este constructor no proporciona ninguna manera de determinar si se creó un evento del sistema con nombre, por lo que no se puede realizar ninguna suposición sobre el estado del evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-139">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="98773-140">Para determinar si se ha creado un evento con nombre, use la <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span><span class="sxs-lookup"><span data-stu-id="98773-140">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="98773-141">Si el estado inicial del evento es no señalado, los subprocesos que esperan en el evento se bloquean.</span><span class="sxs-lookup"><span data-stu-id="98773-141">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="98773-142">Si se señala el estado inicial y la <xref:System.Threading.EventResetMode.ManualReset> marca se especifica para `mode`, no bloqueará los subprocesos que esperan en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-142">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="98773-143">Si se señala el estado inicial, y `mode` es <xref:System.Threading.EventResetMode.AutoReset>, el primer subproceso que espera en el evento se publican inmediatamente, después del cual se restablecerá el evento, y los subprocesos posteriores se bloquean.</span><span class="sxs-lookup"><span data-stu-id="98773-143">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="98773-144">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-144">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-145">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-145">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="98773-146">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-146">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98773-147">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-147">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="98773-148">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-148">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="98773-149">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-149">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="98773-150">
            <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-150">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="98773-151">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-151">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="98773-152">Nombre de un evento de sincronización de todo el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-152">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="98773-153">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se creó un evento local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se creó el evento del sistema con nombre especificado; es <see langword="false" /> si el evento del sistema con nombre especificado ya existía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-153">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="98773-154">Este parámetro se pasa sin inicializar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-154">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-155">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente si se crea como resultado de esta llamada, si se restablece automática o manualmente, el nombre de un evento de sincronización del sistema y una variable booleana cuyo valor después de la llamada indica si se creó el evento del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-155">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-156">Si un evento del sistema con el nombre especificado para la `name` ya existe un parámetro, el `initialState` parámetro se ignora.</span><span class="sxs-lookup"><span data-stu-id="98773-156">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="98773-157">Después de llamar a este constructor, utilice el valor de la variable especificada para el `ref` parámetro (`ByRef` en Visual Basic)`createdNew` para determinar si el evento del sistema con nombre ya existía o se creó.</span><span class="sxs-lookup"><span data-stu-id="98773-157">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="98773-158">Si el estado inicial del evento es no señalado, los subprocesos que esperan en el evento se bloquean.</span><span class="sxs-lookup"><span data-stu-id="98773-158">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="98773-159">Si se señala el estado inicial y la <xref:System.Threading.EventResetMode.ManualReset> marca se especifica para `mode`, no bloqueará los subprocesos que esperan en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-159">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="98773-160">Si se señala el estado inicial, y `mode` es <xref:System.Threading.EventResetMode.AutoReset>, el primer subproceso que espera en el evento se publican inmediatamente, después del cual se restablecerá el evento, y los subprocesos posteriores se bloquean.</span><span class="sxs-lookup"><span data-stu-id="98773-160">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="98773-161">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-161">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-162">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-162">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="98773-163">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-163">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98773-164">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-164">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="98773-165">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-165">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="98773-166">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-166">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="98773-167">
            <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-167">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="98773-168">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-168">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="98773-169">Nombre de un evento de sincronización de todo el sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-169">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="98773-170">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se creó un evento local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se creó el evento del sistema con nombre especificado; es <see langword="false" /> si el evento del sistema con nombre especificado ya existía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-170">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="98773-171">Este parámetro se pasa sin inicializar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-171">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="eventSecurity">
          <span data-ttu-id="98773-172">Objeto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> que representa la seguridad del control de acceso que se va a aplicar al evento del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-172">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-173">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente si se crea como resultado de esta llamada, si se restablece automática o manualmente, el nombre de un evento de sincronización del sistema, una variable booleana cuyo valor después de la llamada indica si se creó el evento del sistema con nombre y la seguridad de control de acceso para aplicar al evento con nombre si se crea.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-173">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-174">Utilice este constructor para aplicar la seguridad de control de acceso a un evento del sistema con nombre cuando se crea, impide que otro código tome el control del evento.</span><span class="sxs-lookup"><span data-stu-id="98773-174">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="98773-175">Este constructor inicializa un <xref:System.Threading.EventWaitHandle> objeto que representa un evento del sistema.</span><span class="sxs-lookup"><span data-stu-id="98773-175">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="98773-176">Puede crear varias <xref:System.Threading.EventWaitHandle> objetos que representan el mismo evento del sistema.</span><span class="sxs-lookup"><span data-stu-id="98773-176">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="98773-177">Si el evento del sistema no existe, se crea con la seguridad de control de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="98773-177">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="98773-178">Si el evento no existe, se omite la seguridad de control de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="98773-178">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="98773-179">El llamador tiene control total sobre el recién creado <xref:System.Threading.EventWaitHandle> objeto incluso si `eventSecurity` deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual.</span><span class="sxs-lookup"><span data-stu-id="98773-179">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="98773-180">Sin embargo, si el usuario actual intenta obtener otro <xref:System.Threading.EventWaitHandle> representar el mismo evento con nombre, utilizando un constructor de objeto o el <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método, se aplica la seguridad de control de acceso de Windows.</span><span class="sxs-lookup"><span data-stu-id="98773-180">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="98773-181">Si un evento del sistema con el nombre especificado para la `name` ya existe un parámetro, el `initialState` parámetro se ignora.</span><span class="sxs-lookup"><span data-stu-id="98773-181">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="98773-182">Después de llamar a este constructor, utilice el valor de la variable especificada para el `ref` parámetro (`ByRef` en Visual Basic) `createdNew` para determinar si el evento del sistema con nombre ya existía o se creó.</span><span class="sxs-lookup"><span data-stu-id="98773-182">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="98773-183">Si el estado inicial del evento es no señalado, los subprocesos que esperan en el evento se bloquean.</span><span class="sxs-lookup"><span data-stu-id="98773-183">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="98773-184">Si se señala el estado inicial y la <xref:System.Threading.EventResetMode.ManualReset> marca se especifica para `mode`, no bloqueará los subprocesos que esperan en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-184">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="98773-185">Si se señala el estado inicial, y `mode` es <xref:System.Threading.EventResetMode.AutoReset>, el primer subproceso que espera en el evento se publican inmediatamente, después del cual se restablecerá el evento, y los subprocesos posteriores se bloquean.</span><span class="sxs-lookup"><span data-stu-id="98773-185">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98773-186">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="98773-186">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="98773-187">El ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-187">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="98773-188">Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero le concede el derecho a leer y cambiar los permisos en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-188">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="98773-189">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="98773-189">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98773-190">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-190">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="98773-191">Una vez cambiados los permisos, el evento se abre con los derechos necesarios para esperar en él y señalarlo.</span><span class="sxs-lookup"><span data-stu-id="98773-191">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="98773-192">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, el ejemplo se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-192">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="98773-193">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-193">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-194">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-194">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="98773-195">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-195">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98773-196">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-196">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="98773-197">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-197">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="98773-198">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-198">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="98773-199">Obtiene un objeto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> que representa la seguridad de control de acceso para el evento del sistema con nombre representado por el objeto <see cref="T:System.Threading.EventWaitHandle" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-199">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="98773-200">Objeto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> que representa la seguridad de control de acceso para el evento del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-200">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-201">El <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método utiliza la siguiente combinación de indicadores (combinados mediante la operación OR bit a bit) para buscar los permisos: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, y <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="98773-201">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="98773-202">El usuario debe tener <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> derechos para llamar a este método y el evento deben haberse abiertos con el <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="98773-202">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98773-203">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="98773-203">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="98773-204">El ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-204">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="98773-205">Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero le concede el derecho a leer y cambiar los permisos en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-205">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="98773-206">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="98773-206">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98773-207">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-207">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="98773-208">Después de que se han leído los permisos, mediante el <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> (método), y ha cambiado, el evento se abre con los derechos necesarios para esperar en él y señalarlo.</span><span class="sxs-lookup"><span data-stu-id="98773-208">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="98773-209">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, el ejemplo se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-209">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-210">El objeto <see cref="T:System.Threading.EventWaitHandle" /> actual representa un evento del sistema con nombre y el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-210">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
          <span data-ttu-id="98773-211">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-211">-or-</span>
          </span>
          <span data-ttu-id="98773-212">El objeto <see cref="T:System.Threading.EventWaitHandle" /> actual representa un evento del sistema con nombre que no se ha abierto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-212">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="98773-213">No se admite para Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-213">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="98773-214">No se ha llamado previamente al método <see cref="M:System.Threading.WaitHandle.Close" /> en este <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-214">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="98773-215">Abre un evento de sincronización con nombre especificado, si ya existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-215">Opens a specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="98773-216">Nombre del evento de sincronización del sistema que se va a abrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-216">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-217">Abre el evento de sincronización con nombre especificado, si ya existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-217">Opens the specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="98773-218">Objeto que representa el evento del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-218">An  object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-219">El <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método intenta abrir el evento del sistema con nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="98773-219">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="98773-220">Si el evento del sistema no existe, este método produce una excepción en lugar de crear el evento del sistema.</span><span class="sxs-lookup"><span data-stu-id="98773-220">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="98773-221">Para crear el evento del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructores que tenga un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="98773-221">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="98773-222">Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.EventWaitHandle> objeto, incluso si los objetos devueltos representan el mismo evento del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-222">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="98773-223">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="98773-223">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="98773-224">Especificar el <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso debe esperar en el evento del sistema con nombre y especificando el <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> y <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="98773-224">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98773-225">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="98773-225">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="98773-226">El ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-226">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="98773-227">Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero le concede el derecho a leer y cambiar los permisos en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-227">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="98773-228">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="98773-228">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98773-229">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-229">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="98773-230">Una vez cambiados los permisos, el evento se abre con los derechos necesarios para esperar en él y señalarlo.</span><span class="sxs-lookup"><span data-stu-id="98773-230">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="98773-231">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, el ejemplo se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-231">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98773-232">
            <paramref name="name" /> es una cadena vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-232">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="98773-233">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-233">-or-</span>
          </span>
          <span data-ttu-id="98773-234">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-234">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98773-235">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-235">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="98773-236">El evento del sistema con nombre no existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-236">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="98773-237">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-237">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-238">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad exigido para utilizarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-238">The named event exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="98773-239">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-239">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="98773-240">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-240">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="98773-241">Nombre del evento de sincronización del sistema que se va a abrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-241">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="98773-242">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-242">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-243">Abre el evento de sincronización con nombre especificado, si ya existe, con el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-243">Opens the specified named synchronization event, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="98773-244">Objeto que representa el evento del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-244">An object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-245">El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos esperan en el evento y el <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> y <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="98773-245">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="98773-246">El <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método intenta abrir un evento del sistema con nombre existente.</span><span class="sxs-lookup"><span data-stu-id="98773-246">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="98773-247">Si el evento del sistema no existe, este método produce una excepción en lugar de crear el evento del sistema.</span><span class="sxs-lookup"><span data-stu-id="98773-247">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="98773-248">Para crear el evento del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructores que tenga un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="98773-248">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="98773-249">Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.EventWaitHandle> objeto, incluso si los objetos devueltos representan el mismo evento del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-249">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98773-250">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="98773-250">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="98773-251">El ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-251">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="98773-252">Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero le concede el derecho a leer y cambiar los permisos en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-252">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="98773-253">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="98773-253">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98773-254">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-254">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="98773-255">Una vez cambiados los permisos, el evento se abre con los derechos necesarios para esperar en él y señalarlo.</span><span class="sxs-lookup"><span data-stu-id="98773-255">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="98773-256">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, el ejemplo se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-256">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98773-257">
            <paramref name="name" /> es una cadena vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-257">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="98773-258">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-258">-or-</span>
          </span>
          <span data-ttu-id="98773-259">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-259">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98773-260">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-260">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="98773-261">El evento del sistema con nombre no existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-261">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="98773-262">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-262">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-263">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-263">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="98773-264">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-264">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="98773-265">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-265">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="98773-266">Establece el estado del evento en no señalado, por lo que se bloquean los subprocesos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-266">Sets the state of the event to nonsignaled, causing threads to block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="98773-267">
            <see langword="true" /> si la operación se realiza correctamente; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-267">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="98773-268">No se ha llamado previamente al método <see cref="M:System.Threading.WaitHandle.Close" /> en este <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-268">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="98773-269">Establece el estado del evento en señalado, lo que permite que uno o varios subprocesos en espera continúen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-269">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="98773-270">
            <see langword="true" /> si la operación se realiza correctamente; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-270">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-271">Para una <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (incluidos <xref:System.Threading.AutoResetEvent>), el <xref:System.Threading.EventWaitHandle.Set%2A> método libera un único subproceso.</span><span class="sxs-lookup"><span data-stu-id="98773-271">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="98773-272">Si no hay ningún subproceso en espera, el identificador de espera permanece señalado hasta que un subproceso intente esperar en él, o hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="98773-272">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="98773-273">No hay ninguna garantía de que todas las llamadas a la <xref:System.Threading.EventWaitHandle.Set%2A> método volverá a liberar un subproceso de un <xref:System.Threading.EventWaitHandle> cuyo modo de restablecimiento es <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="98773-273">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="98773-274">Si dos llamadas están demasiado juntos, por lo que la segunda llamada se produce antes de que se ha liberado un subproceso, se libera un solo subproceso.</span><span class="sxs-lookup"><span data-stu-id="98773-274">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="98773-275">Es como si no se produjera la segunda llamada.</span><span class="sxs-lookup"><span data-stu-id="98773-275">It is as if the second call did not happen.</span></span> <span data-ttu-id="98773-276">Además, si <xref:System.Threading.EventWaitHandle.Set%2A> se llama cuando no hay ningún subproceso esperando y <xref:System.Threading.EventWaitHandle> ya se ha señalado, la llamada no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="98773-276">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="98773-277">Para una <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (incluidos <xref:System.Threading.ManualResetEvent>), la llamada a la <xref:System.Threading.EventWaitHandle.Set%2A> método deja el identificador de espera en estado señalado hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="98773-277">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98773-278">El siguiente ejemplo de código utiliza el <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga del método para permitir que el subproceso principal indicar un subproceso bloqueado y, a continuación, espere a que el subproceso finalice una tarea.</span><span class="sxs-lookup"><span data-stu-id="98773-278">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="98773-279">El ejemplo inicia cinco subprocesos y se les permite bloquearse en un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca, a continuación, en vez de un subproceso de versiones el usuario presiona la tecla ENTRAR.</span><span class="sxs-lookup"><span data-stu-id="98773-279">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="98773-280">En el ejemplo, a continuación, pone en cola otros cinco subprocesos y se liberan todos ellos utilizando una <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="98773-280">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="98773-281">No se ha llamado previamente al método <see cref="M:System.Threading.WaitHandle.Close" /> en este <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-281">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">
          <span data-ttu-id="98773-282">Objeto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> que representa la seguridad del control de acceso que se va a aplicar al evento del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-282">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-283">Establece la seguridad de control de acceso para evento del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-283">Sets the access control security for a named system event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-284">El usuario debe tener <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> derechos para llamar a este método y el evento deben haberse abiertos con el <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="98773-284">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="98773-285">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="98773-285">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="98773-286">El ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para comprobar la existencia de un evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-286">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="98773-287">Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero le concede el derecho a leer y cambiar los permisos en el evento.</span><span class="sxs-lookup"><span data-stu-id="98773-287">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="98773-288">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="98773-288">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="98773-289">Se detectó la excepción y el ejemplo se utiliza la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-289">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="98773-290">Una vez cambiados los permisos, mediante el <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> método, el evento se abre con los derechos necesarios para esperar en él y señalarlo.</span><span class="sxs-lookup"><span data-stu-id="98773-290">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="98773-291">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, el ejemplo se ejecuta utilizando los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="98773-291">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98773-292">
            <paramref name="eventSecurity" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-292">
              <paramref name="eventSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-293">El usuario no dispone de permisos <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-293">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
          <span data-ttu-id="98773-294">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-294">-or-</span>
          </span>
          <span data-ttu-id="98773-295">El evento no se ha abierto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-295">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="98773-296">El objeto <see cref="T:System.Threading.EventWaitHandle" /> actual no representa un evento del sistema con nombre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-296">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="98773-297">No se ha llamado previamente al método <see cref="M:System.Threading.WaitHandle.Close" /> en este <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-297">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="98773-298">Abre un evento de sincronización con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-298">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="98773-299">Nombre del evento de sincronización del sistema que se va a abrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-299">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="98773-300">Cuando este método devuelve un resultado, contiene un objeto <see cref="T:System.Threading.EventWaitHandle" /> que representa el evento de sincronización con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-300">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="98773-301">Este parámetro se trata como sin inicializar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-301">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-302">Abre el evento de sincronización con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-302">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="98773-303">Es <see langword="true" /> si el evento de sincronización con nombre se abrió correctamente; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-303">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-304">Si el evento de sincronización con nombre no existe, este método no la crea.</span><span class="sxs-lookup"><span data-stu-id="98773-304">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="98773-305">Para crear el evento del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructores que tenga un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="98773-305">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="98773-306">Si no está seguro de si existe un evento de sincronización con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método que produce una excepción si el evento de sincronización no existe.</span><span class="sxs-lookup"><span data-stu-id="98773-306">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="98773-307">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="98773-307">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="98773-308">Especificar el <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso debe esperar en el evento del sistema con nombre y especificando el <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> y <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="98773-308">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="98773-309">Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.EventWaitHandle> objeto, incluso si los objetos devueltos representan el mismo evento del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-309">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98773-310">
            <paramref name="name" /> es una cadena vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-310">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="98773-311">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-311">-or-</span>
          </span>
          <span data-ttu-id="98773-312">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-312">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98773-313">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-313">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="98773-314">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-314">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-315">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-315">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="98773-316">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-316">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="98773-317">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-317">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="98773-318">Nombre del evento de sincronización del sistema que se va a abrir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-318">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="98773-319">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-319">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="98773-320">Cuando este método devuelve un resultado, contiene un objeto <see cref="T:System.Threading.EventWaitHandle" /> que representa el evento de sincronización con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-320">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="98773-321">Este parámetro se trata como sin inicializar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-321">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="98773-322">Abre el evento de sincronización con nombre especificado, si ya existe, con el acceso de seguridad deseado, y devuelve un valor que indica si la operación se realizó correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-322">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="98773-323">Es <see langword="true" /> si el evento de sincronización con nombre se abrió correctamente; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-323">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="98773-324">Si el evento de sincronización con nombre no existe, este método no la crea.</span><span class="sxs-lookup"><span data-stu-id="98773-324">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="98773-325">Para crear el evento del sistema cuando aún no existe, utilice uno de los <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructores que tenga un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="98773-325">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="98773-326">Si no está seguro de si existe un evento de sincronización con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método que produce una excepción si el evento de sincronización no existe.</span><span class="sxs-lookup"><span data-stu-id="98773-326">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="98773-327">El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos esperan en el evento y el <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> y <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="98773-327">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="98773-328">Varias llamadas a este método que utilizan el mismo valor para `name` no devuelven necesariamente el mismo <xref:System.Threading.EventWaitHandle> objeto, incluso si los objetos devueltos representan el mismo evento del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="98773-328">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="98773-329">
            <paramref name="name" /> es una cadena vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-329">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="98773-330">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-330">-or-</span>
          </span>
          <span data-ttu-id="98773-331">
            <paramref name="name" /> tiene más de 260 caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-331">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="98773-332">
            <paramref name="name" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-332">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="98773-333">Error de Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-333">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="98773-334">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad deseado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-334">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="98773-335">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-335">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="98773-336">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="98773-336">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>