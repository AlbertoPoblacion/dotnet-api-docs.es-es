<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="736b05993c69add826b16620b79fa609ad8ac941" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48743364" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un evento de sincronización de subprocesos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Threading.EventWaitHandle> clase permite que los subprocesos se comuniquen entre sí mediante señalización. Normalmente, uno o varios subprocesos se bloquean en un <xref:System.Threading.EventWaitHandle> hasta que un subproceso desbloqueado llama el <xref:System.Threading.EventWaitHandle.Set%2A> método, liberando uno o varios de los subprocesos bloqueados. Un subproceso puede señalar un <xref:System.Threading.EventWaitHandle> y, a continuación, bloquearse en ella, mediante una llamada a la `static` (`Shared` en Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  La <xref:System.Threading.EventWaitHandle> clase proporciona acceso a los eventos de sincronización de sistema con nombre.  
  
 El comportamiento de un <xref:System.Threading.EventWaitHandle> que se haya señalado depende de su modo de restablecimiento. Un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca restablece automáticamente cuando se le señala, después de liberar un subproceso en espera único. Un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca permanece señalada hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método.  
  
 Eventos de restablecimiento automático proporcionan un acceso exclusivo a un recurso. Si un evento de restablecimiento automático se señaliza cuando no hay ningún subproceso en espera, permanece señalado hasta que un subproceso intenta esperar en él. El evento libera el subproceso y lo restablece inmediatamente, bloqueando los subprocesos subsiguientes.  
  
 Los eventos son como puertas de restablecimiento manual. Cuando no se señala el evento, se bloquearán los subprocesos que esperan en él. Cuando se señala el evento, se liberan todos los subprocesos en espera y permanece señalado el evento (es decir, las esperas subsiguientes no bloquean) hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método. Eventos de restablecimiento manual son útiles cuando un subproceso debe completar una actividad para que pueden continuar otros subprocesos.  
  
 <xref:System.Threading.EventWaitHandle> los objetos se pueden usar con el `static`(`Shared` en Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> y <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos.  
  
 Para obtener más información acerca de los mecanismos de sincronización de subprocesos, vea [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga del método para permitir que el subproceso principal indicar un subproceso bloqueado y, a continuación, espere a que el subproceso finalice una tarea.  
  
 En el ejemplo se inician cinco subprocesos y le permite bloquear un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca y, después, en vez de un subproceso de versiones el usuario presiona la tecla ENTRAR. En el ejemplo, a continuación, pone en cola otros cinco subprocesos y liberan todos ellos utilizando una <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
    <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">Es <see langword="true" /> para establecer el estado inicial en señalado; es <see langword="false" /> para establecerlo en no señalado.</param>
        <param name="mode">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente y si se restablece automática o manualmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el estado inicial del evento no señalado, se bloquearán los subprocesos que esperan el evento. Si se señala el estado inicial y el <xref:System.Threading.EventResetMode.ManualReset> indicador se especifica para `mode`, no bloqueará los subprocesos que esperan el evento. Si se señala el estado inicial, y `mode` es <xref:System.Threading.EventResetMode.AutoReset>, el primer subproceso que espera en el evento se va a publicar inmediatamente después del cual se restablecerá el evento y se bloquearán los subprocesos subsiguientes.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga del método para permitir que el subproceso principal indicar un subproceso bloqueado y, a continuación, espere a que el subproceso finalice una tarea.  
  
 En el ejemplo se inician cinco subprocesos y le permite bloquear un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca y, después, en vez de un subproceso de versiones el usuario presiona la tecla ENTRAR. En el ejemplo, a continuación, pone en cola otros cinco subprocesos y liberan todos ellos utilizando una <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</param>
        <param name="mode">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
        <param name="name">Nombre de un evento de sincronización de todo el sistema.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente cuando se crea como resultado de esta llamada, si se restablece automática o manualmente y el nombre de un evento de sincronización del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `name` es `null` o una cadena vacía, una variable local <xref:System.Threading.EventWaitHandle> se crea.  
  
 Si un evento del sistema con el nombre especificado para el `name` ya existe un parámetro, el `initialState` se omite el parámetro.  
  
> [!IMPORTANT]
>  Al utilizar este constructor para los eventos del sistema con nombre, especifique `false` para `initialState`. Este constructor no proporciona ninguna manera de determinar si se creó un evento del sistema con nombre, por lo que no se puede hacer ninguna suposición sobre el estado del evento con nombre. Para determinar si se ha creado un evento con nombre, use la <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.  
  
 Si el estado inicial del evento no señalado, se bloquearán los subprocesos que esperan el evento. Si se señala el estado inicial y el <xref:System.Threading.EventResetMode.ManualReset> indicador se especifica para `mode`, no bloqueará los subprocesos que esperan el evento. Si se señala el estado inicial, y `mode` es <xref:System.Threading.EventResetMode.AutoReset>, el primer subproceso que espera en el evento se va a publicar inmediatamente después del cual se restablecerá el evento y se bloquearán los subprocesos subsiguientes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</param>
        <param name="mode">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
        <param name="name">Nombre de un evento de sincronización de todo el sistema.</param>
        <param name="createdNew">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se creó un evento local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se creó el evento del sistema con nombre especificado; es <see langword="false" /> si el evento del sistema con nombre especificado ya existía. Este parámetro se pasa sin inicializar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente si se crea como resultado de esta llamada, si se restablece automática o manualmente, el nombre de un evento de sincronización del sistema y una variable booleana cuyo valor después de la llamada indica si se creó el evento del sistema con nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un evento del sistema con el nombre especificado para el `name` ya existe un parámetro, el `initialState` se omite el parámetro. Después de llamar a este constructor, utilice el valor de la variable especificada para el `ref` parámetro (`ByRef` en Visual Basic)`createdNew` para determinar si el evento del sistema con nombre ya existía o se ha creado.  
  
 Si el estado inicial del evento no señalado, se bloquearán los subprocesos que esperan el evento. Si se señala el estado inicial y el <xref:System.Threading.EventResetMode.ManualReset> indicador se especifica para `mode`, no bloqueará los subprocesos que esperan el evento. Si se señala el estado inicial, y `mode` es <xref:System.Threading.EventResetMode.AutoReset>, el primer subproceso que espera en el evento se va a publicar inmediatamente después del cual se restablecerá el evento y se bloquearán los subprocesos subsiguientes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> para establecer el estado inicial en señalado si el evento con nombre se crea como resultado de esta llamada; <see langword="false" /> para establecerlo en no señalado.</param>
        <param name="mode">Uno de los valores <see cref="T:System.Threading.EventResetMode" /> que determina si el evento se restablece automática o manualmente.</param>
        <param name="name">Nombre de un evento de sincronización de todo el sistema.</param>
        <param name="createdNew">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se creó un evento local (es decir, si <c>name</c> es <see langword="null" /> o una cadena vacía) o si se creó el evento del sistema con nombre especificado; es <see langword="false" /> si el evento del sistema con nombre especificado ya existía. Este parámetro se pasa sin inicializar.</param>
        <param name="eventSecurity">Objeto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> que representa la seguridad del control de acceso que se va a aplicar al evento del sistema con nombre.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.EventWaitHandle" />, especificando si el identificador de espera se señala inicialmente si se crea como resultado de esta llamada, si se restablece automática o manualmente, el nombre de un evento de sincronización del sistema, una variable booleana cuyo valor después de la llamada indica si se creó el evento del sistema con nombre y la seguridad de control de acceso para aplicar al evento con nombre si se crea.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para aplicar la seguridad de control de acceso a un evento del sistema con nombre cuando se crea, impide que otro código tome el control del evento.  
  
 Este constructor inicializa un <xref:System.Threading.EventWaitHandle> objeto que representa un evento del sistema. Puede crear varias <xref:System.Threading.EventWaitHandle> objetos que representan el mismo evento del sistema.  
  
 Si el evento del sistema no existe, se crea con la seguridad de control de acceso especificada. Si el evento existe, se omite la seguridad de control de acceso especificada.  
  
> [!NOTE]
>  El llamador tiene control total sobre el recién creado <xref:System.Threading.EventWaitHandle> objeto incluso si `eventSecurity` deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual. Sin embargo, si el usuario actual intenta obtener otro <xref:System.Threading.EventWaitHandle> representar el mismo evento con nombre, ya sea mediante un constructor de objeto o el <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método, se aplica la seguridad de control de acceso de Windows.  
  
 Si un evento del sistema con el nombre especificado para el `name` ya existe un parámetro, el `initialState` se omite el parámetro. Después de llamar a este constructor, utilice el valor de la variable especificada para el `ref` parámetro (`ByRef` en Visual Basic) `createdNew` para determinar si el evento del sistema con nombre ya existía o se ha creado.  
  
 Si el estado inicial del evento no señalado, se bloquearán los subprocesos que esperan el evento. Si se señala el estado inicial y el <xref:System.Threading.EventResetMode.ManualReset> indicador se especifica para `mode`, no bloqueará los subprocesos que esperan el evento. Si se señala el estado inicial, y `mode` es <xref:System.Threading.EventResetMode.AutoReset>, el primer subproceso que espera en el evento se va a publicar inmediatamente después del cual se restablecerá el evento y se bloquearán los subprocesos subsiguientes.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un evento con nombre.  
  
 Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero se concede el derecho para leer y cambiar los permisos en el evento.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, el evento se abre con los derechos necesarios para esperar en él y señalarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta el ejemplo utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el evento con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> que representa la seguridad de control de acceso para el evento del sistema con nombre representado por el objeto <see cref="T:System.Threading.EventWaitHandle" /> actual.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> que representa la seguridad de control de acceso para el evento del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método utiliza la siguiente combinación de indicadores (combinados con la operación OR bit a bit) para buscar los permisos: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, y <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 El usuario debe tener <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> derechos para llamar a este método y el evento deben haberse abiertos con el <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> marca.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un evento con nombre.  
  
 Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero se concede el derecho para leer y cambiar los permisos en el evento.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de que se han leído los permisos, mediante el <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método, y puede cambiar, el evento se abre con los derechos necesarios para esperar en él y señalarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta el ejemplo utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El objeto <see cref="T:System.Threading.EventWaitHandle" /> actual representa un evento del sistema con nombre y el usuario no tiene <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
O bien 
El objeto <see cref="T:System.Threading.EventWaitHandle" /> actual representa un evento del sistema con nombre que no se ha abierto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite para Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">No se ha llamado previamente al método <see cref="M:System.Threading.WaitHandle.Close" /> en este <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un evento de sincronización con nombre especificado, si ya existe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del evento de sincronización del sistema que se va a abrir.</param>
        <summary>Abre el evento de sincronización con nombre especificado, si ya existe.</summary>
        <returns>Objeto que representa el evento del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método intenta abrir el evento del sistema con nombre especificado. Si el evento del sistema no existe, este método produce una excepción en lugar de crear el evento del sistema. Para crear el evento del sistema cuando ya no existe, use uno de los <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.EventWaitHandle> objeto, aunque los objetos que se devuelven representan el mismo evento del sistema con nombre.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.  
  
 Especificar el <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso espere el evento del sistema con nombre y especificando el <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> y <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un evento con nombre.  
  
 Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero se concede el derecho para leer y cambiar los permisos en el evento.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, el evento se abre con los derechos necesarios para esperar en él y señalarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta el ejemplo utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">El evento del sistema con nombre no existe.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad exigido para utilizarlo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del evento de sincronización del sistema que se va a abrir.</param>
        <param name="rights">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</param>
        <summary>Abre el evento de sincronización con nombre especificado, si ya existe, con el acceso de seguridad deseado.</summary>
        <returns>Objeto que representa el evento del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos esperen en el evento y el <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> y <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 El <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método intenta abrir un evento del sistema con nombre existente. Si el evento del sistema no existe, este método produce una excepción en lugar de crear el evento del sistema. Para crear el evento del sistema cuando ya no existe, use uno de los <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.EventWaitHandle> objeto, aunque los objetos que se devuelven representan el mismo evento del sistema con nombre.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un evento con nombre.  
  
 Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero se concede el derecho para leer y cambiar los permisos en el evento.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, el evento se abre con los derechos necesarios para esperar en él y señalarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta el ejemplo utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">El evento del sistema con nombre no existe.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad deseado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece el estado del evento en no señalado, por lo que se bloquean los subprocesos.</summary>
        <returns>
          <see langword="true" /> si la operación se realiza correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">No se ha llamado previamente al método <see cref="M:System.Threading.WaitHandle.Close" /> en este <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece el estado del evento en señalado, lo que permite que uno o varios subprocesos en espera continúen.</summary>
        <returns>
          <see langword="true" /> si la operación se realiza correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para un <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (incluidos <xref:System.Threading.AutoResetEvent>), el <xref:System.Threading.EventWaitHandle.Set%2A> método libera un único subproceso. Si no hay ningún subproceso en espera, el identificador de espera permanece señalado hasta que un subproceso intenta esperar en él, o hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método.  
  
> [!IMPORTANT]
>  No hay ninguna garantía de que todas las llamadas a la <xref:System.Threading.EventWaitHandle.Set%2A> método liberará un subproceso de un <xref:System.Threading.EventWaitHandle> cuyo modo de restablecimiento <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Si dos llamadas están demasiado cerca, para que la segunda llamada se produce antes de que se ha liberado un subproceso, se libera un solo subproceso. Es como si no se produjera la segunda llamada. Además, si <xref:System.Threading.EventWaitHandle.Set%2A> se llama cuando no hay ningún subproceso en espera y el <xref:System.Threading.EventWaitHandle> ya está señalizado, la llamada no tiene ningún efecto.  
  
 Para un <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (incluidos <xref:System.Threading.ManualResetEvent>), al llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> método deja el identificador de espera en un estado señalado hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga del método para permitir que el subproceso principal indicar un subproceso bloqueado y, a continuación, espere a que el subproceso finalice una tarea.  
  
 En el ejemplo se inician cinco subprocesos y le permite bloquear un <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> marca y, después, en vez de un subproceso de versiones el usuario presiona la tecla ENTRAR. En el ejemplo, a continuación, pone en cola otros cinco subprocesos y liberan todos ellos utilizando una <xref:System.Threading.EventWaitHandle> creado con el <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> marca.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">No se ha llamado previamente al método <see cref="M:System.Threading.WaitHandle.Close" /> en este <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Objeto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> que representa la seguridad del control de acceso que se va a aplicar al evento del sistema con nombre.</param>
        <summary>Establece la seguridad de control de acceso para evento del sistema con nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario debe tener <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> derechos para llamar a este método y el evento deben haberse abiertos con el <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> marca.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un evento del sistema con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un evento con nombre.  
  
 Si el evento no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar el evento, pero se concede el derecho para leer y cambiar los permisos en el evento.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método para esperar en el evento con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, mediante el <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> método, el evento se abre con los derechos necesarios para esperar en él y señalarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta el ejemplo utilizando los nuevos permisos.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no dispone de permisos <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
O bien 
El evento no se ha abierto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">El objeto <see cref="T:System.Threading.EventWaitHandle" /> actual no representa un evento del sistema con nombre.</exception>
        <exception cref="T:System.ObjectDisposedException">No se ha llamado previamente al método <see cref="M:System.Threading.WaitHandle.Close" /> en este <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent y ManualResetEvent</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un evento de sincronización con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del evento de sincronización del sistema que se va a abrir.</param>
        <param name="result">Cuando este método devuelve un resultado, contiene un objeto <see cref="T:System.Threading.EventWaitHandle" /> que representa el evento de sincronización con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma. Este parámetro se trata como sin inicializar.</param>
        <summary>Abre el evento de sincronización con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
        <returns>Es <see langword="true" /> si el evento de sincronización con nombre se abrió correctamente; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el evento de sincronización con nombre no existe, este método no la crea. Para crear el evento del sistema cuando ya no existe, use uno de los <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Si no está seguro de si existe un evento de sincronización con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga del método que produce una excepción si el evento de sincronización no existe.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit. Especificar el <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso espere el evento del sistema con nombre y especificando el <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> y <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.EventWaitHandle> objeto, aunque los objetos que se devuelven representan el mismo evento del sistema con nombre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad deseado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del evento de sincronización del sistema que se va a abrir.</param>
        <param name="rights">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</param>
        <param name="result">Cuando este método devuelve un resultado, contiene un objeto <see cref="T:System.Threading.EventWaitHandle" /> que representa el evento de sincronización con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma. Este parámetro se trata como sin inicializar.</param>
        <summary>Abre el evento de sincronización con nombre especificado, si ya existe, con el acceso de seguridad deseado, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
        <returns>Es <see langword="true" /> si el evento de sincronización con nombre se abrió correctamente; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el evento de sincronización con nombre no existe, este método no la crea. Para crear el evento del sistema cuando ya no existe, use uno de los <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Si no está seguro de si existe un evento de sincronización con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga del método que produce una excepción si el evento de sincronización no existe.  
  
 El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos esperen en el evento y el <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.EventWaitHandle.Set%2A> y <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.EventWaitHandle> objeto, aunque los objetos que se devuelven representan el mismo evento del sistema con nombre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El evento con nombre existe, pero el usuario no tiene el acceso de seguridad deseado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>