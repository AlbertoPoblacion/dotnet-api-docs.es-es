<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fc1a0c88765040869d8ad919aeb575e304c71bde" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531039" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define un bloqueo que admite un escritor y varios lectores.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] tiene dos bloqueos de lector y escritor, <xref:System.Threading.ReaderWriterLockSlim> y <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> se recomienda para todos los nuevos desarrollos. <xref:System.Threading.ReaderWriterLockSlim> es similar a <xref:System.Threading.ReaderWriterLock>, pero se han simplificado las reglas para la recursividad y para actualizar y degradar el estado de bloqueo. <xref:System.Threading.ReaderWriterLockSlim> evita muchos casos de interbloqueo potencial. Además, el rendimiento de <xref:System.Threading.ReaderWriterLockSlim> es significativamente mayor que <xref:System.Threading.ReaderWriterLock>.  
  
 <xref:System.Threading.ReaderWriterLock> se utiliza para sincronizar el acceso a un recurso. En un momento dado, permite el acceso de lectura simultáneo de varios subprocesos, o bien acceso de escritura para un único subproceso. En una situación donde un recurso se cambia con poca frecuencia, un `ReaderWriterLock` proporciona un mayor rendimiento que un simple bloqueo de uno en uno, como <xref:System.Threading.Monitor>.  
  
 `ReaderWriterLock` funciona mejor en su mayoría de los accesos es de lectura y las escrituras son poco frecuentes y de corta duración. Se alternan varios lectores con escritores únicos, para que los lectores ni escritores se bloquean durante largos períodos.  
  
> [!NOTE]
>  Que contiene los bloqueos de lector o bloqueos de escritor durante largos períodos privar a otros subprocesos. Para obtener el mejor rendimiento, considere la posibilidad de reestructurar la aplicación para reducir la duración de las escrituras.  
  
 Un subproceso puede contener un lector de bloqueo o un bloqueo de escritura, pero no ambos al mismo tiempo. En lugar de liberar un bloqueo de lector para adquirir el bloqueo de escritor, puede usar <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> y <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.  
  
 Solicitudes de bloqueo recursivas aumentan el recuento de bloqueos en un bloqueo.  
  
 Los lectores y escritores se ponen en cola por separado. Cuando un subproceso libera el bloqueo de escritor, todos los subprocesos que esperan en la cola del lector en ese momento se conceden bloqueos de lector; Cuando todos los bloqueos de lector de se han liberado, el siguiente subproceso en espera en el sistema de escritura de cola, si los hay, se concede el bloqueo de escritor y así sucesivamente. En otras palabras, `ReaderWriterLock` alterna entre una colección de lectores y un sistema de escritura.  
  
 Mientras un subproceso en la cola del escritor está esperando a que se liberen los bloqueos de lector activo, los subprocesos que soliciten nuevos bloqueos de lector se acumulan en la cola del lector. Sus solicitudes no se conceden, aunque podrían compartir el acceso simultáneo con propietarios de bloqueos de lector existentes; Esto ayuda a proteger a los escritores frente a bloqueos indefinidos por los lectores.  
  
 Mayoría de los métodos para adquirir bloqueos en un `ReaderWriterLock` aceptar valores de tiempo de espera. Use los tiempos de espera para evitar interbloqueos en la aplicación. Por ejemplo, un subproceso podría adquirir el bloqueo de escritor en un recurso y, a continuación, solicitar un bloqueo de lector en un segundo recurso; mientras tanto, otro subproceso podría adquirir el bloqueo de escritura en el segundo recurso y solicitar un bloqueo de lector en la primera. A menos que se utilizan los tiempos de espera, el interbloqueo de subprocesos.  
  
 Si expira el intervalo de tiempo de espera y la solicitud de bloqueo no se ha concedido, el método devuelve el control al subproceso que realiza la llamada produciendo un <xref:System.ApplicationException>. Un subproceso puede detectar esta excepción y determinar qué acción se debe tomar.  
  
 Los tiempos de espera se expresan en milisegundos. Si utiliza un <xref:System.TimeSpan?displayProperty=nameWithType> para especificar el tiempo de espera, el valor utilizado es el número total de milisegundos enteros representados por la <xref:System.TimeSpan>. En la tabla siguiente se muestra los valores válidos de tiempo de espera en milisegundos.  
  
|Valor|Descripción|  
|-----------|-----------------|  
|-1|El subproceso espera hasta que se adquiere el bloqueo, independientemente de cuánto tiempo tarda. Para los métodos que especifican los tiempos de espera de entero, la constante <xref:System.Threading.Timeout.Infinite> se puede utilizar.|  
|0|El subproceso no espera para adquirir el bloqueo. Si no se puede adquirir el bloqueo inmediatamente, el método devuelve.|  
|>0|Número de milisegundos durante los que se va a esperar.|  
  
 A excepción de -1, no se permiten valores negativos de tiempo de espera. Si especifica un entero negativo distinto de -1, se usa en su lugar un valor de tiempo de espera de cero. (Es decir, el método devuelve sin esperar, si no se puede adquirir el bloqueo inmediatamente). Si especifica un <xref:System.TimeSpan> que representa un número negativo de milisegundos distinto de -1, <xref:System.ArgumentOutOfRangeException> se produce.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar un <xref:System.Threading.ReaderWriterLock> para proteger un recurso compartido, un valor entero denominado `resource`, que se leen simultáneamente y escriben exclusivamente por varios subprocesos. Tenga en cuenta que el <xref:System.Threading.ReaderWriterLock> se declara en el nivel de clase para que sea visible para todos los subprocesos.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se crea una nueva instancia de la clase <xref:System.Threading.ReaderWriterLock>.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adquiere un bloqueo de lector.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Tiempo de espera en milisegundos.</param>
        <summary>Adquiere un bloqueo de lector, utilizando un valor <see cref="T:System.Int32" /> para el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> se bloquea si un subproceso distinto tiene el bloqueo de escritor, o si al menos un subproceso está esperando para adquirir el bloqueo de escritor.  
  
> [!NOTE]
>  Si el subproceso actual ya tiene el bloqueo de escritor, no se adquiere ningún bloqueo de lector. En su lugar, se incrementa el recuento de bloqueos del bloqueo de escritor. Esto evita que un subproceso de bloqueo en su propio bloqueo de escritor. El resultado es exactamente el mismo que llamar al método <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>y una llamada adicional al <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> es necesaria cuando se libera el bloqueo de escritor.  
  
 `AcquireReaderLock` admite solicitudes de bloqueo de lector recursivas. Es decir, un subproceso puede llamar a AcquireReaderLock varias veces, lo que aumenta el recuento de bloqueos cada vez. Debe llamar a <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> una vez por cada vez que se llama `AcquireReaderLock`. Como alternativa, puede llamar a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reducir el recuento de bloqueos a cero inmediatamente.  
  
 Solicitudes de bloqueo recursivas siempre se conceden inmediatamente, sin colocar el subproceso de solicitud en la cola del lector. Utilice los bloqueos recursivos con precaución, para evitar el bloqueo de las solicitudes de bloqueo de escritor durante largos períodos.  
  
 Para los valores de tiempo de espera válidos, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo adquirir y liberar un bloqueo de lector y cómo controlar la excepción que se produce cuando se agota el tiempo de espera de una solicitud.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="millisecondsTimeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
        <summary>Adquiere un bloqueo de lector, utilizando un valor <see cref="T:System.TimeSpan" /> para el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> se bloquea si un subproceso distinto tiene el bloqueo de escritor, o si al menos un subproceso está esperando para adquirir el bloqueo de escritor.  
  
> [!NOTE]
>  Si el subproceso actual ya tiene el bloqueo de escritor, no se adquiere ningún bloqueo de lector. En su lugar, se incrementa el recuento de bloqueos del bloqueo de escritor. Esto evita que un subproceso de bloqueo en su propio bloqueo de escritor. El resultado es exactamente el mismo que llamar al método <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>y una llamada adicional al <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> es necesaria cuando se libera el bloqueo de escritor.  
  
 `AcquireReaderLock` admite solicitudes de bloqueo de lector recursivas. Es decir, un subproceso puede llamar a AcquireReaderLock varias veces, lo que aumenta el recuento de bloqueos cada vez. Debe llamar a <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> una vez por cada vez que se llama `AcquireReaderLock`. Como alternativa, puede llamar a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reducir el recuento de bloqueos a cero inmediatamente.  
  
 Solicitudes de bloqueo recursivas siempre se conceden inmediatamente, sin colocar el subproceso de solicitud en la cola del lector. Utilice los bloqueos recursivos con precaución, para evitar el bloqueo de las solicitudes de bloqueo de escritor durante largos períodos.  
  
 Para los valores de tiempo de espera válidos, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adquiere el bloqueo de escritor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Tiempo de espera en milisegundos.</param>
        <summary>Adquiere el bloqueo de escritor, utilizando un valor <see cref="T:System.Int32" /> para el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea si otro subproceso tiene un bloqueo de lector o escritor. Para obtener una descripción de la forma en que el bloqueo de escritor alterna con varios bloqueos de lector simultáneo, consulte la <xref:System.Threading.ReaderWriterLock> clase.  
  
 Un subproceso que ya tiene un bloqueo de lector puede adquirir el bloqueo de escritor de dos maneras: mediante la liberación del bloqueo de lector antes de llamar a <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, o mediante una llamada a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Si un subproceso llama a `AcquireWriterLock` mientras todavía tiene un bloqueo de lector, se bloqueará en su propio bloqueo de lector; si se especifica un tiempo de espera infinito, el subproceso interbloquee. Para evitar estos interbloqueos, utilice <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> para determinar si el subproceso actual ya tiene un bloqueo de lector.  
  
 `AcquireWriterLock` admite solicitudes de bloqueo de escritor recursivas. Es decir, un subproceso puede llamar a `AcquireWriterLock` varias veces, lo que aumenta el recuento de bloqueos cada vez. Debe llamar a <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> una vez por cada vez que se llama `AcquireWriterLock`. Como alternativa, puede llamar a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reducir el recuento de bloqueos a cero inmediatamente.  
  
 Solicitudes de bloqueo recursivas siempre se conceden inmediatamente, sin colocar el subproceso de solicitud en la cola del escritor.  
  
 Para los valores de tiempo de espera válidos, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo adquirir y liberar un bloqueo de escritura y cómo controlar la excepción que se produce cuando se agota el tiempo de espera de una solicitud.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">El <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
        <summary>Adquiere el bloqueo de escritor, utilizando un valor <see cref="T:System.TimeSpan" /> para el tiempo de espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea si otro subproceso tiene un bloqueo de lector o escritor. Para obtener una descripción de la forma en que el bloqueo de escritor alterna con varios bloqueos de lector simultáneo, consulte la <xref:System.Threading.ReaderWriterLock> clase.  
  
 Un subproceso que ya tiene un bloqueo de lector puede adquirir el bloqueo de escritor de dos maneras: mediante la liberación del bloqueo de lector antes de llamar a <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, o mediante una llamada a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Si un subproceso llama a `AcquireWriterLock` mientras todavía tiene un bloqueo de lector, se bloqueará en su propio bloqueo de lector; si se especifica un tiempo de espera infinito, el subproceso interbloquee. Para evitar estos interbloqueos, utilice <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> para determinar si el subproceso actual ya tiene un bloqueo de lector.  
  
 `AcquireWriterLock` admite solicitudes de bloqueo de escritor recursivas. Es decir, un subproceso puede llamar a `AcquireWriterLock` varias veces, lo que aumenta el recuento de bloqueos cada vez. Debe llamar a <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> una vez por cada vez que se llama `AcquireWriterLock`. Como alternativa, puede llamar a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reducir el recuento de bloqueos a cero inmediatamente.  
  
 Solicitudes de bloqueo recursivas siempre se conceden inmediatamente, sin colocar el subproceso de solicitud en la cola del escritor.  
  
 Para los valores de tiempo de espera válidos, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">Número de secuencia.</param>
        <summary>Indica si se ha concedido el bloqueo de escritor a algún subproceso desde que se obtuvo el número de secuencia.</summary>
        <returns>
          <see langword="true" /> si se ha concedido el bloqueo de escritor a algún subproceso desde que se obtuvo el número de secuencia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> y `AnyWritersSince` para mejorar el rendimiento de la aplicación. Por ejemplo, un subproceso puede almacenar en caché la información que obtiene mientras se mantiene un bloqueo de lector. Después de liberar y volver a adquirir el bloqueo, el subproceso puede usar `AnyWritersSince` para determinar si otros subprocesos han escrito en el recurso en el ínterin; en caso contrario, se puede utilizar la información almacenada en caché. Esta técnica es útil donde leer la información protegida por el bloqueo es costoso; Por ejemplo, ejecutar una consulta de base de datos.  
  
 El llamador debe contener un bloqueo de lector o un bloqueo de escritura en orden para el número de secuencia ser útil.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> método y <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propiedad para determinar si otro subproceso haya adquirido el bloqueo de escritura en el recurso protegido desde el subproceso actual estuvo por última vez el bloqueo de escritor.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Un <see cref="T:System.Threading.LockCookie" /> devuelto por <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
        <summary>Recupera el estado de bloqueo del subproceso al estado que tenía antes de llamar a <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Libera el bloqueo de escritor, independientemente del recuento de bloqueos recursivos y restaura el bloqueo de lector que se ha mantenido por el subproceso antes de actualizar al bloqueo de escritor. Se restaura el recuento de bloqueos del bloqueo de lector.  
  
> [!NOTE]
>  `DowngradeFromWriterLock` acepta una <xref:System.Threading.LockCookie> obtenido mediante una llamada a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>. No use un `LockCookie` devuelto por <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.  
  
 Un subproceso no se bloquea al degradar el bloqueo de escritor, incluso si otros subprocesos están esperando el bloqueo de escritor, ya que todas las solicitudes de bloqueo de lector se conceden cuando se libera el bloqueo de escritor.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo solicitar un bloqueo de lector, actualizar el bloqueo de lector al bloqueo de escritor y degradar a un bloqueo de lector de nuevo.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">El subproceso no dispone del bloqueo de escritor.</exception>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="lockCookie" /> es un puntero nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se asegura de que los recursos se liberan y que se llevan a cabo otras operaciones de limpieza cuando el recolector de elementos no utilizados recupere el objeto <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El recolector de elementos no utilizados llame <xref:System.Threading.ReaderWriterLock.Finalize%2A> cuando actual <xref:System.Threading.ReaderWriterLock> objeto está listo para ser finalizados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el subproceso actual tiene un bloqueo de lector.</summary>
        <value>
          <see langword="true" /> si el subproceso actual tiene un bloqueo de lector; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar `IsReaderLockHeld` para evitar interbloqueos.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el subproceso actual tiene el bloqueo de escritor.</summary>
        <value>
          <see langword="true" /> si el subproceso actual tiene el bloqueo de escritor; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra que cuando se realiza un intento de adquirir un bloqueo de lector en un subproceso que tiene un bloqueo de escritor, `ReaderWriterLock` no concede el bloqueo de lector, sino que incrementa el recuento de bloqueos del bloqueo de escritor.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera el bloqueo, independientemente del número de veces que el subproceso haya adquirido el bloqueo.</summary>
        <returns>Un valor <see cref="T:System.Threading.LockCookie" /> que representa el bloqueo liberado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Libera el bloqueo de lector o el bloqueo de escritor, independientemente del recuento de bloqueos recursivos. Para restaurar el estado del bloqueo, incluido el recuento de bloqueos, pasar la <xref:System.Threading.LockCookie> a <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> método para liberar el bloqueo, sin tener en cuenta el número de veces se ha adquirido por el subproceso y cómo restaurar el estado del bloqueo posteriormente.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduce el recuento de bloqueos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> disminuye el recuento de bloqueos. Cuando el recuento llega a cero, se libera el bloqueo.  
  
> [!NOTE]
>  Si un subproceso tiene el bloqueo de escritor, la llamada a `ReleaseReaderLock` tiene el mismo efecto que llamar al método <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>. Si un subproceso no tiene bloqueos, una llamada a `ReleaseReaderLock` produce una <xref:System.ApplicationException>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo adquirir y liberar un bloqueo de lector y cómo controlar la excepción que se produce cuando se agota el tiempo de espera de una solicitud.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">El subproceso no tiene ningún bloqueo de lector o escritor.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reduce el recuento de bloqueos del bloqueo de escritor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> reduce el recuento de bloqueo de escritor. Cuando el recuento llega a cero, se libera el bloqueo de escritor.  
  
> [!NOTE]
>  Si un subproceso tiene un bloqueo de lector, o no tiene bloqueos, una llamada a `ReleaseWriterLock` produce una <xref:System.ApplicationException>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo adquirir y liberar un bloqueo de escritura y cómo controlar la excepción que se produce cuando se agota el tiempo de espera de una solicitud.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">El subproceso no dispone del bloqueo de escritor.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Un <see cref="T:System.Threading.LockCookie" /> devuelto por <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
        <summary>Restaura el estado de bloqueo del subproceso al estado que tenía antes de llamar a <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El estado que restaura `RestoreLock` incluye el recuento de bloqueos recursivos.  
  
 Un subproceso se bloquea si intenta restaurar un bloqueo de lector después de que otro subproceso haya adquirido el bloqueo de escritor, o si intenta restaurar el bloqueo de escritor después de que otro subproceso haya adquirido un bloqueo de lector o escritor. Dado que `RestoreLock` no acepta un tiempo de espera, debe tener cuidado para evitar posibles interbloqueos.  
  
> [!CAUTION]
>  Antes de llamar a `RestoreLock`, asegúrese de que ha liberado todos los bloqueos adquiridos desde la llamada a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>. Por ejemplo, un subproceso se interbloquea si adquiere un bloqueo de lector y, a continuación, intenta restaurar un bloqueo de escritor anterior. Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> y <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> para detectar estos bloqueos adicionales.  
  
 No use un <xref:System.Threading.LockCookie> devuelto desde <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> método para liberar el bloqueo, sin tener en cuenta el número de veces se ha adquirido por el subproceso y cómo restaurar el estado del bloqueo posteriormente.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="lockCookie" /> es un puntero nulo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualiza un bloqueo de lector al bloqueo de escritor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Tiempo de espera en milisegundos.</param>
        <summary>Actualiza un bloqueo de lector al bloqueo de escritor, utilizando un valor <see langword="Int32" /> para el tiempo de espera.</summary>
        <returns>Valor <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un subproceso llama `UpgradeToWriterLock` se libera el bloqueo de lector, independientemente del recuento de bloqueos, y el subproceso va hasta el final de la cola para el bloqueo de escritor. Por lo tanto, otros subprocesos pueden escribir en el recurso antes de que el subproceso que solicitó que la actualización se concede el bloqueo de escritor.  
  
> [!IMPORTANT]
>  No se produce la excepción de tiempo de espera hasta que el subproceso que llamó la <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método puede volver a adquirir el bloqueo de lector. Si no hay ningún otro subproceso esperando el bloqueo de escritor, esto ocurre inmediatamente. Sin embargo, si otro subproceso está en cola para el bloqueo de escritor, el subproceso que llamó la <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método no puede adquirir el bloqueo de lector hasta que todos los lectores actuales liberen sus bloqueos y un subproceso adquiera y libere el bloqueo de escritor. Esto es cierto incluso si otro subproceso que solicitó el bloqueo de escritor solicitado después de que el subproceso actual llamado el <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método.  
  
 Para restaurar el estado de bloqueo, llame a <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> mediante la <xref:System.Threading.LockCookie> devuelto por `UpgradeToWriterLock`. No use este `LockCookie` con <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Cuando un subproceso no tiene ningún bloqueo de lector, no utilice `UpgradeToWriterLock`. Utilice <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> en su lugar.  
  
 Para los valores de tiempo de espera válidos, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo solicitar un bloqueo de lector, actualizar el bloqueo de lector al bloqueo de escritor y degradar a un bloqueo de lector de nuevo.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="millisecondsTimeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">El <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</param>
        <summary>Actualiza un bloqueo de lector al bloqueo de escritor utilizando un valor <see langword="TimeSpan" /> para el tiempo de espera.</summary>
        <returns>Valor <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un subproceso llama `UpgradeToWriterLock` se libera el bloqueo de lector, independientemente del recuento de bloqueos, y el subproceso va hasta el final de la cola para el bloqueo de escritor. Por lo tanto, otros subprocesos pueden escribir en el recurso antes de que el subproceso que solicitó que la actualización se concede el bloqueo de escritor.  
  
> [!IMPORTANT]
>  No se produce la excepción de tiempo de espera hasta que el subproceso que llamó la <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método puede volver a adquirir el bloqueo de lector. Si no hay ningún otro subproceso esperando el bloqueo de escritor, esto ocurre inmediatamente. Sin embargo, si otro subproceso está en cola para el bloqueo de escritor, el subproceso que llamó la <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método no puede adquirir el bloqueo de lector hasta que todos los lectores actuales liberen sus bloqueos y un subproceso adquiera y libere el bloqueo de escritor. Esto es cierto incluso si otro subproceso que solicitó el bloqueo de escritor solicitado después de que el subproceso actual llamado el <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método.  
  
 Para restaurar el estado de bloqueo, llame a <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> mediante la <xref:System.Threading.LockCookie> devuelto por `UpgradeToWriterLock`. No use este `LockCookie` con <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Cuando un subproceso no tiene ningún bloqueo de lector, no utilice `UpgradeToWriterLock`. Utilice <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> en su lugar.  
  
 Para los valores de tiempo de espera válidos, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de secuencia actual.</summary>
        <value>Número de secuencia actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de secuencia aumenta cada vez que un subproceso adquiere el bloqueo de escritor. Puede guardar el número de secuencia y pasarlo a <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> en un momento posterior, si desea determinar si otros subprocesos han adquirido el bloqueo de escritor entretanto.  
  
 Puede usar `WriterSeqNum` para mejorar el rendimiento de la aplicación. Por ejemplo, un subproceso puede almacenar en caché la información que obtiene mientras se mantiene un bloqueo de lector. Después de liberar y volver a adquirir el bloqueo, el subproceso puede determinar si otros subprocesos han escrito en el recurso mediante una llamada a `AnyWritersSince`; si no es así, se puede utilizar la información almacenada en caché. Esta técnica es útil al leer la información protegida por el bloqueo es costosa; Por ejemplo, ejecutar una consulta de base de datos.  
  
 El llamador debe contener un bloqueo de lector o un bloqueo de escritura en orden para el número de secuencia ser útil.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propiedad y el <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> método para determinar si otro subproceso haya adquirido el bloqueo de escritura en el recurso protegido desde el subproceso actual estuvo por última vez el bloqueo de escritor.  
  
 Este código forma parte de un ejemplo mayor proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>