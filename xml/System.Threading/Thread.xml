<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Thread.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b857fe3" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2eccf4de-4b1c-4706-8cb3-f46682ccfb72f908dbd04f1ed17bee04e225536a93e5e092d9d1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f908dbd04f1ed17bee04e225536a93e5e092d9d1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b15b8cf0f6dbc1504057c88969d9ef4b790891fe</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/11/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Creates and controls a thread, sets its priority, and gets its status.</source>
          <target state="translated">Crea y controla un subproceso, establece su prioridad y obtiene su estado.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</source>
          <target state="translated">Cuando se inicia un proceso, common language runtime crea automáticamente un subproceso único de primer plano para ejecutar código de la aplicación.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</source>
          <target state="translated">Junto con este subproceso principal en primer plano, un proceso puede crear uno o varios subprocesos para ejecutar una parte del código de programa asociado al proceso.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>These threads can execute either in the foreground or in the background.</source>
          <target state="translated">Estos subprocesos pueden ejecutar en primer plano o en segundo plano.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class to execute code on worker threads that are managed by the common language runtime.</source>
          <target state="translated">Además, puede usar el <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> clase para ejecutar código en subprocesos de trabajo administrados por common language runtime.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In this section</source>
          <target state="translated">En esta sección</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>A partir de un subproceso<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Retrieving Thread objects<ept id="p1">](#Retrieving)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Al recuperar objetos de subproceso<ept id="p1">](#Retrieving)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Subprocesos de primer plano y fondo<ept id="p1">](#Foreground)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Culture and threads<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Referencia cultural y subprocesos<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><bpt id="p1">[</bpt>Getting information about and controlling threads<ept id="p1">](#Properties)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Obtener información sobre y controlar subprocesos<ept id="p1">](#Properties)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Starting a thread</source>
          <target state="translated">A partir de un subproceso</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</source>
          <target state="translated">Iniciar un subproceso proporcionando un delegado que representa el método que el subproceso está en ejecución en su constructor de clase.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You then call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method to begin execution.</source>
          <target state="translated">A continuación, llame a la <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> método para comenzar la ejecución.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructores pueden aceptar cualquiera de los tipos de delegado dos, dependiendo de si se puede pasar un argumento al método que se ejecute:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>If the method has no arguments, you pass a <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> delegate to  the constructor.</source>
          <target state="translated">Si el método no tiene ningún argumento, se pasa un <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> delegar en el constructor.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It has the signature:</source>
          <target state="translated">Tiene la firma:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example creates and starts a thread that executes the <ph id="ph1">`ExecuteInForeground`</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se crea e inicia un subproceso que ejecuta el <ph id="ph1">`ExecuteInForeground`</ph> método.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</source>
          <target state="translated">El método muestra información acerca de algunas propiedades de subproceso y, a continuación, ejecuta un bucle en el que se pone en pausa durante medio segundo y se muestra el número de segundos transcurrido.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</source>
          <target state="translated">Cuando el subproceso ha ejecutado durante al menos cinco segundos, finaliza el bucle y el subproceso termina la ejecución.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>If the method has an argument, you pass a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate to the constructor.</source>
          <target state="translated">Si el método tiene un argumento, se pasa un <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegar en el constructor.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It has the signature:</source>
          <target state="translated">Tiene la firma:</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</source>
          <target state="translated">El método ejecutado por el delegado, a continuación, puede convertir (en C#) o convertir el parámetro (en Visual Basic) al tipo adecuado.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example is identical to the previous one, except that it calls the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor.</source>
          <target state="translated">En el siguiente ejemplo es idéntico al anterior, salvo que lo llama el <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This version of the <ph id="ph1">`ExecuteInForeground`</ph> method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</source>
          <target state="translated">Esta versión de la <ph id="ph1">`ExecuteInForeground`</ph> método tiene un parámetro único que representa el número aproximado de milisegundos el bucle que se va a ejecutar.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It is not necessary to retain a reference to a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> object once you have started the thread.</source>
          <target state="translated">No es necesario conservar una referencia a un <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> objeto una vez que se ha iniciado el subproceso.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The thread continues to execute until the thread procedure is complete.</source>
          <target state="translated">El subproceso continúa ejecutándose hasta que se complete el procedimiento de subproceso.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Retrieving Thread objects</source>
          <target state="translated">Al recuperar objetos de subproceso</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can use the static (<ph id="ph1">`Shared`</ph> in Visual Basic)  <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</source>
          <target state="translated">Puede usar el método estático (<ph id="ph1">`Shared`</ph> en Visual Basic) <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> propiedad para recuperar una referencia para el subproceso actualmente en ejecución desde el código que se está ejecutando el subproceso.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> propiedad para mostrar información sobre el subproceso de aplicación principal, otro subproceso en primer plano, un subproceso en segundo plano y un subproceso del grupo.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Foreground and background threads</source>
          <target state="translated">Subprocesos de primer plano y fondo</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Instances of the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class represent either foreground threads or background threads.</source>
          <target state="translated">Instancias de la <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> clase representan los subprocesos de primer plano o en subprocesos en segundo plano.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</source>
          <target state="translated">Subprocesos en segundo plano son idénticos a los subprocesos de primer plano con una excepción: un subproceso en segundo plano no mantiene un proceso que se ejecuta si han finalizado todos los subprocesos de primer plano.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</source>
          <target state="translated">Una vez que se han detenido todos los subprocesos de primer plano, el tiempo de ejecución detiene todos los subprocesos en segundo plano y se cierra.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>By default, the following threads execute in the foreground:</source>
          <target state="translated">De forma predeterminada, los siguientes subprocesos se ejecutan en primer plano:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The main application thread.</source>
          <target state="translated">El subproceso de aplicación principal.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>All threads created by calling a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class constructor.</source>
          <target state="translated">Todos los subprocesos creados mediante una llamada a un <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following threads execute in the background by default:</source>
          <target state="translated">Ejecutan los siguientes subprocesos en segundo plano de forma predeterminada:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">El subproceso del grupo de subprocesos, que son un grupo de subprocesos de trabajo mantenida por el tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class.</source>
          <target state="translated">Puede configurar el trabajo de grupo y la programación de subprocesos en el grupo de subprocesos mediante el <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">Operaciones asincrónicas basadas en tareas se ejecutan automáticamente en el grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Task-based asynchronous operations use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> classes to implement the <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>.</source>
          <target state="translated">Usan operaciones asincrónicas basadas en tareas del <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> las clases para implementar el <bpt id="p1">[</bpt>modelo asincrónico basado en tareas<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">Todos los subprocesos que entran en el entorno de ejecución administrado desde código no administrado.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can change a thread to execute in the background by setting the <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property at any time.</source>
          <target state="translated">Puede cambiar un subproceso para ejecutar en segundo plano mediante el establecimiento del <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> propiedad en cualquier momento.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</source>
          <target state="translated">Subprocesos en segundo plano son útiles para cualquier operación que debe continuar mientras que una aplicación se ejecuta, pero debe impedir que la aplicación finalice, como la supervisión de cambios del sistema de archivos o las conexiones de socket entrante.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example illustrates the difference between foreground and background threads.</source>
          <target state="translated">En el ejemplo siguiente se ilustra la diferencia entre los subprocesos de primer plano y fondo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>It is like the first example in the <bpt id="p1">[</bpt>Starting a thread<ept id="p1">](#Starting)</ept> section, except that it sets the thread to execute in the background before starting it.</source>
          <target state="translated">Es como el primer ejemplo de la <bpt id="p1">[</bpt>a partir de un subproceso<ept id="p1">](#Starting)</ept> sección, salvo que establece el subproceso para ejecutar en segundo plano antes de iniciarlo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>As the output shows, the loop is interrupted before it executes for five seconds.</source>
          <target state="translated">Como se muestra en la salida, el bucle se interrumpió antes de ejecutar durante cinco segundos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Culture and threads</source>
          <target state="translated">Referencia cultural y subprocesos</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Each thread has a culture, represented by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property, and a UI culture, represented by the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;</ph> property.</source>
          <target state="translated">Cada subproceso tiene una referencia cultural, representada por la <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> propiedad y una referencia cultural de interfaz de usuario, representan por la <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentUICulture%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</source>
          <target state="translated">La referencia cultural actual admite operaciones dependientes de la referencia cultural como análisis y formato, comparación de cadenas y ordenación y también controla el sistema de escritura y el calendario utilizado por un subproceso.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The current UI culture provides for culture-sensitive retrieval of resources in resource files.</source>
          <target state="translated">Proporciona la referencia cultural de interfaz de usuario actual para la recuperación de cuenta de la referencia cultural de los recursos en archivos de recursos.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</source>
          <target state="translated">Cuando se crea una instancia de un nuevo subproceso, su referencia cultural y la referencia cultural de interfaz de usuario se definen por la referencia cultural del sistema actual y la referencia cultural de interfaz de usuario y no por la referencia cultural y la referencia cultural de interfaz de usuario del subproceso desde el que se creó el nuevo subproceso.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor from the primary thread is English (United States), and not French (France).</source>
          <target state="translated">Esto significa, por ejemplo, que si la referencia cultural del sistema actual es inglés (Estados Unidos) y la referencia cultural actual del subproceso principal de la aplicación es el francés (Francia), la referencia cultural de un nuevo subproceso creado mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor desde el subproceso principal es inglés (Estados Unidos) y no francés (Francia).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the "Culture and threads" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Para obtener más información, vea la sección "Referencia cultural y subprocesos" de la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> tema de la clase.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This is not true of threads that execute asynchronous operations for apps that target the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</source>
          <target state="translated">Esto no es así de subprocesos que se ejecutan las operaciones asincrónicas para aplicaciones que tienen como destino el <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph> y versiones posteriores, en este caso, la referencia cultural y la referencia cultural de interfaz de usuario es parte del contexto de un operaciones asincrónicas; el subproceso en el que una operación asincrónica se ejecuta de forma predeterminada hereda la referencia cultural y la referencia cultural de interfaz de usuario del subproceso desde que se inició la operación asincrónica.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the "Culture and task-based asynchronous operations" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Para obtener más información, vea la sección "Referencia cultural y operaciones asincrónicas basadas en tareas" del tema sobre la clase <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</source>
          <target state="translated">Puede realizar cualquiera de las siguientes acciones para asegurarse de que todos los subprocesos de ejecución en una aplicación comparten la misma referencia cultural y la referencia cultural de interfaz de usuario:</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can pass a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to the <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate or the <ph id="ph3">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Puede pasar un <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objeto que representa esa referencia cultural a la <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegar o <ph id="ph3">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For apps running on the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Para aplicaciones que se ejecutan el <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> y versiones posteriores, puede definir la referencia cultural y la referencia cultural de interfaz de usuario que se asigna a todos los subprocesos que se creó en un dominio de aplicación estableciendo el valor de la <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> propiedades.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Note that this is a per-application domain setting.</source>
          <target state="translated">Tenga en cuenta que esta es una configuración de dominio por aplicación.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information and examples, see the "Culture and threads" section of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class topic.</source>
          <target state="translated">Para obtener más información y ejemplos, vea la sección "Referencia cultural y subprocesos" de la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> tema de la clase.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Getting information about and controlling threads</source>
          <target state="translated">Obtener información sobre y controlar subprocesos</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>You can retrieve a number of property values that provide information about a thread.</source>
          <target state="translated">Puede recuperar un número de valores de propiedad que proporcionan información sobre un subproceso.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>In some cases, you can also set these property values to control the operation of the thread.</source>
          <target state="translated">En algunos casos, también puede establecer estos valores de propiedad para controlar el funcionamiento del subproceso.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>These thread properties include:</source>
          <target state="translated">Estas propiedades de subproceso incluyen:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A name.</source>
          <target state="translated">Un nombre.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> is a write-once property that you can use to identify a thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> es una operación de escritura: propiedad de una vez que puede usar para identificar un subproceso.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Its default value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Su valor predeterminado es <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A hash code, which you can retrieve by calling the <ph id="ph1">&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;</ph> method.</source>
          <target state="translated">Un código hash, que puede recuperar mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Thread.GetHashCode%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</source>
          <target state="translated">El código hash puede utilizarse para identificar de forma exclusiva un subproceso; la duración de su subproceso, el código hash no coincidirá con el valor de ningún otro subproceso, independientemente del dominio de aplicación desde el que obtener el valor.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A thread ID.</source>
          <target state="translated">Un identificador de subproceso.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The value of the read-only <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property is assigned by the runtime and uniquely identifies a thread within its process.</source>
          <target state="translated">El valor de solo lectura <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> propiedad se asigna en tiempo de ejecución y se identifica de forma única un subproceso dentro de su proceso.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>An operating-system <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</source>
          <target state="translated">Un <bpt id="p1">[</bpt>ThreadId<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)</ept> de sistema operativo no tiene una relación fija con un subproceso administrado, ya que un host no administrado puede controlar la relación entre subprocesos administrados y no administrados.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Specifically, a sophisticated host can use the <bpt id="p1">[</bpt>CLR Hosting API<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</source>
          <target state="translated">En concreto, un host sofisticado puede usar el <bpt id="p1">[</bpt>API de hospedaje de CLR<ept id="p1">](https://msdn.microsoft.com/library/ms404385.aspx)</ept> para programar muchos subprocesos administrados en el mismo subproceso de sistema operativo, o para mover un subproceso administrado entre los subprocesos de sistema operativo diferente.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The thread's current state.</source>
          <target state="translated">El estado del subproceso actual.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For the duration of its existence, a thread is always in one or more of the states defined by the <ph id="ph1">&lt;xref:System.Threading.ThreadState&gt;</ph> property.</source>
          <target state="translated">Durante la duración de su existencia, un subproceso está siempre en uno o varios de los estados definidos por el <ph id="ph1">&lt;xref:System.Threading.ThreadState&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>A scheduling priority level, which is defined by the <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> property.</source>
          <target state="translated">Un nivel de prioridad de programación, que es definido por el <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</source>
          <target state="translated">Aunque puede establecer este valor para solicitar la prioridad de un subproceso, no se garantiza que se respete el sistema operativo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The read-only <ph id="ph1">&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</ph> property, which indicates whether a thread is  a thread pool thread.</source>
          <target state="translated">Sólo lectura <ph id="ph1">&lt;xref:System.Threading.Thread.IsThreadPoolThread%2A&gt;</ph> propiedad, que indica si un subproceso es un subproceso del grupo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property.</source>
          <target state="translated">Propiedad <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>For more information, see the <bpt id="p1">[</bpt>Foreground and background threads<ept id="p1">](#Foreground)</ept> section.</source>
          <target state="translated">Para obtener más información, consulte el <bpt id="p1">[</bpt>subprocesos de primer plano y fondo<ept id="p1">](#Foreground)</ept> sección.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>The following example demonstrates simple threading functionality.</source>
          <target state="translated">En el ejemplo siguiente se muestra la funcionalidad de subproceso simple.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This code produces output similar to the following:</source>
          <target state="translated">Este código produce un resultado similar al siguiente:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Thread">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo es seguro para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>A delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Delegado que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>, especificando un delegado que permite pasar un objeto al subproceso cuando este último se inicia.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Un subproceso no comienza a ejecutarse cuando se crea.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>To schedule the thread for execution, call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method.</source>
          <target state="translated">Para programar el subproceso de ejecución, llame a la <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>To pass a data object to the thread, use the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;</ph> method overload.</source>
          <target state="translated">Para pasar un objeto de datos al subproceso, utilice el <ph id="ph1">&lt;xref:System.Threading.Thread.Start%28System.Object%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Visual Basic users can omit the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor when creating a thread.</source>
          <target state="translated">Los usuarios de Visual Basic pueden omitir el <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor al crear un subproceso.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method, for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">`AddressOf`</ph> operador al pasar el método, por ejemplo <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>Visual Basic automatically calls the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</source>
          <target state="translated">Visual Basic llama automáticamente el <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source>The following example shows the syntax for creating and using a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate with a static method and an instance method.</source>
          <target state="translated">En el ejemplo siguiente se muestra la sintaxis para crear y usar un <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegado con un método estático y un método de instancia.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>A thread does not begin executing when it is created.</source>
          <target state="translated">Un subproceso no comienza a ejecutarse cuando se crea.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>To schedule the thread for execution, call the <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> method.</source>
          <target state="translated">Para programar el subproceso de ejecución, llame a la <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Visual Basic users can omit the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor when creating a thread.</source>
          <target state="translated">Los usuarios de Visual Basic pueden omitir el <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor al crear un subproceso.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Use the <ph id="ph1">`AddressOf`</ph> operator when passing your method for example <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</source>
          <target state="translated">Use la <ph id="ph1">`AddressOf`</ph> operador cuando se pasa al método como <ph id="ph2">`Dim t As New Thread(AddressOf ThreadProc)`</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>Visual Basic automatically calls the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</source>
          <target state="translated">Visual Basic llama automáticamente el <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The following code example shows how to create a thread that executes a static method.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear un subproceso que ejecuta un método estático.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The following code example shows how to create a thread that executes an instance method.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear un subproceso que ejecuta un método de instancia.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)">
          <source>The <ph id="ph1">&lt;paramref name="start" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="start" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Tamaño de pila máximo, en bytes, que va a usar el subproceso, o 0 para usar el tamaño de pila máximo predeterminado especificado en el encabezado del ejecutable.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Important   For partially trusted code, <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Importante   En el caso de código de confianza parcial, se pasa por alto <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> si es mayor que el tamaño de pila predeterminado.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">No se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> y, para ello, especifica un delegado que permite pasar un objeto al subproceso cuando este último se inicia; además, especifica el tamaño de pila máximo para el subproceso.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Evite utilizar esta sobrecarga del constructor.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>The default stack size used by the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> constructor overload is the recommended stack size for threads.</source>
          <target state="translated">El tamaño de pila predeterminado utilizado por el <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29&gt;</ph> sobrecarga del constructor es el tamaño de pila recomendado para los subprocesos.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Si un subproceso tiene problemas de memoria, la causa más probable es un error de programación, como recursividad infinita.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph2">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">A partir del <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, solo de plena confianza puede establecer código <ph id="ph2">`maxStackSize`</ph> en un valor que es mayor que el tamaño de pila predeterminado (1 megabyte).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Si se especifica un valor mayor para <ph id="ph1">`maxStackSize`</ph> cuando se ejecuta el código con confianza parcial, <ph id="ph2">`maxStackSize`</ph> se omite y se utiliza el tamaño de pila predeterminado.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">No se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">El código en cualquier nivel de confianza puede establecer <ph id="ph1">`maxStackSize`</ph> en un valor que es menor que el tamaño de pila predeterminado.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">Si está desarrollando una biblioteca de plena confianza que se usará en el código de confianza parcial, y necesita iniciar un subproceso que requiere una pila grande, debe imponer plena confianza antes de crear el subproceso o se utilizará el tamaño de pila predeterminado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">No lo haga, a menos que controla totalmente el código que se ejecuta en el subproceso.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Si <ph id="ph1">`maxStackSize`</ph> es menor que el tamaño de pila mínimo, se utiliza el tamaño de pila mínimo.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Si <ph id="ph1">`maxStackSize`</ph> no es un múltiplo del tamaño de página, se redondea al múltiplo mayor siguiente del tamaño de página.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Por ejemplo, si está utilizando la versión 2.0 de .NET Framework en Windows Vista, 256KB (262.144 bytes) es el tamaño de pila mínimo y el tamaño de página es 64KB (65.536 bytes).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">En las versiones de Microsoft Windows anteriores a Windows XP y Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> se omite, y se utiliza el tamaño de pila especificado en el encabezado del ejecutable.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Si especifica un tamaño de pila muy pequeño, debe deshabilitar el sondeo de desbordamiento de pila.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Cuando la pila está muy limitada, el propio sondeo puede provocar un desbordamiento de pila.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Para deshabilitar el sondeo de desbordamiento de pila, agregue lo siguiente al archivo de configuración de la aplicación.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate that represents the methods to be invoked when this thread begins executing.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</source>
          <target state="translated">Tamaño de pila máximo, en bytes, que va a usar el subproceso, o 0 para usar el tamaño de pila máximo predeterminado especificado en el encabezado del ejecutable.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Important   For partially trusted code, <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> is ignored if it is greater than the default stack size.</source>
          <target state="translated">Importante   En el caso de código de confianza parcial, se pasa por alto <bpt id="p1">&lt;c&gt;</bpt>maxStackSize<ept id="p1">&lt;/c&gt;</ept> si es mayor que el tamaño de pila predeterminado.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">No se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> class, specifying the maximum stack size for the thread.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>, especificando el tamaño de pila máximo para el subproceso.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Avoid using this constructor overload.</source>
          <target state="translated">Evite utilizar esta sobrecarga del constructor.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>The default stack size used by the <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</ph> constructor overload is the recommended stack size for threads.</source>
          <target state="translated">El tamaño de pila predeterminado utilizado por el <ph id="ph1">&lt;xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29&gt;</ph> sobrecarga del constructor es el tamaño de pila recomendado para los subprocesos.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</source>
          <target state="translated">Si un subproceso tiene problemas de memoria, la causa más probable es un error de programación, como recursividad infinita.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, only fully trusted code can set <ph id="ph2">`maxStackSize`</ph> to a value that is greater than the default stack size (1 megabyte).</source>
          <target state="translated">A partir del <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, solo de plena confianza puede establecer código <ph id="ph2">`maxStackSize`</ph> en un valor que es mayor que el tamaño de pila predeterminado (1 megabyte).</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If a larger value is specified for <ph id="ph1">`maxStackSize`</ph> when code is running with partial trust, <ph id="ph2">`maxStackSize`</ph> is ignored and the default stack size is used.</source>
          <target state="translated">Si se especifica un valor mayor para <ph id="ph1">`maxStackSize`</ph> cuando se ejecuta el código con confianza parcial, <ph id="ph2">`maxStackSize`</ph> se omite y se utiliza el tamaño de pila predeterminado.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">No se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Code at any trust level can set <ph id="ph1">`maxStackSize`</ph> to a value that is less than the default stack size.</source>
          <target state="translated">El código en cualquier nivel de confianza puede establecer <ph id="ph1">`maxStackSize`</ph> en un valor que es menor que el tamaño de pila predeterminado.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</source>
          <target state="translated">Si está desarrollando una biblioteca de plena confianza que se usará en el código de confianza parcial, y necesita iniciar un subproceso que requiere una pila grande, debe imponer plena confianza antes de crear el subproceso o se utilizará el tamaño de pila predeterminado.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>Do not do this unless you fully control the code that runs on the thread.</source>
          <target state="translated">No lo haga, a menos que controla totalmente el código que se ejecuta en el subproceso.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is less than the minimum stack size, the minimum stack size is used.</source>
          <target state="translated">Si <ph id="ph1">`maxStackSize`</ph> es menor que el tamaño de pila mínimo, se utiliza el tamaño de pila mínimo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If <ph id="ph1">`maxStackSize`</ph> is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</source>
          <target state="translated">Si <ph id="ph1">`maxStackSize`</ph> no es un múltiplo del tamaño de página, se redondea al múltiplo mayor siguiente del tamaño de página.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</source>
          <target state="translated">Por ejemplo, si está utilizando la versión 2.0 de .NET Framework en Windows Vista, 256KB (262.144 bytes) es el tamaño de pila mínimo y el tamaño de página es 64KB (65.536 bytes).</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> is ignored, and the stack size specified in the executable header is used.</source>
          <target state="translated">En las versiones de Microsoft Windows anteriores a Windows XP y Windows Server 2003, <ph id="ph1">`maxStackSize`</ph> se omite, y se utiliza el tamaño de pila especificado en el encabezado del ejecutable.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>If you specify a very small stack size, you might need to disable stack-overflow probing.</source>
          <target state="translated">Si especifica un tamaño de pila muy pequeño, debe deshabilitar el sondeo de desbordamiento de pila.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>When the stack is severely constrained, the probing can itself cause a stack overflow.</source>
          <target state="translated">Cuando la pila está muy limitada, el propio sondeo puede provocar un desbordamiento de pila.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source>To disable stack overflow probing, add the following to your application configuration file.</source>
          <target state="translated">Para deshabilitar el sondeo de desbordamiento de pila, agregue lo siguiente al archivo de configuración de la aplicación.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxStackSize" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Produce una excepción <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Normalmente, una llamada a este método finaliza el subproceso.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread.</source>
          <target state="translated">Produce una excepción <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Normalmente, una llamada a este método finaliza el subproceso.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>When this method is invoked on a thread, the system throws a <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread to abort it.</source>
          <target state="translated">Cuando se invoca este método en un subproceso, el sistema produce una <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> en el subproceso para interrumpirlo.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> es una excepción especial que puede detectar mediante código de la aplicación, pero se vuelve a producir al final de la <ph id="ph2">`catch`</ph> bloquear a menos que <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> cancela la solicitud para anular la operación y evita la <ph id="ph2">`ThreadAbortException`</ph> de finalización del subproceso.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Haber <ph id="ph1">`finally`</ph> los bloques se ejecutan antes de que el subproceso se anula.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>When a thread calls <ph id="ph1">`Abort`</ph> on itself, the effect is similar to throwing an exception; the <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> happens immediately, and the result is predictable.</source>
          <target state="translated">Cuando un subproceso llama <ph id="ph1">`Abort`</ph> en sí mismo, el efecto es similar a producir una excepción; el <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> ocurre inmediatamente, y el resultado es predecible.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Sin embargo, si un subproceso llama a <ph id="ph1">`Abort`</ph> en otro subproceso, la anulación interrumpe el código que esté en ejecución.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>There is also a chance that a static constructor could be aborted.</source>
          <target state="translated">También es probable que un constructor estático puede anularse.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">En raras ocasiones, esto podría evitar que las instancias de esa clase se crea en ese dominio de aplicación.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">En las versiones 1.0 y 1.1 de .NET Framework, es probable que el subproceso podría interrumpirse mientras un <ph id="ph1">`finally`</ph> bloque se está ejecutando, en cuyo caso el <ph id="ph2">`finally`</ph> bloque se anula.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">El subproceso no se garantiza para anular la operación inmediatamente, o en absoluto.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Esta situación puede producirse si un subproceso realice una cantidad ilimitada de operaciones en el <ph id="ph1">`finally`</ph> bloques que se llaman como parte del procedimiento de anulación, indefinidamente, por tanto, la instrucción abort.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>To wait until a thread has aborted, you can call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method on the thread after calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, but there is no guarantee the wait will end.</source>
          <target state="translated">Para esperar hasta que un subproceso se ha anulado, puede llamar a la <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> método en el subproceso después de llamar a la <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> método, pero no hay ninguna garantía de la espera finalizará.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>The thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">El subproceso que llama <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> podría bloquear si el subproceso que se va a anular está en una región protegida de código, como un <ph id="ph2">`catch`</ph> bloque, <ph id="ph3">`finally`</ph> bloque o región de ejecución restringidas.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If the thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Si el subproceso que llama <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> mantiene un bloqueo que el subproceso anulado requiere, puede producirse un interbloqueo.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> is called.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> se llama en un subproceso que no se ha iniciado, el subproceso anulará cuando <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> se llama en un subproceso que está bloqueado o en modo de suspensión, el subproceso se interrumpe y, a continuación, se anula.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> is thrown in the thread that called <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> is added to the <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property of the thread being aborted.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> se llama en un subproceso que se ha suspendido, un <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> se produce en el subproceso que llamó a <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> se agrega a la <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> propiedad del subproceso que se va a anular.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is not thrown in the suspended thread until <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> is called.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> no se produce en el subproceso suspendido hasta que <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> se llama en un subproceso administrado mientras se ejecuta el código no administrado, un <ph id="ph2">`ThreadAbortException`</ph> no se produce hasta que el subproceso vuelve al código administrado.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Si dos llamadas a <ph id="ph1">`Abort`</ph> proceder al mismo tiempo, es posible que una llamada establecer la información de estado y la otra llamada a ejecutar la <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Sin embargo, una aplicación no puede detectar esta situación.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</source>
          <target state="translated">Después de <ph id="ph1">`Abort`</ph> se invoca en un subproceso, el estado del subproceso incluye <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</source>
          <target state="translated">Después de que el subproceso ha terminado debido a una llamada correcta a <ph id="ph1">`Abort`</ph>, se cambia el estado del subproceso a <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Con los permisos suficientes, un subproceso que constituye el destino de un <ph id="ph1">`Abort`</ph> puede cancelar la anulación utilizando el <ph id="ph2">`ResetAbort`</ph> método.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Para obtener un ejemplo que muestra cómo llamar a la <ph id="ph1">`ResetAbort`</ph> método, consulte la <ph id="ph2">`ThreadAbortException`</ph> clase.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Solo .NET Core: este miembro no se admite.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">Actualmente se suspende el subproceso que se está anulando.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>for advanced operations on threads.</source>
          <target state="translated">para operaciones avanzadas en subprocesos.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>An object that contains application-specific information, such as state, which can be used by the thread being aborted.</source>
          <target state="translated">Objeto que contiene información específica de la aplicación como, por ejemplo, su estado, y que el subproceso anulado puede utilizar.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Raises a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</source>
          <target state="translated">Produce una excepción <ph id="ph1">&lt;see cref="T:System.Threading.ThreadAbortException" /&gt;</ph> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso, proporcionando al mismo tiempo información sobre excepciones relativa a la terminación del subproceso.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Calling this method usually terminates the thread.</source>
          <target state="translated">Normalmente, una llamada a este método finaliza el subproceso.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>When this method is invoked on a thread, the system throws a <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread to abort it.</source>
          <target state="translated">Cuando se invoca este método en un subproceso, el sistema produce una <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> en el subproceso para interrumpirlo.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is re-thrown at the end of the <ph id="ph2">`catch`</ph> block unless <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> es una excepción especial que puede detectar mediante código de la aplicación, pero se vuelve a producir al final de la <ph id="ph2">`catch`</ph> bloquear a menos que <ph id="ph3">&lt;xref:System.Threading.Thread.ResetAbort%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> cancela la solicitud para anular la operación y evita la <ph id="ph2">`ThreadAbortException`</ph> de finalización del subproceso.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Unexecuted <ph id="ph1">`finally`</ph> blocks are executed before the thread is aborted.</source>
          <target state="translated">Haber <ph id="ph1">`finally`</ph> los bloques se ejecutan antes de que el subproceso se anula.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>When a thread calls <ph id="ph1">`Abort`</ph> on itself, the effect is similar to throwing an exception; the <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> happens immediately, and the result is predictable.</source>
          <target state="translated">Cuando un subproceso llama <ph id="ph1">`Abort`</ph> en sí mismo, el efecto es similar a producir una excepción; el <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> ocurre inmediatamente, y el resultado es predecible.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>However, if one thread calls <ph id="ph1">`Abort`</ph> on another thread, the abort interrupts whatever code is running.</source>
          <target state="translated">Sin embargo, si un subproceso llama a <ph id="ph1">`Abort`</ph> en otro subproceso, la anulación interrumpe el código que esté en ejecución.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>There is a chance that a static constructor could be aborted.</source>
          <target state="translated">Es probable que un constructor estático puede anularse.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>In rare cases, this might prevent instances of that class from being created in that application domain.</source>
          <target state="translated">En raras ocasiones, esto podría evitar que las instancias de esa clase se crea en ese dominio de aplicación.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a <ph id="ph1">`finally`</ph> block is running, in which case the <ph id="ph2">`finally`</ph> block is aborted.</source>
          <target state="translated">En las versiones 1.0 y 1.1 de .NET Framework, es probable que el subproceso podría interrumpirse mientras un <ph id="ph1">`finally`</ph> bloque se está ejecutando, en cuyo caso el <ph id="ph2">`finally`</ph> bloque se anula.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread is not guaranteed to abort immediately, or at all.</source>
          <target state="translated">El subproceso no se garantiza para anular la operación inmediatamente, o en absoluto.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>This situation can occur if a thread does an unbounded amount of computation in the <ph id="ph1">`finally`</ph> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</source>
          <target state="translated">Esta situación puede producirse si un subproceso realice una cantidad ilimitada de operaciones en el <ph id="ph1">`finally`</ph> bloques que se llaman como parte del procedimiento de anulación, indefinidamente, por tanto, la instrucción abort.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>To wait until a thread has aborted, you can call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method on the thread after calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, but there is no guarantee that the wait will end.</source>
          <target state="translated">Para esperar hasta que un subproceso se ha anulado, puede llamar a la <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> método en el subproceso después de llamar a la <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> método, pero no hay ninguna garantía de que se va a finalizar la espera.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> might block if the thread that is being aborted is in a protected region of code, such as a <ph id="ph2">`catch`</ph> block, <ph id="ph3">`finally`</ph> block, or constrained execution region.</source>
          <target state="translated">El subproceso que llama <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> podría bloquear si el subproceso que se va a anular está en una región protegida de código, como un <ph id="ph2">`catch`</ph> bloque, <ph id="ph3">`finally`</ph> bloque o región de ejecución restringidas.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If the thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> holds a lock that the aborted thread requires, a deadlock can occur.</source>
          <target state="translated">Si el subproceso que llama <ph id="ph1">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> mantiene un bloqueo que el subproceso anulado requiere, puede producirse un interbloqueo.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has not been started, the thread will abort when <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> is called.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> se llama en un subproceso que no se ha iniciado, el subproceso anulará cuando <ph id="ph2">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> se llama en un subproceso que está bloqueado o en modo de suspensión, el subproceso se interrumpe y, a continuación, se anula.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a thread that has been suspended, a <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> is thrown in the thread that called <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> is added to the <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property of the thread being aborted.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> se llama en un subproceso que se ha suspendido, un <ph id="ph2">&lt;xref:System.Threading.ThreadStateException&gt;</ph> se produce en el subproceso que llamó a <ph id="ph3">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph> se agrega a la <ph id="ph5">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> propiedad del subproceso que se va a anular.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> is not thrown in the suspended thread until <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> is called.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> no se produce en el subproceso suspendido hasta que <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If <ph id="ph1">`Abort`</ph> is called on a managed thread while it is executing unmanaged code, a <ph id="ph2">`ThreadAbortException`</ph> is not thrown until the thread returns to managed code.</source>
          <target state="translated">Si <ph id="ph1">`Abort`</ph> se llama en un subproceso administrado mientras se ejecuta el código no administrado, un <ph id="ph2">`ThreadAbortException`</ph> no se produce hasta que el subproceso vuelve al código administrado.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>If two calls to <ph id="ph1">`Abort`</ph> come at the same time, it is possible for one call to set the state information and the other call to execute the <ph id="ph2">`Abort`</ph>.</source>
          <target state="translated">Si dos llamadas a <ph id="ph1">`Abort`</ph> proceder al mismo tiempo, es posible que una llamada establecer la información de estado y la otra llamada a ejecutar la <ph id="ph2">`Abort`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>However, an application cannot detect this situation.</source>
          <target state="translated">Sin embargo, una aplicación no puede detectar esta situación.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>After <ph id="ph1">`Abort`</ph> is invoked on a thread, the state of the thread includes <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</source>
          <target state="translated">Después de <ph id="ph1">`Abort`</ph> se invoca en un subproceso, el estado del subproceso incluye <ph id="ph2">&lt;xref:System.Threading.ThreadState.AbortRequested&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>After the thread has terminated as a result of a successful call to <ph id="ph1">`Abort`</ph>, the state of the thread is changed to <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</source>
          <target state="translated">Después de que el subproceso ha terminado debido a una llamada correcta a <ph id="ph1">`Abort`</ph>, se cambia el estado del subproceso a <ph id="ph2">&lt;xref:System.Threading.ThreadState.Stopped&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>With sufficient permissions, a thread that is the target of an <ph id="ph1">`Abort`</ph> can cancel the abort using the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Con los permisos suficientes, un subproceso que constituye el destino de un <ph id="ph1">`Abort`</ph> puede cancelar la anulación utilizando el <ph id="ph2">`ResetAbort`</ph> método.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>For an example that demonstrates calling the <ph id="ph1">`ResetAbort`</ph> method, see the <ph id="ph2">`ThreadAbortException`</ph> class.</source>
          <target state="translated">Para obtener un ejemplo que muestra cómo llamar a la <ph id="ph1">`ResetAbort`</ph> método, consulte la <ph id="ph2">`ThreadAbortException`</ph> clase.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The following code example shows how to pass information to a thread that is being aborted.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo pasar información a un subproceso que se va a anular.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Solo .NET Core: este miembro no se admite.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>The thread that is being aborted is currently suspended.</source>
          <target state="translated">Actualmente se suspende el subproceso que se está anulando.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>for advanced operations on threads.</source>
          <target state="translated">para operaciones avanzadas en subprocesos.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Abort(System.Object)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Allocates an unnamed data slot on all the threads.</source>
          <target state="translated">Asigna una ranura de datos sin nombre en todos los subprocesos.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Ranura de datos con nombre asignada en todos los subprocesos.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework proporciona dos mecanismos para usar el almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo) y ranuras de datos.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilita la comprobación de tipos en tiempo de compilación.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el uso de TLS, consulte <bpt id="p1">[</bpt>almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The slot is allocated on all threads.</source>
          <target state="translated">Se asigna la ranura en todos los subprocesos.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Los subprocesos usan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras a cada proceso cuando se crea.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">El subproceso puede asignar una ranura de datos en el almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para volver a usar cuando el subproceso finalice.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Las ranuras de datos son únicas para cada subproceso.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>This section contains two code examples.</source>
          <target state="translated">Esta sección contiene dos ejemplos de código.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">El primer ejemplo muestra cómo utilizar un campo que se marca con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Primer ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar un campo que se marca con <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Segundo ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateDataSlot">
          <source>The following code example demonstrates how to use a data slot to store thread-specific information.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo usar una ranura de datos para almacenar información específica del subproceso.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The name of the data slot to be allocated.</source>
          <target state="translated">Nombre de la ranura de datos que se va a asignar.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Allocates a named data slot on all threads.</source>
          <target state="translated">Asigna una ranura de datos con nombre en todos los subprocesos.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The allocated named data slot on all threads.</source>
          <target state="translated">Ranura de datos con nombre asignada en todos los subprocesos.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework proporciona dos mecanismos para usar el almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo) y ranuras de datos.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilita la comprobación de tipos en tiempo de compilación.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el uso de TLS, consulte <bpt id="p1">[</bpt>almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Los subprocesos usan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras a cada proceso cuando se crea.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">El subproceso puede asignar una ranura de datos en el almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para volver a usar cuando el subproceso finalice.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Las ranuras de datos son únicas para cada subproceso.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>It is not necessary to use the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method to allocate a named data slot, because the <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method allocates the slot if it has not already been allocated.</source>
          <target state="translated">No es necesario utilizar la <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> método para asignar una ranura de datos con nombre, porque el <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> método asigna la ranura si todavía no se ha asignado.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> se utiliza el método, debe llamarse en el subproceso principal al inicio del programa, porque produce una excepción si ya se ha asignado una ranura con el nombre especificado.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>There is no way to test whether a slot has already been allocated.</source>
          <target state="translated">No hay ninguna manera de probar si ya se ha asignado una ranura.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>Slots allocated with this method must be freed with <ph id="ph1">&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</ph>.</source>
          <target state="translated">Las ranuras asignadas con este método se deben liberar con <ph id="ph1">&lt;xref:System.Threading.Thread.FreeNamedDataSlot%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Esta sección contiene dos ejemplos de código.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">El primer ejemplo muestra cómo utilizar un campo que se marca con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Primer ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar un campo que se marca con <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Segundo ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>The example code does not use the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method, because the <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> method allocates the slot if it has not already been allocated.</source>
          <target state="translated">El código de ejemplo no utiliza la <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> método, porque la <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> método asigna la ranura si todavía no se ha asignado.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> method is used, it should be called in the main thread at program startup.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Threading.Thread.AllocateNamedDataSlot%2A&gt;</ph> se utiliza el método, se debe llamar en el subproceso principal al inicio del programa.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)">
          <source>A named data slot with the specified name already exists.</source>
          <target state="translated">Ya existe una ranura para datos con el nombre especificado</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ApartmentState">
          <source>Gets or sets the apartment state of this thread.</source>
          <target state="translated">Obtiene o establece el estado de apartamento de este subproceso.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The initial value is <ph id="ph1">&lt;see langword="Unknown" /&gt;</ph>.</source>
          <target state="translated">El valor inicial es <ph id="ph1">&lt;see langword="Unknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source><bpt id="p1">**</bpt>The <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property is obsolete.<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>El <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propiedad está obsoleta.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The non-obsolete alternatives are the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method to retrieve the apartment state and the   <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method to set the apartment state.</source>
          <target state="translated">Las alternativas no obsoleta son el <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> método para recuperar el estado del apartamento y <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> método para establecer el estado del apartamento.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework versions 1.0 and 1.1, the <ph id="ph1">`ApartmentState`</ph> property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</source>
          <target state="translated">En las versiones de .NET Framework 1.0 y 1.1, la <ph id="ph1">`ApartmentState`</ph> propiedad marca un subproceso para indicar que se ejecutará en un apartamento de un único subproceso o multiproceso.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>This property can be set when the thread is in the <ph id="ph1">`Unstarted`</ph> or <ph id="ph2">`Running`</ph> thread state; however, it can be set only once for a thread.</source>
          <target state="translated">Esta propiedad puede establecerse cuando el subproceso está en el <ph id="ph1">`Unstarted`</ph> o <ph id="ph2">`Running`</ph> subprocesos estado; sin embargo, puede establecerse una sola vez para un subproceso.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>If the property has not been set, it returns <ph id="ph1">`Unknown`</ph>.</source>
          <target state="translated">Si no se estableció la propiedad, devuelve <ph id="ph1">`Unknown`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>An attempt to use the <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property to set the apartment state of a thread whose apartment state has already been set is ignored.</source>
          <target state="translated">Un intento de usar el <ph id="ph1">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> se omite la propiedad para establecer el estado de apartamento de un subproceso cuyo estado de apartamento ya se estableció.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>However, the <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> in this case.</source>
          <target state="translated">Sin embargo, el <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> método produce un <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> en este caso.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework version 2.0, new threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, los nuevos subprocesos se inicializan como <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> si no se ha establecido su estado de apartamento antes de que se inicien.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">El subproceso de aplicación principal se inicializa en <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>You can no longer set the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> by setting the <ph id="ph2">&lt;xref:System.Threading.ApartmentState?displayProperty=nameWithType&gt;</ph> property on the first line of code.</source>
          <target state="translated">Ya no se puede establecer el subproceso de aplicación principal en <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> estableciendo el <ph id="ph2">&lt;xref:System.Threading.ApartmentState?displayProperty=nameWithType&gt;</ph> propiedad en la primera línea de código.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>Use the <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph> instead.</source>
          <target state="translated">Utilice el <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph> en su lugar.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)</ept> linker option.</source>
          <target state="translated">En la versión 2.0 de .NET Framework, puede especificar el modelo para una aplicación de C++ utilizando de subprocesos de COM el <bpt id="p1">[</bpt>/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)<ept id="p1">](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)</ept> opción del vinculador.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ApartmentState">
          <source>The following code example demonstrates how to set the apartment state of a thread.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo establecer el estado del apartamento de un subproceso.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ApartmentState">
          <source>An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<ph id="ph1">&lt;see langword="STA" /&gt;</ph>) or multithreaded apartment (<ph id="ph2">&lt;see langword="MTA" /&gt;</ph>)).</source>
          <target state="translated">Se realiza un intento de establecer esta propiedad en un estado que no es un estado de contenedor válido (un estado distinto de contenedor uniproceso (<ph id="ph1">&lt;see langword="STA" /&gt;</ph>) o contenedor multiproceso (<ph id="ph2">&lt;see langword="MTA" /&gt;</ph>)).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</source>
          <target state="translated">Notifica a un host que la ejecución está a punto de entrar en una región del código donde los efectos de una anulación del subproceso o de una excepción no controlada podrían constituir un riesgo para otras tareas del dominio de aplicaciones.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Los hosts de common language runtime (CLR), como Microsoft SQL Server 2005, pueden establecer directivas diferentes para los errores en las regiones críticas y no críticas de código.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Una región crítica es aquella en la que los efectos de una anulación del subproceso o una excepción no controlada podrían no limitarse a la tarea actual.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Por el contrario, una anulación o un error en una región no crítica del código afecta solo a la tarea en la que se produce el error.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Por ejemplo, considere la posibilidad de una tarea que intenta asignar memoria mientras se mantiene un bloqueo.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Si se produce un error en la asignación de memoria, la anulación de la tarea actual no es suficiente para garantizar la estabilidad de la <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, porque puede haber otras tareas en el dominio esperando el mismo bloqueo.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Si se termina la tarea actual, otras tareas podrían sufrir un interbloqueo.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Cuando se produce un error en una región crítica, el host puede optar por descargar todo el <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> en lugar de correr el riesgo de continuar la ejecución en un estado potencialmente inestable.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>To inform the host that your code is entering a critical region, call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</source>
          <target state="translated">Para informar al host que el código está entrando en una región crítica, llame a <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> when execution returns to a non-critical region of code.</source>
          <target state="translated">Llamar a <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> cuando la ejecución vuelve a una región no crítica del código.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Usar este método en el código que se ejecuta SQL Server 2005 requiere que el código se ejecute en el nivel más alto de protección de host.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginCriticalRegion">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> methods to divide a block of code into critical and non-critical regions.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> métodos para dividir un bloque de código en regiones críticas y no críticas.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Notifica a un host que el código administrado está a punto de ejecutar instrucciones que dependen de la identidad del subproceso del sistema operativo físico actual.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Algunos de los hosts de common language runtime, como Microsoft SQL Server 2005, proporcionan su propia administración de subprocesos.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Un host que proporciona su propia administración de subprocesos puede mover una tarea que se ejecuta desde un subproceso de sistema operativo físico a otro en cualquier momento.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">Mayoría de las tareas no se ven afectada por este cambio.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Sin embargo, algunas tareas tienen afinidad de subprocesos, es decir, que dependen de la identidad de un subproceso físico del sistema operativo.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Estas tareas deben informar al host cuando ejecuta código que no se debe cambiar.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> before acquiring the lock, and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> after releasing the lock.</source>
          <target state="translated">Por ejemplo, si el aplicación llama una API del sistema para adquirir un sistema operativo de bloqueo que tiene afinidad de subprocesos, como CRITICAL_SECTION de Win32, se debe llamar a <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> antes de adquirir el bloqueo, y <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> tras liberar el bloqueo.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Usar este método en el código que se ejecuta SQL Server 2005 requiere que el código se ejecute en el nivel más alto de protección de host.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> métodos para notificar a un host que un bloque de código depende de la identidad de un subproceso físico del sistema operativo.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.BeginThreadAffinity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentContext">
          <source>Gets the current context in which the thread is executing.</source>
          <target state="translated">Obtiene el contexto actual donde se está ejecutando el subproceso.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Contexts.Context" /&gt;</ph> representing the current thread context.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Contexts.Context" /&gt;</ph> que representa el contexto del subproceso actual.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentContext">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentContext">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Gets or sets the culture for the current thread.</source>
          <target state="translated">Obtiene o establece la referencia cultural del subproceso actual.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>An object that represents the culture for the current thread.</source>
          <target state="translated">Objeto que representa la referencia cultural del subproceso actual.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objeto devuelto por esta propiedad, junto con sus objetos asociados, determinar el formato predeterminado para las fechas, horas, números, valores de moneda, el criterio de ordenación de texto, convenciones las mayúsculas y minúsculas y comparaciones de cadenas.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Consulte la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> clase para obtener información acerca de los nombres de referencia cultural y los identificadores, las diferencias entre según la referencia cultural invariable, neutra y específica, y la información de referencia cultural de manera afecta a los dominios de aplicación y subprocesos.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</source>
          <target state="translated">Consulte la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> propiedad para obtener información sobre cómo se determina la referencia cultural predeterminada de un subproceso y cómo los usuarios establecer información de referencia cultural para sus equipos.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, you can set the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property to a neutral culture.</source>
          <target state="translated">A partir del <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, puede establecer el <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> propiedad a una referencia cultural neutra.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>This is because the behavior of the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class has changed: When it represents a neutral culture, its property values (in particular, the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;</ph> properties) now reflect the specific culture that is associated with the neutral culture.</source>
          <target state="translated">Esto es porque el comportamiento de la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> la clase ha cambiado: cuando representa una referencia cultural neutra, sus valores de propiedad (en concreto, el <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.Calendar%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.CompareInfo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Globalization.CultureInfo.DateTimeFormat%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Globalization.CultureInfo.NumberFormat%2A&gt;</ph>, y <ph id="ph6">&lt;xref:System.Globalization.CultureInfo.TextInfo%2A&gt;</ph> propiedades) ahora reflejar la referencia cultural específica que está asociada a la referencia cultural neutra.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>In earlier versions of the .NET Framework, the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property threw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception when a neutral culture was assigned.</source>
          <target state="translated">En versiones anteriores de .NET Framework, el <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> propiedad produjo una <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> excepción cuando se asigna una referencia cultural neutra.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la instrucción de subprocesamiento que permite a la interfaz de usuario de Windows Forms para mostrar de la referencia cultural que se establece en el Panel de Control.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Additional code is needed.</source>
          <target state="translated">Se necesita código adicional.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentCulture">
          <source>The property is set to <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propiedad se establece en <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>for setting the property.</source>
          <target state="translated">Para establecer la propiedad.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentCulture">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>Gets or sets the thread's current principal (for role-based security).</source>
          <target state="translated">Obtiene o establece la entidad de seguridad actual del subproceso (de la seguridad basada en roles).</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.Principal.IPrincipal" /&gt;</ph> value representing the security context.</source>
          <target state="translated">Valor de <ph id="ph1">&lt;see cref="T:System.Security.Principal.IPrincipal" /&gt;</ph> que representa el contexto de seguridad.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>The following code example shows how to set and retrieve the principal of a thread.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo establecer y recuperar la entidad de seguridad de un subproceso.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>The caller does not have the permission required to set the principal.</source>
          <target state="translated">El autor de llamada no tiene el permiso necesario para establecer la entidad de seguridad.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>to manipulate the principal object.</source>
          <target state="translated">para manipular el objeto principal.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentPrincipal">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentThread">
          <source>Gets the currently running thread.</source>
          <target state="translated">Obtiene el subproceso actualmente en ejecución.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> that is the representation of the currently running thread.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> que representa el subproceso actualmente en ejecución.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The following example creates a task that in turn creates 20 child tasks.</source>
          <target state="translated">En el ejemplo siguiente se crea una tarea que a su vez crea 20 tareas secundarias.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The application itself, as well as each task, calls the <ph id="ph1">`ShowThreadInformation`</ph> method, which uses the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> property  to display information about the thread on which it is running.</source>
          <target state="translated">Llama a la propia aplicación, como también de cada tarea, la <ph id="ph1">`ShowThreadInformation`</ph> método, que usa el <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentThread%2A&gt;</ph> propiedad para mostrar información sobre el subproceso en el que se está ejecutando.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</source>
          <target state="translated">Cada tarea secundaria genera números aleatorios de 1 millón entre 1 y 1 millón y devuelve su Media.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>The parent task calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</source>
          <target state="translated">Las llamadas de la tarea primaria la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> método para asegurarse de que las tareas secundarias se han completado antes de mostrar la media devuelta por cada tarea y calcular la media de medios.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentThread">
          <source>Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</source>
          <target state="translated">Tenga en cuenta que mientras la aplicación se ejecuta en un subproceso en primer plano, cada tarea se ejecuta en un subproceso del grupo.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</source>
          <target state="translated">Obtiene o establece la referencia cultural actual utilizada por el administrador de recursos para buscar recursos específicos de la referencia cultural en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>An object that represents the current culture.</source>
          <target state="translated">Objeto que representa la referencia cultural actual.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</source>
          <target state="translated">La referencia cultural de interfaz de usuario especifica los recursos de una aplicación debe admitir proporcionados por el usuario y la salida y de forma predeterminada, es el mismo que la referencia cultural del sistema operativo.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</source>
          <target state="translated">Consulte la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> clase para obtener información acerca de los nombres de referencia cultural y los identificadores, las diferencias entre según la referencia cultural invariable, neutra y específica, y la información de referencia cultural de manera afecta a los dominios de aplicación y subprocesos.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>See the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> property to learn how a thread's default UI culture is determined.</source>
          <target state="translated">Consulte la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType&gt;</ph> propiedad para obtener información sobre cómo se determina la referencia cultural de interfaz de usuario de valor predeterminado de un subproceso.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> returned by this property can be a neutral culture.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> devuelta por esta propiedad puede ser una referencia cultural neutra.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Neutral cultures should not be used with formatting methods such as <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Las referencias culturales neutras no deben usarse con métodos de formato como <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>, y <ph id="ph3">&lt;xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> method to get a specific culture, or use the <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> property.</source>
          <target state="translated">Utilice la <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> método para obtener una referencia cultural específica, o use el <ph id="ph2">&lt;xref:System.Threading.Thread.CurrentCulture%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> method throws <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType&gt;</ph> método inicie una excepción <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> para las referencias culturales neutras "zh-Hant" ("zh-CHT") y "zh-Hans" ("zh-CHS").</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The following example determines whether the language of the current thread's UI culture is French.</source>
          <target state="translated">En el ejemplo siguiente se determina si el idioma de la referencia cultural de interfaz de usuario del subproceso actual es el francés.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>If it is not, it sets the UI culture of the current thread to English (United States).</source>
          <target state="translated">Si no es así, Establece la referencia cultural de interfaz de usuario del subproceso actual para inglés (Estados Unidos).</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la instrucción de subprocesamiento que permite a la interfaz de usuario de Windows Forms para mostrar de la referencia cultural que se establece en el Panel de Control.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Additional code is needed.</source>
          <target state="translated">Se necesita código adicional.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The property is set to <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La propiedad se establece en <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>The property is set to a culture name that cannot be used to locate a resource file.</source>
          <target state="translated">La propiedad se establece en un nombre de referencia cultural que no se puede usar para buscar un archivo de recursos.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.CurrentUICulture">
          <source>Resource filenames must include only letters, numbers, hyphens or underscores.</source>
          <target state="translated">Los nombres de archivo de recursos deben incluir solo letras, números, guiones o caracteres de subrayado.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</source>
          <target state="translated">Desactiva la limpieza automática de contenedores RCW (Runtime Callable Wrappers) para el subproceso actual.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</source>
          <target state="translated">De forma predeterminada, common language runtime (CLR) limpia los contenedores RCW automáticamente.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</source>
          <target state="translated">El CLR bombea los mensajes durante la limpieza, lo que podría producir problemas de reentrada para algunas aplicaciones que cumplen los siguientes criterios inusuales:</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The application does its own message pumping.</source>
          <target state="translated">La aplicación hace su propia distribución de mensajes.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>The application needs to control precisely when message pumping occurs.</source>
          <target state="translated">La aplicación necesita controlar con precisión cuando se produce la distribución de mensajes.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Such applications can use the <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A&gt;</ph> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</source>
          <target state="translated">Tales aplicaciones pueden utilizar el <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A&gt;</ph> método para evitar que el CLR realice contenedores RCW de recuperación automática de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</source>
          <target state="translated">Cuando este método se ha llamado en un subproceso, la limpieza automática no puede habilitarse de nuevo para ese subproceso.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>When your application is ready to clean up runtime callable wrappers, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType&gt;</ph> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</source>
          <target state="translated">Cuando la aplicación está lista para limpiar los contenedores RCW, use la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType&gt;</ph> método para indicar el tiempo de ejecución para limpiar todos los contenedores que se puede llamar en tiempo de ejecución en el contexto actual.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Message pumping occurs while the method executes.</source>
          <target state="translated">Distribución de mensajes tiene lugar mientras se ejecuta el método.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.DisableComObjectEagerCleanup">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</source>
          <target state="translated">Notifica a un host que la ejecución está a punto de entrar en una región de código donde los efectos de una anulación del subproceso o de una excepción no controlada se limitan a la tarea actual.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</source>
          <target state="translated">Los hosts de common language runtime (CLR), como Microsoft SQL Server 2005, pueden establecer directivas diferentes para los errores en las regiones críticas y no críticas de código.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</source>
          <target state="translated">Una región crítica es aquella en la que los efectos de una anulación del subproceso o una excepción no controlada podrían no limitarse a la tarea actual.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</source>
          <target state="translated">Por el contrario, una anulación o un error en una región no crítica del código afecta solo a la tarea en la que se produce el error.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>For example, consider a task that attempts to allocate memory while holding a lock.</source>
          <target state="translated">Por ejemplo, considere la posibilidad de una tarea que intenta asignar memoria mientras se mantiene un bloqueo.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, because there can be other tasks in the domain waiting for the same lock.</source>
          <target state="translated">Si se produce un error en la asignación de memoria, la anulación de la tarea actual no es suficiente para garantizar la estabilidad de la <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, porque puede haber otras tareas en el dominio esperando el mismo bloqueo.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>If the current task is terminated, other tasks could be deadlocked.</source>
          <target state="translated">Si se termina la tarea actual, otras tareas podrían sufrir un interbloqueo.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>When a failure occurs in a critical region, the host might decide to unload the entire <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> rather than take the risk of continuing execution in a potentially unstable state.</source>
          <target state="translated">Cuando se produce un error en una región crítica, el host puede optar por descargar todo el <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> en lugar de correr el riesgo de continuar la ejecución en un estado potencialmente inestable.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>To inform the host that your code is entering a critical region, call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</source>
          <target state="translated">Para informar al host que el código está entrando en una región crítica, llame a <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> when execution returns to a non-critical region of code.</source>
          <target state="translated">Llamar a <ph id="ph1">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> cuando la ejecución vuelve a una región no crítica del código.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Usar este método en el código que se ejecuta SQL Server 2005 requiere que el código se ejecute en el nivel más alto de protección de host.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndCriticalRegion">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> methods to divide a block of code into critical and non-critical regions.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Threading.Thread.BeginCriticalRegion%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.EndCriticalRegion%2A&gt;</ph> métodos para dividir un bloque de código en regiones críticas y no críticas.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</source>
          <target state="translated">Notifica a un host que el código administrado ha terminado de ejecutar instrucciones que dependen de la identidad del subproceso del sistema operativo físico actual.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</source>
          <target state="translated">Algunos de los hosts de common language runtime, como Microsoft SQL Server 2005, proporcionan su propia administración de subprocesos.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</source>
          <target state="translated">Un host que proporciona su propia administración de subprocesos puede mover una tarea que se ejecuta desde un subproceso de sistema operativo físico a otro en cualquier momento.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Most tasks are not affected by this switching.</source>
          <target state="translated">Mayoría de las tareas no se ven afectada por este cambio.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</source>
          <target state="translated">Sin embargo, algunas tareas tienen afinidad de subprocesos, es decir, que dependen de la identidad de un subproceso físico del sistema operativo.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>These tasks must inform the host when they execute code that should not be switched.</source>
          <target state="translated">Estas tareas deben informar al host cuando ejecuta código que no se debe cambiar.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> before acquiring the lock, and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> after releasing the lock.</source>
          <target state="translated">Por ejemplo, si el aplicación llama una API del sistema para adquirir un sistema operativo de bloqueo que tiene afinidad de subprocesos, como CRITICAL_SECTION de Win32, se debe llamar a <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> antes de adquirir el bloqueo, y <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> tras liberar el bloqueo.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</source>
          <target state="translated">Usar este método en el código que se ejecuta SQL Server 2005 requiere que el código se ejecute en el nivel más alto de protección de host.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Threading.Thread.BeginThreadAffinity%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.EndThreadAffinity%2A&gt;</ph> métodos para notificar a un host que un bloque de código depende de la identidad de un subproceso físico del sistema operativo.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.EndThreadAffinity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ExecutionContext">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> object that contains information about the various contexts of the current thread.</source>
          <target state="translated">Obtiene un objeto <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> que contiene información sobre los distintos contextos del subproceso actual.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>An <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> object that consolidates context information for the current thread.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.ExecutionContext" /&gt;</ph> que consolida la información de contexto del subproceso actual.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ExecutionContext&gt;</ph> class provides a single container for all information relevant to a logical thread of execution.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.ExecutionContext&gt;</ph> clase proporciona un contenedor único para toda la información relevante para un subproceso lógico de ejecución.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ExecutionContext">
          <source>This includes security context, call context, synchronization context, localization context, and transaction context.</source>
          <target state="translated">Esto incluye el contexto de seguridad, contexto de llamada, el contexto de sincronización, el contexto de localización y contexto de transacción.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> object.</source>
          <target state="translated">Se asegura de que los recursos se liberan y que se llevan a cabo otras operaciones de limpieza cuando el recolector de elementos no utilizados recupere el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Finalize">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Threading.Thread.Finalize%2A&gt;</ph> when the current object is ready to be finalized.</source>
          <target state="translated">El recolector de elementos no utilizados llame <ph id="ph1">&lt;xref:System.Threading.Thread.Finalize%2A&gt;</ph> cuando el objeto actual está preparado para finalizarse.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The name of the data slot to be freed.</source>
          <target state="translated">Nombre de la ranura de datos que se va a liberar.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Eliminates the association between a name and a slot, for all threads in the process.</source>
          <target state="translated">Elimina la asociación entre un nombre y una ranura en todos los subprocesos del proceso.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework proporciona dos mecanismos para usar el almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo) y ranuras de datos.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilita la comprobación de tipos en tiempo de compilación.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el uso de TLS, consulte <bpt id="p1">[</bpt>almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>After any thread calls <ph id="ph1">`FreeNamedDataSlot`</ph>, any other thread that calls <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> with the same name will allocate a new slot associated with the name.</source>
          <target state="translated">Después de cualquier subproceso llama <ph id="ph1">`FreeNamedDataSlot`</ph>, ningún otro subproceso que llama a <ph id="ph2">&lt;xref:System.Threading.Thread.GetNamedDataSlot%2A&gt;</ph> con el mismo nombre asignará una nueva ranura asociada al nombre.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Subsequent calls to <ph id="ph1">`GetNamedDataSlot`</ph> by any thread will return the new slot.</source>
          <target state="translated">Las llamadas subsiguientes a <ph id="ph1">`GetNamedDataSlot`</ph> ningún subproceso devolverá la nueva ranura.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>However, any thread that still has a <ph id="ph1">&lt;xref:System.LocalDataStoreSlot?displayProperty=nameWithType&gt;</ph> returned by an earlier call to <ph id="ph2">`GetNamedDataSlot`</ph> can continue to use the old slot.</source>
          <target state="translated">Sin embargo, cualquier subproceso que aún un <ph id="ph1">&lt;xref:System.LocalDataStoreSlot?displayProperty=nameWithType&gt;</ph> devuelto por una llamada anterior a <ph id="ph2">`GetNamedDataSlot`</ph> puede seguir usando la ranura anterior.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>A slot that has been associated with a name is released only when every <ph id="ph1">`LocalDataStoreSlot`</ph> that was obtained prior to the call to <ph id="ph2">`FreeNamedDataSlot`</ph> has been released and garbage-collected.</source>
          <target state="translated">Se libera una ranura que se ha asociado con un nombre solamente cuando cada <ph id="ph1">`LocalDataStoreSlot`</ph> que obtuvo antes de la llamada a <ph id="ph2">`FreeNamedDataSlot`</ph> se ha liberado y recolección.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Los subprocesos usan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras a cada proceso cuando se crea.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">El subproceso puede asignar una ranura de datos en el almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para volver a usar cuando el subproceso finalice.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Las ranuras de datos son únicas para cada subproceso.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Esta sección contiene dos ejemplos de código.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">El primer ejemplo muestra cómo utilizar un campo que se marca con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Primer ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar un campo que se marca con <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Segundo ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.FreeNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> value indicating the apartment state.</source>
          <target state="translated">Devuelve un valor <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> que indica el estado del apartamento.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> values indicating the apartment state of the managed thread.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Threading.ApartmentState" /&gt;</ph> que indica el estado del apartamento del subproceso administrado.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The default is <ph id="ph1">&lt;see cref="F:System.Threading.ApartmentState.Unknown" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see cref="F:System.Threading.ApartmentState.Unknown" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>This method, along with the <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph3">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">Este método, junto con el <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> método y la <ph id="ph2">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> método, reemplaza el <ph id="ph3">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The code example creates a thread.</source>
          <target state="translated">El ejemplo de código crea un subproceso.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Antes de inicia el subproceso, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> muestra inicial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> estado y <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> cambia el estado a <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> , a continuación, devuelve el método <ph id="ph2">`false`</ph> al intentar cambiar el estado a <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> porque el estado de apartamento ya está establecido.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Si hubiera intentado la misma operación <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> habría iniciado.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Una vez iniciado el subproceso, la <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> método se vuelve a usar.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetApartmentState">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Esta vez produce <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> porque ya se haya iniciado el subproceso.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> object that can be used to capture the stack for the current thread.</source>
          <target state="translated">Devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> que se puede utilizar para capturar la pila correspondiente al subproceso actual.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>None.</source>
          <target state="translated">Ninguno.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>This method is no longer supported.</source>
          <target state="translated">Ya no se admite este método.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>In all cases.</source>
          <target state="translated">En todos los casos.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetCompressedStack">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> from which to get the value.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> de donde se va a obtener el valor.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</source>
          <target state="translated">Recupera el valor de la ranura especificada en el subproceso actual, dentro del dominio actual del subproceso.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The retrieved value.</source>
          <target state="translated">El valor recuperado.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework proporciona dos mecanismos para usar el almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo) y ranuras de datos.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilita la comprobación de tipos en tiempo de compilación.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el uso de TLS, consulte <bpt id="p1">[</bpt>almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Los subprocesos usan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras a cada proceso cuando se crea.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">El subproceso puede asignar una ranura de datos en el almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para volver a usar cuando el subproceso finalice.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Las ranuras de datos son únicas para cada subproceso.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.GetData%2A&gt;</ph> is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.GetData%2A&gt;</ph> es un <ph id="ph2">`Shared`</ph> método que se aplica siempre al subproceso actualmente en ejecución, incluso si se le llama utilizando una variable que hace referencia a otro subproceso.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</source>
          <target state="translated">Para evitar confusiones, utilice el nombre de clase al llamar a <ph id="ph1">`Shared`</ph> métodos: <ph id="ph2">`Dim test As Object = Thread.GetData(testSlot)`</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>This section contains two code examples.</source>
          <target state="translated">Esta sección contiene dos ejemplos de código.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">El primer ejemplo muestra cómo utilizar un campo que se marca con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Primer ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar un campo que se marca con <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Segundo ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)">
          <source>The following example demonstrates how to use a data slot to store thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo usar una ranura de datos para almacenar información específica del subproceso.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomain">
          <source>Returns the current domain in which the current thread is running.</source>
          <target state="translated">Devuelve el dominio en el que se está ejecutando el subproceso actual.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomain">
          <source>An <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> representing the current application domain of the running thread.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> que representa el dominio de la aplicación actual del subproceso en ejecución.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetDomain">
          <source>The following code example shows how to retrieve the name and ID of the <ph id="ph1">`AppDomain`</ph> in which the thread is running.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo recuperar el nombre e identificador de la <ph id="ph1">`AppDomain`</ph> en que se está ejecutando el subproceso.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomainID">
          <source>Returns a unique application domain identifier.</source>
          <target state="translated">Devuelve un identificador único del dominio de la aplicación.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetDomainID">
          <source>A 32-bit signed integer uniquely identifying the application domain.</source>
          <target state="translated">Entero de 32 bits con signo que identifica de forma unívoca el dominio de la aplicación.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetDomainID">
          <source>The following code example shows how to retrieve the name and ID of the <ph id="ph1">`AppDomain`</ph> in which the thread is running.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo recuperar el nombre e identificador de la <ph id="ph1">`AppDomain`</ph> en que se está ejecutando el subproceso.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetHashCode">
          <source>Returns a hash code for the current thread.</source>
          <target state="translated">Devuelve un código hash para el subproceso actual.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetHashCode">
          <source>An integer hash code value.</source>
          <target state="translated">Valor de código hash entero.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetHashCode">
          <source>The hash code is not guaranteed to be unique.</source>
          <target state="translated">No se garantiza que el código hash sea único.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetHashCode">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property if you need a unique identifier for a managed thread.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> propiedad si necesita un identificador único para un subproceso administrado.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The name of the local data slot.</source>
          <target state="translated">Nombre de la ranura de datos local.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Looks up a named data slot.</source>
          <target state="translated">Busca una ranura de datos con nombre.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>For better performance, use fields that are marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> allocated for this thread.</source>
          <target state="translated">Una <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> asignada para este subproceso.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework proporciona dos mecanismos para usar el almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo) y ranuras de datos.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilita la comprobación de tipos en tiempo de compilación.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el uso de TLS, consulte <bpt id="p1">[</bpt>almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Los subprocesos usan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras a cada proceso cuando se crea.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</source>
          <target state="translated">El subproceso puede asignar una ranura de datos en el almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para volver a usar cuando el subproceso finalice.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Las ranuras de datos son únicas para cada subproceso.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>If the named slot does not exist, a new slot is allocated.</source>
          <target state="translated">Si el espacio con nombre no existe, se asigna un nuevo espacio.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>Named data slots are public and can be manipulated by anyone.</source>
          <target state="translated">Las ranuras de datos con nombre son públicas y se pueden manipular cualquier usuario.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>This section contains two code examples.</source>
          <target state="translated">Esta sección contiene dos ejemplos de código.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">El primer ejemplo muestra cómo utilizar un campo que se marca con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Primer ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar un campo que se marca con <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Segundo ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.GetNamedDataSlot(System.String)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Interrupt">
          <source>Interrupts a thread that is in the <ph id="ph1">&lt;see langword="WaitSleepJoin" /&gt;</ph> thread state.</source>
          <target state="translated">Interrumpe un subproceso que se encuentra en estado de subproceso <ph id="ph1">&lt;see langword="WaitSleepJoin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</source>
          <target state="translated">Si este subproceso no está actualmente bloqueado en una espera, la suspensión o el estado de unión, se interrumpirá cuando empieza a continuación a bloquear.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source><ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> is thrown in the interrupted thread, but not until the thread blocks.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> se produce en el subproceso interrumpido, pero no hasta que el subproceso se bloquea.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</source>
          <target state="translated">Si el subproceso nunca se bloquea, nunca se produce la excepción y, por tanto, el subproceso podría finalizar sin ser interrumpido.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra el comportamiento de un subproceso en ejecución cuando se interrumpe y posteriormente se bloquee.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Interrupt">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">El llamador no tiene el permiso <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph> apropiado.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>for advanced operations on threads.</source>
          <target state="translated">para operaciones avanzadas en subprocesos.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Interrupt">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsAlive">
          <source>Gets a value indicating the execution status of the current thread.</source>
          <target state="translated">Obtiene un valor que indica el estado de ejecución del subproceso actual.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsAlive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread has been started and has not terminated normally or aborted; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso se ha iniciado y no ha terminado con normalidad o se ha anulado; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsBackground">
          <source>Gets or sets a value indicating whether or not a thread is a background thread.</source>
          <target state="translated">Obtiene o establece un valor que indica si un subproceso es o no un subproceso en segundo plano.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread is or is to become a background thread; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso es un subproceso en segundo plano o va a convertirse en un subproceso en segundo plano; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>A thread is either a background thread or a foreground thread.</source>
          <target state="translated">Un subproceso es un subproceso en segundo plano o en un subproceso en primer plano.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</source>
          <target state="translated">Subprocesos en segundo plano son idénticos a los subprocesos de primer plano, salvo que los subprocesos en segundo plano no impiden que un proceso de terminación.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</source>
          <target state="translated">Una vez terminados todos los subprocesos de primer plano que pertenecen a un proceso, common language runtime termina el proceso.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Any remaining background threads are stopped and do not complete.</source>
          <target state="translated">Los subprocesos en segundo plano restantes se detienen y no se completan.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>By default, the following threads execute in the foreground (that is, their <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>):</source>
          <target state="translated">De forma predeterminada, los siguientes subprocesos se ejecutan en primer plano (es decir, su <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> propiedad devuelve <ph id="ph2">`false`</ph>):</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The primary thread (or main application thread).</source>
          <target state="translated">El subproceso principal (o subproceso de aplicación principal).</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>All threads created by calling a <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> class constructor.</source>
          <target state="translated">Todos los subprocesos creados mediante una llamada a un <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>By default, the following threads execute in the background  (that is, their <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>):</source>
          <target state="translated">De forma predeterminada, ejecuten los siguientes subprocesos en segundo plano (es decir, su <ph id="ph1">&lt;xref:System.Threading.Thread.IsBackground%2A&gt;</ph> propiedad devuelve <ph id="ph2">`true`</ph>):</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Thread pool threads, which are a pool of worker threads maintained by the runtime.</source>
          <target state="translated">El subproceso del grupo de subprocesos, que son un grupo de subprocesos de trabajo mantenida por el tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>You can configure the thread pool and schedule work on thread pool threads by using the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class.</source>
          <target state="translated">Puede configurar el trabajo de grupo y la programación de subprocesos en el grupo de subprocesos mediante el <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>Task-based asynchronous operations automatically execute on thread pool threads.</source>
          <target state="translated">Operaciones asincrónicas basadas en tareas se ejecutan automáticamente en el grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>All threads that enter the managed execution environment from unmanaged code.</source>
          <target state="translated">Todos los subprocesos que entran en el entorno de ejecución administrado desde código no administrado.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The following example contrasts the behavior of foreground and background threads.</source>
          <target state="translated">En el ejemplo siguiente se compara el comportamiento de los subprocesos de primer plano y fondo.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>It creates a foreground thread and a background thread.</source>
          <target state="translated">Crea un subproceso en primer plano y un subproceso en segundo plano.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>The foreground thread keeps the process running until completes its <ph id="ph1">`for`</ph> loop and terminates.</source>
          <target state="translated">El subproceso en primer plano mantiene el proceso se ejecuta hasta que finalice su <ph id="ph1">`for`</ph> bucle y finaliza.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsBackground">
          <source>However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</source>
          <target state="translated">Sin embargo, como se muestra en el resultado del ejemplo, dado que el subproceso en primer plano ha terminado de ejecutarse, el proceso se termina antes de que el subproceso en segundo plano ha completado su ejecución.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsBackground">
          <source>The thread is dead.</source>
          <target state="translated">El proceso está inactivo.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>Gets a value indicating whether or not a thread belongs to the managed thread pool.</source>
          <target state="translated">Obtiene un valor que indica si un subproceso pertenece al grupo de subprocesos administrados o no.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this thread belongs to the managed thread pool; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso pertenece al grupo de subprocesos administrados; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>For more information see <bpt id="p1">[</bpt>The Managed Thread Pool<ept id="p1">](~/docs/standard/threading/the-managed-thread-pool.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>el grupo de subprocesos administrado<ept id="p1">](~/docs/standard/threading/the-managed-thread-pool.md)</ept>.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.IsThreadPoolThread">
          <source>The following code example shows how to determine whether a thread is from the thread pool.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo determinar si es un subproceso del grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Blocks the calling thread until the thread represented by this instance terminates.</source>
          <target state="translated">Bloquea el subproceso de llamada hasta que finaliza el subproceso representado por esta instancia.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <ph id="ph1">&lt;see langword="SendMessage" /&gt;</ph> pumping.</source>
          <target state="translated">Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza, pero continúa bombeando <ph id="ph1">&lt;see langword="SendMessage" /&gt;</ph> y COM estándar.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso cuyo <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> se llama al método se ha completado.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>Use this method to ensure that a thread has been terminated.</source>
          <target state="translated">Utilice este método para asegurarse de que un subproceso ha finalizado.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>The caller will block indefinitely if the thread does not terminate.</source>
          <target state="translated">El llamador se bloqueará indefinidamente si el subproceso no termina.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block until <ph id="ph5">`Thread2`</ph> has completed.</source>
          <target state="translated">En el ejemplo siguiente, la <ph id="ph1">`Thread1`</ph> subproceso llama el <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> método <ph id="ph3">`Thread2`</ph>, lo que hace que <ph id="ph4">`Thread1`</ph> al bloque hasta que <ph id="ph5">`Thread2`</ph> se ha completado.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Si el subproceso ya ha terminado cuando <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> se llama, el método vuelve inmediatamente.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>You should never call the <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object that represents the current thread from the current thread.</source>
          <target state="translated">Nunca se debería llamar a la <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> método de la <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> objeto que representa el subproceso actual del subproceso actual.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>This causes your app to hang because the current thread waits upon itself indefinitely,</source>
          <target state="translated">Esto hace que la aplicación que deja de responder porque el subproceso actual espera indefinidamente, en sí misma</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>This method changes the state of the calling thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método cambia el estado del subproceso que realiza la llamada debe incluir <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">No se puede invocar <ph id="ph1">`Join`</ph> en un subproceso que se encuentra en la <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>The caller attempted to join a thread that is in the <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph> state.</source>
          <target state="translated">El autor de la llamada ha intentado combinar un subproceso que se encuentra en el estado <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join">
          <source>The thread is interrupted while waiting.</source>
          <target state="translated">El subproceso se interrumpe mientras espera.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The number of milliseconds to wait for the thread to terminate.</source>
          <target state="translated">Número de milisegundos durante los que se va a esperar a que el subproceso finalice.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza o transcurre el tiempo especificado, pero continúa bombeando SendMessage y COM estándar.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the thread has terminated; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the thread has not terminated after the amount of time specified by the <ph id="ph3">&lt;paramref name="millisecondsTimeout" /&gt;</ph> parameter has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso ha terminado; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si el subproceso no ha terminado una vez transcurrido el período de tiempo especificado por el parámetro <ph id="ph3">&lt;paramref name="millisecondsTimeout" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.Int32%29&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.Int32%29&gt;</ph> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso de cualquier cuyo <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> se llama al método se ha completado o ha transcurrido el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block either until <ph id="ph5">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">En el ejemplo siguiente, la <ph id="ph1">`Thread1`</ph> subproceso llama el <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> método <ph id="ph3">`Thread2`</ph>, lo que hace <ph id="ph4">`Thread1`</ph> para bloquear hasta que <ph id="ph5">`Thread2`</ph> se ha completado o 2 segundos transcurridos.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> is specified for the <ph id="ph2">`millisecondsTimeout`</ph> parameter, this method behaves identically to the <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> method overload, except for the return value.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> se especifica para el <ph id="ph2">`millisecondsTimeout`</ph> parámetro, este método se comporta igual que el <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> sobrecarga del método, excepto para el valor devuelto.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Si el subproceso ya ha terminado cuando <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> se llama, el método vuelve inmediatamente.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>This method changes the state of the calling thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método cambia el estado del subproceso que realiza la llamada debe incluir <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">No se puede invocar <ph id="ph1">`Join`</ph> en un subproceso que se encuentra en la <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es negativo y no es igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> en milisegundos.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.Int32)">
          <source>The thread has not been started.</source>
          <target state="translated">No se ha iniciado el subproceso.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> set to the amount of time to wait for the thread to terminate.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> establecido en el período de tiempo durante el que se esperará a que espere el subproceso.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</source>
          <target state="translated">Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza o transcurre el tiempo especificado, pero continúa bombeando SendMessage y COM estándar.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the thread terminated; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the thread has not terminated after the amount of time specified by the <ph id="ph3">&lt;paramref name="timeout" /&gt;</ph> parameter has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el subproceso ha terminado; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si el subproceso no ha terminado una vez transcurrido el período de tiempo especificado por el parámetro <ph id="ph3">&lt;paramref name="timeout" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.TimeSpan%29&gt;</ph> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method is called has completed or the time-out interval has elapsed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.Join%28System.TimeSpan%29&gt;</ph> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso de cualquier cuyo <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> se llama al método se ha completado o ha transcurrido el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>In the following example, the <ph id="ph1">`Thread1`</ph> thread calls the <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> method of <ph id="ph3">`Thread2`</ph>, which causes <ph id="ph4">`Thread1`</ph> to block either until <ph id="ph5">`Thread2`</ph> has completed or 2 seconds have elapsed.</source>
          <target state="translated">En el ejemplo siguiente, la <ph id="ph1">`Thread1`</ph> subproceso llama el <ph id="ph2">&lt;xref:System.Threading.Thread.Join&gt;</ph> método <ph id="ph3">`Thread2`</ph>, lo que hace <ph id="ph4">`Thread1`</ph> para bloquear hasta que <ph id="ph5">`Thread2`</ph> se ha completado o 2 segundos transcurridos.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> is specified for <ph id="ph2">`timeout`</ph>, this method behaves identically to the <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> method overload, except for the return value.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> especificado para <ph id="ph2">`timeout`</ph>, este método se comporta igual que el <ph id="ph3">&lt;xref:System.Threading.Thread.Join&gt;</ph> sobrecarga del método, excepto para el valor devuelto.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>If the thread has already terminated when <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> is called, the method returns immediately.</source>
          <target state="translated">Si el subproceso ya ha terminado cuando <ph id="ph1">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> se llama, el método vuelve inmediatamente.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>This method changes the state of the current thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Este método cambia el estado del subproceso actual para incluir <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>You cannot invoke <ph id="ph1">`Join`</ph> on a thread that is in the <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> state.</source>
          <target state="translated">No se puede invocar <ph id="ph1">`Join`</ph> en un subproceso que se encuentra en la <ph id="ph2">&lt;xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The following code example demonstrates how to use a <ph id="ph1">`TimeSpan`</ph> value with the <ph id="ph2">`Join`</ph> method.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo utilizar un <ph id="ph1">`TimeSpan`</ph> valor con el <ph id="ph2">`Join`</ph> método.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds, or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es negativo y no es igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> en milisegundos, o es superior a <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milisegundos.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Join(System.TimeSpan)">
          <source>The caller attempted to join a thread that is in the <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph> state.</source>
          <target state="translated">El autor de la llamada ha intentado combinar un subproceso que se encuentra en el estado <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Unstarted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>Gets a unique identifier for the current managed thread.</source>
          <target state="translated">Obtiene un identificador único para el actual subproceso administrado.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>An integer that represents a unique identifier for this managed thread.</source>
          <target state="translated">Entero que representa un identificador único para este subproceso administrado.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>A thread's <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property value serves to uniquely identify that thread within its process.</source>
          <target state="translated">Un subproceso <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> valor de la propiedad sirve para identificar ese subproceso dentro de su proceso.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ManagedThreadId">
          <source>The value of the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</source>
          <target state="translated">El valor de la <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A&gt;</ph> propiedad no varía con el tiempo, incluso si el código no administrado que hospeda common language runtime implemente el subproceso como una fibra.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.MemoryBarrier">
          <source>Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <ph id="ph1">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph> execute after memory accesses that follow the call to <ph id="ph2">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph>.</source>
          <target state="translated">Sincroniza el acceso a la memoria de la siguiente forma: el procesador que ejecuta el subproceso actual no puede reordenar las instrucciones de forma que los accesos a la memoria anteriores a la llamada a <ph id="ph1">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph> se ejecuten después de los accesos a memoria que siguen a la llamada a <ph id="ph2">&lt;see cref="M:System.Threading.Thread.MemoryBarrier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.MemoryBarrier">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.MemoryBarrier%2A&gt;</ph> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.MemoryBarrier%2A&gt;</ph> solo es necesario en sistemas multiprocesador con ordenación (por ejemplo, un sistema que utilice varios procesadores Intel Itanium) de memoria débil.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.MemoryBarrier">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier ways to synchronize data.</source>
          <target state="translated">Para la mayoría de los propósitos, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción), o la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan formas más sencillas de sincronizar los datos.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Name">
          <source>Gets or sets the name of the thread.</source>
          <target state="translated">Obtiene o establece el nombre del subproceso.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>A string containing the name of the thread, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no name was set.</source>
          <target state="translated">Cadena que contiene el nombre del subproceso o <ph id="ph1">&lt;see langword="null" /&gt;</ph> si no se ha establecido ningún nombre.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>This property is write-once.</source>
          <target state="translated">Esta propiedad es de escritura-una vez.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>Because the default value of a thread's <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> property is <ph id="ph2">`null`</ph>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Dado que el valor predeterminado de un subproceso <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> propiedad es <ph id="ph2">`null`</ph>, puede determinar si un nombre ha ya asignado explícitamente al subproceso comparándolo con <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>The string assigned to the <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> property can include any Unicode character.</source>
          <target state="translated">La cadena asignada a la <ph id="ph1">&lt;xref:System.Threading.Thread.Name%2A&gt;</ph> propiedad puede incluir cualquier carácter Unicode.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Name">
          <source>The following example shows how to name a thread.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo denominar un subproceso.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Name">
          <source>A set operation was requested, but the <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property has already been set.</source>
          <target state="translated">Se solicitó una operación Set, pero ya se ha establecido la propiedad <ph id="ph1">&lt;see langword="Name" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>Gets or sets a value indicating the scheduling priority of a thread.</source>
          <target state="translated">Obtiene o establece un valor que indica la prioridad de programación de un subproceso.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph> values.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Threading.ThreadPriority.Normal" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see cref="F:System.Threading.ThreadPriority.Normal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>A thread can be assigned any one of the following priority <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> values:</source>
          <target state="translated">Un subproceso se puede asignar cualquiera de la siguiente prioridad <ph id="ph1">&lt;xref:System.Threading.ThreadPriority&gt;</ph> valores:</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Operating systems are not required to honor the priority of a thread.</source>
          <target state="translated">Sistemas operativos no se debe respetar la prioridad de un subproceso.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>The following example shows the result of changing the priority of a thread.</source>
          <target state="translated">En el ejemplo siguiente se muestra el resultado de cambiar la prioridad de un subproceso.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Three threads are created, the priority of one thread is set to <ph id="ph1">&lt;xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType&gt;</ph>, and the priority of a second is set to <ph id="ph2">&lt;xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se crean tres subprocesos, se establece la prioridad de un subproceso en <ph id="ph1">&lt;xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType&gt;</ph>, y la prioridad de segundo se establece en <ph id="ph2">&lt;xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.Priority">
          <source>Each thread increments a variable in a <ph id="ph1">`while`</ph> loop and runs for a set time.</source>
          <target state="translated">Cada subproceso incrementa una variable en un <ph id="ph1">`while`</ph> bucle y se ejecuta durante un tiempo establecido.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>The thread has reached a final state, such as <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Aborted" /&gt;</ph>.</source>
          <target state="translated">El subproceso ha alcanzado un estado final, como <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Aborted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.Priority">
          <source>The value specified for a set operation is not a valid <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph> value.</source>
          <target state="translated">El valor especificado para una operación de establecimiento no es un valor de <ph id="ph1">&lt;see cref="T:System.Threading.ThreadPriority" /&gt;</ph> valido.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>Cancels an <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Abort(System.Object)" /&gt;</ph> requested for the current thread.</source>
          <target state="translated">Cancela un método <ph id="ph1">&lt;see cref="M:System.Threading.Thread.Abort(System.Object)" /&gt;</ph> solicitado para el subproceso actual.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>This method can only be called by code with the proper permissions.</source>
          <target state="translated">Este método solo puede llamarse mediante código con los permisos adecuados.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>When a call is made to <ph id="ph1">`Abort`</ph> to terminate a thread, the system throws a <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>.</source>
          <target state="translated">Cuando se realiza una llamada a <ph id="ph1">`Abort`</ph> para terminar un subproceso, el sistema produce una <ph id="ph2">&lt;xref:System.Threading.ThreadAbortException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">`ThreadAbortException`</ph> is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless <ph id="ph2">`ResetAbort`</ph> is called.</source>
          <target state="translated"><ph id="ph1">`ThreadAbortException`</ph> es una excepción especial que puede detectar mediante código de la aplicación, pero se vuelve a producir al final del bloque catch a menos que <ph id="ph2">`ResetAbort`</ph> se llama.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">`ResetAbort`</ph> cancels the request to abort, and prevents the <ph id="ph2">`ThreadAbortException`</ph> from terminating the thread.</source>
          <target state="translated"><ph id="ph1">`ResetAbort`</ph> cancela la solicitud para anular la operación y evita la <ph id="ph2">`ThreadAbortException`</ph> de finalización del subproceso.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>See <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> for an example that demonstrates calling the <ph id="ph2">`ResetAbort`</ph> method.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> para obtener un ejemplo que muestra cómo llamar a la <ph id="ph2">`ResetAbort`</ph> método.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Solo .NET Core: este miembro no se admite.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source><ph id="ph1">&lt;see langword="Abort" /&gt;</ph> was not invoked on the current thread.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Abort" /&gt;</ph> no se invocó en el subproceso actual.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.ResetAbort">
          <source>The caller does not have the required security permission for the current thread.</source>
          <target state="translated">El autor de la llamada no tiene el permiso de seguridad necesario para el subproceso actual.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>for advanced operations on threads.</source>
          <target state="translated">para operaciones avanzadas en subprocesos.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.ResetAbort">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>Resumes a thread that has been suspended.</source>
          <target state="translated">Reanuda un subproceso que se ha suspendido.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Do not use the <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> methods to synchronize the activities of threads.</source>
          <target state="translated">No utilice la <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> métodos para sincronizar las actividades de subprocesos.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">No tener ninguna manera de saber qué código un subproceso se ejecuta cuando se lo suspenderá.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> might be blocked.</source>
          <target state="translated">Si se suspende un subproceso mientras contiene los bloqueos durante una evaluación de permisos de seguridad, otros subprocesos en la <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> podría bloquearse.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that attempt to use that class are blocked.</source>
          <target state="translated">Si se suspende un subproceso mientras se ejecuta un constructor de clase, otros subprocesos en la <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> que intentan usar que clase están bloqueadas.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Pueden producirse interbloqueos muy fácilmente.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Solo .NET Core: este miembro no se admite.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>The thread has not been started, is dead, or is not in the suspended state.</source>
          <target state="translated">El subproceso no se ha iniciado, está inactivo o no está en estado suspendido.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Resume">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">El llamador no tiene el permiso <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph> apropiado.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>for advanced operations on threads.</source>
          <target state="translated">para operaciones avanzadas en subprocesos.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Resume">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The new apartment state.</source>
          <target state="translated">Nuevo estado del apartamento.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Establece el estado del apartamento de un subproceso antes de iniciarse.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>New threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">Los subprocesos nuevos se inicializan como <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> si no se ha establecido su estado de apartamento antes de que se inicien.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Estado del apartamento se debe establecer antes de que se inicia un subproceso.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">El subproceso de aplicación principal se inicializa en <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The only way to set the apartment state of the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> is to apply the <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> attribute to the entry point method.</source>
          <target state="translated">La única manera de establecer el estado de apartamento del subproceso de aplicación principal en <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> es aplicar el <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> atributo al método de punto de entrada.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method, along with the <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> método, junto con el <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> método y <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> reemplaza el método, el <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The code example creates a thread.</source>
          <target state="translated">El ejemplo de código crea un subproceso.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Antes de inicia el subproceso, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> muestra inicial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> estado y <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> cambia el estado a <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> , a continuación, devuelve el método <ph id="ph2">`false`</ph> al intentar cambiar el estado a <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> porque el estado de apartamento ya está establecido.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Si hubiera intentado la misma operación <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> habría iniciado.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Una vez iniciado el subproceso, la <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> método se vuelve a usar.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Esta vez produce <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> porque ya se haya iniciado el subproceso.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>.NET Core only: This member is not supported on the macOS and Linux platforms.</source>
          <target state="translated">Solo .NET Core: este miembro no se admite en las plataformas macOS y Linux.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;paramref name="state" /&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="state" /&gt;</ph> no es un estado de tipo apartamento válido.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The thread has already been started.</source>
          <target state="translated">Ya se inició el subproceso.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)">
          <source>The apartment state has already been initialized.</source>
          <target state="translated">El estado de apartamento ya se inicializó.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> object to be applied to the current thread.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> que va a aplicarse al subproceso actual.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>Applies a captured <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> to the current thread.</source>
          <target state="translated">Aplica un objeto <ph id="ph1">&lt;see cref="T:System.Threading.CompressedStack" /&gt;</ph> capturado al subproceso actual.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>This method is no longer supported.</source>
          <target state="translated">Ya no se admite este método.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>In all cases.</source>
          <target state="translated">En todos los casos.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> in which to set the value.</source>
          <target state="translated">La <ph id="ph1">&lt;see cref="T:System.LocalDataStoreSlot" /&gt;</ph> donde se va a establecer el valor.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The value to be set.</source>
          <target state="translated">Valor que se va a establecer.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Sets the data in the specified slot on the currently running thread, for that thread's current domain.</source>
          <target state="translated">Establece los datos de la ranura especificada en el subproceso actualmente en ejecución, para el dominio actual de dicho subproceso.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>For better performance, use fields marked with the <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph> attribute instead.</source>
          <target state="translated">Para obtener un mejor rendimiento, utilice en su lugar los campos marcados con el atributo <ph id="ph1">&lt;see cref="T:System.ThreadStaticAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute) and data slots.</source>
          <target state="translated">.NET Framework proporciona dos mecanismos para usar el almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo) y ranuras de datos.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</source>
          <target state="translated">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilita la comprobación de tipos en tiempo de compilación.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>For more information about using TLS, see <bpt id="p1">[</bpt>Thread Local Storage: Thread-Relative Static Fields and Data Slots<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el uso de TLS, consulte <bpt id="p1">[</bpt>almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos<ept id="p1">](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)</ept>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Threads use a local store memory mechanism to store thread-specific data.</source>
          <target state="translated">Los subprocesos usan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The common language runtime allocates a multi-slot data store array to each process when it is created.</source>
          <target state="translated">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras a cada proceso cuando se crea.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> object has been reclaimed by garbage collection.</source>
          <target state="translated">El subproceso puede asignar una ranura de datos en el almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para volver a usar una vez finalizado el procedimiento de subproceso y <ph id="ph1">&lt;xref:System.Threading.Thread&gt;</ph> objeto ha sido reclamado por la recolección de elementos.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>Data slots are unique per thread.</source>
          <target state="translated">Las ranuras de datos son únicas para cada subproceso.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>No other thread (not even a child thread) can get that data.</source>
          <target state="translated">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SetData%2A&gt;</ph> is a <ph id="ph2">`Shared`</ph> method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SetData%2A&gt;</ph> es un <ph id="ph2">`Shared`</ph> método que se aplica siempre al subproceso actualmente en ejecución, incluso si se le llama utilizando una variable que hace referencia a otro subproceso.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>To avoid confusion, use the class name when calling <ph id="ph1">`Shared`</ph> methods: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</source>
          <target state="translated">Para evitar confusiones, utilice el nombre de clase al llamar a <ph id="ph1">`Shared`</ph> métodos: <ph id="ph2">`Thread.SetData(testSlot, "test data")`</ph>.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>This section contains two code examples.</source>
          <target state="translated">Esta sección contiene dos ejemplos de código.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The first example shows how to use a field that is marked with the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute to hold thread-specific information.</source>
          <target state="translated">El primer ejemplo muestra cómo utilizar un campo que se marca con el <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The second example shows how to use a data slot to do the same thing.</source>
          <target state="translated">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><bpt id="p1">**</bpt>First Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Primer ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The following example shows how to use a field that is marked with <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> to hold thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar un campo que se marca con <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> para almacenar información específica de subprocesos.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>This technique provides better performance than the technique that is shown in the second example.</source>
          <target state="translated">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source><bpt id="p1">**</bpt>Second Example<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Segundo ejemplo<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)">
          <source>The following example demonstrates how to use a named data slot to store thread-specific information.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Suspende el subproceso actual durante la cantidad de tiempo especificada.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The number of milliseconds for which the thread is suspended.</source>
          <target state="translated">Número de milisegundos durante los que el subproceso está suspendido.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If the value of the <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Si el valor del argumento <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> es cero, el subproceso cede el resto de su porción de tiempo a cualquier subproceso de idéntica prioridad que esté listo para ejecutarse.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Si no hay ningún otro subproceso de igual prioridad que está listo para ejecutarse, no se suspende la ejecución del subproceso actual.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>Suspends the current thread for the specified number of milliseconds.</source>
          <target state="translated">Suspende el subproceso actual durante el número de milisegundos especificado.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">El subproceso no se programará para su ejecución por el sistema operativo durante el tiempo especificado.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method changes the state of the thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Este método cambia el estado del subproceso para incluir <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>You can specify <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`millisecondsTimeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Puede especificar <ph id="ph1">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> para el <ph id="ph2">`millisecondsTimeout`</ph> parámetro para suspender el subproceso indefinidamente.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>However, we recommend that you use other <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> classes such as <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> instead to sychronize threads or manage resources.</source>
          <target state="translated">Sin embargo, se recomienda utilizar otros <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> las clases como <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, o <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> en su lugar para sincronizar subprocesos o administrar los recursos.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The system clock ticks at a specific rate called the clock resolution.</source>
          <target state="translated">Los ciclos de reloj del sistema a un ritmo específico llama a la resolución del reloj.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</source>
          <target state="translated">El tiempo de espera real podría no ser exactamente el tiempo de espera, ya que el tiempo de espera especificado se ajustarán para que coincida con los ciclos de reloj.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>For more information on clock resolution and the waiting time, see the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> topic.</source>
          <target state="translated">Para obtener más información sobre la resolución del reloj y el tiempo de espera, vea el <bpt id="p1">[</bpt>suspensión función<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> tema.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method calls the <bpt id="p1">[</bpt>Sleep function<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> from the Windows system APIs.</source>
          <target state="translated">Este método llama a la <bpt id="p1">[</bpt>suspensión función<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)</ept> desde las API del sistema de Windows.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Este método no realiza suministro de SendMessage y COM estándar.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>If you need to sleep on a thread that has <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method that specifies a timeout interval.</source>
          <target state="translated">Si necesita en modo de suspensión en un subproceso que tiene <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, pero desea realizar pero continúa bombeando SendMessage y COM estándar, puede usar una de las sobrecargas de los <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> método que especifica un intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method to block the application's main thread.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> método para bloquear el subproceso principal de la aplicación.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.Int32)">
          <source>The time-out value is negative and is not equal to <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">El valor de tiempo de espera es negativo y no es igual a <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The amount of time for which the thread is suspended.</source>
          <target state="translated">Cantidad de tiempo durante la que el subproceso está suspendido.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If the value of the <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> argument is <ph id="ph1">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</source>
          <target state="translated">Si el valor del argumento <bpt id="p1">&lt;c&gt;</bpt>millisecondsTimeout<ept id="p1">&lt;/c&gt;</ept> es <ph id="ph1">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph>, el subproceso cede el resto de su porción de tiempo a cualquier subproceso de idéntica prioridad que esté listo para ejecutarse.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</source>
          <target state="translated">Si no hay ningún otro subproceso de igual prioridad que está listo para ejecutarse, no se suspende la ejecución del subproceso actual.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>Suspends the current thread for the specified amount of time.</source>
          <target state="translated">Suspende el subproceso actual durante la cantidad de tiempo especificada.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The thread will not be scheduled for execution by the operating system for the amount of time specified.</source>
          <target state="translated">El subproceso no se programará para su ejecución por el sistema operativo durante el tiempo especificado.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This method changes the state of the thread to include <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</source>
          <target state="translated">Este método cambia el estado del subproceso para incluir <ph id="ph1">&lt;xref:System.Threading.ThreadState.WaitSleepJoin&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>You can specify <ph id="ph1">&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter to suspend the thread indefinitely.</source>
          <target state="translated">Puede especificar <ph id="ph1">&lt;xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType&gt;</ph> para el <ph id="ph2">`timeout`</ph> parámetro para suspender el subproceso indefinidamente.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>However, we recommend that you use other <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> classes such as <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> instead to sychronize threads or manage resources.</source>
          <target state="translated">Sin embargo, se recomienda utilizar otros <ph id="ph1">&lt;xref:System.Threading?displayProperty=nameWithType&gt;</ph> las clases como <ph id="ph2">&lt;xref:System.Threading.Mutex&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, o <ph id="ph5">&lt;xref:System.Threading.Semaphore&gt;</ph> en su lugar para sincronizar subprocesos o administrar los recursos.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This overload of <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> uses the total number of whole milliseconds in <ph id="ph2">`timeout`</ph>.</source>
          <target state="translated">Esta sobrecarga de <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> utiliza el número total de milisegundos enteros en <ph id="ph2">`timeout`</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>Fractional milliseconds are discarded.</source>
          <target state="translated">Se descartan las fracciones de milisegundos.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>This method does not perform standard COM and SendMessage pumping.</source>
          <target state="translated">Este método no realiza suministro de SendMessage y COM estándar.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>If you need to sleep on a thread that has <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> method that specifies a timeout interval.</source>
          <target state="translated">Si necesita en modo de suspensión en un subproceso que tiene <ph id="ph1">&lt;xref:System.STAThreadAttribute&gt;</ph>, pero desea realizar pero continúa bombeando SendMessage y COM estándar, puede usar una de las sobrecargas de los <ph id="ph2">&lt;xref:System.Threading.Thread.Join%2A&gt;</ph> método que especifica un intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%28System.TimeSpan%29&gt;</ph> method overload to block the application's main thread five times, for two seconds each time.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%28System.TimeSpan%29&gt;</ph> sobrecarga del método para bloquear el subproceso principal de la aplicación cinco veces, durante dos segundos cada vez.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Sleep(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative and is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> in milliseconds, or is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es negativo y no es igual a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> en milisegundos, o es superior a <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milisegundos.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>A 32-bit signed integer that defines how long a thread is to wait.</source>
          <target state="translated">Entero de 32 bits con signo que define la cantidad de tiempo de espera de un subproceso.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Causes a thread to wait the number of times defined by the <ph id="ph1">&lt;paramref name="iterations" /&gt;</ph> parameter.</source>
          <target state="translated">Hace que un subproceso espere el número de veces definido por el parámetro <ph id="ph1">&lt;paramref name="iterations" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> method is useful for implementing locks.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> método resulta útil para implementar bloqueos.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Classes in the .NET Framework, such as <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, use this method internally.</source>
          <target state="translated">Las clases de .NET Framework, como <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, use este método internamente.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> essentially puts the processor into a very tight loop, with the loop count specified by the <ph id="ph2">`iterations`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> básicamente coloca el procesador en un bucle muy ajustado, con el recuento del bucle especificado por el <ph id="ph2">`iterations`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The duration of the wait therefore depends on the speed of the processor.</source>
          <target state="translated">La duración de la espera, por tanto, depende de la velocidad del procesador.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Contrast this with the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method.</source>
          <target state="translated">Compare esto con el <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>A thread that calls <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> yields the rest of its current slice of processor time, even if the specified interval is zero.</source>
          <target state="translated">Un subproceso que llama <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> da como resultado el resto de su porción actual de tiempo de procesador, incluso si el intervalo especificado es cero.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>Specifying a non-zero interval for <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</source>
          <target state="translated">Especificar un intervalo distinto de cero para <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> quita el subproceso de examen por el programador del subproceso hasta que haya transcurrido el intervalo de tiempo.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> is not generally useful for ordinary applications.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> no es suelen ser útiles para las aplicaciones comunes.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> or a statement that wraps <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">`lock`</ph> in C# or <ph id="ph4">`SyncLock`</ph> in Visual Basic).</source>
          <target state="translated">En la mayoría de los casos, debe usar las clases de sincronización proporcionadas por .NET Framework; Por ejemplo, llamar a <ph id="ph1">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> o una instrucción que ajusta <ph id="ph2">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">`lock`</ph> en C# o <ph id="ph4">`SyncLock`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> method in your loop.</source>
          <target state="translated">En el caso excepcional de que resulte ventajoso para evitar un cambio de contexto, por ejemplo, cuando se sabe que un cambio de estado es inminente, realizar una llamada a la <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> método en el bucle.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>The code <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> executes is designed to prevent problems that can occur on computers with multiple processors.</source>
          <target state="translated">El código <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> ejecuta está diseñado para evitar problemas que pueden producirse en equipos con varios procesadores.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.SpinWait(System.Int32)">
          <source>For example, on computers with multiple Intel processors employing Hyper-Threading technology, <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> prevents processor starvation in certain situations.</source>
          <target state="translated">Por ejemplo, en equipos con varios procesadores Intel que emplean la tecnología Hyper-Threading, <ph id="ph1">&lt;xref:System.Threading.Thread.SpinWait%2A&gt;</ph> evita la inanición del procesador en determinadas situaciones.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Causes a thread to be scheduled for execution.</source>
          <target state="translated">Hace que se programe un subproceso para su ejecución.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>Causes the operating system to change the state of the current instance to <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>.</source>
          <target state="translated">Hace que el sistema operativo cambie el estado de la instancia actual a <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Once a thread is in the <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> state, the operating system can schedule it for execution.</source>
          <target state="translated">Una vez que un subproceso está en el <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> de estado, el sistema operativo puede programarlo para su ejecución.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>The thread begins executing at the first line of the method represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate supplied to the thread constructor.</source>
          <target state="translated">El subproceso empieza a ejecutarse en la primera línea del método representado por la <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegado proporcionado al constructor del subproceso.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Note that the call to <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> does not block the calling thread.</source>
          <target state="translated">Tenga en cuenta que la llamada a <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> no bloquea el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>If this overload is used with a thread created using a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate, <ph id="ph2">`null`</ph> is passed to the method executed by the thread.</source>
          <target state="translated">Si esta sobrecarga se utiliza con un subproceso creado utilizando un <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegar, <ph id="ph2">`null`</ph> se pasa al método ejecutado por el subproceso.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Una vez que finaliza el subproceso, no se puede reiniciar con otra llamada a <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start">
          <source>The following example creates and starts a thread.</source>
          <target state="translated">En el ejemplo siguiente se crea y se inicia un subproceso.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>The thread has already been started.</source>
          <target state="translated">Ya se inició el subproceso.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">No hay memoria suficiente disponible para iniciar este subproceso.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>An object that contains data to be used by the method the thread executes.</source>
          <target state="translated">Objeto que contiene datos para que los use el método ejecutado por el subproceso.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Causes the operating system to change the state of the current instance to <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>, and optionally supplies an object containing data to be used by the method the thread executes.</source>
          <target state="translated">Hace que el sistema operativo cambie el estado de la instancia actual a <ph id="ph1">&lt;see cref="F:System.Threading.ThreadState.Running" /&gt;</ph>; también puede proporcionar un objeto que contiene datos para que los use el método ejecutado por el subproceso.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Once a thread is in the <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> state, the operating system can schedule it for execution.</source>
          <target state="translated">Una vez que un subproceso está en el <ph id="ph1">&lt;xref:System.Threading.ThreadState.Running?displayProperty=nameWithType&gt;</ph> de estado, el sistema operativo puede programarlo para su ejecución.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The thread begins executing at the first line of the method represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate supplied to the thread constructor.</source>
          <target state="translated">El subproceso empieza a ejecutarse en la primera línea del método representado por la <ph id="ph1">&lt;xref:System.Threading.ThreadStart&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegado proporcionado al constructor del subproceso.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Note that the call to <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> does not block the calling thread.</source>
          <target state="translated">Tenga en cuenta que la llamada a <ph id="ph1">&lt;xref:System.Threading.Thread.Start%2A&gt;</ph> no bloquea el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>Once the thread terminates, it cannot be restarted with another call to <ph id="ph1">`Start`</ph>.</source>
          <target state="translated">Una vez que finaliza el subproceso, no se puede reiniciar con otra llamada a <ph id="ph1">`Start`</ph>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>This overload and the <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</source>
          <target state="translated">Esta sobrecarga y la <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegado que sean fáciles de pasar datos a un procedimiento de subproceso, pero la técnica no tiene seguridad de tipos porque puede pasar cualquier objeto a esta sobrecarga.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</source>
          <target state="translated">Es una manera más segura para pasar datos a un procedimiento de subproceso poner el procedimiento de subproceso y los campos de datos en un objeto de trabajo.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Creating Threads and Passing Data at Start Time<ept id="p1">](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>crear subprocesos y pasar datos en tiempo de inicio<ept id="p1">](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)</ept>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegate with a static method and an instance method.</source>
          <target state="translated">En el ejemplo siguiente se crea un <ph id="ph1">&lt;xref:System.Threading.ParameterizedThreadStart&gt;</ph> delegado con un método estático y un método de instancia.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>The thread has already been started.</source>
          <target state="translated">Ya se inició el subproceso.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>There is not enough memory available to start this thread.</source>
          <target state="translated">No hay memoria suficiente iniciar este subproceso.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Start(System.Object)">
          <source>This thread was created using a <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> delegate instead of a <ph id="ph2">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph> delegate.</source>
          <target state="translated">Este subproceso se creó mediante un delegado <ph id="ph1">&lt;see cref="T:System.Threading.ThreadStart" /&gt;</ph> en lugar de un delegado <ph id="ph2">&lt;see cref="T:System.Threading.ParameterizedThreadStart" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>Either suspends the thread, or if the thread is already suspended, has no effect.</source>
          <target state="translated">Suspende el subproceso o, si este ya se ha suspendido, no tiene efecto alguno.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If the thread is already suspended, this method has no effect.</source>
          <target state="translated">Si el subproceso se ha suspendido, este método no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Do not use the <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> methods to synchronize the activities of threads.</source>
          <target state="translated">No utilice la <ph id="ph1">&lt;xref:System.Threading.Thread.Suspend%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.Resume%2A&gt;</ph> métodos para sincronizar las actividades de subprocesos.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>You have no way of knowing what code a thread is executing when you suspend it.</source>
          <target state="translated">No tener ninguna manera de saber qué código un subproceso se ejecuta cuando se lo suspenderá.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> might be blocked.</source>
          <target state="translated">Si se suspende un subproceso mientras contiene los bloqueos durante una evaluación de permisos de seguridad, otros subprocesos en la <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> podría bloquearse.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>If you suspend a thread while it is executing a class constructor, other threads in the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that attempt to use that class are blocked.</source>
          <target state="translated">Si se suspende un subproceso mientras se ejecuta un constructor de clase, otros subprocesos en la <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> que intentan usar que clase están bloqueadas.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Deadlocks can occur very easily.</source>
          <target state="translated">Pueden producirse interbloqueos muy fácilmente.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>.NET Core only: This member is not supported.</source>
          <target state="translated">Solo .NET Core: este miembro no se admite.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>The thread has not been started or is dead.</source>
          <target state="translated">No se ha iniciado el subproceso o está inactivo</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Suspend">
          <source>The caller does not have the appropriate <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph>.</source>
          <target state="translated">El llamador no tiene el permiso <ph id="ph1">&lt;see cref="T:System.Security.Permissions.SecurityPermission" /&gt;</ph> apropiado.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>for advanced operations on threads.</source>
          <target state="translated">para operaciones avanzadas en subprocesos.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Suspend">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz que se pasa con los nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Número de nombres que se van a asignar.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contexto de configuración regional en el que se van a interpretar los nombres.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Información de tipos que se va a devolver.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificador de la configuración regional de la información de tipo.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recibe un puntero al objeto de información de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica el miembro.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para un uso futuro.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Debe ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contexto de la configuración regional en que se interpretan los argumentos.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Marcas que describen el contexto de la llamada.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntero a la ubicación donde se va a almacenar el resultado.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntero a una estructura que contiene información de excepciones.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Índice del primer argumento que tiene un error.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obtener más información sobre <ph id="ph1">`IDispatch::Invoke`</ph>, vea MSDN Library.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> de COM.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="P:System.Threading.Thread.ThreadState">
          <source>Gets a value containing the states of the current thread.</source>
          <target state="translated">Obtiene un valor que contiene los estados del subproceso actual.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Threading.ThreadState" /&gt;</ph> values indicating the state of the current thread.</source>
          <target state="translated">Uno de los valores de <ph id="ph1">&lt;see cref="T:System.Threading.ThreadState" /&gt;</ph> que indica el estado del subproceso actual.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The initial value is <ph id="ph1">&lt;see langword="Unstarted" /&gt;</ph>.</source>
          <target state="translated">El valor inicial es <ph id="ph1">&lt;see langword="Unstarted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> property provides more specific information than the <ph id="ph2">&lt;xref:System.Threading.Thread.IsAlive%2A&gt;</ph> property.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Thread.ThreadState%2A&gt;</ph> propiedad proporciona información más específica que la <ph id="ph2">&lt;xref:System.Threading.Thread.IsAlive%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>Thread state is only of interest in debugging scenarios.</source>
          <target state="translated">Estado de los subprocesos solo es de interés en escenarios de depuración.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>Your code should never use thread state to synchronize the activities of threads.</source>
          <target state="translated">El código nunca debe usar el estado de los subprocesos para sincronizar las actividades de los subprocesos.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Thread.ThreadState">
          <source>The following code example demonstrates accessing the <ph id="ph1">`ThreadState`</ph> of a thread.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo tener acceso el <ph id="ph1">`ThreadState`</ph> de un subproceso.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The new apartment state.</source>
          <target state="translated">Nuevo estado del apartamento.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Sets the apartment state of a thread before it is started.</source>
          <target state="translated">Establece el estado del apartamento de un subproceso antes de iniciarse.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the apartment state is set; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si se ha establecido el estado del apartamento; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>New threads are initialized as <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> if their apartment state has not been set before they are started.</source>
          <target state="translated">Los subprocesos nuevos se inicializan como <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> si no se ha establecido su estado de apartamento antes de que se inicien.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Apartment state must be set before a thread is started.</source>
          <target state="translated">Estado del apartamento se debe establecer antes de que se inicia un subproceso.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The main application thread is initialized to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> by default.</source>
          <target state="translated">El subproceso de aplicación principal se inicializa en <ph id="ph1">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The only way to set the apartment state of the main application thread to <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> is to apply the <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> attribute to the entry point method.</source>
          <target state="translated">La única manera de establecer el estado de apartamento del subproceso de aplicación principal en <ph id="ph1">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph> es aplicar el <ph id="ph2">&lt;xref:System.STAThreadAttribute&gt;</ph> atributo al método de punto de entrada.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method, along with the <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> method and the <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> method, replaces the <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> property.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> método, junto con el <ph id="ph2">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> método y <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> reemplaza el método, el <ph id="ph4">&lt;xref:System.Threading.Thread.ApartmentState%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> methods.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The code example creates a thread.</source>
          <target state="translated">El ejemplo de código crea un subproceso.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>Before the thread is started, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> displays the initial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> state and <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> changes the state to <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Antes de inicia el subproceso, <ph id="ph1">&lt;xref:System.Threading.Thread.GetApartmentState%2A&gt;</ph> muestra inicial <ph id="ph2">&lt;xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType&gt;</ph> estado y <ph id="ph3">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph> cambia el estado a <ph id="ph4">&lt;xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method then returns <ph id="ph2">`false`</ph> when attempting to change the state to <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> because the apartment state is already set.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> , a continuación, devuelve el método <ph id="ph2">`false`</ph> al intentar cambiar el estado a <ph id="ph3">&lt;xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType&gt;</ph> porque el estado de apartamento ya está establecido.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>If the same operation had been attempted with <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> would have been thrown.</source>
          <target state="translated">Si hubiera intentado la misma operación <ph id="ph1">&lt;xref:System.Threading.Thread.SetApartmentState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> habría iniciado.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>After the thread is started, the <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> method is used again.</source>
          <target state="translated">Una vez iniciado el subproceso, la <ph id="ph1">&lt;xref:System.Threading.Thread.TrySetApartmentState%2A&gt;</ph> método se vuelve a usar.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>This time it throws <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> because the thread has already been started.</source>
          <target state="translated">Esta vez produce <ph id="ph1">&lt;xref:System.Threading.ThreadStateException&gt;</ph> porque ya se haya iniciado el subproceso.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source><ph id="ph1">&lt;paramref name="state" /&gt;</ph> is not a valid apartment state.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="state" /&gt;</ph> no es un estado de tipo apartamento válido.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)">
          <source>The thread has already been started.</source>
          <target state="translated">Ya se inició el subproceso.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Byte@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Double@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int16@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int32@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Int64@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.IntPtr@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Object@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.SByte@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.Single@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt16@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt32@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UInt64@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The field to be read.</source>
          <target state="translated">Campo que se va a leer.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Reads the value of a field.</source>
          <target state="translated">Lee el valor de un campo.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</source>
          <target state="translated">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>The latest value written to the field by any processor.</source>
          <target state="translated">Último valor que ha escrito en el campo un procesador.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> obtains the very latest value written to a memory location by any processor.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> Obtiene el último valor escrito en una ubicación de memoria cualquier procesador.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="T:System.Threading.Thread">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>The field to which the value is to be written.</source>
          <target state="translated">Campo en el que se escribirá el valor.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>The value to be written.</source>
          <target state="translated">Valor que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Writes a value to a field immediately, so that the value is visible to all processors in the computer.</source>
          <target state="translated">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> are for special cases of synchronization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> son para casos especiales de sincronización.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Under normal circumstances, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, and the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier alternatives.</source>
          <target state="translated">En circunstancias normales, C# <ph id="ph1">`lock`</ph> instrucción, Visual Basic <ph id="ph2">`SyncLock`</ph> (instrucción) y la <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> clase proporcionan alternativas más sencillas.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>On a multiprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensures that a value written to a memory location is immediately visible to all processors.</source>
          <target state="translated">En un sistema multiprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> garantiza que un valor escrito en una ubicación de memoria resulta inmediatamente visible para todos los procesadores.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>This might require flushing processor caches.</source>
          <target state="translated">Esto podría requerir vaciar las cachés de procesador.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Even on a uniprocessor system, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</source>
          <target state="translated">Incluso en un sistema monoprocesador, <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph> Asegúrese de que un valor se leen o escriben en la memoria y no almacena en caché (por ejemplo, en un registro del procesador).</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</source>
          <target state="translated">Por consiguiente, se puede usar para sincronizar el acceso a un campo que se pueden actualizar mediante otro subproceso o el hardware.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>Calling this method affects only a single memory access.</source>
          <target state="translated">Llamar a este método sólo afecta a una sola memoria access.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>To provide effective synchronization for a field, all access to the field must use <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <ph id="ph1">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)">
          <source>In C#, using the <ph id="ph1">`volatile`</ph> modifier on a field guarantees that all access to that field uses <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</source>
          <target state="translated">En C#, utilizando la <ph id="ph1">`volatile`</ph> modificador en un campo garantiza que todo el acceso a ese campo utilice <ph id="ph2">&lt;xref:System.Threading.Thread.VolatileRead%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Thread.VolatileWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source>Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</source>
          <target state="translated">Hace que el subproceso que realiza la llamada ceda la ejecución a otro subproceso que está listo para ejecutarse en el procesador actual.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source>The operating system selects the thread to yield to.</source>
          <target state="translated">El sistema operativo selecciona el subproceso al que se va a ceder la ejecución.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.Threading.Thread.Yield">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system switched execution to another thread; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el sistema operativo cambió la ejecución a otro subproceso; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>If this method succeeds, the rest of the thread's current time slice is yielded.</source>
          <target state="translated">Si este método se realiza correctamente, se produjo el resto del intervalo de tiempo actual del subproceso.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</source>
          <target state="translated">El sistema operativo programa el subproceso que realiza la llamada para otro intervalo de tiempo, según su prioridad y el estado de otros subprocesos que están disponibles para su ejecución.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>Yielding is limited to the processor that is executing the calling thread.</source>
          <target state="translated">Generando se limita al procesador que se está ejecutando el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</source>
          <target state="translated">El sistema operativo no se cambiará la ejecución a otro procesador, incluso si ese procesador está inactivo o está ejecutando un subproceso de prioridad más baja.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si no hay ningún otro subproceso que está listo para ejecutarse en el procesador actual, el sistema operativo no ceda la ejecución y este método devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>This method is equivalent to using platform invoke to call the native Win32 <ph id="ph1">`SwitchToThread`</ph> function.</source>
          <target state="translated">Este método es equivalente a usar invocación de plataforma para llamar a Win32 nativo <ph id="ph1">`SwitchToThread`</ph> función.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Thread.Yield">
          <source>You should call the <ph id="ph1">&lt;xref:System.Threading.Thread.Yield%2A&gt;</ph> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</source>
          <target state="translated">Debe llamar a la <ph id="ph1">&lt;xref:System.Threading.Thread.Yield%2A&gt;</ph> invocar el método en lugar de con la plataforma, porque la invocación de plataforma omite cualquier comportamiento del subprocesamiento personalizado el host ha solicitado.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>