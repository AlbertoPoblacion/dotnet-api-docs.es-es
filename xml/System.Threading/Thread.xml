<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5898bc0bb3f1bad19d1c42352de58d030ed20fae" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39867517" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Crea y controla un subproceso, establece su prioridad y obtiene su estado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se inicia un proceso, common language runtime crea automáticamente un subproceso único de primer plano para ejecutar código de la aplicación. Junto con este subproceso principal en primer plano, un proceso puede crear uno o varios subprocesos para ejecutar una parte del código de programa asociado al proceso. Estos subprocesos pueden ejecutar en primer plano o en segundo plano. Además, puede usar el <xref:System.Threading.ThreadPool> clase para ejecutar código en subprocesos de trabajo que están administrados por common language runtime.  
  
 En esta sección  
  
 [Iniciar un subproceso](#Starting)   
 [Recuperar objetos de subprocesos](#Retrieving)   
 [Subprocesos de primer y segundo plano](#Foreground)   
 [Referencia cultural y los subprocesos](#Culture)   
 [Obtener información sobre y el control de subprocesos](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Iniciar un subproceso  
 Iniciar un subproceso proporcionando un delegado que representa el método que es el subproceso ejecutar en su constructor de clase. A continuación, llame a la <xref:System.Threading.Thread.Start%2A> método para comenzar la ejecución.  
  
 El <xref:System.Threading.Thread> los constructores pueden aceptar cualquiera de los tipos de delegado de dos, dependiendo de si se puede pasar un argumento al método para ejecutarse:  
  
-   Si el método no tiene ningún argumento, se pasa un <xref:System.Threading.ThreadStart> delegar en el constructor. Tiene la firma:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     El ejemplo siguiente se crea e inicia un subproceso que ejecuta el `ExecuteInForeground` método. El método muestra información acerca de algunas propiedades de subproceso y, a continuación, ejecuta un bucle en el que se pone en pausa durante medio segundo y se muestra el número de segundos transcurrido. Cuando el subproceso se ha ejecutado durante al menos cinco segundos, finaliza el bucle y el subproceso termina la ejecución.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Si el método tiene un argumento, se pasa un <xref:System.Threading.ParameterizedThreadStart> delegar en el constructor. Tiene la firma:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     El método ejecutado por el delegado puede, a continuación, convierta (en C#) o (en Visual Basic) el parámetro al tipo adecuado.  
  
     El ejemplo siguiente es idéntico al anterior, salvo que llama a la <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor. Esta versión de la `ExecuteInForeground` método tiene un parámetro único que representa el número aproximado de milisegundos que es ejecutar el bucle.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 No es necesario conservar una referencia a un <xref:System.Threading.Thread> objeto una vez que ha iniciado el subproceso. El subproceso continúa ejecutándose hasta que se complete el procedimiento de subproceso.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Recuperar objetos de subprocesos  
 Puede usar estático (`Shared` en Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> propiedad para recuperar una referencia al subproceso actualmente en ejecución desde el código que se está ejecutando el subproceso. En el ejemplo siguiente se usa el <xref:System.Threading.Thread.CurrentThread%2A> propiedad para mostrar información sobre el subproceso principal de la aplicación, otro subproceso en primer plano, un subproceso en segundo plano y un subproceso del grupo de subprocesos.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Subprocesos de primer y segundo plano  
 Las instancias de la <xref:System.Threading.Thread> clase representan los subprocesos de primer plano o subprocesos en segundo plano. Subprocesos en segundo plano son idénticos a los subprocesos de primer plano con una excepción: un subproceso en segundo plano no mantiene un proceso que se ejecuta si se han finalizado todos los subprocesos de primer plano. Una vez que se han detenido todos los subprocesos de primer plano, el tiempo de ejecución detiene todos los subprocesos en segundo plano y se cierra.  
  
 De forma predeterminada, los subprocesos siguientes se ejecutan en primer plano:  
  
-   El subproceso principal de la aplicación.  
  
-   Todos los subprocesos creados mediante una llamada a un <xref:System.Threading.Thread> constructor de clase.  
  
 Ejecuten los siguientes subprocesos en segundo plano de forma predeterminada:  
  
-   El subproceso del grupo de subprocesos, que son un grupo de subprocesos de trabajo mantenidas el tiempo de ejecución.  Puede configurar el trabajo del subproceso de grupo y la programación de subprocesos de grupo mediante la <xref:System.Threading.ThreadPool> clase.  
  
    > [!NOTE]
    >  Operaciones asincrónicas basadas en la tarea se ejecutan automáticamente en subprocesos de grupo. Usan operaciones asincrónicas basadas en tareas el <xref:System.Threading.Tasks.Task> y <xref:System.Threading.Tasks.Task%601> clases para implementar el [modelo asincrónico basado en tareas](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Todos los subprocesos que entran en el entorno de ejecución administrado desde código no administrado.  
  
 Puede cambiar un subproceso que ejecute en segundo plano estableciendo el <xref:System.Threading.Thread.IsBackground%2A> propiedad en cualquier momento.  Subprocesos en segundo plano son útiles para cualquier operación que debe continuar mientras se está ejecutando una aplicación, pero no debe impedir que la aplicación finalice, como la supervisión de los cambios del sistema de archivos o las conexiones de socket entrante.  
  
 El ejemplo siguiente muestra la diferencia entre los subprocesos de primer y segundo plano. Es como el primer ejemplo de la [a partir de un subproceso](#Starting) sección, salvo que establecen el subproceso para ejecutar en segundo plano antes de iniciarlo. Como se muestra en la salida, el bucle se interrumpe antes de ejecutar durante cinco segundos.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Referencia cultural y los subprocesos  
 Cada subproceso tiene una referencia cultural, representada por el <xref:System.Threading.Thread.CurrentCulture%2A> propiedad y una referencia cultural de interfaz de usuario, representan por el <xref:System.Threading.Thread.CurrentUICulture%2A> propiedad.  La referencia cultural actual admite operaciones cultural como de análisis y formato, comparación de cadenas y ordenación y también controla el sistema de escritura y el calendario usado por un subproceso. Proporciona la referencia cultural de interfaz de usuario actual para la recuperación de la referencia cultural de recursos en archivos de recursos.  
  
 Cuando se crea una instancia de un nuevo subproceso, su referencia cultural y la referencia cultural de interfaz de usuario se definen por la referencia cultural actual del sistema y la referencia cultural de interfaz de usuario y no por la referencia cultural y la referencia cultural de interfaz de usuario del subproceso desde el que se crea el nuevo subproceso. Esto significa, por ejemplo, que si la referencia cultural del sistema actual es inglés (Estados Unidos) y la referencia cultural del subproceso principal de la aplicación es francés (Francia), la referencia cultural de un nuevo subproceso creado mediante una llamada a la <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor desde el subproceso principal es el inglés (Estados Unidos) y no francés (Francia). Para obtener más información, consulte la sección "Referencia cultural y los subprocesos" de la <xref:System.Globalization.CultureInfo> tema de la clase.  
  
> [!IMPORTANT]
>  No es el caso de los subprocesos que se ejecutan las operaciones asincrónicas para las aplicaciones que tienen como destino el [!INCLUDE[net_v46](~/includes/net-v46-md.md)] y versiones posteriores, en este caso, la referencia cultural y la referencia cultural de interfaz de usuario es parte de una forma asincrónica el contexto de las operaciones; el subproceso en el que una operación asincrónica ejecuta de forma predeterminada hereda la referencia cultural y la referencia cultural de interfaz de usuario del subproceso desde el que se inició la operación asincrónica. Para obtener más información, vea la sección "Referencia cultural y operaciones asincrónicas basadas en tareas" del tema sobre la clase <xref:System.Globalization.CultureInfo>.  
  
 Puede realizar una de las siguientes acciones para asegurarse de que todos los subprocesos de ejecución en una aplicación comparten la misma referencia cultural y la referencia cultural de interfaz de usuario:  
  
-   Puede pasar un <xref:System.Globalization.CultureInfo> objeto que representa esa referencia cultural a la <xref:System.Threading.ParameterizedThreadStart> delegar o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> método.  
  
-   Para las aplicaciones que se ejecutan en el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] y versiones posteriores, puede definir la referencia cultural y la referencia cultural de interfaz de usuario que se asigna a todos los subprocesos creados en un dominio de aplicación estableciendo el valor de la <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> y <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> propiedades. Tenga en cuenta que se trata de una configuración por dominio de aplicación.  
  
 Para obtener más información y ejemplos, vea la sección "Referencia cultural y los subprocesos" de la <xref:System.Globalization.CultureInfo> tema de la clase.  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Obtener información sobre y el control de subprocesos  
 Puede recuperar un número de valores de propiedad que proporcionan información sobre un subproceso. En algunos casos, también puede establecer estos valores de propiedad para controlar el funcionamiento del subproceso. Estas propiedades de subproceso incluyen:  
  
-   Un nombre. <xref:System.Threading.Thread.Name%2A> es una operación de escritura-propiedad una vez que puede usar para identificar un subproceso.  Su valor predeterminado es `null`.  
  
-   Un código hash, que puede recuperar mediante una llamada a la <xref:System.Threading.Thread.GetHashCode%2A> método. El código hash puede utilizarse para identificar de forma única un subproceso; durante la vigencia de su subproceso, su código hash no entra en conflicto con el valor de ningún otro subproceso, independientemente del dominio de aplicación desde el que se obtener el valor.  
  
-   Un identificador de subproceso. El valor de solo lectura <xref:System.Threading.Thread.ManagedThreadId%2A> propiedad asignado por el tiempo de ejecución y se identifica un subproceso dentro de su proceso.  
  
    > [!NOTE]
    >  Un [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) de sistema operativo no tiene una relación fija con un subproceso administrado, ya que un host no administrado puede controlar la relación entre subprocesos administrados y no administrados. En concreto, un host sofisticado puede usar el [API de hospedaje de CLR](https://msdn.microsoft.com/library/ms404385.aspx) para programar muchos subprocesos administrados en el mismo subproceso de sistema operativo, o para mover un subproceso administrado entre los subprocesos del sistema operativo diferente.  
  
-   El estado del subproceso actual. Durante la duración de su existencia, un subproceso está siempre en uno o varios de los estados definidos por el <xref:System.Threading.ThreadState> propiedad.  
  
-   Un nivel de prioridad de programación, que se define mediante el <xref:System.Threading.ThreadPriority> propiedad. Aunque puede establecer este valor para solicitar la prioridad de un subproceso, no se garantiza que se respeta el sistema operativo.  
  
-   Solo lectura <xref:System.Threading.Thread.IsThreadPoolThread%2A> propiedad, que indica si un subproceso es un subproceso del grupo de subprocesos.  
  
-   Propiedad <xref:System.Threading.Thread.IsBackground%2A> Para obtener más información, consulte el [subprocesos de primer plano y fondo](#Foreground) sección.  
  
## Examples  
 El ejemplo siguiente muestra la funcionalidad de subprocesamiento simple.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Este código genera una salida similar al siguiente:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Delegado que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" />, especificando un delegado que permite pasar un objeto al subproceso cuando este último se inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un subproceso no comienza a ejecutarse cuando se crea. Para programar el subproceso de ejecución, llame a la <xref:System.Threading.Thread.Start%2A> método. Para pasar un objeto de datos para el subproceso, use el <xref:System.Threading.Thread.Start%28System.Object%29> sobrecarga del método.  
  
> [!NOTE]
>  Los usuarios de Visual Basic pueden omitir el <xref:System.Threading.ThreadStart> constructor al crear un subproceso. Use la `AddressOf` operador al pasar el método, por ejemplo `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic llama automáticamente el <xref:System.Threading.ThreadStart> constructor.  
  
   
  
## Examples  
 El ejemplo siguiente muestra la sintaxis para crear y usar un <xref:System.Threading.ParameterizedThreadStart> delegado con un método estático y un método de instancia.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Delegado <see cref="T:System.Threading.ThreadStart" /> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un subproceso no comienza a ejecutarse cuando se crea. Para programar el subproceso de ejecución, llame a la <xref:System.Threading.Thread.Start%2A> método.  
  
> [!NOTE]
>  Los usuarios de Visual Basic pueden omitir el <xref:System.Threading.ThreadStart> constructor al crear un subproceso. Use la `AddressOf` al pasar por ejemplo el método de operador `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic llama automáticamente el <xref:System.Threading.ThreadStart> constructor.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear un subproceso que ejecuta un método estático.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 El ejemplo de código siguiente muestra cómo crear un subproceso que ejecuta un método de instancia.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="start" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Delegado <see cref="T:System.Threading.ParameterizedThreadStart" /> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</param>
        <param name="maxStackSize">Tamaño de pila máximo, en bytes, que va a usar el subproceso, o 0 para usar el tamaño de pila máximo predeterminado especificado en el encabezado del ejecutable.  
  
Importante   En el caso de código de confianza parcial, se pasa por alto <c>maxStackSize</c> si es mayor que el tamaño de pila predeterminado. No se inicia ninguna excepción.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" /> y, para ello, especifica un delegado que permite pasar un objeto al subproceso cuando este último se inicia; además, especifica el tamaño de pila máximo para el subproceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Evite utilizar esta sobrecarga del constructor. El tamaño de pila predeterminado utilizado por el <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> sobrecarga del constructor es el tamaño de pila recomendado para los subprocesos. Si un subproceso tiene problemas de memoria, la causa más probable es un error de programación, como una recursividad infinita.  
  
> [!IMPORTANT]
>  A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], sólo de plena confianza puede establecer código `maxStackSize` en un valor que es mayor que el tamaño de pila predeterminado (1 megabyte). Si se especifica un valor mayor para `maxStackSize` cuando se ejecuta el código con confianza parcial, `maxStackSize` se omite y se utiliza el tamaño de pila predeterminado. No se inicia ninguna excepción. Puede establecer el código en cualquier nivel de confianza `maxStackSize` en un valor que es menor que el tamaño de pila predeterminado.  
  
> [!NOTE]
>  Si está desarrollando una biblioteca de plena confianza que se usará en el código de confianza parcial, y necesita iniciar un subproceso que requiere una pila de gran tamaño, debe imponer plena confianza antes de crear el subproceso o se utilizará el tamaño de pila predeterminado. De no hacerlo a menos que se controla por completo el código que se ejecuta en el subproceso.  
  
 Si `maxStackSize` es menor que el tamaño de pila mínimo, se utiliza el tamaño mínimo de la pila. Si `maxStackSize` no es un múltiplo del tamaño de página, se redondea al múltiplo más grande del tamaño de página siguiente. Por ejemplo, si utiliza la versión 2.0 de .NET Framework en Windows Vista, 256KB (262 144 bytes) es el tamaño de pila mínimo y el tamaño de página es de 64KB (65.536 bytes).  
  
> [!NOTE]
>  En las versiones de Microsoft Windows anteriores a Windows XP y Windows Server 2003, `maxStackSize` se omite, y se utiliza el tamaño de pila especificado en el encabezado del ejecutable.  
  
 Si especifica un tamaño de pila muy pequeño, es posible que deba deshabilitar el sondeo de desbordamiento de pila. Cuando la pila está muy limitada, el propio sondeo puede provocar un desbordamiento de pila. Para deshabilitar el sondeo de desbordamiento de pila, agregue lo siguiente al archivo de configuración de la aplicación.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Delegado <see cref="T:System.Threading.ThreadStart" /> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</param>
        <param name="maxStackSize">Tamaño de pila máximo, en bytes, que va a usar el subproceso, o 0 para usar el tamaño de pila máximo predeterminado especificado en el encabezado del ejecutable.  
  
Importante   En el caso de código de confianza parcial, se pasa por alto <c>maxStackSize</c> si es mayor que el tamaño de pila predeterminado. No se inicia ninguna excepción.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" />, especificando el tamaño de pila máximo para el subproceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Evite utilizar esta sobrecarga del constructor. El tamaño de pila predeterminado utilizado por el <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> sobrecarga del constructor es el tamaño de pila recomendado para los subprocesos. Si un subproceso tiene problemas de memoria, la causa más probable es un error de programación, como una recursividad infinita.  
  
> [!IMPORTANT]
>  A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], sólo de plena confianza puede establecer código `maxStackSize` en un valor que es mayor que el tamaño de pila predeterminado (1 megabyte). Si se especifica un valor mayor para `maxStackSize` cuando se ejecuta el código con confianza parcial, `maxStackSize` se omite y se utiliza el tamaño de pila predeterminado. No se inicia ninguna excepción. Puede establecer el código en cualquier nivel de confianza `maxStackSize` en un valor que es menor que el tamaño de pila predeterminado.  
  
> [!NOTE]
>  Si está desarrollando una biblioteca de plena confianza que se usará en el código de confianza parcial, y necesita iniciar un subproceso que requiere una pila de gran tamaño, debe imponer plena confianza antes de crear el subproceso o se utilizará el tamaño de pila predeterminado. De no hacerlo a menos que se controla por completo el código que se ejecuta en el subproceso.  
  
 Si `maxStackSize` es menor que el tamaño de pila mínimo, se utiliza el tamaño mínimo de la pila. Si `maxStackSize` no es un múltiplo del tamaño de página, se redondea al múltiplo más grande del tamaño de página siguiente. Por ejemplo, si utiliza la versión 2.0 de .NET Framework en Windows Vista, 256KB (262 144 bytes) es el tamaño de pila mínimo y el tamaño de página es de 64KB (65.536 bytes).  
  
> [!NOTE]
>  En las versiones de Microsoft Windows anteriores a Windows XP y Windows Server 2003, `maxStackSize` se omite, y se utiliza el tamaño de pila especificado en el encabezado del ejecutable.  
  
 Si especifica un tamaño de pila muy pequeño, es posible que deba deshabilitar el sondeo de desbordamiento de pila. Cuando la pila está muy limitada, el propio sondeo puede provocar un desbordamiento de pila. Para deshabilitar el sondeo de desbordamiento de pila, agregue lo siguiente al archivo de configuración de la aplicación.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Produce una excepción <see cref="T:System.Threading.ThreadAbortException" /> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso. Normalmente, una llamada a este método finaliza el subproceso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Produce una excepción <see cref="T:System.Threading.ThreadAbortException" /> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso. Normalmente, una llamada a este método finaliza el subproceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se invoca en un subproceso, el sistema produce una <xref:System.Threading.ThreadAbortException> en el subproceso para anularla. `ThreadAbortException` es una excepción especial que se puede detectar el código de aplicación, pero se vuelve a producir al final de la `catch` bloquear a menos que <xref:System.Threading.Thread.ResetAbort%2A> se llama. `ResetAbort` cancela la solicitud de anulación y evita la `ThreadAbortException` de finalización del subproceso. Sin ejecutar `finally` bloques se ejecutan antes de que se anula el subproceso.  
  
> [!NOTE]
>  Cuando un subproceso llama `Abort` en sí mismo, el efecto es similar a producir una excepción; la <xref:System.Threading.ThreadAbortException> sucede inmediatamente, y el resultado es predecible. Sin embargo, si un subproceso llama a `Abort` en otro subproceso, se interrumpe el código que se está ejecutando. También es probable que se pudo anular un constructor estático. En raras ocasiones, esto podría impedir que las instancias de esa clase que se crean en ese dominio de aplicación. En las versiones 1.0 y 1.1 de .NET Framework, es probable que se ha podido anular el subproceso mientras un `finally` bloque se está ejecutando, en cuyo caso el `finally` bloque se ha anulado.  
  
 El subproceso no se garantiza para anular la operación inmediatamente, o en absoluto. Esta situación puede producirse si un subproceso realiza una cantidad ilimitada de operaciones en el `finally` bloques que se llaman como parte del procedimiento de anulación, indefinidamente, por tanto, la anulación. Para esperar hasta que se anula un subproceso, puede llamar a la <xref:System.Threading.Thread.Join%2A> método en el subproceso después de llamar a la <xref:System.Threading.Thread.Abort%2A> método, pero no hay ninguna garantía de la espera finalizará.  
  
> [!NOTE]
>  El subproceso que llama <xref:System.Threading.Thread.Abort%2A> podrían bloquear si el subproceso que se va a anular está en una región protegida de código, como un `catch` bloque, `finally` bloque o región de ejecución restringida. Si el subproceso que llama <xref:System.Threading.Thread.Abort%2A> mantiene un bloqueo que el subproceso anulado requiere, puede producirse un interbloqueo.  
  
 Si `Abort` se llama en un subproceso que no se ha iniciado, el subproceso anulará cuando <xref:System.Threading.Thread.Start%2A> se llama. Si `Abort` se llama en un subproceso que está bloqueado o inactivo, el subproceso se interrumpe y, a continuación, se anula.  
  
 Si `Abort` se llama en un subproceso que se ha suspendido, un <xref:System.Threading.ThreadStateException> se produce en el subproceso que llamó a <xref:System.Threading.Thread.Abort%2A>, y <xref:System.Threading.ThreadState.AbortRequested> se agrega a la <xref:System.Threading.Thread.ThreadState%2A> propiedad del subproceso que se va a anular. Un <xref:System.Threading.ThreadAbortException> no se produce en el subproceso suspendido hasta que <xref:System.Threading.Thread.Resume%2A> se llama.  
  
 Si `Abort` se llama en un subproceso administrado mientras se ejecuta el código no administrado, un `ThreadAbortException` no se produce hasta que el subproceso vuelve al código administrado.  
  
 Si dos llamadas a `Abort` proceder al mismo tiempo, es posible que una llamada establecer la información de estado y la otra llamada para ejecutar el `Abort`. Sin embargo, una aplicación no puede detectar esta situación.  
  
 Después de `Abort` se invoca en un subproceso, el estado del subproceso incluye <xref:System.Threading.ThreadState.AbortRequested>. Después de que el subproceso ha terminado debido a una llamada correcta a `Abort`, se cambia el estado del subproceso a <xref:System.Threading.ThreadState.Stopped>. Con los permisos suficientes, un subproceso que es el destino de una `Abort` puede cancelar la anulación utilizando el `ResetAbort` método. Para obtener un ejemplo que muestra cómo llamar a la `ResetAbort` método, consulte el `ThreadAbortException` clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: este miembro no se admite.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Actualmente se suspende el subproceso que se está anulando.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para las operaciones avanzadas en subprocesos. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Objeto que contiene información específica de la aplicación como, por ejemplo, su estado, y que el subproceso anulado puede utilizar.</param>
        <summary>Produce una excepción <see cref="T:System.Threading.ThreadAbortException" /> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso, proporcionando al mismo tiempo información sobre excepciones relativa a la terminación del subproceso. Normalmente, una llamada a este método finaliza el subproceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se invoca en un subproceso, el sistema produce una <xref:System.Threading.ThreadAbortException> en el subproceso para anularla. `ThreadAbortException` es una excepción especial que se puede detectar el código de aplicación, pero se vuelve a producir al final de la `catch` bloquear a menos que <xref:System.Threading.Thread.ResetAbort%2A> se llama. `ResetAbort` cancela la solicitud de anulación y evita la `ThreadAbortException` de finalización del subproceso. Sin ejecutar `finally` bloques se ejecutan antes de que se anula el subproceso.  
  
> [!NOTE]
>  Cuando un subproceso llama `Abort` en sí mismo, el efecto es similar a producir una excepción; la <xref:System.Threading.ThreadAbortException> sucede inmediatamente, y el resultado es predecible. Sin embargo, si un subproceso llama a `Abort` en otro subproceso, se interrumpe el código que se está ejecutando. Es probable que se pudo anular un constructor estático. En raras ocasiones, esto podría impedir que las instancias de esa clase que se crean en ese dominio de aplicación. En las versiones 1.0 y 1.1 de .NET Framework, es probable que se ha podido anular el subproceso mientras un `finally` bloque se está ejecutando, en cuyo caso el `finally` bloque se ha anulado.  
  
 El subproceso no se garantiza para anular la operación inmediatamente, o en absoluto. Esta situación puede producirse si un subproceso realiza una cantidad ilimitada de operaciones en el `finally` bloques que se llaman como parte del procedimiento de anulación, indefinidamente, por tanto, la anulación. Para esperar hasta que se anula un subproceso, puede llamar a la <xref:System.Threading.Thread.Join%2A> método en el subproceso después de llamar a la <xref:System.Threading.Thread.Abort%2A> método, pero no hay ninguna garantía de que la espera finalizará.  
  
> [!NOTE]
>  El subproceso que llama <xref:System.Threading.Thread.Abort%2A> podrían bloquear si el subproceso que se va a anular está en una región protegida de código, como un `catch` bloque, `finally` bloque o región de ejecución restringida. Si el subproceso que llama <xref:System.Threading.Thread.Abort%2A> mantiene un bloqueo que el subproceso anulado requiere, puede producirse un interbloqueo.  
  
 Si `Abort` se llama en un subproceso que no se ha iniciado, el subproceso anulará cuando <xref:System.Threading.Thread.Start%2A> se llama. Si `Abort` se llama en un subproceso que está bloqueado o inactivo, el subproceso se interrumpe y, a continuación, se anula.  
  
 Si `Abort` se llama en un subproceso que se ha suspendido, un <xref:System.Threading.ThreadStateException> se produce en el subproceso que llamó a <xref:System.Threading.Thread.Abort%2A>, y <xref:System.Threading.ThreadState.AbortRequested> se agrega a la <xref:System.Threading.Thread.ThreadState%2A> propiedad del subproceso que se va a anular. Un <xref:System.Threading.ThreadAbortException> no se produce en el subproceso suspendido hasta que <xref:System.Threading.Thread.Resume%2A> se llama.  
  
 Si `Abort` se llama en un subproceso administrado mientras se ejecuta el código no administrado, un `ThreadAbortException` no se produce hasta que el subproceso vuelve al código administrado.  
  
 Si dos llamadas a `Abort` proceder al mismo tiempo, es posible que una llamada establecer la información de estado y la otra llamada para ejecutar el `Abort`. Sin embargo, una aplicación no puede detectar esta situación.  
  
 Después de `Abort` se invoca en un subproceso, el estado del subproceso incluye <xref:System.Threading.ThreadState.AbortRequested>. Después de que el subproceso ha terminado debido a una llamada correcta a `Abort`, se cambia el estado del subproceso a <xref:System.Threading.ThreadState.Stopped>. Con los permisos suficientes, un subproceso que es el destino de una `Abort` puede cancelar la anulación utilizando el `ResetAbort` método. Para obtener un ejemplo que muestra cómo llamar a la `ResetAbort` método, consulte el `ThreadAbortException` clase.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo pasar información a un subproceso que se va a anular.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: este miembro no se admite.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Actualmente se suspende el subproceso que se está anulando.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para las operaciones avanzadas en subprocesos. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asigna una ranura de datos sin nombre en todos los subprocesos. Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Ranura de datos con nombre asignada en todos los subprocesos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos. Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación. Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Se asigna a la ranura en todos los subprocesos.  
  
 Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso. Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea. El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso. Las ranuras de datos son únicas para cada subproceso. Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos. El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.  
  
 **Primer ejemplo**  
  
 En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos. Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo ejemplo**  
  
 El ejemplo de código siguiente muestra cómo usar una ranura de datos para almacenar información específica del subproceso.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la ranura de datos que se va a asignar.</param>
        <summary>Asigna una ranura de datos con nombre en todos los subprocesos. Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Ranura de datos con nombre asignada en todos los subprocesos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos. Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación. Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso. Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea. El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso. Las ranuras de datos son únicas para cada subproceso. Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.  
  
 No es necesario utilizar el <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método para asignar una ranura de datos con nombre, porque el <xref:System.Threading.Thread.GetNamedDataSlot%2A> método asigna la ranura si ya no se ha asignado.  
  
> [!NOTE]
>  Si el <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> se usa el método, debe llamarse en el subproceso principal al inicio del programa, ya que produce una excepción si ya se ha asignado una ranura con el nombre especificado. No hay ninguna manera para comprobar si ya se ha asignado una ranura.  
  
 Las ranuras asignadas con este método se deben liberar con <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos. El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.  
  
 **Primer ejemplo**  
  
 En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos. Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo ejemplo**  
  
 El ejemplo siguiente muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.  
  
> [!NOTE]
>  El código de ejemplo no utiliza la <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método, porque el <xref:System.Threading.Thread.GetNamedDataSlot%2A> método asigna la ranura si ya no se ha asignado. Si el <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> se usa el método, se debe llamar en el subproceso principal al inicio del programa.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ya existe una ranura para datos con el nombre especificado</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el estado de apartamento de este subproceso.</summary>
        <value>Uno de los valores de <see cref="T:System.Threading.ApartmentState" />. El valor inicial es <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **El <xref:System.Threading.Thread.ApartmentState%2A> propiedad está obsoleta.**  Las alternativas no obsoleto son el <xref:System.Threading.Thread.GetApartmentState%2A> método para recuperar el estado del apartamento y <xref:System.Threading.Thread.SetApartmentState%2A> método para establecer el estado del apartamento.  
  
 En las versiones de .NET Framework 1.0 y 1.1, el `ApartmentState` propiedad marca un subproceso para indicar que se ejecutará en un apartamento multiproceso o uniproceso. Esta propiedad puede establecerse cuando el subproceso está en el `Unstarted` o `Running` subprocesos estado; sin embargo, puede establecerse solo una vez por subproceso. Si no se estableció la propiedad, devuelve `Unknown`.  
  
 Intentar utilizar el <xref:System.Threading.Thread.ApartmentState%2A> se omite la propiedad para establecer el estado de apartamento de un subproceso cuyo estado de apartamento ya se ha establecido. Sin embargo, el <xref:System.Threading.Thread.SetApartmentState%2A> método produce una <xref:System.InvalidOperationException> en este caso.  
  
> [!IMPORTANT]
>  En la versión 2.0 de .NET Framework, los subprocesos nuevos se inicializan como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si no se ha establecido su estado de apartamento antes de que se inicien. El subproceso principal de la aplicación se inicializa en <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> de forma predeterminada. Ya no se puede establecer el subproceso principal de la aplicación en <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> estableciendo el <xref:System.Threading.ApartmentState?displayProperty=nameWithType> propiedad en la primera línea de código. Use el <xref:System.STAThreadAttribute> en su lugar.  
  
 En la versión 2.0 de .NET Framework, puede especificar el COM de subprocesamiento de modelo para una aplicación de C++ mediante el [/CLRTHREADATTRIBUTE (Establecer atributo de subproceso de CLR)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) opción del vinculador.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo establecer el estado de apartamento de un subproceso.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se realiza un intento de establecer esta propiedad en un estado que no es un estado de contenedor válido (un estado distinto de contenedor uniproceso (<see langword="STA" />) o contenedor multiproceso (<see langword="MTA" />)).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un host que la ejecución está a punto de entrar en una región del código donde los efectos de una anulación del subproceso o de una excepción no controlada podrían constituir un riesgo para otras tareas del dominio de aplicaciones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts de common language runtime (CLR), como Microsoft SQL Server 2005, pueden establecer directivas diferentes para los errores en regiones críticas y no críticas del código. Una región crítica es aquella en la que los efectos de una anulación de subproceso o una excepción no controlada pueden no limitarse a la tarea actual. Por el contrario, una anulación o un error en una región no crítica del código afecta a solo la tarea que se produce el error.  
  
 Por ejemplo, considere la posibilidad de una tarea que intenta asignar memoria mientras se mantiene un bloqueo. Si se produce un error en la asignación de memoria, la anulación de la tarea actual no es suficiente para garantizar la estabilidad de la <xref:System.AppDomain>, porque puede haber otras tareas en el dominio esperando el mismo bloqueo. Si se termina la tarea actual, otras tareas podrían sufrir un interbloqueo.  
  
 Cuando se produce un error en una región crítica, el host puede optar por descargar toda la <xref:System.AppDomain> en lugar de correr el riesgo de continuar la ejecución en un estado potencialmente inestable. Para informar al host que el código está entrando en una región crítica, llame a <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Llamar a <xref:System.Threading.Thread.EndCriticalRegion%2A> cuando se devuelve a una región no crítica del código de ejecución.  
  
 Con este método en el código que se ejecuta en SQL Server 2005 requiere que el código que se ejecutará en el nivel más alto de protección de host.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Threading.Thread.BeginCriticalRegion%2A> y <xref:System.Threading.Thread.EndCriticalRegion%2A> métodos para dividir un bloque de código en regiones críticas y no críticas.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un host que el código administrado está a punto de ejecutar instrucciones que dependen de la identidad del subproceso del sistema operativo físico actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos hosts de common language runtime, como Microsoft SQL Server 2005, proporcionan su propia administración de subprocesos. Un host que proporciona su propia administración de subprocesos puede mover una tarea en ejecución de un subproceso de sistema operativo físico a otro en cualquier momento. Mayoría de las tareas no se ven afectada por este cambio. Sin embargo, algunas tareas tienen afinidad de subprocesos, es decir, que dependen de la identidad de un subproceso físico del sistema operativo. Estas tareas deben informar al host cuando ejecuta código que no se debe cambiar.  
  
 Por ejemplo, si la aplicación llama una API del sistema para adquirir un sistema operativo de bloqueo que tiene afinidad de subprocesos, como CRITICAL_SECTION de Win32, se debe llamar a <xref:System.Threading.Thread.BeginThreadAffinity%2A> antes de adquirir el bloqueo, y <xref:System.Threading.Thread.EndThreadAffinity%2A> después de liberar el bloqueo.  
  
 Con este método en el código que se ejecuta en SQL Server 2005 requiere que el código que se ejecutará en el nivel más alto de protección de host.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Threading.Thread.BeginThreadAffinity%2A> y <xref:System.Threading.Thread.EndThreadAffinity%2A> métodos para notificar a un host que un bloque de código depende de la identidad de un subproceso físico del sistema operativo.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el contexto actual donde se está ejecutando el subproceso.</summary>
        <value>
          <see cref="T:System.Runtime.Remoting.Contexts.Context" /> que representa el contexto del subproceso actual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la referencia cultural del subproceso actual.</summary>
        <value>Objeto que representa la referencia cultural del subproceso actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Globalization.CultureInfo> objeto devuelto por esta propiedad, junto con sus objetos asociados, determinar el formato predeterminado para las fechas, horas, números, valores de moneda, el criterio de ordenación de texto, las mayúsculas y minúsculas de las convenciones y comparaciones de cadenas. Consulte la <xref:System.Globalization.CultureInfo> clase para obtener información sobre los nombres de referencia cultural y los identificadores, las diferencias entre culturas invariables, neutras y específicas, y la información de referencia cultural de manera que afecta a dominios de aplicación y subprocesos. Consulte la <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propiedad para obtener información sobre cómo se determina la referencia cultural predeterminada de un subproceso y cómo los usuarios establecer información de referencia cultural para sus equipos.  
  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], puede establecer el <xref:System.Threading.Thread.CurrentCulture%2A> propiedad a una referencia cultural neutra. Esto es porque el comportamiento de la <xref:System.Globalization.CultureInfo> clase ha cambiado: cuando representa una referencia cultural neutra, sus valores de propiedad (en concreto, el <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, y <xref:System.Globalization.CultureInfo.TextInfo%2A> propiedades) ahora refleja la referencia cultural específica que está asociada con la referencia cultural neutra. En versiones anteriores de .NET Framework, el <xref:System.Threading.Thread.CurrentCulture%2A> propiedad produjo una <xref:System.NotSupportedException> excepción cuando se le asignó una referencia cultural neutra.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra la instrucción de subprocesamiento que permite a la interfaz de usuario de un Windows Forms para mostrar en la referencia cultural que se establece en el Panel de Control. Se necesita código adicional.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad se establece en <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para establecer la propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la entidad de seguridad actual del subproceso (de la seguridad basada en roles).</summary>
        <value>Valor de <see cref="T:System.Security.Principal.IPrincipal" /> que representa el contexto de seguridad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y recuperar la entidad de seguridad de un subproceso.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El autor de llamada no tiene el permiso necesario para establecer la entidad de seguridad.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para manipular el objeto principal. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el subproceso actualmente en ejecución.</summary>
        <value>
          <see cref="T:System.Threading.Thread" /> que representa el subproceso actualmente en ejecución.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea una tarea que a su vez crea 20 tareas secundarias. La aplicación, como también cada tarea, llama a la `ShowThreadInformation` método, que usa el <xref:System.Threading.Thread.CurrentThread%2A> propiedad para mostrar información sobre el subproceso en el que se está ejecutando.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Cada tarea secundaria genera números aleatorios de 1 millón de entre 1 y 1 millón y devuelve su Media. Las llamadas de la tarea primaria la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método para asegurarse de que se han completado las tareas secundarias antes de mostrar la media devuelta por cada tarea y calcular la media de medios.  
  
 Tenga en cuenta que mientras la aplicación se ejecuta en un subproceso en primer plano, cada tarea se ejecuta en un subproceso ThreadPool.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la referencia cultural actual utilizada por el administrador de recursos para buscar recursos específicos de la referencia cultural en tiempo de ejecución.</summary>
        <value>Objeto que representa la referencia cultural actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La referencia cultural de interfaz de usuario especifica los recursos de una aplicación debe admitir la entrada de usuario y la salida y de forma predeterminada es igual que la referencia cultural del sistema operativo. Consulte la <xref:System.Globalization.CultureInfo> clase para obtener información sobre los nombres de referencia cultural y los identificadores, las diferencias entre culturas invariables, neutras y específicas, y la información de referencia cultural de manera que afecta a dominios de aplicación y subprocesos. Consulte la <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propiedad para obtener información sobre cómo se determina la referencia cultural de interfaz de usuario de predeterminada de un subproceso.  
  
 El <xref:System.Globalization.CultureInfo> devuelto por esta propiedad puede ser una referencia cultural neutra. No deben usarse con métodos de formato, como las referencias culturales neutras <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, y <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Utilice la <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> método para obtener una referencia cultural específica, o use el <xref:System.Threading.Thread.CurrentCulture%2A> propiedad.  
  
> [!NOTE]
>  El <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> método inicie una excepción <xref:System.ArgumentException> para las referencias culturales neutras "zh-Hant" ("zh-CHT") y "zh-Hans" ("zh-CHS").  
  
   
  
## Examples  
 El ejemplo siguiente determina si el idioma de la referencia cultural de interfaz de usuario del subproceso actual es francés. Si no es así, Establece la referencia cultural de interfaz de usuario del subproceso actual para inglés (Estados Unidos).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 El ejemplo de código siguiente muestra la instrucción de subprocesamiento que permite a la interfaz de usuario de un Windows Forms para mostrar en la referencia cultural que se establece en el Panel de Control. Se necesita código adicional.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad se establece en <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad se establece en un nombre de referencia cultural que no se puede usar para buscar un archivo de recursos. Los nombres de archivo de recursos deben incluir solo letras, números, guiones o caracteres de subrayado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desactiva la limpieza automática de contenedores RCW (Runtime Callable Wrappers) para el subproceso actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, common language runtime (CLR) limpia los contenedores RCW de automáticamente. El CLR bombea los mensajes durante la limpieza, lo que podría producir problemas de reentrada de algunas aplicaciones que cumplen los criterios siguientes inusuales:  
  
-   La aplicación realiza su propia distribución de mensajes.  
  
-   La aplicación debe controlar con precisión cuando se produce la distribución de mensajes.  
  
 Pueden usar estas aplicaciones las <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> método para evitar que el CLR de realizar una recuperación automática del tiempo de ejecución de contenedores RCW.  
  
 Cuando este método se ha llamado en un subproceso, la limpieza automática no se puede volver a habilitar para ese subproceso. Cuando la aplicación está lista para limpiar los contenedores RCW, utilice el <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> método para indicar al runtime para limpiar todos los contenedores RCW en el contexto actual. Suministro de mensajes tiene lugar mientras se ejecuta el método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un host que la ejecución está a punto de entrar en una región de código donde los efectos de una anulación del subproceso o de una excepción no controlada se limitan a la tarea actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hosts de common language runtime (CLR), como Microsoft SQL Server 2005, pueden establecer directivas diferentes para los errores en regiones críticas y no críticas del código. Una región crítica es aquella en la que los efectos de una anulación de subproceso o una excepción no controlada pueden no limitarse a la tarea actual. Por el contrario, una anulación o un error en una región no crítica del código afecta a solo la tarea que se produce el error.  
  
 Por ejemplo, considere la posibilidad de una tarea que intenta asignar memoria mientras se mantiene un bloqueo. Si se produce un error en la asignación de memoria, la anulación de la tarea actual no es suficiente para garantizar la estabilidad de la <xref:System.AppDomain>, porque puede haber otras tareas en el dominio esperando el mismo bloqueo. Si se termina la tarea actual, otras tareas podrían sufrir un interbloqueo.  
  
 Cuando se produce un error en una región crítica, el host puede optar por descargar toda la <xref:System.AppDomain> en lugar de correr el riesgo de continuar la ejecución en un estado potencialmente inestable. Para informar al host que el código está entrando en una región crítica, llame a <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Llamar a <xref:System.Threading.Thread.EndCriticalRegion%2A> cuando se devuelve a una región no crítica del código de ejecución.  
  
 Con este método en el código que se ejecuta en SQL Server 2005 requiere que el código que se ejecutará en el nivel más alto de protección de host.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Threading.Thread.BeginCriticalRegion%2A> y <xref:System.Threading.Thread.EndCriticalRegion%2A> métodos para dividir un bloque de código en regiones críticas y no críticas.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un host que el código administrado ha terminado de ejecutar instrucciones que dependen de la identidad del subproceso del sistema operativo físico actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos hosts de common language runtime, como Microsoft SQL Server 2005, proporcionan su propia administración de subprocesos. Un host que proporciona su propia administración de subprocesos puede mover una tarea en ejecución de un subproceso de sistema operativo físico a otro en cualquier momento. Mayoría de las tareas no se ven afectada por este cambio. Sin embargo, algunas tareas tienen afinidad de subprocesos, es decir, que dependen de la identidad de un subproceso físico del sistema operativo. Estas tareas deben informar al host cuando ejecuta código que no se debe cambiar.  
  
 Por ejemplo, si la aplicación llama una API del sistema para adquirir un sistema operativo de bloqueo que tiene afinidad de subprocesos, como CRITICAL_SECTION de Win32, se debe llamar a <xref:System.Threading.Thread.BeginThreadAffinity%2A> antes de adquirir el bloqueo, y <xref:System.Threading.Thread.EndThreadAffinity%2A> después de liberar el bloqueo.  
  
 Con este método en el código que se ejecuta en SQL Server 2005 requiere que el código que se ejecutará en el nivel más alto de protección de host.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Threading.Thread.BeginThreadAffinity%2A> y <xref:System.Threading.Thread.EndThreadAffinity%2A> métodos para notificar a un host que un bloque de código depende de la identidad de un subproceso físico del sistema operativo.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Threading.ExecutionContext" /> que contiene información sobre los distintos contextos del subproceso actual.</summary>
        <value>Objeto <see cref="T:System.Threading.ExecutionContext" /> que consolida la información de contexto del subproceso actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Threading.ExecutionContext> clase proporciona un único contenedor para toda la información relevante para un subproceso lógico de ejecución. Esto incluye el contexto de seguridad, contexto de llamada, el contexto de sincronización, el contexto de localización y contexto de transacción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se asegura de que los recursos se liberan y que se llevan a cabo otras operaciones de limpieza cuando el recolector de elementos no utilizados recupere el objeto <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El recolector de elementos no utilizados llame al <xref:System.Threading.Thread.Finalize%2A> cuando el objeto actual está preparado para finalizarse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la ranura de datos que se va a liberar.</param>
        <summary>Elimina la asociación entre un nombre y una ranura en todos los subprocesos del proceso. Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos. Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación. Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Después de cualquier subproceso llama a `FreeNamedDataSlot`, ningún otro subproceso que llama a <xref:System.Threading.Thread.GetNamedDataSlot%2A> con el mismo nombre que se asignará una nueva ranura asociada con el nombre. Las llamadas subsiguientes a `GetNamedDataSlot` cualquier subproceso devolverá el nuevo espacio. Sin embargo, cualquier subproceso que aún tiene un <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> devuelto por una llamada anterior a `GetNamedDataSlot` puede seguir usando la ranura anterior.  
  
 Se libera una ranura que se ha asociado con el nombre solo cuando cada `LocalDataStoreSlot` que obtuvo antes de llamar a `FreeNamedDataSlot` se ha liberado y recolección.  
  
 Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso. Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea. El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso. Las ranuras de datos son únicas para cada subproceso. Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos. El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.  
  
 **Primer ejemplo**  
  
 En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos. Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo ejemplo**  
  
 El ejemplo siguiente muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor <see cref="T:System.Threading.ApartmentState" /> que indica el estado del apartamento.</summary>
        <returns>Uno de los valores de <see cref="T:System.Threading.ApartmentState" /> que indica el estado del apartamento del subproceso administrado. El valor predeterminado es <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método, junto con el <xref:System.Threading.Thread.SetApartmentState%2A> método y el <xref:System.Threading.Thread.TrySetApartmentState%2A> método, reemplaza el <xref:System.Threading.Thread.ApartmentState%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, y <xref:System.Threading.Thread.TrySetApartmentState%2A> métodos. El ejemplo de código crea un subproceso. Antes de inicia el subproceso, <xref:System.Threading.Thread.GetApartmentState%2A> muestra inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado y <xref:System.Threading.Thread.SetApartmentState%2A> cambia el estado a <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. El <xref:System.Threading.Thread.TrySetApartmentState%2A> , a continuación, devuelve el método `false` al intentar cambiar el estado a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque ya está establecido el estado del apartamento. Si hubiera intentado la misma operación <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> habría iniciado.  
  
 Una vez iniciado el subproceso, el <xref:System.Threading.Thread.TrySetApartmentState%2A> método se utiliza de nuevo. Esta vez, se produce <xref:System.Threading.ThreadStateException> porque ya se inició el subproceso.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Threading.CompressedStack" /> que se puede utilizar para capturar la pila correspondiente al subproceso actual.</summary>
        <returns>Ninguno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método ya no se admite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">En todos los casos.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">La <see cref="T:System.LocalDataStoreSlot" /> de donde se va a obtener el valor.</param>
        <summary>Recupera el valor de la ranura especificada en el subproceso actual, dentro del dominio actual del subproceso. Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>El valor recuperado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos. Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación. Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso. Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea. El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso. Las ranuras de datos son únicas para cada subproceso. Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> es un `Shared` método que se aplica siempre que el subproceso actualmente en ejecución, incluso si se le llama mediante una variable que hace referencia a otro subproceso. Para evitar confusiones, utilice el nombre de clase al llamar a `Shared` métodos: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos. El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.  
  
 **Primer ejemplo**  
  
 En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos. Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo ejemplo**  
  
 El ejemplo siguiente muestra cómo usar una ranura de datos para almacenar información específica del subproceso.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el dominio en el que se está ejecutando el subproceso actual.</summary>
        <returns>Un <see cref="T:System.AppDomain" /> que representa el dominio de la aplicación actual del subproceso en ejecución.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra cómo recuperar el nombre e identificador de la `AppDomain` en que se está ejecutando el subproceso.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un identificador único del dominio de la aplicación.</summary>
        <returns>Entero de 32 bits con signo que identifica de forma unívoca el dominio de la aplicación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra cómo recuperar el nombre e identificador de la `AppDomain` en que se está ejecutando el subproceso.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un código hash para el subproceso actual.</summary>
        <returns>Valor de código hash entero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El código hash no se garantiza que sea único. Use el <xref:System.Threading.Thread.ManagedThreadId%2A> propiedad si necesita un identificador único para un subproceso administrado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la ranura de datos local.</param>
        <summary>Busca una ranura de datos con nombre. Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Una <see cref="T:System.LocalDataStoreSlot" /> asignada para este subproceso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos. Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación. Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso. Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea. El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso. Las ranuras de datos son únicas para cada subproceso. Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.  
  
 Si la ranura con nombre no existe, se asigna un nuevo espacio. Las ranuras de datos con nombre son públicas y se pueden manipular cualquier usuario.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos. El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.  
  
 **Primer ejemplo**  
  
 En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos. Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo ejemplo**  
  
 El ejemplo siguiente muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrumpe un subproceso que se encuentra en estado de subproceso <see langword="WaitSleepJoin" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este subproceso no está actualmente bloqueada en espera, suspensión o estado de unión, se interrumpirá cuando comienza a continuación bloquear.  
  
 <xref:System.Threading.ThreadInterruptedException> se produce en el subproceso interrumpido, pero no hasta que el subproceso se bloquea. Si el subproceso nunca se bloquea, nunca se produce la excepción y, por tanto, el subproceso podría finalizar sin ser interrumpido.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento de un subproceso en ejecución cuando se interrumpe y posteriormente se bloquea.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene el permiso <see cref="T:System.Security.Permissions.SecurityPermission" /> apropiado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para las operaciones avanzadas en subprocesos. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica el estado de ejecución del subproceso actual.</summary>
        <value>
          <see langword="true" /> si el subproceso se ha iniciado y no ha terminado con normalidad o se ha anulado; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si un subproceso es o no un subproceso en segundo plano.</summary>
        <value>
          <see langword="true" /> si el subproceso es un subproceso en segundo plano o va a convertirse en un subproceso en segundo plano; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un subproceso es un subproceso en segundo plano o en un subproceso en primer plano. Subprocesos en segundo plano son idénticos a los subprocesos de primer plano, salvo que los subprocesos en segundo plano no impiden que un proceso de terminación. Una vez que han finalizado todos los subprocesos de primer plano que pertenecen a un proceso, common language runtime finaliza el proceso. Los subprocesos en segundo plano restantes se detienen y no se completan.  
  
 De forma predeterminada, los subprocesos siguientes se ejecutan en primer plano (es decir, sus <xref:System.Threading.Thread.IsBackground%2A> propiedad devuelve `false`):  
  
-   El subproceso principal (o subproceso de aplicación principal).  
  
-   Todos los subprocesos creados mediante una llamada a un <xref:System.Threading.Thread> constructor de clase.  
  
 De forma predeterminada, los subprocesos siguientes se ejecutan en segundo plano (es decir, sus <xref:System.Threading.Thread.IsBackground%2A> propiedad devuelve `true`):  
  
-   El subproceso del grupo de subprocesos, que son un grupo de subprocesos de trabajo mantenidas el tiempo de ejecución. Puede configurar el trabajo del subproceso de grupo y la programación de subprocesos de grupo mediante la <xref:System.Threading.ThreadPool> clase.  
  
    > [!NOTE]
    >  Operaciones asincrónicas basadas en la tarea se ejecutan automáticamente en subprocesos de grupo.  
  
-   Todos los subprocesos que entran en el entorno de ejecución administrado desde código no administrado.  
  
   
  
## Examples  
 El ejemplo siguiente compara el comportamiento de los subprocesos de primer y segundo plano. Crea un subproceso en primer plano y un subproceso en segundo plano. El subproceso en primer plano mantiene el proceso que se ejecuta hasta que finalice su `for` un bucle y termina. Sin embargo, como se muestra el resultado del ejemplo, porque el subproceso en primer plano ha terminado de ejecutarse, el proceso finaliza antes de que el subproceso en segundo plano ha finalizado su ejecución.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">El proceso está inactivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si un subproceso pertenece al grupo de subprocesos administrados o no.</summary>
        <value>
          <see langword="true" /> si el subproceso pertenece al grupo de subprocesos administrados; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte [The Managed Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo determinar si es un subproceso del grupo de subprocesos.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bloquea el subproceso de llamada hasta que finaliza el subproceso representado por esta instancia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza, pero continúa bombeando <see langword="SendMessage" /> y COM estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso cuyo <xref:System.Threading.Thread.Join%2A> se llama al método se ha completado. Utilice este método para asegurarse de que un subproceso ha finalizado. El llamador se bloquee indefinidamente si el subproceso no termina. En el ejemplo siguiente, la `Thread1` subproceso llama a la <xref:System.Threading.Thread.Join> método `Thread2`, lo que hace que `Thread1` al bloque hasta `Thread2` se ha completado.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Si el subproceso ya ha terminado cuando <xref:System.Threading.Thread.Join%2A> se llama, el método vuelve inmediatamente.  
  
> [!WARNING]
>  Nunca debe llamar a la <xref:System.Threading.Thread.Join%2A> método de la <xref:System.Threading.Thread> objeto que representa el subproceso actual del subproceso actual. Esto hace que la aplicación deje de responder porque el subproceso actual espera a sí mismo indefinidamente,  
  
 Este método cambia el estado del subproceso que realiza la llamada debe incluir <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. No se puede invocar `Join` en un subproceso que está en el <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">El autor de la llamada ha intentado combinar un subproceso que se encuentra en el estado <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">El subproceso se interrumpe mientras espera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Número de milisegundos durante los que se va a esperar a que el subproceso finalice.</param>
        <summary>Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza o transcurre el tiempo especificado, pero continúa bombeando SendMessage y COM estándar.</summary>
        <returns>
          <see langword="true" /> si el subproceso ha terminado; <see langword="false" /> si el subproceso no ha terminado una vez transcurrido el período de tiempo especificado por el parámetro <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso de cualquier cuyo <xref:System.Threading.Thread.Join%2A> se llama al método se ha completado o ha transcurrido el intervalo de tiempo de espera. En el ejemplo siguiente, la `Thread1` subproceso llama a la <xref:System.Threading.Thread.Join> método `Thread2`, lo que hace que `Thread1` para bloquear hasta que `Thread2` se ha completado o hayan transcurrido 2 segundos.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Si <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> se especifica para el `millisecondsTimeout` parámetro, este método se comporta igual que el <xref:System.Threading.Thread.Join> sobrecarga del método, excepto para el valor devuelto.  
  
 Si el subproceso ya ha terminado cuando <xref:System.Threading.Thread.Join%2A> se llama, el método vuelve inmediatamente.  
  
 Este método cambia el estado del subproceso que realiza la llamada debe incluir <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. No se puede invocar `Join` en un subproceso que está en el <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> en milisegundos.</exception>
        <exception cref="T:System.Threading.ThreadStateException">No se ha iniciado el subproceso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> establecido en el período de tiempo durante el que se esperará a que espere el subproceso.</param>
        <summary>Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza o transcurre el tiempo especificado, pero continúa bombeando SendMessage y COM estándar.</summary>
        <returns>
          <see langword="true" /> si el subproceso ha terminado; <see langword="false" /> si el subproceso no ha terminado una vez transcurrido el período de tiempo especificado por el parámetro <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso de cualquier cuyo <xref:System.Threading.Thread.Join%2A> se llama al método se ha completado o ha transcurrido el intervalo de tiempo de espera. En el ejemplo siguiente, la `Thread1` subproceso llama a la <xref:System.Threading.Thread.Join> método `Thread2`, lo que hace que `Thread1` para bloquear hasta que `Thread2` se ha completado o hayan transcurrido 2 segundos.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Si <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> se especifica para `timeout`, este método se comporta igual que el <xref:System.Threading.Thread.Join> sobrecarga del método, excepto para el valor devuelto.  
  
 Si el subproceso ya ha terminado cuando <xref:System.Threading.Thread.Join%2A> se llama, el método vuelve inmediatamente.  
  
 Este método cambia el estado del subproceso actual para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>. No se puede invocar `Join` en un subproceso que está en el <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar un `TimeSpan` valor con el `Join` método.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> en milisegundos, o es superior a <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
        <exception cref="T:System.Threading.ThreadStateException">El autor de la llamada ha intentado combinar un subproceso que se encuentra en el estado <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un identificador único para el actual subproceso administrado.</summary>
        <value>Entero que representa un identificador único para este subproceso administrado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un subproceso <xref:System.Threading.Thread.ManagedThreadId%2A> valor de propiedad sirve para identificar de forma exclusiva ese subproceso dentro de su proceso.  
  
 El valor de la <xref:System.Threading.Thread.ManagedThreadId%2A> propiedad no varía con el tiempo, incluso si el código no administrado que hospeda common language runtime implementa el subproceso como una fibra.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sincroniza el acceso a la memoria de la siguiente forma: el procesador que ejecuta el subproceso actual no puede reordenar las instrucciones de forma que los accesos a la memoria anteriores a la llamada a <see cref="M:System.Threading.Thread.MemoryBarrier" /> se ejecuten después de los accesos a memoria que siguen a la llamada a <see cref="M:System.Threading.Thread.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> solo es necesario en sistemas multiprocesador con ordenación (por ejemplo, un sistema que utilice varios procesadores Intel Itanium) de memoria débil.  
  
 Para la mayoría de los casos, C# `lock` instrucción, Visual Basic `SyncLock` instrucción, o la <xref:System.Threading.Monitor> clase proporcionan formas sencillas para sincronizar los datos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del subproceso.</summary>
        <value>Cadena que contiene el nombre del subproceso o <see langword="null" /> si no se ha establecido ningún nombre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es de escritura: una vez. Dado que el valor predeterminado de un subproceso <xref:System.Threading.Thread.Name%2A> propiedad es `null`, puede determinar si un nombre ya se han explícitamente asignado al subproceso comparándola con `null`.  
  
 La cadena asignada a la <xref:System.Threading.Thread.Name%2A> propiedad puede incluir cualquier carácter Unicode.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo denominar un subproceso.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se solicitó una operación Set, pero ya se ha establecido la propiedad <see langword="Name" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica la prioridad de programación de un subproceso.</summary>
        <value>Uno de los valores de <see cref="T:System.Threading.ThreadPriority" />. El valor predeterminado es <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un subproceso se puede asignar cualquiera de la siguiente prioridad <xref:System.Threading.ThreadPriority> valores:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Sistemas operativos no tienen que respeta la prioridad de un subproceso.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el resultado de cambiar la prioridad de un subproceso. Se crean tres subprocesos, se establece la prioridad de un subproceso en <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, y la prioridad de segundo se establece en <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>. Cada subproceso incrementa una variable en un `while` bucle y se ejecuta durante un tiempo establecido.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">El subproceso ha alcanzado un estado final, como <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">El valor especificado para una operación de establecimiento no es un valor de <see cref="T:System.Threading.ThreadPriority" /> valido.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela un método <see cref="M:System.Threading.Thread.Abort(System.Object)" /> solicitado para el subproceso actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo se puede llamar mediante código con los permisos adecuados.  
  
 Cuando se realiza una llamada a `Abort` para terminar un subproceso, el sistema produce una <xref:System.Threading.ThreadAbortException>. `ThreadAbortException` es una excepción especial que puede detectar el código de la aplicación, pero se vuelve a producir al final del bloque catch a menos que `ResetAbort` se llama. `ResetAbort` cancela la solicitud de anulación y evita la `ThreadAbortException` de finalización del subproceso.  
  
 Consulte <xref:System.Threading.ThreadAbortException> para obtener un ejemplo que muestra cómo llamar a la `ResetAbort` método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: este miembro no se admite.</exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" /> no se invocó en el subproceso actual.</exception>
        <exception cref="T:System.Security.SecurityException">El autor de la llamada no tiene el permiso de seguridad necesario para el subproceso actual.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para las operaciones avanzadas en subprocesos. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reanuda un subproceso que se ha suspendido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  No utilice el <xref:System.Threading.Thread.Suspend%2A> y <xref:System.Threading.Thread.Resume%2A> métodos para sincronizar las actividades de subprocesos. No tener ninguna manera de saber qué código un subproceso se ejecuta cuando se suspende. Si se suspende un subproceso mientras mantiene bloqueos durante una evaluación de permisos de seguridad, otros subprocesos en la <xref:System.AppDomain> podría bloquearse. Si se suspende un subproceso mientras se esté ejecutando un constructor de clase, otros subprocesos en la <xref:System.AppDomain> que intentan usar que se bloquean la clase. Pueden producirse interbloqueos muy fácilmente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: este miembro no se admite.</exception>
        <exception cref="T:System.Threading.ThreadStateException">El subproceso no se ha iniciado, está inactivo o no está en estado suspendido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene el permiso <see cref="T:System.Security.Permissions.SecurityPermission" /> apropiado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para las operaciones avanzadas en subprocesos. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Nuevo estado del apartamento.</param>
        <summary>Establece el estado del apartamento de un subproceso antes de iniciarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los subprocesos nuevos se inicializan como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si no se ha establecido su estado de apartamento antes de que se inicien. Estado del apartamento se debe establecer antes de que se inicia un subproceso.  
  
> [!NOTE]
>  El subproceso principal de la aplicación se inicializa en <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> de forma predeterminada. La única forma de establecer el estado del apartamento del subproceso principal de la aplicación para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste en aplicar el <xref:System.STAThreadAttribute> atributo al método de punto de entrada.  
  
 El <xref:System.Threading.Thread.SetApartmentState%2A> método, junto con el <xref:System.Threading.Thread.GetApartmentState%2A> método y el <xref:System.Threading.Thread.TrySetApartmentState%2A> método, reemplaza el <xref:System.Threading.Thread.ApartmentState%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, y <xref:System.Threading.Thread.TrySetApartmentState%2A> métodos. El ejemplo de código crea un subproceso. Antes de inicia el subproceso, <xref:System.Threading.Thread.GetApartmentState%2A> muestra inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado y <xref:System.Threading.Thread.SetApartmentState%2A> cambia el estado a <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. El <xref:System.Threading.Thread.TrySetApartmentState%2A> , a continuación, devuelve el método `false` al intentar cambiar el estado a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque ya está establecido el estado del apartamento. Si hubiera intentado la misma operación <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> habría iniciado.  
  
 Una vez iniciado el subproceso, el <xref:System.Threading.Thread.TrySetApartmentState%2A> método se utiliza de nuevo. Esta vez, se produce <xref:System.Threading.ThreadStateException> porque ya se inició el subproceso.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: este miembro no se admite en las plataformas macOS y Linux.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> no es un estado de tipo apartamento válido.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Ya se inició el subproceso.</exception>
        <exception cref="T:System.InvalidOperationException">El estado de apartamento ya se inicializó.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">Objeto <see cref="T:System.Threading.CompressedStack" /> que va a aplicarse al subproceso actual.</param>
        <summary>Aplica un objeto <see cref="T:System.Threading.CompressedStack" /> capturado al subproceso actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método ya no se admite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">En todos los casos.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">La <see cref="T:System.LocalDataStoreSlot" /> donde se va a establecer el valor.</param>
        <param name="data">Valor que se va a establecer.</param>
        <summary>Establece los datos de la ranura especificada en el subproceso actualmente en ejecución, para el dominio actual de dicho subproceso. Para obtener un mejor rendimiento, utilice en su lugar los campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos. Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación. Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso. Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea. El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para volver a usarse una vez finalizado el procedimiento de subproceso y el <xref:System.Threading.Thread> objeto se ha recuperado por la recolección. Las ranuras de datos son únicas para cada subproceso. Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> es un `Shared` método que se aplica siempre que el subproceso actualmente en ejecución, incluso si se le llama mediante una variable que hace referencia a otro subproceso. Para evitar confusiones, utilice el nombre de clase al llamar a `Shared` métodos: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos. El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.  
  
 **Primer ejemplo**  
  
 En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos. Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Segundo ejemplo**  
  
 El ejemplo siguiente muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Suspende el subproceso actual durante la cantidad de tiempo especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Número de milisegundos durante los que el subproceso está suspendido. Si el valor del argumento <c>millisecondsTimeout</c> es cero, el subproceso cede el resto de su porción de tiempo a cualquier subproceso de idéntica prioridad que esté listo para ejecutarse. Si no hay ningún otro subproceso de igual prioridad que está listo para ejecutarse, no se suspende la ejecución del subproceso actual.</param>
        <summary>Suspende el subproceso actual durante el número de milisegundos especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El subproceso no se programará para su ejecución por el sistema operativo durante el tiempo especificado. Este método cambia el estado del subproceso para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Puede especificar <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para el `millisecondsTimeout` parámetro para suspender el subproceso indefinidamente. Sin embargo, se recomienda utilizar otros <xref:System.Threading?displayProperty=nameWithType> clases como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, o <xref:System.Threading.Semaphore> en su lugar para sincronizar subprocesos o administrar los recursos.  
  
 Los ciclos de reloj del sistema a un ritmo específico denomina la resolución del reloj. El tiempo de espera real podría no ser exactamente el tiempo de espera, ya que el tiempo de espera especificado se ajustará para que coincida con los ciclos de reloj. Para obtener más información sobre la resolución del reloj y el tiempo de espera, vea el [suspensión función](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tema. Este método llama a la [suspensión función](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) desde las API del sistema de Windows.  
  
 Este método no realiza suministro de SendMessage y COM estándar.  
  
> [!NOTE]
>  Si se debe al modo de suspensión en un subproceso que tiene <xref:System.STAThreadAttribute>, pero desea bombeando SendMessage y COM estándar, puede usar una de las sobrecargas de los <xref:System.Threading.Thread.Join%2A> método que especifica un intervalo de tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Threading.Thread.Sleep%2A> método para bloquear el subproceso principal de la aplicación.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de tiempo de espera es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Cantidad de tiempo durante la que el subproceso está suspendido. Si el valor del argumento <c>millisecondsTimeout</c> es <see cref="F:System.TimeSpan.Zero" />, el subproceso cede el resto de su porción de tiempo a cualquier subproceso de idéntica prioridad que esté listo para ejecutarse. Si no hay ningún otro subproceso de igual prioridad que está listo para ejecutarse, no se suspende la ejecución del subproceso actual.</param>
        <summary>Suspende el subproceso actual durante la cantidad de tiempo especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El subproceso no se programará para su ejecución por el sistema operativo durante el tiempo especificado. Este método cambia el estado del subproceso para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 Puede especificar <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> para el `timeout` parámetro para suspender el subproceso indefinidamente. Sin embargo, se recomienda utilizar otros <xref:System.Threading?displayProperty=nameWithType> clases como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, o <xref:System.Threading.Semaphore> en su lugar para sincronizar subprocesos o administrar los recursos.  
  
 Esta sobrecarga de <xref:System.Threading.Thread.Sleep%2A> utiliza el número total de milisegundos enteros en `timeout`. Se descartan las fracciones de milisegundos.  
  
 Este método no realiza suministro de SendMessage y COM estándar.  
  
> [!NOTE]
>  Si se debe al modo de suspensión en un subproceso que tiene <xref:System.STAThreadAttribute>, pero desea bombeando SendMessage y COM estándar, puede usar una de las sobrecargas de los <xref:System.Threading.Thread.Join%2A> método que especifica un intervalo de tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> sobrecarga del método para bloquear el subproceso principal de la aplicación cinco veces, durante dos segundos cada vez.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> en milisegundos, o es superior a <see cref="F:System.Int32.MaxValue" /> milisegundos.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">Entero de 32 bits con signo que define la cantidad de tiempo de espera de un subproceso.</param>
        <summary>Hace que un subproceso espere el número de veces definido por el parámetro <paramref name="iterations" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Thread.SpinWait%2A> método es útil para implementar bloqueos. Las clases de .NET Framework, como <xref:System.Threading.Monitor> y <xref:System.Threading.ReaderWriterLock>, use este método internamente. <xref:System.Threading.Thread.SpinWait%2A> Básicamente, coloca el procesador en un bucle ajustado muy, con el recuento del bucle especificado por el `iterations` parámetro. El tiempo de espera, por tanto, depende de la velocidad del procesador.  
  
 Compare esto con el <xref:System.Threading.Thread.Sleep%2A> método. Un subproceso que llama a <xref:System.Threading.Thread.Sleep%2A> genera el resto de su porción de tiempo de procesador actual, incluso si el intervalo especificado es cero. Especificar un intervalo distinto de cero para <xref:System.Threading.Thread.Sleep%2A> quita el subproceso de examen por el programador del subproceso hasta que haya transcurrido el intervalo de tiempo.  
  
 <xref:System.Threading.Thread.SpinWait%2A> no es generalmente útil para las aplicaciones comunes. En la mayoría de los casos, debe usar las clases de sincronización proporcionadas por .NET Framework; Por ejemplo, llamar a <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> o una instrucción que ajusta <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` en C# o `SyncLock` en Visual Basic).  
  
> [!CAUTION]
>  En el caso excepcional donde resulta ventajoso para evitar un cambio de contexto, por ejemplo, cuando se sabe que un cambio de estado es inminente, realice una llamada a la <xref:System.Threading.Thread.SpinWait%2A> método en el bucle. El código <xref:System.Threading.Thread.SpinWait%2A> ejecuta está diseñado para evitar problemas que pueden producirse en equipos con varios procesadores. Por ejemplo, en equipos con varios procesadores de Intel que emplean la tecnología Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> evita la inanición del procesador en determinadas situaciones.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hace que se programe un subproceso para su ejecución.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que el sistema operativo cambie el estado de la instancia actual a <see cref="F:System.Threading.ThreadState.Running" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una vez que un subproceso está en el <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> de estado, el sistema operativo puede programarlo para su ejecución. El subproceso empieza a ejecutarse en la primera línea del método representado por la <xref:System.Threading.ThreadStart> o <xref:System.Threading.ParameterizedThreadStart> delegado proporcionado al constructor del subproceso. Tenga en cuenta que la llamada a <xref:System.Threading.Thread.Start%2A> no bloquea el subproceso que realiza la llamada.  
  
> [!NOTE]
>  Si esta sobrecarga se utiliza con un subproceso creado mediante una <xref:System.Threading.ParameterizedThreadStart> delegar, `null` se pasa al método ejecutado por el subproceso.  
  
 Una vez que finaliza el subproceso, no se puede reiniciar con otra llamada a `Start`.  
  
   
  
## Examples  
 El ejemplo siguiente se crea e inicia un subproceso.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Ya se inició el subproceso.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente disponible para iniciar este subproceso.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Objeto que contiene datos para que los use el método ejecutado por el subproceso.</param>
        <summary>Hace que el sistema operativo cambie el estado de la instancia actual a <see cref="F:System.Threading.ThreadState.Running" />; también puede proporcionar un objeto que contiene datos para que los use el método ejecutado por el subproceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una vez que un subproceso está en el <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> de estado, el sistema operativo puede programarlo para su ejecución. El subproceso empieza a ejecutarse en la primera línea del método representado por la <xref:System.Threading.ThreadStart> o <xref:System.Threading.ParameterizedThreadStart> delegado proporcionado al constructor del subproceso. Tenga en cuenta que la llamada a <xref:System.Threading.Thread.Start%2A> no bloquea el subproceso que realiza la llamada.  
  
 Una vez que finaliza el subproceso, no se puede reiniciar con otra llamada a `Start`.  
  
 Esta sobrecarga y la <xref:System.Threading.ParameterizedThreadStart> delegado facilitan la tarea pasar datos a un procedimiento de subproceso, pero la técnica no es segura porque se puede pasar cualquier objeto a esta sobrecarga. Es una manera más sólida para pasar datos a un procedimiento de subproceso poner el procedimiento de subproceso y los campos de datos en un objeto de trabajo. Para obtener más información, consulte [crear subprocesos y pasar datos en tiempo de inicio](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Threading.ParameterizedThreadStart> delegado con un método estático y un método de instancia.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Ya se inició el subproceso.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente iniciar este subproceso.</exception>
        <exception cref="T:System.InvalidOperationException">Este subproceso se creó mediante un delegado <see cref="T:System.Threading.ThreadStart" /> en lugar de un delegado <see cref="T:System.Threading.ParameterizedThreadStart" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspende el subproceso o, si este ya se ha suspendido, no tiene efecto alguno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el subproceso ya está suspendido, este método tiene ningún efecto.  
  
> [!CAUTION]
>  No utilice el <xref:System.Threading.Thread.Suspend%2A> y <xref:System.Threading.Thread.Resume%2A> métodos para sincronizar las actividades de subprocesos. No tener ninguna manera de saber qué código un subproceso se ejecuta cuando se suspende. Si se suspende un subproceso mientras mantiene bloqueos durante una evaluación de permisos de seguridad, otros subprocesos en la <xref:System.AppDomain> podría bloquearse. Si se suspende un subproceso mientras se esté ejecutando un constructor de clase, otros subprocesos en la <xref:System.AppDomain> que intentan usar que se bloquean la clase. Pueden producirse interbloqueos muy fácilmente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: este miembro no se admite.</exception>
        <exception cref="T:System.Threading.ThreadStateException">No se ha iniciado el subproceso o está inactivo</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene el permiso <see cref="T:System.Security.Permissions.SecurityPermission" /> apropiado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para las operaciones avanzadas en subprocesos. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="rgszNames">Matriz que se pasa con los nombres que se van a asignar.</param>
        <param name="cNames">Número de nombres que se van a asignar.</param>
        <param name="lcid">Contexto de configuración regional en el que se van a interpretar los nombres.</param>
        <param name="rgDispId">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</param>
        <summary>Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Información de tipos que se va a devolver.</param>
        <param name="lcid">Identificador de la configuración regional de la información de tipo.</param>
        <param name="ppTInfo">Recibe un puntero al objeto de información de tipo solicitado.</param>
        <summary>Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</param>
        <summary>Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica el miembro.</param>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="lcid">Contexto de la configuración regional en que se interpretan los argumentos.</param>
        <param name="wFlags">Marcas que describen el contexto de la llamada.</param>
        <param name="pDispParams">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</param>
        <param name="pVarResult">Puntero a la ubicación donde se va a almacenar el resultado.</param>
        <param name="pExcepInfo">Puntero a una estructura que contiene información de excepciones.</param>
        <param name="puArgErr">Índice del primer argumento que tiene un error.</param>
        <summary>Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que contiene los estados del subproceso actual.</summary>
        <value>Uno de los valores de <see cref="T:System.Threading.ThreadState" /> que indica el estado del subproceso actual. El valor inicial es <see langword="Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Thread.ThreadState%2A> propiedad proporciona información más específica que la <xref:System.Threading.Thread.IsAlive%2A> propiedad.  
  
> [!IMPORTANT]
>  Estado de los subprocesos solo es de interés en escenarios de depuración. El código nunca debe usar el estado de los subprocesos para sincronizar las actividades de los subprocesos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo tener acceso el `ThreadState` de un subproceso.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Nuevo estado del apartamento.</param>
        <summary>Establece el estado del apartamento de un subproceso antes de iniciarse.</summary>
        <returns>
          <see langword="true" /> si se ha establecido el estado del apartamento; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los subprocesos nuevos se inicializan como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si no se ha establecido su estado de apartamento antes de que se inicien. Estado del apartamento se debe establecer antes de que se inicia un subproceso.  
  
> [!NOTE]
>  El subproceso principal de la aplicación se inicializa en <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> de forma predeterminada. La única forma de establecer el estado del apartamento del subproceso principal de la aplicación para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste en aplicar el <xref:System.STAThreadAttribute> atributo al método de punto de entrada.  
  
 El <xref:System.Threading.Thread.TrySetApartmentState%2A> método, junto con el <xref:System.Threading.Thread.GetApartmentState%2A> método y el <xref:System.Threading.Thread.SetApartmentState%2A> método, reemplaza el <xref:System.Threading.Thread.ApartmentState%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, y <xref:System.Threading.Thread.TrySetApartmentState%2A> métodos. El ejemplo de código crea un subproceso. Antes de inicia el subproceso, <xref:System.Threading.Thread.GetApartmentState%2A> muestra inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado y <xref:System.Threading.Thread.SetApartmentState%2A> cambia el estado a <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. El <xref:System.Threading.Thread.TrySetApartmentState%2A> , a continuación, devuelve el método `false` al intentar cambiar el estado a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque ya está establecido el estado del apartamento. Si hubiera intentado la misma operación <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> habría iniciado.  
  
 Una vez iniciado el subproceso, el <xref:System.Threading.Thread.TrySetApartmentState%2A> método se utiliza de nuevo. Esta vez, se produce <xref:System.Threading.ThreadStateException> porque ya se inició el subproceso.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> no es un estado de tipo apartamento válido.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Ya se inició el subproceso.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo que se va a leer.</param>
        <summary>Lee el valor de un campo. El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</summary>
        <returns>Último valor que ha escrito en el campo un procesador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Campo en el que se escribirá el valor.</param>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización. En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.  
  
 En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores. Esto podría requerir vaciar las memorias caché de procesador.  
  
 Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador). Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.  
  
 Llamar a este método sólo afecta a una sola memoria access. Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que el subproceso que realiza la llamada ceda la ejecución a otro subproceso que está listo para ejecutarse en el procesador actual. El sistema operativo selecciona el subproceso al que se va a ceder la ejecución.</summary>
        <returns>Es <see langword="true" /> si el sistema operativo cambió la ejecución a otro subproceso; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este método se realiza correctamente, se cede el resto del intervalo de tiempo actual del subproceso. El sistema operativo programa el subproceso de llamada para otro intervalo de tiempo, según su prioridad y el estado de otros subprocesos que están disponibles para ejecutarse.  
  
 La retención se limita al procesador que se está ejecutando el subproceso de llamada. El sistema operativo no se cambiará la ejecución a otro procesador, incluso si dicho procesador está inactivo o se está ejecutando un subproceso de menor prioridad. Si no hay ningún otro subproceso que esté listo para ejecutarse en el procesador actual, el sistema operativo no produce la ejecución y que devuelve este método `false`.  
  
 Este método es equivalente a usar invocación de plataforma para llamar a Win32 nativo `SwitchToThread` función. Debe llamar a la <xref:System.Threading.Thread.Yield%2A> invocación de método en lugar de usar la plataforma, ya que omite cualquier comportamiento de subprocesamiento personalizado el host ha solicitado la invocación de plataforma.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>