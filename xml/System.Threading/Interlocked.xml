<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7fd6b58d4830bad8e69f870f2d493afbb5945295" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48769819" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona operaciones atómicas para las variables compartidas por varios subprocesos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos de esta clase ayudan a protegerse frente a errores que pueden producirse cuando el programador cambia de contexto mientras un subproceso está actualizando una variable que se puede acceder por otros subprocesos, o cuando dos subprocesos se ejecutan simultáneamente en procesadores separados. Los miembros de esta clase no producen excepciones.  
  
 El <xref:System.Threading.Interlocked.Increment%2A> y <xref:System.Threading.Interlocked.Decrement%2A> métodos aumentar o reducir una variable y almacenar el valor resultante en una sola operación. En la mayoría de los equipos, el incremento de una variable no es una operación atómica, que requieren los pasos siguientes:  
  
1.  Cargar un valor de una variable de instancia en un registro.  
  
2.  Incrementar o disminuir el valor.  
  
3.  Store el valor en la variable de instancia.  
  
 Si no usas <xref:System.Threading.Interlocked.Increment%2A> y <xref:System.Threading.Interlocked.Decrement%2A>, un subproceso puede ser adelantado después de ejecutar los dos primeros pasos. Otro subproceso, a continuación, puede ejecutar estos tres pasos. Cuando el primer subproceso reanuda la ejecución, sobrescribe el valor de la variable de instancia y se pierde el efecto del incremento o decremento realizadas por el segundo subproceso.  
  
 El <xref:System.Threading.Interlocked.Exchange%2A> método intercambia los valores de las variables especificadas atómicamente. El <xref:System.Threading.Interlocked.CompareExchange%2A> método combina dos operaciones: compara dos valores y almacena un tercer valor en una de las variables, en función del resultado de la comparación. Las operaciones de comparación e intercambio se realizan como una operación atómica.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra un mecanismo de bloqueo de recursos seguro para subprocesos.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
    <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega dos enteros y reemplaza el primer entero por la suma, como una operación atómica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Variable que contiene el primer valor que se va a agregar. La suma de los dos valores se almacena en <c>location1</c>.</param>
        <param name="value">Valor que se va a agregar al entero en <c>location1</c>.</param>
        <summary>Agrega dos enteros de 32 bits y reemplaza el primer entero por la suma, como una operación atómica.</summary>
        <returns>Nuevo valor almacenado en <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método controla una condición de desbordamiento mediante un ajuste: si el valor en `location1` es <xref:System.Int32.MaxValue?displayProperty=nameWithType> y `value` es 1, el resultado es <xref:System.Int32.MinValue?displayProperty=nameWithType>; si `value` es 2, el resultado es (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); y así sucesivamente. No se inicia ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Variable que contiene el primer valor que se va a agregar. La suma de los dos valores se almacena en <c>location1</c>.</param>
        <param name="value">Valor que se va a agregar al entero en <c>location1</c>.</param>
        <summary>Agrega dos enteros de 64 bits y reemplaza el primer entero por la suma, como una operación atómica.</summary>
        <returns>Nuevo valor almacenado en <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método controla una condición de desbordamiento mediante un ajuste: si el valor en `location1` es <xref:System.Int64.MaxValue?displayProperty=nameWithType> y `value` es 1, el resultado es <xref:System.Int64.MinValue?displayProperty=nameWithType>; si `value` es 2, el resultado es (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); y así sucesivamente. No se inicia ninguna excepción.  
  
 El <xref:System.Threading.Interlocked.Read%2A> método y las sobrecargas de 64 bits de la <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, y <xref:System.Threading.Interlocked.Add%2A> métodos son atómicos realmente sólo en sistemas donde un <xref:System.IntPtr?displayProperty=nameWithType> tiene una longitud de 64 bits. En otros sistemas, estos métodos son atómicos con respecto a entre sí, pero no con respecto a otros medios de acceso a los datos. Por lo tanto, para que sea segura para subprocesos en los sistemas de 32 bits, cualquier acceso a un valor de 64 bits debe realizarse a través de los miembros de la <xref:System.Threading.Interlocked> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara dos valores para comprobar si son iguales y, si lo son, reemplaza el primer valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">Destino cuyo valor se compara con <c>comparand</c> y que posiblemente se reemplace.</param>
        <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
        <param name="comparand">Valor que se compara con el que hay en <c>location1</c>.</param>
        <summary>Compara dos números de punto flotante de precisión doble para comprobar si son iguales y, si lo son, reemplaza el primero de los valores.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparand` y el valor de `location1` son iguales, a continuación, `value` se almacena en `location1`. De lo contrario, no se realiza ninguna operación. Las operaciones de comparación e intercambio se realizan como una operación atómica. El valor devuelto de <xref:System.Threading.Interlocked.CompareExchange%2A> es el valor original en `location1`, o no tenga lugar el intercambio.  
  
   
  
## Examples  
 El código siguiente muestra un método seguro para subprocesos que se acumula un total de <xref:System.Double> valores. Dos subprocesos agregan una serie de <xref:System.Double> valores mediante el método de subprocesos y la suma ordinaria, y cuando los subprocesos se completan los totales se comparan. En un equipo con procesador dual, hay una diferencia significativa en los totales.  
  
 En el método seguro para subprocesos, se guarda el valor inicial del total acumulado y, a continuación, el <xref:System.Threading.Interlocked.CompareExchange%2A> método se utiliza para intercambiar el total calculado recientemente con el total anterior. Si el valor devuelto no es igual que el valor guardado del total de ejecución, a continuación, otro subproceso ha actualizado el total durante el proceso. En ese caso, se debe repetir el intento de actualizar el total acumulado.  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Destino cuyo valor se compara con <c>comparand</c> y que posiblemente se reemplace.</param>
        <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
        <param name="comparand">Valor que se compara con el que hay en <c>location1</c>.</param>
        <summary>Compara dos enteros de 32 bits con signo para comprobar si son iguales y, si lo son, reemplaza el primer valor.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparand` y el valor de `location1` son iguales, a continuación, `value` se almacena en `location1`. De lo contrario, no se realiza ninguna operación. Las operaciones de comparación e intercambio se realizan como una operación atómica. El valor devuelto de <xref:System.Threading.Interlocked.CompareExchange%2A> es el valor original en `location1`, o no tenga lugar el intercambio.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra un método seguro para subprocesos que se acumula un total acumulado. Se guarda el valor inicial del total acumulado y, a continuación, el <xref:System.Threading.Interlocked.CompareExchange%2A> método se utiliza para intercambiar el total calculado recientemente con el total anterior. Si el valor devuelto no es igual que el valor guardado del total de ejecución, a continuación, otro subproceso ha actualizado el total durante el proceso. En ese caso, se debe repetir el intento de actualizar el total acumulado.  
  
> [!NOTE]
>  El <xref:System.Threading.Interlocked.Add%2A> método, introducida en la versión 2.0 de .NET Framework, proporciona una manera más cómoda para acumular los totales acumulados de subprocesos para números enteros.  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Destino cuyo valor se compara con <c>comparand</c> y que posiblemente se reemplace.</param>
        <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
        <param name="comparand">Valor que se compara con el que hay en <c>location1</c>.</param>
        <summary>Compara dos enteros de 64 bits con signo para comprobar si son iguales y, si lo son, reemplaza el primer valor.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparand` y el valor de `location1` son iguales, a continuación, `value` se almacena en `location1`. De lo contrario, no se realiza ninguna operación. Las operaciones de comparación e intercambio se realizan como una operación atómica. El valor devuelto de <xref:System.Threading.Interlocked.CompareExchange%2A> es el valor original en `location1`, o no tenga lugar el intercambio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">Destino <see cref="T:System.IntPtr" />, cuyo valor se compara con el valor de <c>comparand</c> y que posiblemente se reemplace por <c>value</c>.</param>
        <param name="value">Estructura <see cref="T:System.IntPtr" /> que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
        <param name="comparand">Valor <see cref="T:System.IntPtr" /> que se compara con el que hay en <c>location1</c>.</param>
        <summary>Compara dos identificadores o punteros específicos de plataforma para comprobar si son iguales y, si lo son, reemplaza el primero.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparand` y el valor de `location1` son iguales, a continuación, `value` se almacena en `location1`. De lo contrario, no se realiza ninguna operación. Las operaciones de comparación e intercambio se realizan como una operación atómica. El valor devuelto de este método es el valor original en `location1`, o no tenga lugar el intercambio.  
  
> [!NOTE]
>  <xref:System.IntPtr> es un tipo específico de la plataforma.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">Objeto de destino que se compara con <c>comparand</c> y que posiblemente se reemplace.</param>
        <param name="value">Objeto que reemplaza el objeto de destino si la comparación da como resultado la igualdad de ambos parámetros.</param>
        <param name="comparand">Objeto que se compara con el objeto que hay en <c>location1</c>.</param>
        <summary>Compara dos objetos para comprobar si sus referencias son iguales y, si lo son, reemplaza el primero de los objetos.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparand` y el objeto en `location1` son iguales, a continuación, `value` se almacena en `location1`. De lo contrario, no se realiza ninguna operación. Las operaciones de comparación e intercambio se realizan como una operación atómica. El valor devuelto de <xref:System.Threading.Interlocked.CompareExchange%2A> es el valor original en `location1`, o no tenga lugar el intercambio.  
  
 A partir de .NET Framework versión 2.0, el <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> sobrecarga del método proporciona una alternativa de seguridad de tipos para tipos de referencia.  
  
> [!NOTE]
>  Los objetos se comparan la igualdad de referencia, en lugar de <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Como resultado, dos instancias de conversión boxing del mismo tipo de valor (por ejemplo, el valor entero 3) siempre parecen ser iguales, y se realiza ninguna operación. No utilice esta sobrecarga con tipos de valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">Destino cuyo valor se compara con <c>comparand</c> y que posiblemente se reemplace.</param>
        <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
        <param name="comparand">Valor que se compara con el que hay en <c>location1</c>.</param>
        <summary>Compara dos números de punto flotante de precisión sencilla para comprobar si son iguales y, si lo son, reemplaza el primero de los valores.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparand` y el valor de `location1` son iguales, a continuación, `value` se almacena en `location1`. De lo contrario, no se realiza ninguna operación. Las operaciones de comparación e intercambio se realizan como una operación atómica. El valor devuelto de <xref:System.Threading.Interlocked.CompareExchange%2A> es el valor original en `location1`, o no tenga lugar el intercambio.  
  
   
  
## Examples  
 El código siguiente muestra un método seguro para subprocesos que se acumula un total de <xref:System.Single> valores. Dos subprocesos agregan una serie de <xref:System.Single> valores mediante el método de subprocesos y la suma ordinaria, y cuando los subprocesos se completan los totales se comparan. En un equipo con procesador dual, hay una diferencia significativa en los totales.  
  
 En el método seguro para subprocesos, se guarda el valor inicial del total acumulado y, a continuación, el <xref:System.Threading.Interlocked.CompareExchange%2A> método se utiliza para intercambiar el total calculado recientemente con el total anterior. Si el valor devuelto no es igual que el valor guardado del total de ejecución, a continuación, otro subproceso ha actualizado el total durante el proceso. En ese caso, se debe repetir el intento de actualizar el total acumulado.  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">El tipo que se usará para <c>location1</c>, <c>valor</c>, y <c>comparand</c>. Este tipo debe ser un tipo de referencia.</typeparam>
        <param name="location1">Destino cuyo valor se compara con <c>comparand</c> y que posiblemente se reemplace. Este es un parámetro de referencia (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</param>
        <param name="value">Valor que reemplaza el valor de destino si la comparación da como resultado una igualdad.</param>
        <param name="comparand">Valor que se compara con el que hay en <c>location1</c>.</param>
        <summary>Compara dos instancias del tipo de referencia especificado <paramref name="T" /> para comprobar si son iguales y, si lo son, reemplaza la primera.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparand` y el valor de `location1` son iguales, a continuación, `value` se almacena en `location1`. De lo contrario, no se realiza ninguna operación. La comparación y el intercambio se realizan como una operación atómica. El valor devuelto de este método es el valor original en `location1`, o no tenga lugar el intercambio.  
  
 Este método solo admite tipos de referencia. Hay sobrecargas de los <xref:System.Threading.Interlocked.CompareExchange%2A> método para los tipos de valor <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, y <xref:System.Double>, pero no hay ninguna compatibilidad con otros tipos de valor.  
  
> [!NOTE]
>  Esta sobrecarga del método es preferible el <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> sobrecarga del método, porque el último requiere el objeto de destino para tener acceso en tiempo de ejecución.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Disminuye el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Variable cuyo valor se va a reducir.</param>
        <summary>Disminuye el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
        <returns>Valor reducido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método controla una condición de desbordamiento mediante un ajuste: si `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>. No se inicia ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente determina cuántos números aleatorios comprendidos entre 0 y 1000 son necesarias para generar números aleatorios 1.000 con un valor de punto medio. Para mantener el seguimiento del número de valores de punto medio, una variable, `midpointCount`, es establecer iguales a 1.000 y disminuye cada vez que el generador de números aleatorios devuelve un valor de punto medio. Dado que tres subprocesos generan los números aleatorios, la <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> método se llama para garantizar que varios subprocesos no se actualicen `midpointCount` simultáneamente. Tenga en cuenta que un bloqueo también se usa para proteger el generador de números aleatorios y que un <xref:System.Threading.CountdownEvent> objeto sirve para asegurarse de que el `Main` método no finaliza la ejecución antes de los tres subprocesos.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 El ejemplo siguiente es similar al anterior, salvo que usa el <xref:System.Threading.Tasks.Task> clase en lugar de un procedimiento de subproceso para generar 50 000 enteros aleatorios de punto medio. En este ejemplo, una expresión lambda reemplaza el `GenerateNumbers` procedimiento de subproceso y la llamada a la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método elimina la necesidad de la <xref:System.Threading.CountdownEvent> objeto.  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Variable cuyo valor se va a reducir.</param>
        <summary>Disminuye el valor de la variable especificada y almacena el resultado, como una operación atómica.</summary>
        <returns>Valor reducido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método controla una condición de desbordamiento mediante un ajuste: si `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>. No se inicia ninguna excepción.  
  
 El <xref:System.Threading.Interlocked.Read%2A> método y las sobrecargas de 64 bits de la <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, y <xref:System.Threading.Interlocked.Add%2A> métodos son atómicos realmente sólo en sistemas donde un <xref:System.IntPtr?displayProperty=nameWithType> tiene una longitud de 64 bits. En otros sistemas, estos métodos son atómicos con respecto a entre sí, pero no con respecto a otros medios de acceso a los datos. Por lo tanto, para que sea segura para subprocesos en los sistemas de 32 bits, cualquier acceso a un valor de 64 bits debe realizarse a través de los miembros de la <xref:System.Threading.Interlocked> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece una variable en un valor especificado como una operación atómica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">Variable que se va a establecer en el valor especificado.</param>
        <param name="value">Valor en el que está establecido el parámetro <c>location1</c>.</param>
        <summary>Establece un número de punto flotante de precisión doble en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">Variable que se va a establecer en el valor especificado.</param>
        <param name="value">Valor en el que está establecido el parámetro <c>location1</c>.</param>
        <summary>Establece un entero de 32 bits con signo en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra un mecanismo de bloqueo de recursos seguro para subprocesos.  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">Variable que se va a establecer en el valor especificado.</param>
        <param name="value">Valor en el que está establecido el parámetro <c>location1</c>.</param>
        <summary>Establece un entero de 64 bits con signo en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">Variable que se va a establecer en el valor especificado.</param>
        <param name="value">Valor en el que está establecido el parámetro <c>location1</c>.</param>
        <summary>Establece un puntero o identificador específico de plataforma en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">Variable que se va a establecer en el valor especificado.</param>
        <param name="value">Valor en el que está establecido el parámetro <c>location1</c>.</param>
        <summary>Establece un objeto en un valor especificado y devuelve una referencia al objeto original, como una operación atómica.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!NOTE]
> A partir de .NET Framework versión 2.0, el <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> sobrecarga del método proporciona una alternativa de seguridad de tipos para tipos de referencia.  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">Variable que se va a establecer en el valor especificado.</param>
        <param name="value">Valor en el que está establecido el parámetro <c>location1</c>.</param>
        <summary>Establece un número de punto flotante de precisión sencilla en un valor especificado y devuelve el valor original, como una operación atómica.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">El tipo que se usará para <c>location1</c> y <c>valor</c>. Este tipo debe ser un tipo de referencia.</typeparam>
        <param name="location1">Variable que se va a establecer en el valor especificado. Este es un parámetro de referencia (<see langword="ref" /> en C#, <see langword="ByRef" /> en Visual Basic).</param>
        <param name="value">Valor en el que está establecido el parámetro <c>location1</c>.</param>
        <summary>Establece una variable del tipo <paramref name="T" /> especificado en un valor determinado y devuelve el valor original, como una operación atómica.</summary>
        <returns>Valor original de <paramref name="location1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo admite tipos de referencia. Hay sobrecargas de los <xref:System.Threading.Interlocked.Exchange%2A> método para el <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, y <xref:System.Double> los tipos de valor, pero no hay ninguna compatibilidad con otros tipos de valor.  
  
> [!NOTE]
>  Esta sobrecarga del método es preferible el <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> sobrecarga del método, porque el último requiere acceso enlazado en tiempo de ejecución para el objeto de destino.  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location1" /> es un puntero nulo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aumenta el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Variable cuyo valor se va a incrementar.</param>
        <summary>Aumenta el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
        <returns>Valor incrementado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método controla una condición de desbordamiento mediante un ajuste: si `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>. No se inicia ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente determina cuántos números aleatorios comprendidos entre 0 y 1000 son necesarias para generar números aleatorios 1.000 con un valor de punto medio. Para mantener el seguimiento del número de valores de punto medio, una variable, `midpointCount`, es igual a 0 y se incrementa cada vez que el generador de números aleatorios devuelve un valor de punto medio hasta que llega a 10.000. Dado que tres subprocesos generan los números aleatorios, la <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> método se llama para garantizar que varios subprocesos no se actualicen `midpointCount` simultáneamente. Tenga en cuenta que un bloqueo también se usa para proteger el generador de números aleatorios y que un <xref:System.Threading.CountdownEvent> objeto sirve para asegurarse de que el `Main` método no finaliza la ejecución antes de los tres subprocesos.  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 El ejemplo siguiente es similar al anterior, salvo que usa el <xref:System.Threading.Tasks.Task> clase en lugar de un procedimiento de subproceso para generar 50 000 enteros aleatorios de punto medio. En este ejemplo, una expresión lambda reemplaza el `GenerateNumbers` procedimiento de subproceso y la llamada a la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método elimina la necesidad de la <xref:System.Threading.CountdownEvent> objeto.  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Variable cuyo valor se va a incrementar.</param>
        <summary>Aumenta el valor de una variable especificada y almacena el resultado, como una operación atómica.</summary>
        <returns>Valor incrementado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método controla una condición de desbordamiento mediante un ajuste: si `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>. No se inicia ninguna excepción.  
  
 El <xref:System.Threading.Interlocked.Read%2A> método y las sobrecargas de 64 bits de la <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, y <xref:System.Threading.Interlocked.Add%2A> métodos son atómicos realmente sólo en sistemas donde un <xref:System.IntPtr?displayProperty=nameWithType> tiene una longitud de 64 bits. En otros sistemas, estos métodos son atómicos con respecto a entre sí, pero no con respecto a otros medios de acceso a los datos. Por lo tanto, para que sea segura para subprocesos en los sistemas de 32 bits, cualquier acceso a un valor de 64 bits debe realizarse a través de los miembros de la <xref:System.Threading.Interlocked> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La dirección de <paramref name="location" /> es un puntero nulo.</exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sincroniza el acceso a la memoria de la siguiente forma: el procesador que ejecuta el subproceso actual no puede reordenar instrucciones de forma que los accesos a la memoria anteriores a la llamada a <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> se ejecuten después de los accesos a memoria que siguen a la llamada a <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se agregó a la <xref:System.Threading.Interlocked> clase en el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] como una comodidad; es un contenedor para el <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> método.  
  
 <xref:System.Threading.Interlocked.MemoryBarrier%2A> solo es necesario en sistemas con varios procesadores que tienen una ordenación de memoria débil (por ejemplo, un sistema que emplea varios procesadores Intel Itanium).  
  
 Para la mayoría de los casos, C# `lock` instrucción, Visual Basic `SyncLock` instrucción, o la <xref:System.Threading.Monitor> clase proporcionan formas sencillas para sincronizar los datos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">Valor de 64 bits que se va a cargar.</param>
        <summary>Devuelve un valor de 64 bits, cargado como una operación atómica.</summary>
        <returns>Valor cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Interlocked.Read%2A> método no es necesario en sistemas de 64 bits, ya que las operaciones de lectura de 64 bits ya son atómicas. En los sistemas de 32 bits, 64 bits, las operaciones de lectura no son atómicas a menos que se realiza mediante <xref:System.Threading.Interlocked.Read%2A>.  
  
 El <xref:System.Threading.Interlocked.Read%2A> método y las sobrecargas de 64 bits de la <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, y <xref:System.Threading.Interlocked.Add%2A> métodos son atómicos realmente sólo en sistemas donde un <xref:System.IntPtr?displayProperty=nameWithType> tiene una longitud de 64 bits. En otros sistemas, estos métodos son atómicos con respecto a entre sí, pero no con respecto a otros medios de acceso a los datos. Por lo tanto, para que sea segura para subprocesos en los sistemas de 32 bits, cualquier acceso a un valor de 64 bits debe realizarse a través de los miembros de la <xref:System.Threading.Interlocked> clase.  
  
> [!NOTE]
>  <xref:System.IntPtr> es un tipo específico de la plataforma.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">Interlocked</related>
      </Docs>
    </Member>
  </Members>
</Type>