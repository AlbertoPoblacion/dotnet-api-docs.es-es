<Type Name="ThreadState" FullName="System.Threading.ThreadState">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a93f1275163776d80a243344a4a1beb07c33cc80" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30528629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum ThreadState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed ThreadState extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadState" />
  <TypeSignature Language="VB.NET" Value="Public Enum ThreadState" />
  <TypeSignature Language="C++ CLI" Value="public enum class ThreadState" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Especifica los estados de ejecución de <see cref="T:System.Threading.Thread" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.ThreadState> enumeración es de interés sólo en algunos escenarios de depuración. El código nunca debe usar el estado de los subprocesos para sincronizar las actividades de subprocesos.  
  
 <xref:System.Threading.ThreadState> define un conjunto de todos los Estados de ejecución posibles para los subprocesos. Una vez que se crea un subproceso, encuentra en al menos uno de los Estados hasta que termina. Los subprocesos creados en common language runtime se encuentran inicialmente en el `Unstarted` estado, mientras que los subprocesos externos que entran en el tiempo de ejecución ya están en el `Running` estado. Un `Unstarted` subproceso se ha pasado el `Running` estado mediante una llamada a <xref:System.Threading.Thread.Start%2A>. No todas las combinaciones de `ThreadState` valores son válidos; por ejemplo, un subproceso no puede ser tanto en el `Aborted` y `Unstarted` Estados.  
  
> [!IMPORTANT]
>  Hay dos enumeraciones del estado de subproceso,<xref:System.Threading.ThreadState?displayProperty=nameWithType> y <xref:System.Diagnostics.ThreadState?displayProperty=nameWithType>.  
  
 La siguiente tabla muestra las acciones que provocan un cambio de estado.  
  
|Acción|ThreadState|  
|------------|-----------------|  
|Se crea un subproceso dentro de common language runtime.|Sin comenzar|  
|Otro subproceso llama a la <xref:System.Threading.Thread.Start%2A?displayProperty=nameWithType> devuelve el método en el nuevo subproceso y la llamada.<br /><br /> El <xref:System.Threading.Thread.Start%2A> método no devuelve hasta que el nuevo subproceso ha empezado a ejecutarse. No hay ninguna manera de saber en qué punto el nuevo subproceso empezará a ejecutarse durante la llamada a <xref:System.Threading.Thread.Start%2A>.|En ejecución|  
|Las llamadas de subprocesos <xref:System.Threading.Thread.Sleep%2A>|WaitSleepJoin|  
|El subproceso llama a <xref:System.Threading.Monitor.Wait%2A> en otro objeto.|WaitSleepJoin|  
|El subproceso llama a <xref:System.Threading.Thread.Join%2A> en otro subproceso.|WaitSleepJoin|  
|Otro subproceso llama a <xref:System.Threading.Thread.Interrupt%2A>|En ejecución|  
|Otro subproceso llama a <xref:System.Threading.Thread.Suspend%2A>|SuspendRequested|  
|El subproceso responde a una solicitud <xref:System.Threading.Thread.Suspend%2A>.|Suspendido|  
|Otro subproceso llama a <xref:System.Threading.Thread.Resume%2A>|En ejecución|  
|Otro subproceso llama a <xref:System.Threading.Thread.Abort%2A>|AbortRequested|  
|El subproceso responde a una solicitud <xref:System.Threading.Thread.Abort%2A>.|Detenido|  
|Finaliza un subproceso.|Detenido|  
  
 Además de los Estados que se ha mencionado anteriormente, hay también el `Background` estado, que indica si el subproceso se está ejecutando en el primer plano o de fondo.  
  
 Un subproceso puede estar en más de un estado en un momento dado. Por ejemplo, si un subproceso está bloqueado en una llamada a <xref:System.Threading.Monitor.Wait%2A>y otro subproceso llama a <xref:System.Threading.Thread.Abort%2A> en el subproceso bloqueado, el subproceso bloqueado será tanto en el `WaitSleepJoin` y `AbortRequested` Estados al mismo tiempo. En este caso, tan pronto como el subproceso vuelve de la llamada a <xref:System.Threading.Monitor.Wait%2A> o se interrumpe, recibirá el <xref:System.Threading.ThreadAbortException> para empezar a anular.  
  
 El <xref:System.Threading.Thread.ThreadState%2A?displayProperty=nameWithType> propiedad de un subproceso proporciona el estado actual de un subproceso. Las aplicaciones deben usar una máscara de bits para determinar si un subproceso se está ejecutando. Puesto que el valor de `Running` es cero (0), comprobar si un subproceso se está ejecutando mediante código C# como `(myThread.ThreadState & (ThreadState.Stopped | ThreadState.Unstarted)) == 0` o código de Visual Basic como `(myThread.ThreadState And (ThreadState.Stopped Or ThreadState.Unstarted)) = 0`.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <Member MemberName="Aborted">
      <MemberSignature Language="C#" Value="Aborted" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Aborted = int32(256)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Aborted" />
      <MemberSignature Language="VB.NET" Value="Aborted" />
      <MemberSignature Language="C++ CLI" Value="Aborted" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>256</MemberValue>
      <Docs>
        <summary>El estado del subproceso incluye <see cref="F:System.Threading.ThreadState.AbortRequested" /> y el subproceso está ahora inactivo, pero su estado no ha cambiado todavía a <see cref="F:System.Threading.ThreadState.Stopped" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="AbortRequested">
      <MemberSignature Language="C#" Value="AbortRequested" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState AbortRequested = int32(128)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.AbortRequested" />
      <MemberSignature Language="VB.NET" Value="AbortRequested" />
      <MemberSignature Language="C++ CLI" Value="AbortRequested" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>128</MemberValue>
      <Docs>
        <summary>Se ha invocado al método <see cref="M:System.Threading.Thread.Abort(System.Object)" /> en el subproceso, pero el subproceso aún no ha recibido la excepción <see cref="T:System.Threading.ThreadAbortException" /> pendiente que intentará finalizarlo.</summary>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="Background" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Background = int32(4)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Background" />
      <MemberSignature Language="VB.NET" Value="Background" />
      <MemberSignature Language="C++ CLI" Value="Background" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>El subproceso está ejecutándose como subproceso en segundo plano, por oposición a un subproceso en primer plano. Para controlar este estado, hay que establecer la propiedad <see cref="P:System.Threading.Thread.IsBackground" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="Running">
      <MemberSignature Language="C#" Value="Running" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Running = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Running" />
      <MemberSignature Language="VB.NET" Value="Running" />
      <MemberSignature Language="C++ CLI" Value="Running" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>El subproceso se ha iniciado, no está bloqueado y no existe una excepción <see cref="T:System.Threading.ThreadAbortException" /> pendiente.</summary>
      </Docs>
    </Member>
    <Member MemberName="Stopped">
      <MemberSignature Language="C#" Value="Stopped" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Stopped = int32(16)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Stopped" />
      <MemberSignature Language="VB.NET" Value="Stopped" />
      <MemberSignature Language="C++ CLI" Value="Stopped" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>16</MemberValue>
      <Docs>
        <summary>El subproceso se ha detenido.</summary>
      </Docs>
    </Member>
    <Member MemberName="StopRequested">
      <MemberSignature Language="C#" Value="StopRequested" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState StopRequested = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.StopRequested" />
      <MemberSignature Language="VB.NET" Value="StopRequested" />
      <MemberSignature Language="C++ CLI" Value="StopRequested" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Se ha solicitado que el subproceso se detenga. Esto último sólo se refiere al uso interno.</summary>
      </Docs>
    </Member>
    <Member MemberName="Suspended">
      <MemberSignature Language="C#" Value="Suspended" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Suspended = int32(64)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Suspended" />
      <MemberSignature Language="VB.NET" Value="Suspended" />
      <MemberSignature Language="C++ CLI" Value="Suspended" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>64</MemberValue>
      <Docs>
        <summary>El subproceso se ha suspendido.</summary>
      </Docs>
    </Member>
    <Member MemberName="SuspendRequested">
      <MemberSignature Language="C#" Value="SuspendRequested" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState SuspendRequested = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.SuspendRequested" />
      <MemberSignature Language="VB.NET" Value="SuspendRequested" />
      <MemberSignature Language="C++ CLI" Value="SuspendRequested" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Se ha solicitado que el subproceso se suspenda.</summary>
      </Docs>
    </Member>
    <Member MemberName="Unstarted">
      <MemberSignature Language="C#" Value="Unstarted" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Unstarted = int32(8)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Unstarted" />
      <MemberSignature Language="VB.NET" Value="Unstarted" />
      <MemberSignature Language="C++ CLI" Value="Unstarted" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>8</MemberValue>
      <Docs>
        <summary>No se ha invocado al método <see cref="M:System.Threading.Thread.Start" /> en el subproceso.</summary>
      </Docs>
    </Member>
    <Member MemberName="WaitSleepJoin">
      <MemberSignature Language="C#" Value="WaitSleepJoin" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState WaitSleepJoin = int32(32)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.WaitSleepJoin" />
      <MemberSignature Language="VB.NET" Value="WaitSleepJoin" />
      <MemberSignature Language="C++ CLI" Value="WaitSleepJoin" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>32</MemberValue>
      <Docs>
        <summary>Subproceso bloqueado. Este podría ser el resultado de llamar a <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> o <see cref="M:System.Threading.Thread.Join" />, de solicitar un bloqueo (por ejemplo, llamando a <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> o <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />) o de esperar en un objeto de sincronización de subprocesos como <see cref="T:System.Threading.ManualResetEvent" />.</summary>
      </Docs>
    </Member>
  </Members>
</Type>