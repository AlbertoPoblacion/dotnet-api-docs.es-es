<Type Name="ThreadState" FullName="System.Threading.ThreadState">
  <Metadata><Meta Name="ms.openlocfilehash" Value="656d97a2b505a8d5edf741716b9b074784c35d44" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58725535" /></Metadata><TypeSignature Language="C#" Value="public enum ThreadState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed ThreadState extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadState" />
  <TypeSignature Language="VB.NET" Value="Public Enum ThreadState" />
  <TypeSignature Language="C++ CLI" Value="public enum class ThreadState" />
  <TypeSignature Language="F#" Value="type ThreadState = " />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Especifica los estados de ejecución de <see cref="T:System.Threading.Thread" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  El `ThreadState` enumeración define un conjunto de todos los Estados de ejecución posibles para los subprocesos. Resulta de interés sólo en algunos escenarios de depuración. El código nunca debe usar el estado del subproceso para sincronizar las actividades de subprocesos.  
  
  Una vez que se crea un subproceso, está en al menos uno de los Estados hasta que termina. Los subprocesos creados en common language runtime se encuentran inicialmente en el <xref:System.Threading.ThreadState.Unstarted> estado mientras externo, o no administrada, los subprocesos que entran en el tiempo de ejecución ya están en el <xref:System.Threading.ThreadState.Running> estado. Un subproceso realice la transición desde el <xref:System.Threading.ThreadState.Unstarted> estado en el <xref:System.Threading.ThreadState.Running> estado mediante una llamada a <xref:System.Threading.Thread.Start%2A?displayProperty=nameWithType>. Una vez que un subproceso abandona el estado <xref:System.Threading.ThreadState.Unstarted> como resultado de una llamada a <xref:System.Threading.Thread.Start%2A>, nunca puede volver al estado <xref:System.Threading.ThreadState.Unstarted> .  

  Un subproceso puede estar en más de un estado en un momento dado. Por ejemplo, si un subproceso está bloqueado en una llamada a <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>y otro subproceso llama <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> en el subproceso bloqueado, el subproceso bloqueado estará en ambos el <xref:System.Threading.ThreadState.WaitSleepJoin> y <xref:System.Threading.ThreadState.AbortRequested> Estados al mismo tiempo. En este caso, tan pronto como el subproceso vuelve de la llamada a <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType> o se interrumpe, recibirá el <xref:System.Threading.ThreadAbortException> para empezar a anular. No todas las combinaciones de `ThreadState` valores son válidos; por ejemplo, un subproceso no puede ser tanto en el <xref:System.Threading.ThreadState.Aborted> y <xref:System.Threading.ThreadState.Unstarted> Estados.  

  Un subproceso nunca puede abandonar el estado <xref:System.Threading.ThreadState.Stopped> .  
  
> [!IMPORTANT]
> Hay dos enumeraciones del estado de subproceso: <xref:System.Threading.ThreadState?displayProperty=nameWithType> y <xref:System.Diagnostics.ThreadState?displayProperty=nameWithType>.  
  
 La siguiente tabla muestra las acciones que provocan un cambio de estado.  
  
|Acción|ThreadState|  
|------------|-----------------|  
|Se crea un subproceso dentro de common language runtime.|<xref:System.Threading.ThreadState.Unstarted>|  
|Otro subproceso llama a la <xref:System.Threading.Thread.Start%2A?displayProperty=nameWithType> devuelve el método en el nuevo subproceso y la llamada.<br /><br /> El <xref:System.Threading.Thread.Start%2A> método no vuelve hasta que el nuevo subproceso ha empezado a ejecutarse. No hay ninguna manera de saber en qué punto se iniciará el nuevo subproceso está ejecutando, durante la llamada a <xref:System.Threading.Thread.Start%2A>.|<xref:System.Threading.ThreadState.Running>|  
|El subproceso llama a <xref:System.Threading.Thread.Sleep%2A>|<xref:System.Threading.ThreadState.WaitSleepJoin>|  
|El subproceso llama a <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType> en otro objeto.|<xref:System.Threading.ThreadState.WaitSleepJoin>|  
|El subproceso llama a <xref:System.Threading.Thread.Join%2A> en otro subproceso.|<xref:System.Threading.ThreadState.WaitSleepJoin>|  
|Otro subproceso llama a <xref:System.Threading.Thread.Interrupt%2A>|<xref:System.Threading.ThreadState.Running>|  
|Otro subproceso llama a <xref:System.Threading.Thread.Suspend%2A>|<xref:System.Threading.ThreadState.SuspendRequested>|  
|El subproceso responde a una solicitud <xref:System.Threading.Thread.Suspend%2A>.|<xref:System.Threading.ThreadState.Suspended>|  
|Otro subproceso llama a <xref:System.Threading.Thread.Resume%2A>|<xref:System.Threading.ThreadState.Running>|  
|Otro subproceso llama a <xref:System.Threading.Thread.Abort%2A>|<xref:System.Threading.ThreadState.AbortRequested>|  
|El subproceso responde a un <xref:System.Threading.Thread.Abort%2A> solicitud.|<xref:System.Threading.ThreadState.Stopped>|  
|Finaliza un subproceso.|<xref:System.Threading.ThreadState.Stopped>|  
  
 Además de los Estados que se ha indicado anteriormente, también hay la <xref:System.Threading.ThreadState.Background> estado, que indica si se está ejecutando el subproceso en segundo plano o primer plano. Para obtener más información, vea [Subprocesos de primer y segundo plano](~/docs/standard/threading/foreground-and-background-threads.md).  
   
 El <xref:System.Threading.Thread.ThreadState%2A?displayProperty=nameWithType> propiedad de un subproceso proporciona el estado actual de un subproceso. Las aplicaciones deben usar una máscara de bits para determinar si un subproceso se está ejecutando. Puesto que el valor de <xref:System.Threading.ThreadState.Running> es cero (0), comprobar si un subproceso se está ejecutando en el código siguiente:

```csharp
(myThread.ThreadState & (ThreadState.Stopped | ThreadState.Unstarted)) == 0
```

```vb
(myThread.ThreadState And (ThreadState.Stopped Or ThreadState.Unstarted)) = 0
```
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <Member MemberName="Aborted">
      <MemberSignature Language="C#" Value="Aborted" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Aborted = int32(256)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Aborted" />
      <MemberSignature Language="VB.NET" Value="Aborted" />
      <MemberSignature Language="C++ CLI" Value="Aborted" />
      <MemberSignature Language="F#" Value="Aborted = 256" Usage="System.Threading.ThreadState.Aborted" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>256</MemberValue>
      <Docs>
        <summary>El estado del subproceso incluye <see cref="F:System.Threading.ThreadState.AbortRequested" /> y el subproceso está ahora inactivo, pero su estado no ha cambiado todavía a <see cref="F:System.Threading.ThreadState.Stopped" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="AbortRequested">
      <MemberSignature Language="C#" Value="AbortRequested" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState AbortRequested = int32(128)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.AbortRequested" />
      <MemberSignature Language="VB.NET" Value="AbortRequested" />
      <MemberSignature Language="C++ CLI" Value="AbortRequested" />
      <MemberSignature Language="F#" Value="AbortRequested = 128" Usage="System.Threading.ThreadState.AbortRequested" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>128</MemberValue>
      <Docs>
        <summary>Se ha invocado al método <see cref="M:System.Threading.Thread.Abort(System.Object)" /> en el subproceso, pero el subproceso aún no ha recibido la excepción <see cref="T:System.Threading.ThreadAbortException" /> pendiente que intentará finalizarlo.</summary>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="Background" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Background = int32(4)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Background" />
      <MemberSignature Language="VB.NET" Value="Background" />
      <MemberSignature Language="C++ CLI" Value="Background" />
      <MemberSignature Language="F#" Value="Background = 4" Usage="System.Threading.ThreadState.Background" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>El subproceso está ejecutándose como subproceso en segundo plano, por oposición a un subproceso en primer plano. Para controlar este estado, hay que establecer la propiedad <see cref="P:System.Threading.Thread.IsBackground" />.</summary>
      </Docs>
    </Member>
    <Member MemberName="Running">
      <MemberSignature Language="C#" Value="Running" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Running = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Running" />
      <MemberSignature Language="VB.NET" Value="Running" />
      <MemberSignature Language="C++ CLI" Value="Running" />
      <MemberSignature Language="F#" Value="Running = 0" Usage="System.Threading.ThreadState.Running" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>El subproceso se ha iniciado y aún no se ha detenido.</summary>
      </Docs>
    </Member>
    <Member MemberName="Stopped">
      <MemberSignature Language="C#" Value="Stopped" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Stopped = int32(16)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Stopped" />
      <MemberSignature Language="VB.NET" Value="Stopped" />
      <MemberSignature Language="C++ CLI" Value="Stopped" />
      <MemberSignature Language="F#" Value="Stopped = 16" Usage="System.Threading.ThreadState.Stopped" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>16</MemberValue>
      <Docs>
        <summary>El subproceso se ha detenido.</summary>
      </Docs>
    </Member>
    <Member MemberName="StopRequested">
      <MemberSignature Language="C#" Value="StopRequested" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState StopRequested = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.StopRequested" />
      <MemberSignature Language="VB.NET" Value="StopRequested" />
      <MemberSignature Language="C++ CLI" Value="StopRequested" />
      <MemberSignature Language="F#" Value="StopRequested = 1" Usage="System.Threading.ThreadState.StopRequested" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Se ha solicitado que el subproceso se detenga. Esto último sólo se refiere al uso interno.</summary>
      </Docs>
    </Member>
    <Member MemberName="Suspended">
      <MemberSignature Language="C#" Value="Suspended" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Suspended = int32(64)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Suspended" />
      <MemberSignature Language="VB.NET" Value="Suspended" />
      <MemberSignature Language="C++ CLI" Value="Suspended" />
      <MemberSignature Language="F#" Value="Suspended = 64" Usage="System.Threading.ThreadState.Suspended" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>64</MemberValue>
      <Docs>
        <summary>El subproceso se ha suspendido.</summary>
      </Docs>
    </Member>
    <Member MemberName="SuspendRequested">
      <MemberSignature Language="C#" Value="SuspendRequested" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState SuspendRequested = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.SuspendRequested" />
      <MemberSignature Language="VB.NET" Value="SuspendRequested" />
      <MemberSignature Language="C++ CLI" Value="SuspendRequested" />
      <MemberSignature Language="F#" Value="SuspendRequested = 2" Usage="System.Threading.ThreadState.SuspendRequested" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Se ha solicitado que el subproceso se suspenda.</summary>
      </Docs>
    </Member>
    <Member MemberName="Unstarted">
      <MemberSignature Language="C#" Value="Unstarted" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState Unstarted = int32(8)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.Unstarted" />
      <MemberSignature Language="VB.NET" Value="Unstarted" />
      <MemberSignature Language="C++ CLI" Value="Unstarted" />
      <MemberSignature Language="F#" Value="Unstarted = 8" Usage="System.Threading.ThreadState.Unstarted" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>8</MemberValue>
      <Docs>
        <summary>No se ha invocado al método <see cref="M:System.Threading.Thread.Start" /> en el subproceso.</summary>
      </Docs>
    </Member>
    <Member MemberName="WaitSleepJoin">
      <MemberSignature Language="C#" Value="WaitSleepJoin" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.ThreadState WaitSleepJoin = int32(32)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.ThreadState.WaitSleepJoin" />
      <MemberSignature Language="VB.NET" Value="WaitSleepJoin" />
      <MemberSignature Language="C++ CLI" Value="WaitSleepJoin" />
      <MemberSignature Language="F#" Value="WaitSleepJoin = 32" Usage="System.Threading.ThreadState.WaitSleepJoin" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <MemberValue>32</MemberValue>
      <Docs>
        <summary>Subproceso bloqueado. Este podría ser el resultado de llamar a <see cref="M:System.Threading.Thread.Sleep(System.Int32)" /> o <see cref="M:System.Threading.Thread.Join" />, de solicitar un bloqueo (por ejemplo, llamando a <see cref="M:System.Threading.Monitor.Enter(System.Object)" /> o <see cref="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />) o de esperar en un objeto de sincronización de subprocesos como <see cref="T:System.Threading.ManualResetEvent" />.</summary>
      </Docs>
    </Member>
  </Members>
</Type>