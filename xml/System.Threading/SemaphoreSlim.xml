<Type Name="SemaphoreSlim" FullName="System.Threading.SemaphoreSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="268af4ec18ef9780af942f18f0369318755e0b83" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061747" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SemaphoreSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SemaphoreSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class SemaphoreSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Current Count = {m_currentCount}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una alternativa ligera a <see cref="T:System.Threading.Semaphore" /> que limita el número de subprocesos que puede obtener acceso a la vez a un recurso o a un grupo de recursos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Semáforos son de dos tipos: semáforos locales y semáforos de sistema con nombre. El primero es local a una aplicación. Este último está visible en todo el sistema operativo y es adecuado para la sincronización entre procesos. El <xref:System.Threading.SemaphoreSlim> es una alternativa ligera a la <xref:System.Threading.Semaphore> clase que no utilice semáforos de kernel de Windows. A diferencia de la <xref:System.Threading.Semaphore> (clase), el <xref:System.Threading.SemaphoreSlim> clase no es compatible con los semáforos de sistema con nombre. Puede usarlo como un semáforo local únicamente. La <xref:System.Threading.SemaphoreSlim> clase es el semáforo recomendado para la sincronización en una sola aplicación.  
  
 Un semáforo ligero controla el acceso a un grupo de recursos que es local para la aplicación. Cuando crea una instancia de un semáforo, puede especificar el número máximo de subprocesos que pueden entrar en el semáforo simultáneamente. Especificar el número inicial de subprocesos que pueden entrar en el semáforo simultáneamente. Esto define el recuento del semáforo.  
  
 El recuento se reduce de cada vez que un subproceso entra en el semáforo e incrementa cada vez que un subproceso libere el semáforo. Para entrar en el semáforo, un subproceso llama a uno de los <xref:System.Threading.SemaphoreSlim.Wait%2A> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> sobrecargas. Para liberar el semáforo, llama a uno de los <xref:System.Threading.SemaphoreSlim.Release%2A> sobrecargas. Cuando el recuento llega a cero, las llamadas subsiguientes a uno de los `Wait` métodos se bloquean hasta que otros subprocesos liberan el semáforo. Si varios subprocesos se bloquean, no hay ningún orden garantizado, como FIFO o LIFO, que controla cuándo subprocesos entran en el semáforo.  
  
 La estructura básica para el código que utiliza un semáforo para proteger los recursos es:  
  
```vb  
  
' Enter semaphore by calling one of the Wait or WaitAsync methods.  
SemaphoreSlim.Wait()  
'   
' Execute code protected by the semaphore.   
'  
SemaphoreSlim.Release()  
  
```  
  
 Cuando todos los subprocesos han liberado el semáforo, el recuento es el valor máximo especificado cuando se creó el semáforo. El recuento del semáforo está disponible en la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad.  
  
> [!IMPORTANT]
>  El <xref:System.Threading.SemaphoreSlim> clase no exige la identidad del subproceso o una tarea en las llamadas a la <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>, y <xref:System.Threading.SemaphoreSlim.Release%2A> métodos. Además, si la <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29> constructor se utiliza para crear una instancia de la <xref:System.Threading.SemaphoreSlim> objeto, el <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> puede aumentar la propiedad por encima del valor establecido por el constructor. Es responsabilidad del programador asegurarse de que las llamadas a <xref:System.Threading.SemaphoreSlim.Wait%2A> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> métodos están correctamente emparejados con llamadas a <xref:System.Threading.SemaphoreSlim.Release%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un semáforo con un recuento máximo de tres subprocesos y un recuento inicial de cero subprocesos. El ejemplo inicia cinco tareas, todos ellos bloquear la espera para el semáforo. El subproceso principal llama el <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> sobrecarga para aumentar el recuento del semáforo a su máximo, que permite que las tres tareas entrar en el semáforo. Cada vez que se libera el semáforo, se muestra el recuento del semáforo anterior. Uso del semáforo del seguimiento mensajes de consola. El intervalo de trabajo simulado aumenta ligeramente por cada subproceso facilitar la lectura de la salida.  
  
 [!code-csharp[System.Threading.SemaphoreSlim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.semaphoreslim/cs/example.cs#1)]
 [!code-vb[System.Threading.SemaphoreSlim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.semaphoreslim/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros públicos y protegidos de <see cref="T:System.Threading.SemaphoreSlim" /> son seguras para subprocesos y se pueden usar simultáneamente desde varios subprocesos, con la excepción de <see cref="M:System.Threading.SemaphoreSlim.Dispose" />, que debe usarse solo cuando todas las demás operaciones en el <see cref="T:System.Threading.SemaphoreSlim" /> ha completado.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreSlim" />, especificando el número inicial de solicitudes que se pueden conceder simultáneamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `initialCount` parámetro define el número de solicitudes simultáneas para entrar en el semáforo que se pueden conceder. Sin embargo, no define el número máximo de solicitudes que se pueden conceder simultáneamente. A <xref:System.Threading.SemaphoreSlim> objeto crea una instancia mediante una llamada a este constructor no produce una excepción un <xref:System.Threading.SemaphoreFullException> excepción si una llamada a la <xref:System.Threading.SemaphoreSlim.Release%2A> método aumenta el valor de la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad más allá de `initialCount`. Esto sucede si hay más llamadas a <xref:System.Threading.SemaphoreSlim.Release%2A> métodos que allí <xref:System.Threading.SemaphoreSlim.Wait%2A> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> métodos. Para establecer el número máximo de solicitudes simultáneas para entrar en el semáforo que se pueden conceder, llame a la <xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCount" /> es menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount, int maxCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maxCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maxCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount, int maxCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maxCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
        <param name="maxCount">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.SemaphoreSlim" />, especificando el número inicial y máximo de solicitudes que se pueden conceder simultáneamente.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCount" /> es menor que 0, <paramref name="initialCount" /> es mayor que <paramref name="maxCount" />, o <paramref name="maxCount" /> es igual o menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="AvailableWaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle AvailableWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AvailableWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ AvailableWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Threading.WaitHandle" /> que se puede usar para esperar en el semáforo.</summary>
        <value>
          <see cref="T:System.Threading.WaitHandle" /> que se puede usar para esperar en el semáforo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad sólo cuando se debe esperar a SemaphoreSlim junto con otros objetos de sincronización basada en kernel con el mismo identificador de espera. Una espera correcta en el <xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A> no implica una espera correcta en el <xref:System.Threading.SemaphoreSlim> , ni que disminuya el recuento del semáforo. Después de que se señala el identificador de espera disponibles, debe esperar el <xref:System.Threading.SemaphoreSlim> específicamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado <see cref="T:System.Threading.SemaphoreSlim" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentCount">
      <MemberSignature Language="C#" Value="public int CurrentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de subprocesos restantes que puede introducir el objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <value>Obtiene el número de subprocesos restantes que pueden entrar en el semáforo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor inicial de la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad se establece mediante la llamada a la <xref:System.Threading.SemaphoreSlim.%23ctor%2A> constructor de clase. Disminuye por cada llamada a la <xref:System.Threading.SemaphoreSlim.Wait%2A> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> método y se incrementa en cada llamada a la <xref:System.Threading.SemaphoreSlim.Release%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera los recursos que usa la instancia actual de la clase <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a `Dispose` cuando haya terminado de usar <xref:System.Threading.SemaphoreSlim>. El método `Dispose` deja el <xref:System.Threading.SemaphoreSlim> en un estado no utilizable. Después de llamar a `Dispose`, debe liberar todas las referencias a la <xref:System.Threading.SemaphoreSlim> para que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Threading.SemaphoreSlim> estaba ocupando.  
  
 Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a `Dispose` antes de liberar la última referencia al objeto <xref:System.Threading.SemaphoreSlim>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Threading.SemaphoreSlim> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Threading.SemaphoreSlim" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la mayoría de los miembros de <xref:System.Threading.SemaphoreSlim>, <xref:System.Threading.SemaphoreSlim.Dispose%2A> no es segura para subprocesos y no puede usarse simultáneamente con otros miembros de esta instancia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera el objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera una vez el objeto <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <returns>Recuento anterior de <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Threading.SemaphoreSlim.Release> método aumenta la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad en uno. Si el valor de la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad es cero antes de llama a este método, el método también permite que un subproceso o tarea bloqueada por una llamada a la <xref:System.Threading.SemaphoreSlim.Wait%2A> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> método para entrar en el semáforo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <see cref="T:System.Threading.SemaphoreSlim" /> ya ha alcanzado su tamaño máximo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Número de veces que se abandona el semáforo.</param>
        <summary>Libera el objeto <see cref="T:System.Threading.SemaphoreSlim" /> un número especificado de veces.</summary>
        <returns>Recuento anterior de <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29> método aumenta la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad `releaseCount`. Si el valor de la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad es cero antes de llama a este método, el método también permite `releaseCount` subproceso o tarea bloqueada por una llamada a la <xref:System.Threading.SemaphoreSlim.Wait%2A> o <xref:System.Threading.SemaphoreSlim.WaitAsync%2A> método para entrar en el semáforo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> es menor que 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <see cref="T:System.Threading.SemaphoreSlim" /> ya ha alcanzado su tamaño máximo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una tarea o subproceso puede entrar en el semáforo, se reduce la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad en uno.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" />(-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
        <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />, usando un entero de 32 bits con signo que especifica el tiempo de espera.</summary>
        <returns>
          Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 
Si el tiempo de espera se establece en-1 milisegundos, el método espera indefinidamente.
 
Si el tiempo de espera se establece en cero milisegundos, que el método no bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente.

Si una tarea o subproceso puede entrar en el semáforo, se reduce la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad en uno.  
  
Si una tarea o subproceso se bloquea cuando se llama a <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29> y el intervalo de tiempo de espera especificado por `millisecondsTimeout` caduca:

- El subproceso o tarea no entrar en el semáforo.
- El <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad no es reducida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
        <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />, mientras se observa un elemento <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una tarea o subproceso puede entrar en el semáforo, se reduce la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad en uno.  
  
 Si `cancellationToken` está cancelado, el subproceso o tarea no entran en el semáforo y el <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad no es reducida. En su lugar, el método produce una <xref:System.OperationCanceledException> excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          Se canceló <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.  
  
 O bien  
  
 El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
        <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />, usando <see cref="T:System.TimeSpan" /> para especificar el tiempo de espera.</summary>
        <returns>
          Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Si el tiempo de espera se establece en-1 milisegundos, el método espera indefinidamente.
 
Si el tiempo de espera se establece en cero milisegundos, que el método no bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente. 
 
Si una tarea o subproceso puede entrar en el semáforo, se reduce la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad en uno.  
  
Si una tarea o subproceso se bloquea cuando se llama a <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29> y el intervalo de tiempo de espera especificado por `millisecondsTimeout` caduca:

- El subproceso o tarea no entrar en el semáforo.
- El <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad no es reducida.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La instancia semaphoreSlim se ha eliminado <paramref name="." /></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" />(-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
        <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />, usando un entero de 32 bits con signo que especifica el tiempo de espera mientras se observa un elemento <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>
          Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Si el tiempo de espera se establece en-1 milisegundos, el método espera indefinidamente.
 
Si el tiempo de espera se establece en cero milisegundos, que el método no bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente.

Si una tarea o subproceso puede entrar en el semáforo, se reduce la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad en uno.  
  
Si `cancellationToken` se cancela, o si se bloquea un subproceso o una tarea cuando se llama a <xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> y el intervalo de tiempo de espera especificado por `millisecondsTimeout` caduca:

- El subproceso o tarea no entrar en el semáforo.
- El <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad no es reducida.  
 
Si `cancellationToken` está cancelado, el método produce una <xref:System.OperationCanceledException> excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          Se canceló <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado la instancia <see cref="T:System.Threading.SemaphoreSlim" /> o se ha eliminado el <see cref="T:System.Threading.CancellationTokenSource" /> que ha creado <paramref name="cancellationToken" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
        <summary>Bloquea el subproceso actual hasta que pueda introducir <see cref="T:System.Threading.SemaphoreSlim" />, usando un <see cref="T:System.TimeSpan" /> que especifica el tiempo de espera mientras se observa un elemento <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>
          Es <see langword="true" /> si el subproceso actual entró correctamente en <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Si el tiempo de espera se establece en-1 milisegundos, el método espera indefinidamente.
 
Si el tiempo de espera se establece en cero milisegundos, que el método no bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente. 

Si una tarea o subproceso puede entrar en el semáforo, se reduce la <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad en uno.  
  
Si `cancellationToken` se cancela, o si se bloquea un subproceso o una tarea cuando se llama a <xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> y el intervalo de tiempo de espera especificado por `millisecondsTimeout` caduca:

- El subproceso o tarea no entrar en el semáforo.
- El <xref:System.Threading.SemaphoreSlim.CurrentCount%2A> propiedad no es reducida.  

Si `cancellationToken` está cancelado, el método produce una <xref:System.OperationCanceledException> excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          Se canceló <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado la instancia semaphoreSlim <paramref name="." /><paramref name="-or-" />  
  
 El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>De forma asincrónica espera que se introduzca <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>De forma asincrónica espera que se introduzca <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
        <returns>Tarea que se completará cuando se entre en el semáforo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (millisecondsTimeout As Integer) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
        <summary>De forma asincrónica espera que se introduzca <see cref="T:System.Threading.SemaphoreSlim" />, usando un entero de 32 bits para medir el intervalo de tiempo.</summary>
        <returns>Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el tiempo de espera se establece en-1 milisegundos, el método espera indefinidamente.
 
 Si el tiempo de espera se establece en cero milisegundos, que el método no bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
        <summary>De forma asincrónica, espera introducir <see cref="T:System.Threading.SemaphoreSlim" />, mientras observa un elemento <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Tarea que se completará cuando se entre en el semáforo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.OperationCanceledException">
          Se canceló <paramref name="cancellationToken" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (timeout As TimeSpan) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
        <summary>De forma asincrónica, espera introducir <see cref="T:System.Threading.SemaphoreSlim" />, usando un <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo.</summary>
        <returns>Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el tiempo de espera se establece en-1 milisegundos, el método espera indefinidamente.
 
 Si el tiempo de espera se establece en cero milisegundos, que el método no bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">El número de milisegundos que hay que esperar: <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente o cero para comprobar el estado del identificador de espera y volver inmediatamente.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
        <summary>De forma asincrónica, espera introducir <see cref="T:System.Threading.SemaphoreSlim" />, usando un entero de 32 bits para medir el intervalo de tiempo, mientras observa un elemento <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el tiempo de espera se establece en-1 milisegundos, el método espera indefinidamente.
 
 Si el tiempo de espera se establece en cero milisegundos, que el método no bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado la instancia actual.</exception>
        <exception cref="T:System.OperationCanceledException">
          Se canceló <paramref name="cancellationToken" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">Un <see cref="T:System.TimeSpan" /> que representa el número de milisegundos que hay que esperar: <see cref="T:System.TimeSpan" /> representa -1 milisegundos para esperar indefinidamente o <see cref="T:System.TimeSpan" /> representa 0 milisegundos para comprobar el identificador de espera y volver inmediatamente.</param>
        <param name="cancellationToken">Token <see cref="T:System.Threading.CancellationToken" /> que se va a observar.</param>
        <summary>De forma asincrónica, espera introducir <see cref="T:System.Threading.SemaphoreSlim" />, usando un <see cref="T:System.TimeSpan" /> para medir el intervalo de tiempo, mientras observa un elemento <see cref="T:System.Threading.CancellationToken" />.</summary>
        <returns>Tarea que se completará con un resultado <see langword="true" /> si el subproceso actual introdujo correctamente <see cref="T:System.Threading.SemaphoreSlim" />; de lo contrario, el resultado será <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el tiempo de espera se establece en-1 milisegundos, el método espera indefinidamente.

 Si el tiempo de espera se establece en cero milisegundos, que el método no bloquea. Comprueba el estado del identificador de espera y vuelve inmediatamente. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1, que representa un tiempo de espera infinito, o el tiempo de espera es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          Se canceló <paramref name="cancellationToken" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>