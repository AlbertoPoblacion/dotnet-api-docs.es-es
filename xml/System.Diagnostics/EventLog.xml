<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cddf1c04c07302ffae82270967f7c9c372cd50df" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49158517" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona interacción con los registros de eventos de Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> le permite tener acceso o personalizar los registros de eventos de Windows, que registran información sobre eventos importantes de software o hardware. Uso de <xref:System.Diagnostics.EventLog>, puede leer los registros existentes, escribir entradas en los registros, crear o eliminar orígenes de eventos, eliminar los registros y responder a entradas de registro. También puede crear nuevos registros al crear un origen de eventos.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 Además de proporcionar acceso a registros de eventos individuales y sus entradas, la <xref:System.Diagnostics.EventLog> clase le permite tener acceso a la colección de todos los registros de eventos. Puede usar el `static` los miembros de <xref:System.Diagnostics.EventLog> para eliminar registros, obtener listas de registros, crear o eliminar un origen o determinar si un equipo ya contiene un origen determinado.  
  
 Hay tres registros de eventos de forma predeterminada: aplicación, sistema y seguridad. Un registro de seguridad es de solo lectura. Otras aplicaciones y servicios que se instale, como Active Directory, podrían tener registros de eventos adicionales.  
  
 Existen consideraciones de seguridad al usar el <xref:System.Diagnostics.EventLog> clase. <xref:System.Diagnostics.EventLog> requiere <xref:System.Diagnostics.EventLogPermission> permisos para acciones específicas en .NET Framework 2.0 y versiones posteriores, o de plena confianza en .NET Framework 1.0 y 1.1. Se recomienda que <xref:System.Diagnostics.EventLogPermission> no se conceden al código de confianza parcial.  Nunca se debe pasar cualquier objeto de registro de eventos, incluidos <xref:System.Diagnostics.EventLogEntryCollection> y <xref:System.Diagnostics.EventLogEntry> objetos al código de menor confianza. Por ejemplo, creando un <xref:System.Diagnostics.EventLog> objeto, escribir una entrada y, a continuación, pasar la <xref:System.Diagnostics.EventLog> objeto para el código de confianza parcial puede crear un problema de seguridad, puesto que la capacidad de leer y escribir en el registro de eventos permite realizar acciones como la emisión de código mensajes de registro de eventos en el nombre de otra aplicación.  
  
 A partir de Windows Vista, Control de cuentas de usuario (UAC) determina las credenciales de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código de acceso al registro de seguridad, primero debe elevar sus credenciales de usuario estándar a administrador. Puede hacerlo al iniciar una aplicación, abra el menú contextual de la aplicación (si está usando un mouse, haga clic en el icono de aplicación) y que indica que desea ejecutar como administrador.  
  
 Puede usar <xref:System.Diagnostics.EventLog> para crear registros de eventos personalizados que puede ver a través del servidor del Visor de eventos. Use el <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> método para mostrar un nombre localizado para el registro de eventos en el Visor de eventos. Use el <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método para configurar el comportamiento de su registro de eventos cuando alcanza su tamaño máximo del registro.  
  
 Para leer de un registro de eventos, especifique el nombre del registro (<xref:System.Diagnostics.EventLog.Log%2A> propiedad) y el nombre de equipo del servidor (<xref:System.Diagnostics.EventLog.MachineName%2A> propiedad para el registro de eventos. Si no se especifica el nombre del equipo servidor, el equipo local, ".", se da por hecho. No es necesario especificar el origen del evento (<xref:System.Diagnostics.EventLog.Source%2A> propiedad), ya que es necesario solo para escribir en los registros de un origen. El <xref:System.Diagnostics.EventLog.Entries%2A> propiedad se rellena automáticamente con la lista del registro de eventos de entradas.  
  
 Para escribir en un registro de eventos, especificar o crear un origen de eventos (<xref:System.Diagnostics.EventLog.Source%2A> propiedad). Debe tener credenciales administrativas en el equipo para crear un nuevo origen de eventos. El origen del evento registra la aplicación con el registro de eventos como un origen válido de entradas. Puede usar el origen de eventos para escribir en un único registro a la vez. El <xref:System.Diagnostics.EventLog.Source%2A> propiedad puede ser cualquier cadena aleatoria, pero el nombre debe ser diferente de otros orígenes en el equipo. El origen del evento normalmente es el nombre de la aplicación u otra cadena de identificación. Al intentar crear un duplicado <xref:System.Diagnostics.EventLog.Source%2A> valor produce una excepción. Sin embargo, un único registro de eventos puede asociarse con varios orígenes.  
  
 Si el origen de eventos para el registro de eventos asociados con el <xref:System.Diagnostics.EventLog> instancia no existe, se crea un nuevo origen de eventos. Para crear un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener credenciales administrativas.  
  
 Este requisito es porque todos los registros de eventos, incluidos los registros de seguridad, se debe buscar para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tiene permiso para acceder al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
  
> [!IMPORTANT]
>  Creación o eliminación de un origen de eventos requiere la sincronización del código subyacente mediante el uso de una exclusión mutua con nombre. Si una aplicación con muchos privilegios bloquea la exclusión mutua con nombre, se intenta crear o eliminar un origen de eventos hace que la aplicación deje de responder hasta que se libere el bloqueo. Para evitar este problema, no conceder nunca <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permiso al código de confianza. Además, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permiso potencialmente permite omitir otros permisos y solo debe concederse al código de plena confianza.  
  
 En el registro de aplicación o en un registro personalizado, deben escribir aplicaciones y servicios. Deben escribir controladores de dispositivo en el registro del sistema. Si no establece explícitamente el <xref:System.Diagnostics.EventLog.Log%2A> propiedad, el registro de eventos como el valor predeterminado para el registro de aplicación.  
  
> [!NOTE]
>  No hay nada para proteger una aplicación desde la escritura de cualquier origen registrado.  Si se concede a una aplicación <xref:System.Diagnostics.EventLogPermissionAccess.Write> permiso, puede escribir eventos para cualquier origen válido registrado en el equipo.  
  
 Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> métodos para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no se ha actualizado la lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller> objeto o el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener credenciales administrativas en el equipo para crear un nuevo origen de eventos.  
  
 Cada origen puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, su aplicación puede requerir configurados para los diferentes registros de eventos o archivos de recursos de varios orígenes. Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada en lugar de eliminar el origen existente.  
  
 Puede registrar el origen de eventos con los recursos localizados para las cadenas de categoría y el mensaje de evento. La aplicación puede escribir entradas de registro de eventos mediante el uso de identificadores de recursos en lugar de especificar los valores de cadena real. Hacer referencia a la <xref:System.Diagnostics.EventLogInstaller> y <xref:System.Diagnostics.EventSourceCreationData> clases para obtener más información acerca de cómo configurar el origen con archivos de recursos.  
  
 Si su aplicación escribe los valores de cadena directamente en el registro de eventos, no es necesario establecer las propiedades de archivo para el origen de recurso. El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
 Al escribir los eventos, debe especificar al menos una cadena de mensaje o el identificador de recurso para una cadena de mensaje. Otras propiedades de evento son opcionales. Ejemplos de configuración opcional de eventos incluyen lo siguiente:  
  
-   Puede establecer el <xref:System.Diagnostics.EventLogEntryType> para especificar el icono que muestra el Visor de eventos para la entrada.  
  
-   Puede especificar un identificador de categoría para el evento, si la aplicación utiliza categorías para filtrar los eventos.  
  
-   Puede adjuntar datos binarios a la entrada del evento si desea asociar información adicional a un evento determinado.  
  
> [!IMPORTANT]
>  Registro de eventos consume espacio en disco, el tiempo de procesador y otros recursos del sistema. Es importante registrar solamente información esencial. Se recomienda que coloque las llamadas de registro de eventos en una ruta de acceso de error, en lugar de en la ruta de acceso del código principal, por lo tanto no afectar negativamente al rendimiento.  
  
 Para obtener una lista de valores de propiedad iniciales de una instancia de <xref:System.Diagnostics.EventLog>, consulte el <xref:System.Diagnostics.EventLog.%23ctor%2A> constructor.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen del evento `MySource` si ya no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
> [!NOTE]
>  A partir de Windows Vista, debe ejecutar esta aplicación como administrador.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />. No asocia la instancia a ningún registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de llamar a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de la <xref:System.Diagnostics.EventLog> instancia. Si solo va a leer <xref:System.Diagnostics.EventLog.Entries%2A> desde el registro, o bien puede especificar solo el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Diagnostics.EventLog>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Cadena vacía ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Cadena vacía ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|El equipo local (".").|  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro en el equipo local.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />. Asocia la instancia a un registro del equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga establece el <xref:System.Diagnostics.EventLog.Log%2A> propiedad a la `logName` parámetro. Antes de llamar a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de la <xref:System.Diagnostics.EventLog> instancia. Si solo va a leer <xref:System.Diagnostics.EventLog.Entries%2A> desde el registro, o bien puede especificar solo el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho. Esta sobrecarga del constructor especifica el <xref:System.Diagnostics.EventLog.Log%2A> propiedad, pero puede cambiar esto antes de leer el <xref:System.Diagnostics.EventLog.Entries%2A> propiedad.  
  
 Si el origen se especifica en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad es exclusivo de otros orígenes en el equipo, una llamada subsiguiente a <xref:System.Diagnostics.EventLog.WriteEntry%2A> crea un registro con el nombre especificado, si aún no existe.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Diagnostics.EventLog>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Cadena vacía ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parámetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|El equipo local (".").|  
  
   
  
## Examples  
 El ejemplo siguiente lee las entradas del registro de eventos, "myNewLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El nombre del registro es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del registro no es válido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro en el equipo especificado.</param>
        <param name="machineName">Equipo en el que existe el registro.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />. Asocia la instancia a un registro en el equipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga establece el <xref:System.Diagnostics.EventLog.Log%2A> propiedad a la `logName` parámetro y el <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad a la `machineName` parámetro. Antes de llamar a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de la <xref:System.Diagnostics.EventLog>. Si solo va a leer <xref:System.Diagnostics.EventLog.Entries%2A> desde el registro, o bien puede especificar solo el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades.  
  
> [!NOTE]
>  Esta sobrecarga del constructor especifica el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades, pero puede cambiar antes de leer el <xref:System.Diagnostics.EventLog.Entries%2A> propiedad.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Diagnostics.EventLog>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Cadena vacía ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parámetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Parámetro `machineName`.|  
  
   
  
## Examples  
 El ejemplo siguiente lee las entradas del registro de eventos, "myNewLog", en el equipo "myServer".  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El nombre del registro es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del registro no es válido.  
  
O bien 
El nombre de equipo no es válido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro en el equipo especificado.</param>
        <param name="machineName">Equipo en el que existe el registro.</param>
        <param name="source">Origen de las entradas del registro de eventos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />. Asocia la instancia a un registro en el equipo especificado y crea o asigna el origen especificado a <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor establece la <xref:System.Diagnostics.EventLog.Log%2A> propiedad a la `logName` parámetro, el <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad a la `machineName` parámetro y el <xref:System.Diagnostics.EventLog.Source%2A> propiedad a la `source` parámetro. El <xref:System.Diagnostics.EventLog.Source%2A> propiedad es necesaria cuando se escribe en un registro de eventos. Sin embargo, si solo está leyendo desde un registro de eventos, sólo el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades son necesarias (siempre y cuando el registro de eventos en el servidor tiene ya un origen asociado con él). Si solo está leyendo desde el registro de eventos, otra sobrecarga del constructor podría ser suficiente.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Diagnostics.EventLog>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Parámetro `source`.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parámetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Parámetro `machineName`.|  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe una entrada en un registro de eventos, "MyNewLog", en el equipo local, con el origen "MySource".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El nombre del registro es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del registro no es válido.  
  
O bien 
El nombre de equipo no es válido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comienza la inicialización de un objeto <see cref="T:System.Diagnostics.EventLog" /> que se emplea en un formulario o que utiliza otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] entorno usa este método para iniciar la inicialización de un componente usado en un formulario u otro componente de diseño. El <xref:System.Diagnostics.EventLog.EndInit%2A> método termina la inicialización. Mediante el <xref:System.Diagnostics.EventLog.BeginInit%2A> y <xref:System.Diagnostics.EventLog.EndInit%2A> métodos evitar que el control que se va a usar antes de inicializarse completamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> ya se ha inicializado.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todas las entradas del registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los registros de eventos se establecen con un tamaño máximo que determina cuántas entradas pueden contener. Cuando un registro de eventos está lleno, detiene la grabación de la nueva información de eventos o comienza a sobrescribir las entradas anteriores. Si se detiene el registro de eventos, puede usar este método para borrar el registro de las entradas existentes y permitir que se vuelva a iniciar la grabación de eventos. Debe tener permisos de administrador en el equipo en el que reside el registro para borrar las entradas de registro de eventos.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> cierra el registro de eventos, libera los identificadores de evento, recupera nueva lectura y escritura de controladores y vuelve a abrir el registro de eventos. No se borran los eventos recibidos después de la llamada al método junto con los eventos existentes.  
  
   
  
## Examples  
 El siguiente ejemplo borra un registro de eventos.  
  
> [!CAUTION]
>  Porque la aplicación, sistema, seguridad y otros registros no personalizados pueden contener información crucial; Asegúrese de especificar un registro personalizado antes de ejecutar este código de ejemplo. Este ejemplo elimina el registro personalizado `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">El registro de eventos no se ha borrado correctamente.  
  
O bien 
No puede abrirse el registro. No hay ningún código de error de Windows disponible.</exception>
        <exception cref="T:System.ArgumentException">No se especifica un valor para la propiedad <see cref="P:System.Diagnostics.EventLog.Log" />. Asegúrese de que el nombre del Registro no es una cadena vacía.</exception>
        <exception cref="T:System.InvalidOperationException">El registro no existe.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra el registro de eventos y libera los identificadores de lectura y escritura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.EventLog.Close%2A> se llama al método por protegido <xref:System.ComponentModel.Component.Dispose%2A> método. No es necesario invocar <xref:System.Diagnostics.EventLog.Close%2A> antes de llamar a <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">El identificador de lectura o el identificador de escritura del registro de eventos no se ha liberado correctamente.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece una aplicación como capaz de escribir información de eventos en un determinado registro del sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">Propiedades de configuración para el origen de eventos y su registro de eventos de destino.</param>
        <summary>Establece un origen de eventos válido para la escritura de mensajes de evento localizados, mediante las propiedades de configuración especificadas para el origen y el correspondiente registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para configurar un nuevo origen para escribir entradas en un registro de eventos en el equipo local o en un equipo remoto. No es necesario usar este método para leer desde un registro de eventos.  
  
 El <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método usa la entrada `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> y <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> propiedades para crear valores del registro en el equipo de destino para el nuevo origen y su registro de eventos asociado. Un nuevo nombre de origen no puede coincidir con un nombre de origen existente o un nombre de registro de eventos existente en el equipo de destino. Si el <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> no está establecida la propiedad, el origen está registrado para el registro de eventos de aplicación. Si el <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> no está establecido, el origen está registrado en el equipo local.  
  
> [!NOTE]
>  Para crear un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que deben buscarse todos los registros de eventos, incluida la seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tiene permiso para acceder al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  A partir de Windows Vista, Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código de acceso al registro de seguridad, primero debe elevar sus privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Puede crear un origen de eventos para un registro de eventos existente o un registro de eventos. Cuando se crea un nuevo origen para un registro de eventos, el sistema registra el origen para este registro, pero no se crea el registro hasta que la primera entrada se escriba en él.  
  
 El sistema operativo almacena los registros de eventos como archivos. Cuando usas <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para crear un nuevo registro de eventos, el archivo asociado se almacena en el directorio %SystemRoot%\System32\Config del equipo especificado. Se establece el nombre de archivo anexando los 8 primeros caracteres de la <xref:System.Diagnostics.EventLog.Log%2A> propiedad con la extensión de nombre de archivo "evt".  
  
 Cada origen solo puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, su aplicación puede requerir configurados para los diferentes registros de eventos o archivos de recursos de varios orígenes.  
  
 Puede registrar el origen de eventos con los archivos de recursos localizados para las cadenas de categoría y el mensaje de evento. La aplicación puede escribir entradas del registro de eventos con identificadores de recursos, en lugar de especificar la cadena real. El Visor de eventos usa el identificador de recursos para buscar y mostrar la cadena correspondiente desde el archivo de recursos localizado en función de la configuración de idioma actual. Puede registrar un archivo independiente para las categorías de eventos, mensajes y las cadenas de inserción de parámetro, o puede registrar el mismo archivo de recursos para los tres tipos de cadenas. Use la <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, y <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> propiedades para configurar el origen para escribir entradas adaptadas en el registro de eventos. Si su aplicación escribe los valores de cadenas directamente en el registro de eventos, no es necesario establecer estas propiedades.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
 Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada en lugar de eliminar el origen existente.  
  
> [!NOTE]
>  Si se configura un origen para un registro de eventos, y volver a configurar para otro registro de eventos, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 El ejemplo siguiente determina si el origen de eventos denominado `SampleApplicationSource` está registrado en el equipo local. Si el origen del evento no existe, el ejemplo establece el archivo de recursos de mensaje para el origen y crea el nuevo origen de eventos. Por último, el ejemplo establece el nombre para mostrar localizado para el registro de eventos mediante el valor de identificador de recurso en `DisplayNameMsgId` y la ruta de acceso del archivo de recursos en `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 El ejemplo utiliza el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto del mensaje es el origen desde el que se crea el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto para la categoría, mensaje de evento y las cadenas de inserción de parámetro. En concreto, el identificador de recursos 5001 se define para el nombre traducido del registro de eventos.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de equipo especificado en <paramref name="sourceData" /> no es válido.  
  
\- o - 
El nombre del origen especificado en <paramref name="sourceData" /> es <see langword="null" />.  
  
\- o - 
El nombre de registro especificado en <paramref name="sourceData" /> no es válido. Los nombres de los registros de eventos deben estar compuestos por caracteres imprimibles, excluidos "*", "?" o "\\".  
  
\- o - 
El nombre del registro especificado en <paramref name="sourceData" /> no es válido para la creación de registros de usuario. Los nombres de registro de eventos AppEvent, SysEvent y SecEvent están reservados para uso del sistema.  
  
\- o - 
El nombre del registro coincide con el nombre de un origen de eventos ya existente.  
  
\- o - 
El nombre de origen especificado en <paramref name="sourceData" /> produce una ruta de clave del Registro con una longitud superior a 254 caracteres.  
  
\- o - 
Los 8 primeros caracteres del nombre del registro especificado en <paramref name="sourceData" /> no son únicos.  
  
\- o - 
El nombre de origen especificado en <paramref name="sourceData" /> ya está registrado.  
  
\- o - 
El nombre de origen especificado en <paramref name="sourceData" /> coincide con un nombre del registro de eventos ya existente.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceData" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen por el que se registra la aplicación en el equipo local.</param>
        <param name="logName">Nombre del registro en el que se escriben las entradas del origen. Entre los posibles valores se incluye Aplicación, Sistema o un registro de eventos personalizado.</param>
        <summary>Establece el nombre de origen especificado como origen de eventos válido para la escritura de entradas en un registro del equipo local. Este método también puede crear un nuevo registro personalizado en el equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear un registro personalizado o para crear y registrar un <xref:System.Diagnostics.EventLog.Source%2A> en un registro existente en el equipo local.  
  
 Si `logName` es `null` o una cadena vacía ("") al llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, el valor predeterminado es el registro en el registro de aplicación. Si el registro no existe en el equipo local, el sistema crea un registro personalizado y registra la aplicación como un <xref:System.Diagnostics.EventLog.Source%2A> para ese registro.  
  
> [!NOTE]
>  Para crear un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que deben buscarse todos los registros de eventos, incluida la seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tiene permiso para acceder al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  En Windows Vista y versiones posteriores, el Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código de acceso al registro de seguridad, primero debe elevar sus privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
 Sólo necesitará crear un origen de eventos si va a escribir en el registro de eventos. Antes de escribir una entrada en un registro de eventos, debe registrar el origen del evento con el registro de eventos como un origen de eventos válido. Cuando se escribe una entrada de registro, el sistema usa el <xref:System.Diagnostics.EventLog.Source%2A> para buscar el registro adecuado en el que se va a colocar la entrada. Si está leyendo el registro de eventos, puede especificar el <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  No es necesario especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro en el equipo local. Si no especifica la <xref:System.Diagnostics.EventLog.MachineName%2A> al leer de un registro, el equipo local (".") se da por hecho.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Puede crear un origen de eventos para un registro de eventos existente o un registro de eventos. Cuando se crea un nuevo origen para un registro de eventos, el sistema registra el origen para este registro, pero no se crea el registro hasta que la primera entrada se escriba en él.  
  
 El sistema operativo almacena los registros de eventos como archivos. Cuando usas <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para crear un nuevo registro de eventos, el archivo asociado se almacena en el directorio %SystemRoot%\System32\Config del equipo especificado. Se establece el nombre de archivo anexando los 8 primeros caracteres de la <xref:System.Diagnostics.EventLog.Log%2A> propiedad con la extensión de nombre de archivo "evt".  
  
 El origen debe ser único en el equipo local; un nuevo nombre de origen no puede coincidir con un nombre de origen existente o un nombre de registro de eventos existente. Cada origen puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, su aplicación puede requerir configurados para los diferentes registros de eventos o archivos de recursos de varios orígenes.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
 Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada en lugar de eliminar el origen existente.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarla a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> es una cadena vacía ("") o <see langword="null" />.  
  
\- o - 
 <paramref name="logName" /> no es un nombre de registro de eventos válido. Los nombres de los registros de eventos deben estar compuestos por caracteres imprimibles, excluidos "*", "?" o "\\".  
  
\- o - 
 <paramref name="logName" /> no es válido para la creación del registro de usuario. Los nombres de registro de eventos AppEvent, SysEvent y SecEvent están reservados para uso del sistema.  
  
\- o - 
El nombre del registro coincide con el nombre de un origen de eventos ya existente.  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.  
  
\- o - 
Los 8 primeros caracteres de <paramref name="logName" /> coinciden con los 8 primeros caracteres del nombre de un registro de eventos ya existente.  
  
\- o - 
No puede registrarse el origen porque ya existe en el equipo local.  
  
\- o - 
El nombre del origen coincide con el nombre de un registro de eventos ya existente.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir en el equipo local la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="logName">Nombre del registro en el que se escriben las entradas del origen. Entre los posibles valores se incluye Aplicación, Sistema o un registro de eventos personalizado. Si no se especifica un valor <c>logName</c>, toma Aplicación como valor predeterminado.</param>
        <param name="machineName">Nombre del equipo con el que se va a registrar este origen de eventos o "." para el equipo local.</param>
        <summary>Establece el nombre de origen especificado como origen de eventos válido para la escritura de entradas en un registro del equipo especificado. Este método puede utilizarse también para crear un nuevo registro personalizado en el equipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear un registro personalizado o para crear y registrar un <xref:System.Diagnostics.EventLog.Source%2A> en un registro existente en el equipo especificado.  
  
 Si `logName` es `null` o una cadena vacía ("") al llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, el valor predeterminado es el registro en el registro de aplicación. Si el registro no existe en el equipo especificado, el sistema crea un registro personalizado y registra la aplicación como un <xref:System.Diagnostics.EventLog.Source%2A> para ese registro.  
  
 Sólo necesitará crear un origen de eventos si va a escribir en el registro de eventos. Antes de escribir una entrada en un registro de eventos, debe registrar el origen del evento con el registro de eventos como un origen de eventos válido. Cuando se escribe una entrada de registro, el sistema usa el <xref:System.Diagnostics.EventLog.Source%2A> para buscar el registro adecuado en el que se va a colocar la entrada. Si está leyendo el registro de eventos, puede especificar el <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Para crear un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que deben buscarse todos los registros de eventos, incluida la seguridad, para determinar si el origen del evento es único. En Windows Vista y versiones posteriores, los usuarios no tienen permiso para acceder al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  En Windows Vista y versiones posteriores, el Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código de acceso al registro de seguridad, primero debe elevar sus privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Puede crear un origen de eventos para un registro de eventos existente o un registro de eventos. Cuando se crea un nuevo origen para un registro de eventos, el sistema registra el origen para este registro, pero no se crea el registro hasta que la primera entrada se escriba en él.  
  
 El sistema operativo almacena los registros de eventos como archivos. Cuando usas <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para crear un nuevo registro de eventos, el archivo asociado se almacena en el directorio %SystemRoot%\System32\Config del equipo especificado. Se establece el nombre de archivo anexando los 8 primeros caracteres de la <xref:System.Diagnostics.EventLog.Log%2A> propiedad con la extensión de nombre de archivo "evt".  
  
 El origen debe ser único en el equipo local; un nuevo nombre de origen no puede coincidir con un nombre de origen existente o un nombre de registro de eventos existente. Cada origen puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, su aplicación puede requerir configurados para los diferentes registros de eventos o archivos de recursos de varios orígenes.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
 Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada en lugar de eliminar el origen existente.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarla a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen `MySource` en el equipo `MyServer`y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> no es un nombre de equipo válido.  
  
\- o - 
 <paramref name="source" /> es una cadena vacía ("") o <see langword="null" />.  
  
\- o - 
 <paramref name="logName" /> no es un nombre de registro de eventos válido. Los nombres de los registros de eventos deben estar compuestos por caracteres imprimibles, excluidos "*", "?" o "\\".  
  
\- o - 
 <paramref name="logName" /> no es válido para la creación del registro de usuario. Los nombres de registro de eventos AppEvent, SysEvent y SecEvent están reservados para uso del sistema.  
  
\- o - 
El nombre del registro coincide con el nombre de un origen de eventos ya existente.  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.  
  
\- o - 
Los 8 primeros caracteres de <paramref name="logName" /> coinciden con los 8 primeros caracteres del nombre de un registro de eventos ya existente en el equipo especificado.  
  
\- o - 
No puede registrarse el origen porque ya existe en el equipo especificado.  
  
\- o - 
El nombre del origen coincide con el nombre de un origen de eventos ya existente.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir en el equipo especificado la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita un recurso de registro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro que se va a eliminar. Posibles valores: Aplicación, Seguridad, Sistema o cualquier registro de eventos personalizado del equipo.</param>
        <summary>Quita un registro de eventos del equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando el registro que desea eliminar está en el equipo local. Puede eliminar cualquier registro en el equipo, siempre que tenga los permisos adecuados.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Quita el registro especificado por `logName` desde el equipo local. Si desea eliminar solo el origen registrado en un registro, llame a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Si solo desea eliminar las entradas del registro, llame a <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> y <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> son `static` métodos, por lo que se pueden llamar desde la propia clase. No es necesario crear una nueva instancia de <xref:System.Diagnostics.EventLog> para llamar a cualquiera de estos métodos.  
  
 El <xref:System.Diagnostics.EventLog.Delete%2A> método elimina primero el archivo que contiene el contenido del registro. A continuación, obtiene acceso al registro y quita todos los orígenes de eventos registrados para ese registro. Si se vuelve a crear el registro en un momento posterior, debe registrar los orígenes de eventos de nuevo, si van a reutilizar. Si no se registran los orígenes de eventos y escriban otros usuarios a un origen de eventos sin especificar un nombre de registro, se creará el origen del evento en el registro de eventos de aplicación. Por lo tanto, las aplicaciones que anteriormente podían escribir entradas en el registro eliminado y vuelto a crear escribirá en el registro de aplicación en su lugar, ya que ahora contiene el origen del evento.  
  
> [!NOTE]
>  Volver a crear un registro de eventos puede ser un proceso difícil. Evitar la eliminación de cualquiera de los registros de eventos creado por el sistema, como el registro de aplicación.  
  
 Eliminación de un registro mediante una llamada a <xref:System.Diagnostics.EventLog.Delete%2A> elimina automáticamente los orígenes registrados en el registro. Esto puede hacer que otras aplicaciones que utilicen dicho registro no funciona.  
  
   
  
## Examples  
 El ejemplo siguiente elimina un registro desde el equipo local. El ejemplo determina el registro de su origen.  
  
> [!NOTE]
>  Puede escribir más de un origen en un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> es una cadena vacía ("") o <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir en el equipo local la clave del Registro para el registro de eventos.  
  
\- o - 
El registro no existe en el equipo local.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El registro de eventos no se ha borrado correctamente.  
  
O bien 
No puede abrirse el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro que se va a eliminar. Posibles valores: Aplicación, Seguridad, Sistema y cualquier registro de eventos personalizado del equipo especificado.</param>
        <param name="machineName">Nombre del equipo del que se va a eliminar el registro o "." para el equipo local.</param>
        <summary>Quita un registro de eventos del equipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando el registro que desea eliminar está en un equipo remoto. Puede eliminar cualquier registro en el equipo, siempre que tenga los permisos adecuados.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Quita el registro especificado por `logName` desde el equipo especificado por `machineName`. Si desea eliminar solo el origen registrado en un registro, llame a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Si solo desea eliminar las entradas del registro, llame a <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> y <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> son `static` métodos, por lo que se pueden llamar desde la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a cualquiera de estos métodos.  
  
 En primer lugar, este método elimina el archivo que contiene el contenido del registro. A continuación, obtiene acceso al registro y quita todos los orígenes de eventos registrados para ese registro. Si se vuelve a crear el registro en un momento posterior, debe registrar los orígenes de eventos de nuevo, si van a reutilizar. Si no se registran los orígenes de eventos y escriban otros usuarios a un origen de eventos sin especificar un nombre de registro, se creará el origen del evento en el registro de eventos de aplicación. Por lo tanto, las aplicaciones que anteriormente podían escribir entradas en el registro eliminado y vuelto a crear escribirá en el registro de aplicación en su lugar, ya que ahora contiene el origen del evento.  
  
> [!NOTE]
>  Volver a crear un registro de eventos puede ser un proceso difícil. Evitar la eliminación de cualquiera de los registros de eventos creado por el sistema, como el registro de aplicación.  
  
 Eliminación de un registro mediante una llamada a <xref:System.Diagnostics.EventLog.Delete%2A> elimina automáticamente los orígenes registrados en el registro. Esto puede hacer que otras aplicaciones que utilicen dicho registro no funciona.  
  
   
  
## Examples  
 El ejemplo siguiente elimina un registro del equipo especificado. El ejemplo determina el registro de su origen.  
  
> [!NOTE]
>  Puede escribir más de un origen en un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> es una cadena vacía ("") o <see langword="null" />.  
  
\- o - 
 <paramref name="machineName" /> no es un nombre de equipo válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir en el equipo especificado la clave del Registro para el registro de eventos.  
  
\- o - 
El registro no existe en el equipo especificado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El registro de eventos no se ha borrado correctamente.  
  
O bien 
No puede abrirse el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita del registro de eventos un registro del origen de eventos de una aplicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre con el que se registra la aplicación en el sistema de registro de eventos.</param>
        <summary>Quita del registro de eventos del equipo local el registro del origen de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para quitar el registro de un <xref:System.Diagnostics.EventLog.Source%2A> desde el equipo local. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Obtiene acceso al registro en el equipo local y quita el registro de la aplicación como un origen de eventos válido.  
  
 Puede quitar el componente como un origen de eventos válido si ya no necesita escribir entradas en el registro. Por ejemplo, podría hacerlo si necesita cambiar el componente de un registro a otro. Porque solo se puede registrar un origen en un registro a la vez, el cambio de registro requiere que se quite el registro actual.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sólo quita el origen registrado en un registro. Si desea quitar el registro de sí mismo, llame a <xref:System.Diagnostics.EventLog.Delete%2A>. Si solo desea eliminar las entradas del registro, llame a <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> y <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> son `static` métodos, por lo que se pueden llamar desde la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a cualquiera de estos métodos.  
  
 Eliminación de un registro mediante una llamada a <xref:System.Diagnostics.EventLog.Delete%2A> elimina automáticamente los orígenes registrados en el registro. Esto puede hacer que otras aplicaciones que utilicen dicho registro no funciona.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarla a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 El ejemplo siguiente elimina un origen desde el equipo local. El ejemplo determina el registro de su origen y, a continuación, elimina el registro.  
  
> [!NOTE]
>  Puede escribir más de un origen en un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="source" /> no existe en el Registro del equipo local.  
  
\- o - 
No se dispone de acceso de escritura en la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre con el que se registra la aplicación en el sistema de registro de eventos.</param>
        <param name="machineName">Nombre del equipo del que hay que quitar el registro o "." para el equipo local.</param>
        <summary>Quita del equipo especificado el registro del origen de eventos de la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para quitar el registro de un <xref:System.Diagnostics.EventLog.Source%2A> desde un equipo remoto. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Obtiene acceso al registro en el equipo especificado por `machineName` y quita el registro de la aplicación como un origen de eventos válido.  
  
 Puede quitar el componente como un origen de eventos válido si ya no necesita escribir entradas en el registro. Por ejemplo, podría hacerlo si necesita cambiar el componente de un registro a otro. Porque solo se puede registrar un origen en un registro a la vez, el cambio de registro requiere que se quite el registro actual.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sólo quita el origen registrado en un registro. Si desea quitar el registro de sí mismo, llame a <xref:System.Diagnostics.EventLog.Delete%2A>. Si solo desea eliminar las entradas del registro, llame a <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> y <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> son `static` métodos, por lo que se pueden llamar desde la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a cualquiera de estos métodos.  
  
 Eliminación de un registro mediante una llamada a <xref:System.Diagnostics.EventLog.Delete%2A> elimina automáticamente los orígenes registrados en el registro. Esto puede hacer que otras aplicaciones que utilicen dicho registro no funciona.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarla a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 El ejemplo siguiente elimina un origen desde el equipo especificado. El ejemplo determina el registro de su origen y, a continuación, elimina el registro.  
  
> [!NOTE]
>  Puede escribir más de un origen en un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="machineName" /> no es válido.  
  
\- o - 
El parámetro <paramref name="source" /> no existe en el Registro del equipo especificado.  
  
\- o - 
No se dispone de acceso de escritura en la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.InvalidOperationException">No se puede eliminar <paramref name="source" /> porque en el Registro, la clave del Registro primaria para <paramref name="source" /> no contiene una subclave con el mismo nombre.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Diagnostics.EventLog" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose()` método y el <xref:System.Object.Finalize%2A> método. `Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el `disposing` parámetro es true, este método libera todos los recursos mantenidos por los objetos administrados que este <xref:System.Diagnostics.EventLog> referencias. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Cuando se reemplaza <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si <see cref="T:System.Diagnostics.EventLog" /> recibe notificaciones de eventos <see cref="E:System.Diagnostics.EventLog.EntryWritten" />.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Diagnostics.EventLog" /> recibe la notificación cuando se escribe una entrada en el registro; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> propiedad determina si el <xref:System.Diagnostics.EventLog> provoca eventos cuando se escriben entradas en el registro. Cuando la propiedad es `true`, los componentes que reciben el <xref:System.Diagnostics.EventLog.EntryWritten> eventos recibirá notificación cada vez que se escribe una entrada en el registro que se especifica en el <xref:System.Diagnostics.EventLog.Log%2A> propiedad. Si <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> es `false`, se genera ningún evento.  
  
> [!NOTE]
>  Puede recibir notificaciones de eventos solo cuando se escriben entradas en el equipo local. No puede recibir notificaciones de entradas escritas en equipos remotos.  
  
   
  
## Examples  
 El ejemplo siguiente se controla un <xref:System.Diagnostics.EventLog.EntryWritten> eventos.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El registro de eventos está en un equipo remoto.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina la inicialización de <see cref="T:System.Diagnostics.EventLog" /> utilizada en un formulario o empleada por otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] entorno usa este método para finalizar la inicialización de un componente usado en un formulario u otro componente de diseño. El <xref:System.Diagnostics.EventLog.BeginInit%2A> método comienza la inicialización. Mediante el <xref:System.Diagnostics.EventLog.BeginInit%2A> y <xref:System.Diagnostics.EventLog.EndInit%2A> métodos impide que el control que se va a usar antes de inicializarse completamente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el contenido del registro de eventos.</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLogEntryCollection" /> que incluye las entradas del registro de eventos. Cada entrada se asocia a una instancia de la clase <see cref="T:System.Diagnostics.EventLogEntry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Diagnostics.EventLog.Entries%2A> miembro al leer desde el registro de eventos.  
  
 Dado que la propiedad es de solo lectura, no se puede modificar una entrada o escribir en el registro mediante <xref:System.Diagnostics.EventLog.Entries%2A>. En su lugar, especifique un <xref:System.Diagnostics.EventLog.Source%2A> y llamar a <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir una nueva entrada de registro. Puede usar <xref:System.Diagnostics.EventLog.Entries%2A> para contar el número de entradas del registro de eventos y ver cada <xref:System.Diagnostics.EventLogEntry> en la colección. Utilice el indizado <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> miembros para recuperar información sobre una entrada específica, como <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, o <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 No es necesario especificar un <xref:System.Diagnostics.EventLog.Source%2A> cuando sólo se lee de un registro. Sólo se puede especificar el <xref:System.Diagnostics.EventLog.Log%2A> nombre y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades (nombre de equipo del servidor) para el <xref:System.Diagnostics.EventLog> instancia. En cualquier caso, el <xref:System.Diagnostics.EventLog.Entries%2A> miembro se rellena automáticamente con la lista del registro de eventos de entradas. Puede seleccionar el índice adecuado para un elemento de esta lista para leer las entradas individuales.  
  
 Una diferencia importante entre leer y escribir entradas del registro es que no es necesario llamar explícitamente a un método de lectura. Después de la <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> se especifican, el <xref:System.Diagnostics.EventLog.Entries%2A> propiedad se rellena automáticamente. Si cambia el valor de la <xref:System.Diagnostics.EventLog.Log%2A> o <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad, el <xref:System.Diagnostics.EventLog.Entries%2A> propiedad se vuelve a llenar la próxima vez que se lee.  
  
> [!NOTE]
>  No es necesario especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro. Si no especifica la <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local, ".", se da por hecho.  
  
   
  
## Examples  
 El ejemplo siguiente lee las entradas del registro de eventos, "MyNewLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se escribe una entrada en un registro de eventos en el equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener las notificaciones de eventos, se debe establecer <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> a `true`. Solo puede recibir notificaciones de eventos cuando se escriben entradas en el equipo local. No puede recibir notificaciones de entradas escritas en equipos remotos.  
  
 Cuando se crea un delegado <xref:System.Diagnostics.EventLog.EntryWritten>, se identifica el método que controlará el evento. Para asociar el evento al controlador, se debe agregar una instancia del delegado al evento. Se llama al controlador de eventos cada vez que se produce el evento, hasta que quite al delegado. Para obtener más información sobre cómo controlar eventos con delegados, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El sistema responde a <xref:System.Diagnostics.EventLog.WriteEntry%2A> sólo si el último evento de escritura se produjo anteriormente al menos seis segundos. Esto implica que solo recibirá uno <xref:System.Diagnostics.EventLog.EntryWritten> notificación de eventos dentro de un intervalo de seis segundos, incluso si más de un evento de cambio de registro se produce. Si inserta un intervalo de espera lo suficientemente prolongado (aproximadamente 10 segundos) entre las llamadas a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, es menos probable que se pierda un evento. Sin embargo, si se producen eventos de escritura con más frecuencia, puede que no reciba la notificación de eventos hasta el siguiente intervalo. Normalmente, las notificaciones de eventos que faltan no se pierden, pero que se retrasa.  
  
   
  
## Examples  
 El ejemplo siguiente controla una evento escrito de entrada.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si existe el registro especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro que se va a buscar. Posibles valores: Aplicación, Seguridad, Sistema, otros registros específicos de aplicaciones (como los asociados a Active Directory) o cualquier registro personalizado del equipo.</param>
        <summary>Determina si el registro existe en el equipo local.</summary>
        <returns>
          <see langword="true" /> si el registro existe en el equipo local; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para determinar si existe un registro en el equipo local. Si desea determinar si existe un origen en el equipo local, utilice <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Dado que este método obtiene acceso al registro, debe tener los permisos adecuados en el equipo local; en caso contrario, devuelve la consulta `false`.  
  
 Ya no se puede proporcionar el nombre de un registro existente de un nuevo registro en el mismo equipo, utilice este método antes de crear un nuevo registro para determinar si el texto especificado `logName` ya existe en el equipo local. El `logName` parámetro no distingue mayúsculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> es un `static` método, por lo que puede llamarse en la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">LogName es <see langword="null" /> o el valor está vacío.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Registro que se va a buscar. Posibles valores: Aplicación, Seguridad, Sistema, otros registros específicos de aplicaciones (como los asociados a Active Directory) o cualquier registro personalizado del equipo.</param>
        <param name="machineName">Nombre del equipo en el que se va a buscar el registro o "." para el equipo local.</param>
        <summary>Determina si el registro existe en el equipo especificado.</summary>
        <returns>
          <see langword="true" /> si el registro existe en el equipo especificado; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para determinar si existe un registro en un equipo remoto. Si desea determinar si existe un origen en un equipo remoto, utilice <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Dado que este método obtiene acceso al registro, debe tener los permisos adecuados en el equipo especificado; en caso contrario, devuelve la consulta `false`.  
  
 Ya no se puede proporcionar el nombre de un registro existente de un nuevo registro en el mismo equipo, utilice este método antes de crear un nuevo registro para determinar si hay uno con los valores especificados `logName` ya existe en el servidor especificado por el `machineName` parámetro. El `logName` y `machineName` parámetros no distinguen mayúsculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> es un `static` método, por lo que puede llamarse en la propia clase. No es necesario crear una nueva instancia de <xref:System.Diagnostics.EventLog> para llamar a <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="machineName" /> no es un formato válido. Asegúrese de que ha utilizado la sintaxis adecuada para el equipo en el que está buscando.  
  
O bien 
El parámetro <paramref name="logName" /> es <see langword="null" /> o el valor está vacío.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matriz de los registros de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Busca todos los registros de eventos en el equipo local y crea una matriz de objetos <see cref="T:System.Diagnostics.EventLog" /> que contiene la lista.</summary>
        <returns>Matriz de tipo <see cref="T:System.Diagnostics.EventLog" /> que representa los registros del equipo local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz de <xref:System.Diagnostics.EventLog> objetos es una instantánea de todos los registros de eventos en el equipo local cuando la llamada a <xref:System.Diagnostics.EventLog.GetEventLogs%2A> se realiza. Esto no es una colección dinámica, por lo que no refleja la eliminación o la creación de registros en tiempo real. Debe comprobar que un registro de la matriz existe antes de leer o escribir en él. La matriz normalmente incluye al menos tres registros: aplicación, sistema y seguridad. Si ha creado los registros personalizados en el equipo local, aparecerá en la matriz también.  
  
 Para recuperar la lista de registros de eventos, debe tener los permisos adecuados. Estos permisos son idénticos a los necesarios para llamar a <xref:System.Diagnostics.EventLog.Exists%2A> y <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente enumera los registros de eventos definidos en el equipo local y muestra los detalles de configuración para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">No se dispone de acceso de lectura al Registro.  
  
O bien 
No existe ningún servicio de registro de eventos en el equipo.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Equipo en el que buscar registros de eventos.</param>
        <summary>Busca todos los registros de eventos en el equipo dado y crea una matriz de objetos <see cref="T:System.Diagnostics.EventLog" /> que contiene la lista.</summary>
        <returns>Matriz de tipo <see cref="T:System.Diagnostics.EventLog" /> que representa los registros del equipo dado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz de <xref:System.Diagnostics.EventLog> objetos es una instantánea de todos los registros de eventos en el equipo especificado por el `machineName` parámetro cuando la llamada a <xref:System.Diagnostics.EventLog.GetEventLogs%2A> se realiza. Esto no es una colección dinámica, por lo que no refleja la eliminación o la creación de registros en tiempo real. Debe comprobar que un registro de la matriz existe antes de leer o escribir en él. La matriz normalmente incluye al menos tres registros: aplicación, sistema y seguridad. Si ha creado los registros personalizados en el equipo especificado, aparecen en la matriz también.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> es un `static` método, por lo que puede llamarse en el <xref:System.Diagnostics.EventLog> propia clase. No es necesario crear una instancia de un <xref:System.Diagnostics.EventLog> objeto para realizar una llamada al método.  
  
 Para recuperar la lista de registros de eventos, debe tener los permisos adecuados. Estos permisos son idénticos a los necesarios para llamar a <xref:System.Diagnostics.EventLog.Exists%2A> y <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente obtiene una lista de registros en el equipo "myServer". A continuación, genera el nombre de cada registro.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="machineName" /> no es un nombre de equipo válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se dispone de acceso de lectura al Registro.  
  
O bien 
No existe ningún servicio de registro de eventos en el equipo.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del registro del que se lee o en el que se escribe.</summary>
        <value>Nombre del registro. Puede ser Aplicación, Sistema, Seguridad o el nombre de un registro personalizado. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Existen tres archivos de registro de forma predeterminada en el servidor: aplicación, sistema y seguridad. Aplicaciones y servicios utilizan el archivo de registro de aplicación. Controladores de dispositivos utilizan el archivo de registro del sistema. El sistema genera eventos de auditoría de aciertos y errores en el registro de seguridad cuando está activada la auditoría. Si tiene otras aplicaciones instaladas, como Active Directory en los servidores de Windows, puede haber otros archivos de registro predeterminado. Además, puede crear archivos de registro personalizado en un equipo local o remoto. Los registros personalizados ayudan a organizar las entradas de una forma más detallada que se permite cuando los componentes escriben eventos en el registro de aplicación predeterminado.  
  
> [!NOTE]
>  Los nombres de registro están limitados a ocho caracteres. Según el sistema, MyLogSample1 y MyLogSample2 son el mismo registro.  
  
 Si se escribe en un registro de eventos, no es suficiente especificar el <xref:System.Diagnostics.EventLog.Log%2A> propiedad. Debe asociar un <xref:System.Diagnostics.EventLog.Source%2A> propiedad con el recurso de registro de eventos para conectarse a un registro determinado. No es necesario especificar un <xref:System.Diagnostics.EventLog.Source%2A> cuando sólo se lee de un registro, pero un origen de eventos debe estar asociado con el recurso de registro de eventos en el registro del servidor. Sólo se puede especificar el <xref:System.Diagnostics.EventLog.Log%2A> nombre y <xref:System.Diagnostics.EventLog.MachineName%2A> (nombre de equipo del servidor) para leer de él.  
  
> [!NOTE]
>  No es necesario especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro. Si no especifica la <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho.  
  
 Si el <xref:System.Diagnostics.EventLog.Source%2A> propiedad no se ha especificado, una llamada a <xref:System.Diagnostics.EventLog.Log%2A> devuelve una cadena vacía si <xref:System.Diagnostics.EventLog.Log%2A> no se ha establecido explícitamente (estableciendo la <xref:System.Diagnostics.EventLog.Log%2A> propiedad, o a través del constructor). Si el <xref:System.Diagnostics.EventLog.Source%2A> se ha especificado, <xref:System.Diagnostics.EventLog.Log%2A> devuelve el nombre del registro que se registró ese origen.  
  
 Solo se puede registrar un origen en un registro a la vez. Si el <xref:System.Diagnostics.EventLog.Source%2A> se estableció la propiedad de una instancia de <xref:System.Diagnostics.EventLog>, no puede cambiar el <xref:System.Diagnostics.EventLog.Log%2A> propiedad para que <xref:System.Diagnostics.EventLog> sin cambiar el valor de <xref:System.Diagnostics.EventLog.Source%2A> o llamar a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> primero. Si cambia el <xref:System.Diagnostics.EventLog.Log%2A> propiedad después de la <xref:System.Diagnostics.EventLog.Source%2A> propiedad se ha establecido, escribir una entrada del registro produce una excepción.  
  
 El sistema operativo almacena los registros de eventos como archivos. Cuando usas <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para crear un nuevo registro de eventos, el archivo asociado se almacena en el directorio %SystemRoot%\System32\Config del equipo especificado. Se establece el nombre de archivo anexando los 8 primeros caracteres de la <xref:System.Diagnostics.EventLog.Log%2A> propiedad con la extensión de nombre de archivo "evt".  
  
 No se puede crear un nuevo registro con el <xref:System.Diagnostics.EventLog.Log%2A> propiedad independiente (sin especificar un origen para el registro). Puede llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, pasando un nuevo nombre de registro como un parámetro y, a continuación, llamar a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Sin embargo, suele ser la intención crear (y escribir entradas en) nuevos registros específicos de la aplicación, o para leer los registros existentes.  
  
 Si el <xref:System.Diagnostics.EventLog.Log%2A> cambia el valor, se cierra el registro de eventos y se liberan todos los identificadores de evento.  
  
> [!CAUTION]
>  Si establece la <xref:System.Diagnostics.EventLog.Log%2A> propiedad en el nombre de un registro que no existe, el sistema asocia el <xref:System.Diagnostics.EventLog> en el registro de aplicación, pero no advertirá de que está usando un registro que no sea el mismo que especificó.  
  
   
  
## Examples  
 El ejemplo siguiente lee las entradas del registro de eventos, "NewEventLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre descriptivo del registro de eventos.</summary>
        <value>Nombre que representa el registro de eventos en el visor de eventos del sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  En Windows Vista y versiones posteriores, los usuarios no tienen permiso para acceder al registro de seguridad. Si está ejecutando Windows Vista o versiones posteriores como un usuario, obtendrá un <xref:System.Security.SecurityException> al intentar obtener acceso al nombre de presentación para un evento en el registro de seguridad.  
>   
>  En Windows Vista y versiones posteriores, el Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código de acceso al registro de seguridad, primero debe elevar sus privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
   
  
## Examples  
 El ejemplo siguiente se enumeran los registros de eventos definidos en el equipo local y muestra el <xref:System.Diagnostics.EventLog.LogDisplayName%2A> para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.EventLog.Log" /> especificada no existe en el Registro para este equipo.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Para poder leer la clave del registro especificada. Enumeración asociada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para que poder acceder a la clave de registro especificado, si es una clave remota. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos.</param>
        <param name="machineName">Nombre del equipo en el que se debe buscar o "." para el equipo local.</param>
        <summary>Obtiene el nombre del registro en el que se registra el origen especificado.</summary>
        <returns>Nombre del registro asociado al origen especificado en el Registro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El origen de eventos indica qué registra el evento. A menudo resulta el nombre de la aplicación o el nombre de un subcomponente de la aplicación, si la aplicación es grande. Aplicaciones y servicios deben escribir en el registro de aplicación o un registro personalizado. Deben escribir controladores de dispositivo en el registro del sistema.  
  
 Cuando se crea un nuevo origen, que solo se puede escribir en un registro a la vez, el sistema registra la aplicación con el registro de eventos como un origen válido de entradas. El <xref:System.Diagnostics.EventLog.Source%2A> propiedad puede ser cualquier cadena, pero el nombre no puede usarse por otros orígenes en el equipo. Un intento de crear un duplicado <xref:System.Diagnostics.EventLog.Source%2A> valor produce una excepción. Sin embargo, un único registro de eventos puede tener muchos orígenes diferentes, escribir en él.  
  
   
  
## Examples  
 El ejemplo siguiente elimina un origen desde el equipo local. El ejemplo determina el registro de su origen y, a continuación, elimina el registro.  
  
> [!NOTE]
>  Puede escribir más de un origen en un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del equipo en el que se van a leer o en el que se van a escribir los eventos.</summary>
        <value>Nombre del servidor en el que reside el registro de eventos. El valor predeterminado es el equipo local (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se escribe en un registro de eventos, debe asociar un <xref:System.Diagnostics.EventLog.Source%2A> con el objeto de registro de eventos para conectarse a un registro determinado. No es necesario especificar el <xref:System.Diagnostics.EventLog.Source%2A> propiedad cuando sólo se lee de un registro. Sólo se puede especificar el <xref:System.Diagnostics.EventLog.Log%2A> nombre y <xref:System.Diagnostics.EventLog.MachineName%2A> (nombre de equipo del servidor).  
  
> [!NOTE]
>  No es necesario especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro. Si no especifica la <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho.  
  
 Solo se puede registrar un origen en un registro a la vez. Si el <xref:System.Diagnostics.EventLog.Source%2A> se estableció la propiedad de una instancia de <xref:System.Diagnostics.EventLog>, no puede cambiar el <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad para que <xref:System.Diagnostics.EventLog> sin cambiar el valor de <xref:System.Diagnostics.EventLog.Source%2A> o llamar a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> primero. Si cambia el <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad, el <xref:System.Diagnostics.EventLog> todos los identificadores se cierra y vuelve a adjuntar en el registro y el origen en el nuevo equipo.  
  
 El <xref:System.Diagnostics.EventLog.MachineName%2A> valor no puede ser una cadena vacía. Si no se establece explícitamente, el valor predeterminado es el equipo local (".").  
  
   
  
## Examples  
 El ejemplo siguiente lee las entradas del registro de eventos, "NewEventLog", en un equipo especificado.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de equipo no es válido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño máximo del registro de eventos, en kilobytes.</summary>
        <value>Tamaño máximo del registro de eventos, en kilobytes. El valor predeterminado es 512, lo que indica que el tamaño máximo de archivo es de 512 kilobytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propiedad representa el límite de tamaño del archivo de registro de eventos. Cuando el registro de eventos alcanza el límite de tamaño configurado <xref:System.Diagnostics.EventLog.OverflowAction%2A> valor determina si se descartan las entradas nuevas, o si las nuevas entradas sobrescriben las entradas más antiguas.  
  
> [!NOTE]
>  Esta propiedad representa un valor de configuración para el registro de eventos representado por esta instancia. Cuando el registro de eventos alcanza su tamaño máximo, esta propiedad especifica cómo el sistema operativo controla las nuevas entradas escritas por todos los orígenes de eventos registrados para el registro de eventos.  
  
   
  
## Examples  
 El ejemplo siguiente enumera los registros de eventos definidos en el equipo local y muestra los detalles de configuración para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado es menor que 64, mayor que 4194240 o no es un múltiplo par de 64.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> no es un nombre de registro válido.  
  
\- o - 
No se ha podido abrir en el equipo de destino la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de días que se deben conservar las entradas en el registro de eventos.</summary>
        <value>Número de días que se conservan las entradas del registro de eventos. El valor predeterminado es 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> propiedad para examinar la configuración actual de un registro de eventos. Use <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> para cambiar el número mínimo de días que se debe conservar cada entrada del registro de eventos.  
  
 El <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor depende del comportamiento de desbordamiento configurado el registro de eventos. Si el <xref:System.Diagnostics.OverflowAction> propiedad para un registro de eventos se establece en <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, el <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor es 0. Si el <xref:System.Diagnostics.OverflowAction> propiedad para un registro de eventos se establece en <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, el <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor es -1. Si el <xref:System.Diagnostics.OverflowAction> propiedad para un registro de eventos se establece en <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, el <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor es mayor que cero y representa el número de días que se deben conservar las entradas de registro de eventos cuando el registro de eventos está lleno.  
  
 El comportamiento de desbordamiento sólo se produce cuando un registro de eventos alcanza su límite de tamaño. Cuando un <xref:System.Diagnostics.EventLog> tiene su <xref:System.Diagnostics.EventLog.OverflowAction%2A> establecido en <xref:System.Diagnostics.OverflowAction.OverwriteOlder>y el registro de eventos alcanza su tamaño máximo, a continuación, las nuevas entradas se escriben solo si pueden reemplazar entradas cuya antigüedad supere el <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> período. Conservar las entradas de eventos durante un período mínimo es adecuado cuando el registro de eventos se archivan con regularidad. En caso contrario, se arriesga a perder las entradas nuevas cuando el registro de eventos alcanza su límite. Para evitar perder la información de eventos nuevo, establezca los días de retención mínimo para los eventos según la programación de archivo para un determinado registro de eventos.  
  
   
  
## Examples  
 El ejemplo siguiente enumera los registros de eventos definidos en el equipo local y muestra los detalles de configuración para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">Comportamiento de desbordamiento para la escritura de entradas nuevas en el registro de eventos.</param>
        <param name="retentionDays">Número mínimo de días que se conserva cada entrada del registro de eventos. Solo se usa este parámetro si <c>action</c> se establece en <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Cambia el comportamiento configurado para la escritura de entradas nuevas cuando el registro de eventos alcanza su tamaño máximo de archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de desbordamiento para un registro de eventos especifica lo que sucede cuando las entradas nuevas se escriban en un registro que se ha alcanzado su tamaño máximo de archivo.  
  
> [!NOTE]
>  El comportamiento de desbordamiento surte efecto sólo cuando un registro de eventos alcanza su tamaño máximo de archivo. El comportamiento de desbordamiento no afecta a escribir una nueva entrada en un registro que puede dar cabida a las entradas de registro de eventos adicional.  
  
 El <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método configura el comportamiento de desbordamiento de un registro de eventos. <xref:System.Diagnostics.EventLog> instancia de. Después de llamar a este método para el registro de eventos especificado por el <xref:System.Diagnostics.EventLog.Log%2A> propiedad, el <xref:System.Diagnostics.EventLog.OverflowAction%2A> y <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> los valores de propiedad reflejan el comportamiento de desbordamiento recién configurado.  
  
> [!NOTE]
>  Esta propiedad representa un valor de configuración para el registro de eventos representado por esta instancia. Cuando el registro de eventos alcanza su tamaño máximo, esta propiedad especifica cómo el sistema operativo controla las nuevas entradas escritas por todos los orígenes de eventos registrados para el registro de eventos.  
  
 Establecer el `action` parámetro <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> para indicar que una nueva entrada sobrescribe la entrada más antigua cuando el <xref:System.Diagnostics.EventLog> alcanza su tamaño máximo. Si el `action` parámetro está establecido en <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, el `retentionDays` se omite el valor del parámetro.  
  
 Establecer el `action` parámetro <xref:System.Diagnostics.OverflowAction.OverwriteOlder> para indicar que cada entrada nueva sobrescribirá las entradas más antiguas cuando el <xref:System.Diagnostics.EventLog> alcanza su tamaño máximo. Especifique el número de días que deben conservarse los eventos en el registro usando el `retentionDays` parámetro. Los eventos escritos en el intervalo de retención no se sobrescriben con nuevas entradas.  
  
 Establecer el `action` parámetro <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> descartar nuevos eventos cuando se alcanza el tamaño máximo del registro. Si el `action` parámetro está establecido en <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, el `retentionDays` se omite el valor del parámetro.  
  
> [!CAUTION]
>  Establecer la directiva de desbordamiento en <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> especifica que se descartan las entradas nuevas cuando el registro de eventos está lleno. Si usa esta opción, asegúrese del registro de eventos con regularidad es archivar y borrar para evitar que alcance su límite de tamaño máximo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra la directiva de desbordamiento configurado para un registro de eventos especificado y permite al usuario seleccionar una nueva configuración de directiva de desbordamiento para el registro de eventos.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> no es un valor <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> es menor que 1 o mayor que 365. </exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> no es un nombre de registro válido.  
  
\- o - 
No se ha podido abrir en el equipo de destino la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el comportamiento configurado para el almacenamiento de entradas nuevas cuando el registro de eventos haya alcanzado su tamaño máximo de archivo.</summary>
        <value>Valor de <see cref="T:System.Diagnostics.OverflowAction" /> que especifica el comportamiento de almacenamiento configurado para las entradas nuevas cuando el registro de eventos haya alcanzado su tamaño máximo. El valor predeterminado es <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los registros de eventos aumentan de tamaño como nuevos eventos se escriben en ellos. Cada registro de eventos tiene un límite de tamaño máximo configurado; el <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propiedad define el número máximo de kilobytes permitidos para el tamaño del archivo de registro de eventos.  
  
 Use la <xref:System.Diagnostics.EventLog.OverflowAction%2A> valor de propiedad para examinar el comportamiento de desbordamiento configurado para un registro de eventos en su tamaño máximo. Use el <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método para cambiar el comportamiento de desbordamiento para un registro de eventos.  
  
> [!NOTE]
>  El comportamiento de desbordamiento surte efecto sólo cuando un registro de eventos alcanza su tamaño máximo de archivo. El comportamiento de desbordamiento no afecta a escribir una nueva entrada en un registro que puede dar cabida a las entradas de registro de eventos adicional.  
  
   
  
## Examples  
 El ejemplo siguiente enumera los registros de eventos definidos en el equipo local y muestra los detalles de configuración para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Ruta de acceso completa a un archivo de recursos localizado.</param>
        <param name="resourceId">Identificador de recursos que indiza una cadena localizada dentro del archivo de recursos.</param>
        <summary>Especifica el nombre localizado del registro de eventos, que aparece en el Visor de eventos del servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> para registrar y mostrar un nombre traducido del Visor de eventos para los registros de eventos personalizados.  
  
 El identificador de recurso especificado debe corresponder a una cadena localizada que se define en el archivo de recursos. El Visor de eventos muestra el nombre de registro de eventos personalizado utilizando la cadena localizada y la configuración de referencia cultural actual. Por ejemplo, puede definir varios nombres de registro de eventos localizados para referencias culturales diferentes en el archivo de recursos. El Visor de eventos muestra la cadena localizada que corresponde a la configuración de la referencia cultural del usuario actual.  
  
 Si el Visor de eventos no se puede cargar la cadena localizada del archivo de recursos, o si no se registró ningún nombre para mostrar para el registro de eventos, el Visor de eventos muestra el nombre de registro de eventos definido en <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  No es necesario registrar un nombre para mostrar para los registros de eventos predefinidos. El sistema operativo registra los nombres para mostrar localizado para los registros de eventos de aplicación, sistema y seguridad.  
  
   
  
## Examples  
 El ejemplo siguiente determina si el origen de eventos denominado `SampleApplicationSource` está registrado en el equipo local. Si el origen del evento no existe, el ejemplo establece el archivo de recursos de mensaje para el origen y crea el nuevo origen de eventos. Por último, el ejemplo establece el nombre para mostrar localizado para el registro de eventos mediante el valor de identificador de recurso en `DisplayNameMsgId` y la ruta de acceso del archivo de recursos en `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 El ejemplo utiliza el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto del mensaje es el origen desde el que se crea el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto para la categoría, mensaje de evento y las cadenas de inserción de parámetro. En concreto, el identificador de recursos 5001 se define para el nombre traducido del registro de eventos.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> no es un nombre de registro válido.  
  
\- o - 
No se ha podido abrir en el equipo de destino la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="resourceFile" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre de origen que se va a registrar y utilizar al escribir en el registro de eventos.</summary>
        <value>Nombre registrado con el registro de eventos como origen de entradas. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El origen de eventos indica qué registra el evento. A menudo resulta el nombre de la aplicación o el nombre de un subcomponente de la aplicación, si la aplicación es grande. Aplicaciones y servicios deben escribir en el registro de aplicación o un registro personalizado. Deben escribir controladores de dispositivo en el registro del sistema.  
  
 Solo debe especificar un origen de eventos si va a escribir en un registro de eventos. Antes de escribir una entrada en un registro de eventos, debe registrar el origen del evento con el registro de eventos como un origen de eventos válido. Cuando se escribe una entrada de registro, el sistema usa el <xref:System.Diagnostics.EventLog.Source%2A> propiedad que se va a buscar el registro adecuado en el que se va a colocar la entrada. Si está leyendo el registro de eventos, puede especificar el <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  No es necesario especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro en el equipo local. Si no especifica la <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Puede crear un origen de eventos para un registro de eventos existente o un registro de eventos. Cuando se crea un nuevo origen para un registro de eventos, el sistema registra el origen para este registro, pero no se crea el registro hasta que la primera entrada se escriba en él.  
  
 El origen debe ser único en el equipo local; un nuevo nombre de origen no puede coincidir con un nombre de origen existente o un nombre de registro de eventos existente. Cada origen puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, su aplicación puede requerir configurados para los diferentes registros de eventos o archivos de recursos de varios orígenes.  
  
 Si cambia el <xref:System.Diagnostics.EventLog.Source%2A> valor, el <xref:System.Diagnostics.EventLog> al que está registrado se cierra y se liberan todos los identificadores de evento.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
 Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada en lugar de eliminar el origen existente.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarla a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca un origen de eventos dado en el registro de un equipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos.</param>
        <summary>Determina si un origen de eventos está registrado en el equipo local.</summary>
        <returns>
          <see langword="true" /> si el origen de eventos está registrado en el equipo local; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para determinar si existe un origen de eventos en el equipo local. Si desea determinar si existe un registro en el equipo local, utilice <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Dado que este método obtiene acceso al registro, debe tener los permisos adecuados en el equipo local; en caso contrario, un <xref:System.Security.SecurityException> se iniciará.  
  
> [!NOTE]
>  Para buscar un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que deben buscarse todos los registros de eventos, incluida la seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tiene permiso para acceder al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  A partir de Windows Vista, Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso a los contadores de rendimiento, primero debe elevar sus privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
> [!NOTE]
>  Un servicio que se está ejecutando bajo el <xref:System.ServiceProcess.ServiceAccount.LocalSystem> cuenta no tiene los privilegios necesarios para ejecutar este método. La solución consiste en comprobar si existe el origen del evento en el <xref:System.ServiceProcess.ServiceInstaller>, y si no existe, para crear el origen en el instalador.  
  
 Ya que no puede proporcionar un nuevo origen el nombre de un origen existente en el mismo equipo, utilice este método antes de intentar llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para asegurarse de que un origen con el nombre especificado por `source` aún no existe en el equipo local. El `source` parámetro no distingue mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">No se ha encontrado <paramref name="source" />, aunque no se ha podido buscar en algunos de los registros de eventos o en ninguno.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos.</param>
        <param name="machineName">Nombre del equipo en el se debe buscar o "." para el equipo local.</param>
        <summary>Determina si un origen de eventos está registrado en un equipo especificado.</summary>
        <returns>Es <see langword="true" /> si el origen de eventos está registrado en el equipo dado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para determinar si existe un origen de eventos en el equipo especificado por el `machineName` parámetro. Si desea determinar si existe un registro en el equipo especificado, utilice <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Dado que este método obtiene acceso al registro, debe tener los permisos adecuados en el servidor especificado. en caso contrario, un <xref:System.Security.SecurityException> se iniciará.  
  
> [!NOTE]
>  Para buscar un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que deben buscarse todos los registros de eventos, incluida la seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tiene permiso para acceder al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  A partir de Windows Vista, Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso a los contadores de rendimiento, primero debe elevar sus privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
> [!NOTE]
>  Un servicio que se está ejecutando bajo el <xref:System.ServiceProcess.ServiceAccount.LocalSystem> cuenta no tiene los privilegios necesarios para ejecutar este método. La solución consiste en comprobar si existe el origen del evento en el <xref:System.ServiceProcess.ServiceInstaller>, y si no existe, para crear el origen en el instalador.  
  
 Ya que no puede proporcionar un nuevo origen el nombre de un origen existente en el mismo equipo, utilice este método antes de intentar llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para asegurarse de que un origen con el nombre especificado por `source` aún no existe en el equipo. El `source` y `machineName` parámetros no distinguen mayúsculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> es un `static` método, por lo que puede llamarse en la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen `MySource` en el equipo `MyServer`y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> no es un nombre de equipo válido.</exception>
        <exception cref="T:System.Security.SecurityException">No se ha encontrado <paramref name="source" />, aunque no se ha podido buscar en algunos de los registros de eventos o en ninguno.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto utilizado para serializar de las llamadas del controlador de eventos emitidas como resultado de un evento escrito en una entrada de <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> utilizado para calcular las referencias de las llamadas del controlador de eventos emitidas como resultado de un evento <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> del registro de eventos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> es `null`, métodos que controlan el <xref:System.Diagnostics.EventLog.EntryWritten> evento se denominan en un subproceso del grupo de subprocesos del sistema. Para obtener más información sobre los grupos de subprocesos del sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Cuando el <xref:System.Diagnostics.EventLog.EntryWritten> evento está controlado por un visual formularios de Windows podría no funcionar el componente, como un botón, acceso al componente en el grupo de subprocesos del sistema o podría producir una excepción. Evitar esta situación estableciendo <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> a un componente de Windows Forms, lo que hace que los métodos que controlan el <xref:System.Diagnostics.EventLog.EntryWritten> evento al que se llama en el mismo subproceso en el que se creó el componente.  
  
 Si el <xref:System.Diagnostics.EventLog> se utiliza dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] en un diseñador de Windows Forms, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> se establece automáticamente en el control que contiene el <xref:System.Diagnostics.EventLog>. Por ejemplo, si coloca un <xref:System.Diagnostics.EventLog> en un diseñador de Form1 (que hereda de <xref:System.Windows.Forms.Form>) la <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> propiedad de <xref:System.Diagnostics.EventLog> se establece en la instancia de Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe una entrada en el registro de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <summary>Escribe una entrada de tipo de información, con un texto de mensaje determinado, en el registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada de información en el registro de eventos asociado a este <xref:System.Diagnostics.EventLog> instancia. Si desea especificar cualquier otro <xref:System.Diagnostics.EventLogEntryType>, use una sobrecarga diferente del <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> antes de llamar a la instancia <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema necesita para registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> no se estableció la propiedad en su <xref:System.Diagnostics.EventLog> instancia, el registro el valor predeterminado es el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones enumeradas anteriormente son generados por errores generados durante el proceso de registrar el <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no se está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
O bien 
El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
\- o - 
El origen ya está registrado para otro registro de eventos.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Escribe en el registro de eventos una entrada de error, advertencia, información, auditoría correcta o auditoría incorrecta con el texto de mensaje dado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada de un <xref:System.Diagnostics.EventLogEntryType> al registro de eventos. El `type` se indica mediante un icono y texto en la columna de tipo en el Visor de eventos para un registro.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> antes de llamar a la instancia <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema necesita para registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> no se estableció la propiedad en su <xref:System.Diagnostics.EventLog> instancia, el registro el valor predeterminado es el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones enumeradas anteriormente son generados por errores generados durante el proceso de registrar el <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no se está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
  
   
  
## Examples  
 El ejemplo siguiente escribe una entrada de advertencia en un registro de eventos, "MyNewLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
O bien 
El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
\- o - 
El origen ya está registrado para otro registro de eventos.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <summary>Escribe una entrada de tipo de información con un texto de mensaje determinado en el registro de eventos utilizando el origen de eventos registrado que se haya especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada de información en el registro de eventos mediante un origen que ya está registrado como un origen de eventos para el registro adecuado. Si desea especificar cualquier otro <xref:System.Diagnostics.EventLogEntryType>, use una sobrecarga diferente del <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
>   
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
\- o - 
El valor <paramref name="source" /> es <see langword="null" />.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <summary>Escribe una entrada con el identificador de eventos definido por la aplicación y el texto de mensaje dado en el registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada con una aplicación define `eventID` al registro de eventos. El `eventID` junto con el origen identifican un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y se sugiere qué acciones emprender.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Además del identificador de evento, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y texto en la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> antes de llamar a la instancia <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema necesita para registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> no se estableció la propiedad en su <xref:System.Diagnostics.EventLog> instancia, el registro el valor predeterminado es el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones enumeradas anteriormente son generados por errores generados durante el proceso de registrar el <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no se está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
O bien 
El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
\- o - 
El origen ya está registrado para otro registro de eventos.  
  
\- o - 
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Escribe en el registro de eventos una entrada de error, advertencia, información, auditoría correcta o auditoría incorrecta con el texto de mensaje dado mediante el origen de eventos registrado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada de un <xref:System.Diagnostics.EventLogEntryType> en el registro de eventos mediante un origen ya registrado como un origen de eventos para el registro adecuado. El `type` se indica mediante un icono y texto en la columna de tipo en el Visor de eventos para un registro.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
  
   
  
## Examples  
 El ejemplo siguiente escribe una entrada de advertencia en un registro de eventos, "MyNewLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
\- o - 
El valor <paramref name="source" /> es <see langword="null" />.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <param name="category">Subcategoría específica de la aplicación asociada al mensaje.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado, el identificador de eventos definido por la aplicación y la categoría definida por la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada con una aplicación define `category` al registro de eventos. El Visor de eventos usa la categoría para filtrar los eventos escritos por un origen de eventos. El Visor de eventos puede mostrar la categoría como un valor numérico o la categoría puede usar como identificador de recurso para mostrar una cadena de categoría adaptada.  
  
> [!NOTE]
>  El `category` parámetro debe ser un valor positivo. Valores de categoría negativos aparecen como un número positivo complementario del Visor de eventos. Por ejemplo, -10 aparece como 65.526, -1 como 65.535.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Para mostrar las cadenas de categoría traducida del Visor de eventos, debe usar un origen de eventos configurado con un archivo de recursos de categoría y establezca el `category` a un identificador de recurso en el archivo de recursos de categoría. Si el origen del evento no tiene un archivo de recursos de categoría configurado o especificado `category` no indiza una cadena en el archivo de recursos de categoría, a continuación, el Visor de eventos muestra el valor de categoría numérica para esa entrada. Configurar el archivo de recursos de categoría, junto con el número de cadenas de categoría en el archivo de recursos, mediante el <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventSourceCreationData> clase.  
  
 Además de la categoría, puede especificar un identificador de evento para el evento que se escriben en el registro de eventos. Los identificadores de eventos, junto con el origen del evento, identifican de forma única un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y se sugiere qué acciones emprender.  
  
 Por último, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y texto en la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> antes de llamar a la instancia <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema necesita para registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> no se estableció la propiedad en su <xref:System.Diagnostics.EventLog> instancia, el registro el valor predeterminado es el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones enumeradas anteriormente son generados por errores generados durante el proceso de registrar el <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no se está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
O bien 
El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
\- o - 
El origen ya está registrado para otro registro de eventos.  
  
\- o - 
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado y el identificador de eventos definido por la aplicación mediante el origen de eventos registrado que se especifique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada con una aplicación define `eventID` en el registro de eventos mediante un origen ya registrado como un origen de eventos para el registro adecuado. El `eventID`, junto con el origen, identificar de forma única un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Los visores de eventos presentan estas cadenas al usuario para ayudar al usuario a comprender qué salió mal y se sugiere qué acciones emprender.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Además del identificador de evento, esta sobrecarga de <xref:System.Diagnostics.EventLog.WriteEntry%2A> le permite especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y texto en la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
\- o - 
El valor <paramref name="source" /> es <see langword="null" />.  
  
\- o - 
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <param name="category">Subcategoría específica de la aplicación asociada al mensaje.</param>
        <param name="rawData">Matriz de bytes que incluye los datos binarios asociados a la entrada.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado, el identificador de eventos definido por la aplicación y la categoría definida por la aplicación y anexa datos binarios al mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para escribir datos de evento específico definido por la aplicación en el registro de eventos. El Visor de eventos no interpreta este tipo de datos; Muestra los datos sin procesar solo en un formato hexadecimal y de texto combinado. Usar datos específicos del evento con moderación, incluirlo solo si está seguro de que serán útiles para alguien que depure el problema. También puede usar los datos específicos del evento para almacenar información de que la aplicación puede procesar con independencia del Visor de eventos. Por ejemplo, podría escribir un visor específicamente para los eventos, o escribir un programa que examina el archivo de registro y crea informes que incluyen información de los datos específicos del evento.  
  
 Además de los datos binarios, puede especificar una categoría definida por la aplicación y un identificador de evento definido por la aplicación. El Visor de eventos usa la categoría para filtrar los eventos escritos por un origen de eventos. El Visor de eventos puede mostrar la categoría como un valor numérico o la categoría puede usar como identificador de recurso para mostrar una cadena de categoría adaptada.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
> [!NOTE]
>  El `category` parámetro debe ser un valor positivo. Valores de categoría negativos aparecen como un número positivo complementario del Visor de eventos. Por ejemplo, -10 aparece como 65.526, -1 como 65.535.  
  
 Para mostrar las cadenas de categoría traducida del Visor de eventos, debe usar un origen de eventos configurado con un archivo de recursos de categoría y establezca el `category` a un identificador de recurso en el archivo de recursos de categoría. Si el origen del evento no tiene un archivo de recursos de categoría configurado o especificado `category` no indiza una cadena en el archivo de recursos de categoría, a continuación, el Visor de eventos muestra el valor de categoría numérica para esa entrada. Configurar el archivo de recursos de categoría, junto con el número de cadenas de categoría en el archivo de recursos, mediante el <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventSourceCreationData> clase.  
  
 Los identificadores de eventos, junto con el origen del evento, identifican de forma única un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y se sugiere qué acciones emprender.  
  
 Por último, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y texto en la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> antes de llamar a la instancia <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema necesita para registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> no se estableció la propiedad en su <xref:System.Diagnostics.EventLog> instancia, el registro el valor predeterminado es el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones enumeradas anteriormente son generados por errores generados durante el proceso de registrar el <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no se está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
O bien 
El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
\- o - 
El origen ya está registrado para otro registro de eventos.  
  
\- o - 
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <param name="category">Subcategoría específica de la aplicación asociada al mensaje.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado, el identificador de eventos definido por la aplicación y la categoría definida por la aplicación mediante el origen de eventos registrado específico. El Visor de eventos puede usar el parámetro <paramref name="category" /> para filtrar los eventos del registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada con una aplicación define `category` en el registro de eventos mediante un origen que ya está registrado como un origen de eventos para el registro adecuado. El Visor de eventos usa la categoría para filtrar los eventos escritos por un origen de eventos. El Visor de eventos puede mostrar la categoría como un valor numérico o la categoría puede usar como identificador de recurso para mostrar una cadena de categoría adaptada.  
  
> [!NOTE]
>  El `category` parámetro debe ser un valor positivo. Valores de categoría negativos aparecen como un número positivo complementario del Visor de eventos. Por ejemplo, -10 aparece como 65.526, -1 como 65.535.  
  
 Para mostrar las cadenas de categoría traducida del Visor de eventos, debe usar un origen de eventos configurado con un archivo de recursos de categoría y establezca el `category` a un identificador de recurso en el archivo de recursos de categoría. Si el origen del evento no tiene un archivo de recursos de categoría configurado o especificado `category` no indiza una cadena en el archivo de recursos de categoría, a continuación, el Visor de eventos muestra el valor de categoría numérica para esa entrada. Configurar el archivo de recursos de categoría, junto con el número de cadenas de categoría en el archivo de recursos, mediante el <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventSourceCreationData> clase.  
  
 Además de la categoría, puede especificar un identificador de evento para el evento que se escriben en el registro de eventos. Los identificadores de eventos, junto con el origen del evento, identifican de forma única un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y se sugiere qué acciones emprender.  
  
 Por último, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y texto en la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
>   
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
\- o - 
El valor <paramref name="source" /> es <see langword="null" />.  
  
\- o - 
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <param name="category">Subcategoría específica de la aplicación asociada al mensaje.</param>
        <param name="rawData">Matriz de bytes que incluye los datos binarios asociados a la entrada.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado, el identificador de eventos definido por la aplicación y la categoría definida por la aplicación (mediante el origen de eventos registrado especificado) y anexa datos binarios al mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir datos de evento específico definido por la aplicación en el registro de eventos mediante un origen ya está registrado como un origen de eventos para el registro adecuado. El Visor de eventos no interpreta este tipo de datos; Muestra los datos sin procesar solo en un formato hexadecimal y de texto combinado. Usar con moderación; los datos específicos del evento incluir solo si está seguro de que serán útiles. También puede usar los datos específicos del evento para almacenar información de que la aplicación puede procesar con independencia del Visor de eventos. Por ejemplo, podría escribir un visor específicamente para los eventos, o escribir un programa que examina el archivo de registro y crea informes que incluyen información de los datos específicos del evento.  
  
 Además de los datos binarios, puede especificar una categoría definida por la aplicación y un identificador de evento definido por la aplicación. El Visor de eventos usa la categoría para filtrar los eventos escritos por un origen de eventos. El Visor de eventos puede mostrar la categoría como un valor numérico o la categoría puede usar como identificador de recurso para mostrar una cadena de categoría adaptada.  
  
> [!NOTE]
>  El `category` parámetro debe ser un valor positivo. Valores de categoría negativos aparecen como un número positivo complementario del Visor de eventos. Por ejemplo, -10 aparecerá como 65.526, -1 como 65.535.  
  
 Para mostrar las cadenas de categoría traducida del Visor de eventos, debe usar un origen de eventos configurado con un archivo de recursos de categoría y establezca el `category` a un identificador de recurso en el archivo de recursos de categoría. Si el origen del evento no tiene un archivo de recursos de categoría configurado o especificado `category` no indiza una cadena en el archivo de recursos de categoría, a continuación, el Visor de eventos muestra el valor de categoría numérica para esa entrada. Configurar el archivo de recursos de categoría, junto con el número de cadenas de categoría en el archivo de recursos, mediante el <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventSourceCreationData> clase.  
  
 Los identificadores de eventos, junto con el origen del evento, identifican de forma única un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y se sugiere qué acciones emprender.  
  
 Por último, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y texto en la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no utiliza un archivo de recursos de mensaje localizable. Use el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir los eventos mediante un archivo de recursos de mensaje localizado.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, se termina el mensaje en el registro de eventos en el carácter NUL.  
>   
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
\- o - 
El valor <paramref name="source" /> es <see langword="null" />.  
  
\- o - 
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe una entrada de evento localizada en el registro de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Instancia de <see cref="T:System.Diagnostics.EventInstance" /> que representa una entrada localizada del registro de eventos.</param>
        <param name="values">Matriz de cadenas que se van a fusionar mediante combinación para formar el texto del mensaje de la entrada del registro de eventos.</param>
        <summary>Escribe una entrada localizada en el registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada localizada en el registro de eventos. Especifique las propiedades de eventos con identificadores de recursos en lugar de los valores de cadena. El Visor de eventos utiliza los identificadores de recursos para mostrar las cadenas correspondientes del archivo de recursos localizados para el <xref:System.Diagnostics.EventLog.Source%2A>. Debe registrar el origen con el correspondiente archivo de recursos antes de escribir eventos con identificadores de recursos.  
  
 La entrada `instance` instancia especifica las propiedades y el mensaje de evento. Establecer el <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` de entrada para el mensaje definido en el archivo de recursos de mensaje de origen. Opcionalmente, puede establecer el <xref:System.Diagnostics.EventInstance.CategoryId%2A> y <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrada para definir el tipo de categoría y eventos de la entrada del evento. También puede especificar una matriz de cadenas independientes del lenguaje para insertar en el texto del mensaje localizado. Establecer `values` a `null` si el mensaje de evento no contiene marcadores de formato para las cadenas de reemplazo.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. El origen especificado debe configurarse para escribir entradas adaptadas en el registro; el origen debe tener como mínimo un archivo de recursos de mensaje definido.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Use el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método si la aplicación escribe los valores de cadena directamente en el registro de eventos.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si escribe una entrada a un equipo remoto, el valor de la `message` cadena podría no ser los esperados si el equipo remoto no se está ejecutando .NET Framework. Además, el `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 El ejemplo siguiente escribe dos entradas al registro de eventos de auditoría `myNewLog`. En el ejemplo se crea un nuevo origen de eventos y un registro de eventos si no existen en el equipo local. El texto del mensaje de evento se especifica mediante un identificador de recursos en un archivo de recursos.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 El ejemplo utiliza el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto del mensaje es el origen desde el que se crea el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto para la categoría, mensaje de evento y las cadenas de inserción de parámetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
O bien 
El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
\- o - 
El origen ya está registrado para otro registro de eventos.  
  
\- o - 
 <paramref name="instance.InstanceId" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
 <paramref name="values" /> tiene más de 256 elementos.  
  
\- o - 
Uno de los elementos <paramref name="values" /> tiene más de 32766 bytes.  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="instance" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Instancia de <see cref="T:System.Diagnostics.EventInstance" /> que representa una entrada localizada del registro de eventos.</param>
        <param name="data">Matriz de bytes que incluye los datos binarios asociados a la entrada.</param>
        <param name="values">Matriz de cadenas que se van a fusionar mediante combinación para formar el texto del mensaje de la entrada del registro de eventos.</param>
        <summary>Escribe una entrada de registro de eventos con los datos de evento dados, con cadenas de reemplazo de mensajes y con datos binarios asociados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada localizada con datos adicionales específicos de eventos en el registro de eventos. Especifique las propiedades de eventos con identificadores de recursos en lugar de los valores de cadena. El Visor de eventos utiliza los identificadores de recursos para mostrar las cadenas correspondientes del archivo de recursos localizados para el <xref:System.Diagnostics.EventLog.Source%2A>. Debe registrar el origen con el correspondiente archivo de recursos antes de escribir eventos con identificadores de recursos.  
  
 La entrada `instance` instancia especifica las propiedades y el mensaje de evento. Establecer el <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` de entrada para el mensaje definido en el archivo de recursos de mensaje de origen. Opcionalmente, puede establecer el <xref:System.Diagnostics.EventInstance.CategoryId%2A> y <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrada para definir el tipo de categoría y eventos de la entrada del evento. También puede especificar una matriz de cadenas independientes del lenguaje para insertar en el texto del mensaje localizado. Establecer `values` a `null` si el mensaje de evento no contiene marcadores de formato para las cadenas de reemplazo.  
  
 Especificar datos binarios con un evento cuando es necesario proporcionar detalles adicionales para el evento. Por ejemplo, use el `data` parámetro incluir información sobre un error específico. El Visor de eventos no interpreta los datos de evento asociado; Muestra los datos en un formato hexadecimal y de texto combinado. Usar con moderación; los datos específicos del evento incluir solo si está seguro de que serán útiles. También puede usar los datos específicos del evento para almacenar información de que la aplicación puede procesar con independencia del Visor de eventos. Por ejemplo, podría escribir un visor específicamente para los eventos, o escribir un programa que examina el registro de eventos y crea informes que incluyen información de los datos específicos del evento.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de componente antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. El origen especificado debe configurarse para escribir entradas adaptadas en el registro; el origen debe tener como mínimo un archivo de recursos de mensaje definido.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> antes de llamar a la instancia <xref:System.Diagnostics.EventLog.WriteEvent%2A>, el equipo local (".") se da por hecho.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Use el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método si la aplicación escribe los valores de cadena directamente en el registro de eventos.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
> [!NOTE]
>  Si escribe una entrada a un equipo remoto, el valor de la `message` cadena podría no ser los esperados si el equipo remoto no se está ejecutando .NET Framework. Además, el `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 El ejemplo siguiente escribe dos entradas al registro de eventos de auditoría `myNewLog`. En el ejemplo se crea un nuevo origen de eventos y un registro de eventos si no existen en el equipo local. El texto del mensaje de evento se especifica mediante un identificador de recursos en un archivo de recursos.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 El ejemplo utiliza el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto del mensaje es el origen desde el que se crea el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto para la categoría, mensaje de evento y las cadenas de inserción de parámetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
O bien 
El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
\- o - 
El origen ya está registrado para otro registro de eventos.  
  
\- o - 
 <paramref name="instance.InstanceId" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
 <paramref name="values" /> tiene más de 256 elementos.  
  
\- o - 
Uno de los elementos <paramref name="values" /> tiene más de 32766 bytes.  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="instance" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos registrado para la aplicación en el equipo especificado.</param>
        <param name="instance">Instancia de <see cref="T:System.Diagnostics.EventInstance" /> que representa una entrada localizada del registro de eventos.</param>
        <param name="values">Matriz de cadenas que se van a fusionar mediante combinación para formar el texto del mensaje de la entrada del registro de eventos.</param>
        <summary>Escribe una entrada de registro de eventos con las cadenas de reemplazo de mensaje y los datos de evento proporcionados, para lo que utiliza el origen de eventos registrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada localizada en el registro de eventos mediante un origen ya está registrado como un origen de eventos para el registro adecuado. Especifique las propiedades de eventos con identificadores de recursos en lugar de los valores de cadena. El Visor de eventos utiliza los identificadores de recursos para mostrar las cadenas correspondientes desde el archivo de recursos localizado para el origen. Debe registrar el origen con el correspondiente archivo de recursos antes de escribir eventos con identificadores de recursos.  
  
 La entrada `instance` instancia especifica las propiedades y el mensaje de evento. Establecer el <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` de entrada para el mensaje definido en el archivo de recursos de mensaje de origen. Opcionalmente, puede establecer el <xref:System.Diagnostics.EventInstance.CategoryId%2A> y <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrada para definir el tipo de categoría y eventos de la entrada del evento. También puede especificar una matriz de cadenas independientes del lenguaje para insertar en el texto del mensaje localizado. Establecer `values` a `null` si el mensaje de evento no contiene marcadores de formato para las cadenas de reemplazo.  
  
 El origen especificado debe estar registrado para un registro de eventos antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. El origen especificado debe configurarse para escribir entradas adaptadas en el registro; el origen debe tener como mínimo un archivo de recursos de mensaje definido.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Use el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método si la aplicación escribe los valores de cadena directamente en el registro de eventos.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
   
  
## Examples  
 El ejemplo siguiente escribe una entrada de evento de información y una entrada de evento de advertencia en un registro de eventos existente. El texto del mensaje de evento se especifica mediante un identificador de recursos en un archivo de recursos. El ejemplo se supone que el archivo de recursos correspondiente se ha registrado para el origen.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 El ejemplo utiliza el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto del mensaje es el origen desde el que se crea el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto para la categoría, mensaje de evento y las cadenas de inserción de parámetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
\- o - 
El valor <paramref name="source" /> es <see langword="null" />.  
  
\- o - 
 <paramref name="instance.InstanceId" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
 <paramref name="values" /> tiene más de 256 elementos.  
  
\- o - 
Uno de los elementos <paramref name="values" /> tiene más de 32766 bytes.  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="instance" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos registrado para la aplicación en el equipo especificado.</param>
        <param name="instance">Instancia de <see cref="T:System.Diagnostics.EventInstance" /> que representa una entrada localizada del registro de eventos.</param>
        <param name="data">Matriz de bytes que incluye los datos binarios asociados a la entrada.</param>
        <param name="values">Matriz de cadenas que se van a fusionar mediante combinación para formar el texto del mensaje de la entrada del registro de eventos.</param>
        <summary>Escribe una entrada de registro con los datos de evento dados, con cadenas de reemplazo de mensajes y con datos binarios asociados y, además, utiliza el origen de eventos registrado que se especifica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada localizada con datos adicionales específicos de eventos en el registro de eventos mediante un origen ya está registrado como un origen de eventos para el registro adecuado. Especifique las propiedades de eventos con identificadores de recursos en lugar de los valores de cadena. El Visor de eventos utiliza los identificadores de recursos para mostrar las cadenas correspondientes desde el archivo de recursos localizado para el origen. Debe registrar el origen con el correspondiente archivo de recursos antes de escribir eventos con identificadores de recursos.  
  
 La entrada `instance` instancia especifica las propiedades y el mensaje de evento. Establecer el <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` de entrada para el mensaje definido en el archivo de recursos de mensaje de origen. Opcionalmente, puede establecer el <xref:System.Diagnostics.EventInstance.CategoryId%2A> y <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrada para definir el tipo de categoría y eventos de la entrada del evento. También puede especificar una matriz de cadenas independientes del lenguaje para insertar en el texto del mensaje localizado. Establecer `values` a `null` si el mensaje de evento no contiene marcadores de formato para las cadenas de reemplazo.  
  
 Especificar datos binarios con un evento cuando es necesario proporcionar detalles adicionales para el evento. Por ejemplo, use el `data` parámetro incluir información sobre un error específico. El Visor de eventos no interpreta los datos de evento asociado; Muestra los datos en un formato hexadecimal y de texto combinado. Usar con moderación; los datos específicos del evento incluir solo si está seguro de que serán útiles. También puede usar los datos específicos del evento para almacenar información de que la aplicación puede procesar con independencia del Visor de eventos. Por ejemplo, podría escribir un visor específicamente para los eventos, o escribir un programa que examina el registro de eventos y crea informes que incluyen información de los datos específicos del evento.  
  
 El origen especificado debe estar registrado para un registro de eventos antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. El origen especificado debe configurarse para escribir entradas adaptadas en el registro; el origen debe tener como mínimo un archivo de recursos de mensaje definido.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el tiempo para el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos e intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen utilizando un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Use el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método si la aplicación escribe los valores de cadena directamente en el registro de eventos.  
  
 Si su aplicación escribe las entradas mediante identificadores de recursos y los valores de cadena, debe registrar dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos con ese origen.  
  
   
  
## Examples  
 El ejemplo siguiente escribe una entrada de evento de información y una entrada de evento de advertencia en un registro de eventos existente. El texto del mensaje de evento se especifica mediante un identificador de recursos en un archivo de recursos. El ejemplo se supone que el archivo de recursos correspondiente se ha registrado para el origen.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 El ejemplo utiliza el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto del mensaje es el origen desde el que se crea el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto para la categoría, mensaje de evento y las cadenas de inserción de parámetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
\- o - 
El valor <paramref name="source" /> es <see langword="null" />.  
  
\- o - 
 <paramref name="instance.InstanceId" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
\- o - 
 <paramref name="values" /> tiene más de 256 elementos.  
  
\- o - 
Uno de los elementos <paramref name="values" /> tiene más de 32766 bytes.  
  
\- o - 
El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="instance" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>