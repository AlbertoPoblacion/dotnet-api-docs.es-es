<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2145a11bbb9faa94763035b22147eede6d4adee" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30400609" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona interacción con los registros de eventos de Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> le permite tener acceso o personalizar los registros de eventos de Windows, que registra información acerca de eventos importantes de software o hardware. Usar <xref:System.Diagnostics.EventLog>, puede leer los registros existentes, escribir entradas en registros, crear o eliminar orígenes de eventos, eliminar registros y responder a las entradas de registro. También puede crear nuevos registros al crear un origen de eventos.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 Además de proporcionar acceso a los registros de eventos individuales y sus entradas, la <xref:System.Diagnostics.EventLog> clase le permite tener acceso a la colección de todos los registros de eventos. Puede usar el `static` los miembros de <xref:System.Diagnostics.EventLog> para eliminar registros, obtener listas de registros, crear o eliminar un origen o determinar si un equipo ya contiene un origen determinado.  
  
 Hay tres registros de eventos predeterminados: aplicación, sistema y seguridad. Un registro de seguridad es de solo lectura. Otras aplicaciones y servicios que se instala, como Active Directory, podrían tener registros de eventos adicionales.  
  
 Existen consideraciones de seguridad cuando se usa el <xref:System.Diagnostics.EventLog> clase. <xref:System.Diagnostics.EventLog> requiere <xref:System.Diagnostics.EventLogPermission> permisos para acciones específicas en el .NET Framework 2.0 y versiones posteriores, o de plena confianza en .NET Framework 1.0 y 1.1. Se recomienda que <xref:System.Diagnostics.EventLogPermission> no se conceden al código de confianza parcial.  No debe pasar nunca cualquier objeto de registro de eventos, incluidos los <xref:System.Diagnostics.EventLogEntryCollection> y <xref:System.Diagnostics.EventLogEntry> objetos al código de menor confianza. Por ejemplo, al crear un <xref:System.Diagnostics.EventLog> objeto, escribir una entrada y, a continuación, pasar la <xref:System.Diagnostics.EventLog> objeto al código de confianza parcial puede crear un problema de seguridad, ya que la capacidad de leer y escribir en el registro de eventos permite que el código para realizar acciones como la emisión de mensajes de registro de eventos en el nombre de otra aplicación.  
  
 A partir de Windows Vista, Control de cuentas de usuario (UAC) determina las credenciales de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso el registro de seguridad, primero debe elevar el nivel sus credenciales de usuario estándar a administrador. Puede hacerlo cuando inicie una aplicación, abra el menú contextual de la aplicación (si está usando un mouse, haga clic en el icono de la aplicación) e indique que desea ejecutarla como administrador.  
  
 Puede usar <xref:System.Diagnostics.EventLog> para crear registros de eventos personalizados que se pueden ver a través del servidor del Visor de eventos. Use la <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> método para mostrar un nombre traducido para el registro de eventos en el Visor de eventos. Use la <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método para configurar el comportamiento de su registro de eventos cuando alcanza su tamaño máximo del registro.  
  
 Para leer de un registro de eventos, especifique el nombre del registro (<xref:System.Diagnostics.EventLog.Log%2A> propiedad) y el nombre de equipo del servidor (<xref:System.Diagnostics.EventLog.MachineName%2A> propiedad para el registro de eventos. Si no se especifica el nombre del equipo servidor, el equipo local, ".", se da por hecho. No es necesario especificar el origen del evento (<xref:System.Diagnostics.EventLog.Source%2A> propiedad), porque es necesario solo para escribir en registros de un origen. El <xref:System.Diagnostics.EventLog.Entries%2A> propiedad se rellena automáticamente con la lista del registro de eventos de entradas.  
  
 Para escribir en un registro de eventos, especificar o crear un origen de eventos (<xref:System.Diagnostics.EventLog.Source%2A> propiedad). Debe tener credenciales administrativas en el equipo para crear un nuevo origen de eventos. El origen del evento registra la aplicación con el registro de eventos como un origen válido de entradas. Puede usar el origen de eventos para escribir en un único registro a la vez. El <xref:System.Diagnostics.EventLog.Source%2A> propiedad puede ser cualquier cadena aleatoria, pero el nombre debe ser diferente de otros orígenes en el equipo. El origen del evento suele ser el nombre de la aplicación u otra cadena de identificación. Al intentar crear un duplicado <xref:System.Diagnostics.EventLog.Source%2A> valor produce una excepción. Sin embargo, un único registro de eventos puede asociarse con varios orígenes.  
  
 Si el origen de eventos para el registro de eventos asociados con el <xref:System.Diagnostics.EventLog> instancia no existe, se crea un nuevo origen de eventos. Para crear un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener credenciales administrativas.  
  
 Este requisito es porque se deben buscar todos los registros de eventos, incluidos los registros de seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tienen permiso para tener acceso al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
  
> [!IMPORTANT]
>  Crear o eliminar un origen de eventos requiere la sincronización del código subyacente utilizando una exclusión mutua con nombre. Si una aplicación con muchos privilegios bloquea la exclusión mutua con nombre, intenta crear o eliminar un origen de eventos hace que la aplicación deje de responder hasta que se libere el bloqueo. Para evitar este problema, no conceda nunca <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permiso al código de confianza. Además, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> permiso potencialmente permite que otros permisos que se omita y solo debería garantizarse al código de plena confianza.  
  
 En el registro de aplicación o en un registro personalizado, deben escribir aplicaciones y servicios. Controladores de dispositivos deben escribir en el registro del sistema. Si no establece explícitamente la <xref:System.Diagnostics.EventLog.Log%2A> la propiedad, el registro de eventos es el registro de aplicación.  
  
> [!NOTE]
>  No hay nada para proteger una aplicación de escribir como cualquier origen registrado.  Si una aplicación se le conceden <xref:System.Diagnostics.EventLogPermissionAccess.Write> permiso, puede escribir eventos para cualquier origen válido registrado en el equipo.  
  
 Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> métodos para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no se ha actualizado la lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller> objeto o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener credenciales administrativas en el equipo para crear un nuevo origen de eventos.  
  
 Cada origen puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, la aplicación podría requerir configurados para diferentes registros de eventos o archivos de recursos de varios orígenes. Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada en lugar de eliminar el origen existente.  
  
 Puede registrar el origen de eventos con los recursos localizados para las cadenas de categoría y el mensaje de evento. La aplicación puede escribir entradas del registro de eventos mediante el uso de identificadores de recursos en lugar de especificar los valores de cadena real. Hacer referencia a la <xref:System.Diagnostics.EventLogInstaller> y <xref:System.Diagnostics.EventSourceCreationData> clases para obtener más información acerca de cómo configurar el origen con archivos de recursos.  
  
 Si su aplicación escribe valores de cadena directamente en el registro de eventos, no es necesario establecer las propiedades de archivo para el origen de recurso. El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
 Al escribir eventos, debe especificar al menos una cadena de mensaje o el identificador de recurso para una cadena de mensaje. Otras propiedades de evento son opcionales. A continuación se indican algunos ejemplos de configuración opcional de eventos:  
  
-   Puede establecer el <xref:System.Diagnostics.EventLogEntryType> para especificar el icono que muestra el Visor de eventos para la entrada.  
  
-   Puede especificar un identificador de categoría para el evento, si la aplicación utiliza categorías para filtrar los eventos.  
  
-   Puede adjuntar datos binarios a la entrada del evento si desea asociar información adicional a un evento determinado.  
  
> [!IMPORTANT]
>  El registro de eventos consume espacio en disco, tiempo de procesador y otros recursos del sistema. Es importante registrar solamente información esencial. Se recomienda que coloque llamadas de registro de eventos en una ruta de acceso de error, en lugar de en la ruta de acceso de código principal, por lo tanto no afectar negativamente al rendimiento.  
  
 Para obtener una lista de valores de propiedad iniciales para una instancia de <xref:System.Diagnostics.EventLog>, consulte el <xref:System.Diagnostics.EventLog.%23ctor%2A> constructor.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen del evento `MySource` si no existe ya y escribe una entrada en el registro de eventos `MyNewLog`.  
  
> [!NOTE]
>  A partir de Windows Vista, debe ejecutar esta aplicación como administrador.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />. No asocia la instancia a ningún registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de llamar a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de la <xref:System.Diagnostics.EventLog> instancia. Si solo está leyendo <xref:System.Diagnostics.EventLog.Entries%2A> en el registro, o bien puede especificar solo el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho.  
  
 La siguiente tabla muestra los valores de propiedad iniciales para una instancia de <xref:System.Diagnostics.EventLog>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Cadena vacía ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Cadena vacía ("").|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|El equipo local (".").|  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen de `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro en el equipo local.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />. Asocia la instancia a un registro del equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga establece el <xref:System.Diagnostics.EventLog.Log%2A> propiedad a la `logName` parámetro. Antes de llamar a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de la <xref:System.Diagnostics.EventLog> instancia. Si solo está leyendo <xref:System.Diagnostics.EventLog.Entries%2A> en el registro, o bien puede especificar solo el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho. Esta sobrecarga del constructor especifica la <xref:System.Diagnostics.EventLog.Log%2A> propiedad, pero puede cambiar esto antes de leer el <xref:System.Diagnostics.EventLog.Entries%2A> propiedad.  
  
 Si el origen se especifica en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad es exclusivo de otros orígenes en el equipo, una llamada subsiguiente a <xref:System.Diagnostics.EventLog.WriteEntry%2A> crea un registro con el nombre especificado, si aún no existe.  
  
 La siguiente tabla muestra los valores de propiedad iniciales para una instancia de <xref:System.Diagnostics.EventLog>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Cadena vacía ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parámetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|El equipo local (".").|  
  
   
  
## Examples  
 En el ejemplo siguiente se lee las entradas en el registro de eventos, "myNewLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El nombre del registro es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del registro no es válido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro en el equipo especificado.</param>
        <param name="machineName">Equipo en el que existe el registro.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />. Asocia la instancia a un registro en el equipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga establece el <xref:System.Diagnostics.EventLog.Log%2A> propiedad a la `logName` parámetro y el <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad a la `machineName` parámetro. Antes de llamar a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, especifique el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de la <xref:System.Diagnostics.EventLog>. Si solo está leyendo <xref:System.Diagnostics.EventLog.Entries%2A> en el registro, o bien puede especificar solo el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades.  
  
> [!NOTE]
>  Esta sobrecarga del constructor especifica la <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades, pero se puede cambiar antes de leer el <xref:System.Diagnostics.EventLog.Entries%2A> propiedad.  
  
 La siguiente tabla muestra los valores de propiedad iniciales para una instancia de <xref:System.Diagnostics.EventLog>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Cadena vacía ("").|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parámetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Parámetro `machineName`.|  
  
   
  
## Examples  
 En el ejemplo siguiente se lee las entradas en el registro de eventos, "myNewLog", en el equipo "myServer".  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El nombre del registro es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del registro no es válido.  
  
 O bien  
  
 El nombre de equipo no es válido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro en el equipo especificado.</param>
        <param name="machineName">Equipo en el que existe el registro.</param>
        <param name="source">Origen de las entradas del registro de eventos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.EventLog" />. Asocia la instancia a un registro en el equipo especificado y crea o asigna el origen especificado a <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor establece la <xref:System.Diagnostics.EventLog.Log%2A> propiedad a la `logName` parámetro, el <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad a la `machineName` parámetro y el <xref:System.Diagnostics.EventLog.Source%2A> propiedad a la `source` parámetro. El <xref:System.Diagnostics.EventLog.Source%2A> propiedad es necesaria cuando se escribe en un registro de eventos. Sin embargo, si solo está leyendo de un registro de eventos, solo el <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades son necesarias (siempre y cuando el registro de eventos en el servidor tenga ya un origen asociado con él). Si solo está leyendo desde el registro de eventos, puede ser suficiente otra sobrecarga del constructor.  
  
 La siguiente tabla muestra los valores de propiedad iniciales para una instancia de <xref:System.Diagnostics.EventLog>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|Parámetro `source`.|  
|<xref:System.Diagnostics.EventLog.Log%2A>|Parámetro `logName`.|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|Parámetro `machineName`.|  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe una entrada en un registro de eventos, "MyNewLog", en el equipo local, con el origen "MySource".  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El nombre del registro es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El nombre del registro no es válido.  
  
 O bien  
  
 El nombre de equipo no es válido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comienza la inicialización de un objeto <see cref="T:System.Diagnostics.EventLog" /> que se emplea en un formulario o que utiliza otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] diseño entorno usa este método para comenzar la inicialización de un componente utilizado en un formulario o por otro componente. El <xref:System.Diagnostics.EventLog.EndInit%2A> método termina la inicialización. Mediante el <xref:System.Diagnostics.EventLog.BeginInit%2A> y <xref:System.Diagnostics.EventLog.EndInit%2A> métodos impiden que se utilice antes de que se inicialice completamente el control.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> ya se ha inicializado.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todas las entradas del registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registros de eventos se establecen con un tamaño máximo que determina cuántas entradas pueden contener. Cuando un registro de eventos está lleno, se detiene la grabación de la nueva información de eventos o comienza a sobrescribir las entradas anteriores. Si se detiene el registro de eventos, puede usar este método para borrar el registro de las entradas existentes y permitir que se vuelva a iniciar la grabación de eventos. Debe tener permisos de administrador en el equipo en el que reside el registro para borrar las entradas de registro de eventos.  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> cierra el registro de eventos, libera los identificadores de eventos, recupera nueva lectura y escritura de controladores y vuelve a abrir el registro de eventos. Eventos recibidos después de la llamada al método no se borran junto con los eventos existentes.  
  
   
  
## Examples  
 En el ejemplo siguiente se borra un registro de eventos.  
  
> [!CAUTION]
>  Porque la aplicación, sistema, seguridad y otros registros no personalizados pueden contener información crucial; Asegúrese de especificar un registro personalizado antes de ejecutar este código de ejemplo. Este ejemplo elimina el registro personalizado `myNewLog`.  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">El registro de eventos no se ha borrado correctamente.  
  
 O bien  
  
 No puede abrirse el registro. No hay ningún código de error de Windows disponible.</exception>
        <exception cref="T:System.ArgumentException">No se especifica un valor para la propiedad <see cref="P:System.Diagnostics.EventLog.Log" />. Asegúrese de que el nombre del Registro no es una cadena vacía.</exception>
        <exception cref="T:System.InvalidOperationException">El registro no existe.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra el registro de eventos y libera los identificadores de lectura y escritura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.EventLog.Close%2A> se llama al método mediante el protegido <xref:System.ComponentModel.Component.Dispose%2A> método. No es necesario invocar <xref:System.Diagnostics.EventLog.Close%2A> antes de llamar a <xref:System.ComponentModel.Component.Dispose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">El identificador de lectura o el identificador de escritura del registro de eventos no se ha liberado correctamente.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece una aplicación como capaz de escribir información de eventos en un determinado registro del sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">Propiedades de configuración para el origen de eventos y su registro de eventos de destino.</param>
        <summary>Establece un origen de eventos válido para la escritura de mensajes de evento localizados, mediante las propiedades de configuración especificadas para el origen y el correspondiente registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para configurar un nuevo origen para escribir entradas en un registro de eventos en el equipo local o en un equipo remoto. No es necesario utilizar este método para leer de un registro de eventos.  
  
 El <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método usa la entrada `sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> y <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> propiedades para crear valores del registro en el equipo de destino para el nuevo origen y su registro de eventos asociado. Un nuevo nombre de origen no puede coincidir con un nombre de origen existente o un nombre de registro de eventos existente en el equipo de destino. Si el <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> no está establecida la propiedad, se registra el origen para el registro de eventos de aplicación. Si el <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> no está establecido, el origen está registrado en el equipo local.  
  
> [!NOTE]
>  Para crear un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que se deben buscar todos los registros de eventos, como la seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tienen permiso para tener acceso al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  A partir de Windows Vista, Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso el registro de seguridad, primero debe elevar el nivel los privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Puede crear un origen de eventos para un registro de eventos existente o un nuevo registro de eventos. Cuando se crea un nuevo origen para un registro de eventos, el sistema registra el origen para este registro, pero no se crea el registro hasta que la primera entrada se escribe en él.  
  
 El sistema operativo almacena los registros de eventos como archivos. Cuando usas <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para crear un nuevo registro de eventos, el archivo asociado se almacena en el directorio %SystemRoot%\System32\Config del equipo especificado. El nombre de archivo se establece anexando los 8 primeros caracteres de la <xref:System.Diagnostics.EventLog.Log%2A> propiedad con la extensión de nombre de archivo "evt".  
  
 Cada origen sólo puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, la aplicación podría requerir configurados para diferentes registros de eventos o archivos de recursos de varios orígenes.  
  
 Puede registrar el origen de eventos con los archivos de recursos localizados para las cadenas de categoría y el mensaje de evento. La aplicación puede escribir entradas del registro de eventos con identificadores de recursos, en lugar de especificar la cadena real. El Visor de eventos usa el identificador de recursos para buscar y mostrar la cadena correspondiente del archivo de recursos localizado en función de la configuración de idioma actual. Puede registrar un archivo independiente para categorías de eventos, mensajes y las cadenas de inserción de parámetro, o puede registrar el mismo archivo de recursos para los tres tipos de cadenas. Use la <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, y <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> propiedades para configurar el origen para escribir entradas adaptadas en el registro de eventos. Si su aplicación escribe valores de cadenas directamente en el registro de eventos, no es necesario establecer estas propiedades.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
 Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada, en lugar de eliminar el origen existente.  
  
> [!NOTE]
>  Si se configura un origen para un registro de eventos, y volver a configurar para otro registro de eventos, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina si el origen de eventos denominado `SampleApplicationSource` está registrado en el equipo local. Si el origen del evento no existe, el ejemplo establece el archivo de recursos de mensaje para el origen y crea el nuevo origen de eventos. Por último, en el ejemplo se establece el nombre para mostrar localizado para el registro de eventos utilizando el valor de identificador de recurso en `DisplayNameMsgId` y la ruta de acceso del archivo de recursos en `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 En el ejemplo se usa el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto de mensaje es el origen desde el que se creó el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto de categoría, mensaje de evento y las cadenas de inserción de parámetro. En concreto, el identificador de recursos 5001 se define para el nombre localizado del registro de eventos.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de equipo especificado en <paramref name="sourceData" /> no es válido.  
  
 \- o -  
  
 El nombre del origen especificado en <paramref name="sourceData" /> es <see langword="null" />.  
  
 \- o -  
  
 El nombre de registro especificado en <paramref name="sourceData" /> no es válido. Los nombres de los registros de eventos deben estar compuestos por caracteres imprimibles, excluidos "*", "?" o "\\".  
  
 \- o -  
  
 El nombre del registro especificado en <paramref name="sourceData" /> no es válido para la creación de registros de usuario. Los nombres de registro de eventos AppEvent, SysEvent y SecEvent están reservados para uso del sistema.  
  
 \- o -  
  
 El nombre del registro coincide con el nombre de un origen de eventos ya existente.  
  
 \- o -  
  
 El nombre de origen especificado en <paramref name="sourceData" /> produce una ruta de clave del Registro con una longitud superior a 254 caracteres.  
  
 \- o -  
  
 Los 8 primeros caracteres del nombre del registro especificado en <paramref name="sourceData" /> no son únicos.  
  
 \- o -  
  
 El nombre de origen especificado en <paramref name="sourceData" /> ya está registrado.  
  
 \- o -  
  
 El nombre de origen especificado en <paramref name="sourceData" /> coincide con un nombre del registro de eventos ya existente.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen por el que se registra la aplicación en el equipo local.</param>
        <param name="logName">Nombre del registro en el que se escriben las entradas del origen. Entre los posibles valores se incluye Aplicación, Sistema o un registro de eventos personalizado.</param>
        <summary>Establece el nombre de origen especificado como origen de eventos válido para la escritura de entradas en un registro del equipo local. Este método también puede crear un nuevo registro personalizado en el equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear un registro personalizado o para crear y registrar un <xref:System.Diagnostics.EventLog.Source%2A> en un registro existente en el equipo local.  
  
 Si `logName` es `null` o una cadena vacía ("") cuando se llama a <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, tiene como valor predeterminado en el registro en el registro de aplicación. Si el registro no existe en el equipo local, el sistema crea un registro personalizado y registra la aplicación como un <xref:System.Diagnostics.EventLog.Source%2A> para este registro.  
  
> [!NOTE]
>  Para crear un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que se deben buscar todos los registros de eventos, como la seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tienen permiso para tener acceso al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  En Windows Vista y versiones posteriores, el Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso el registro de seguridad, primero debe elevar el nivel los privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
 Basta con crear un origen de eventos si va a escribir en el registro de eventos. Antes de escribir una entrada en un registro de eventos, debe registrar el origen de eventos con el registro de eventos como un origen válido de eventos. Cuando se escribe una entrada del registro, el sistema utiliza el <xref:System.Diagnostics.EventLog.Source%2A> para buscar el registro adecuado en el que se va a colocar la entrada. Si está leyendo el registro de eventos, puede especificar el <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  No tienen que especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro en el equipo local. Si no se especifica la <xref:System.Diagnostics.EventLog.MachineName%2A> al leer de un registro, el equipo local (".") se da por hecho.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Puede crear un origen de eventos para un registro de eventos existente o un nuevo registro de eventos. Cuando se crea un nuevo origen para un registro de eventos, el sistema registra el origen para este registro, pero no se crea el registro hasta que la primera entrada se escribe en él.  
  
 El sistema operativo almacena los registros de eventos como archivos. Cuando usas <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para crear un nuevo registro de eventos, el archivo asociado se almacena en el directorio %SystemRoot%\System32\Config del equipo especificado. El nombre de archivo se establece anexando los 8 primeros caracteres de la <xref:System.Diagnostics.EventLog.Log%2A> propiedad con la extensión de nombre de archivo "evt".  
  
 El origen debe ser único en el equipo local; un nuevo nombre de origen no puede coincidir con un nombre de origen existente o un nombre de registro de eventos existente. Cada origen puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, la aplicación podría requerir configurados para diferentes registros de eventos o archivos de recursos de varios orígenes.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
 Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada, en lugar de eliminar el origen existente.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarlo a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen de `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> es una cadena vacía ("") o <see langword="null" />.  
  
 \- o -  
  
 <paramref name="logName" /> no es un nombre de registro de eventos válido. Los nombres de los registros de eventos deben estar compuestos por caracteres imprimibles, excluidos "*", "?" o "\\".  
  
 \- o -  
  
 <paramref name="logName" /> no es válido para la creación del registro de usuario. Los nombres de registro de eventos AppEvent, SysEvent y SecEvent están reservados para uso del sistema.  
  
 \- o -  
  
 El nombre del registro coincide con el nombre de un origen de eventos ya existente.  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.  
  
 \- o -  
  
 Los 8 primeros caracteres de <paramref name="logName" /> coinciden con los 8 primeros caracteres del nombre de un registro de eventos ya existente.  
  
 \- o -  
  
 No puede registrarse el origen porque ya existe en el equipo local.  
  
 \- o -  
  
 El nombre del origen coincide con el nombre de un registro de eventos ya existente.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir en el equipo local la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="logName">Nombre del registro en el que se escriben las entradas del origen. Entre los posibles valores se incluye Aplicación, Sistema o un registro de eventos personalizado. Si no se especifica un valor <c>logName</c>, toma Aplicación como valor predeterminado.</param>
        <param name="machineName">Nombre del equipo con el que se va a registrar este origen de eventos o "." para el equipo local.</param>
        <summary>Establece el nombre de origen especificado como origen de eventos válido para la escritura de entradas en un registro del equipo especificado. Este método puede utilizarse también para crear un nuevo registro personalizado en el equipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear un registro personalizado o para crear y registrar un <xref:System.Diagnostics.EventLog.Source%2A> en un registro existente en el equipo especificado.  
  
 Si `logName` es `null` o una cadena vacía ("") cuando se llama a <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, tiene como valor predeterminado en el registro en el registro de aplicación. Si el registro no existe en el equipo especificado, el sistema crea un registro personalizado y registra la aplicación como un <xref:System.Diagnostics.EventLog.Source%2A> para este registro.  
  
 Basta con crear un origen de eventos si va a escribir en el registro de eventos. Antes de escribir una entrada en un registro de eventos, debe registrar el origen de eventos con el registro de eventos como un origen válido de eventos. Cuando se escribe una entrada del registro, el sistema utiliza el <xref:System.Diagnostics.EventLog.Source%2A> para buscar el registro adecuado en el que se va a colocar la entrada. Si está leyendo el registro de eventos, puede especificar el <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  Para crear un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que se deben buscar todos los registros de eventos, como la seguridad, para determinar si el origen del evento es único. En Windows Vista y versiones posteriores, los usuarios no tienen permiso para tener acceso al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  En Windows Vista y versiones posteriores, el Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso el registro de seguridad, primero debe elevar el nivel los privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Puede crear un origen de eventos para un registro de eventos existente o un nuevo registro de eventos. Cuando se crea un nuevo origen para un registro de eventos, el sistema registra el origen para este registro, pero no se crea el registro hasta que la primera entrada se escribe en él.  
  
 El sistema operativo almacena los registros de eventos como archivos. Cuando usas <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para crear un nuevo registro de eventos, el archivo asociado se almacena en el directorio %SystemRoot%\System32\Config del equipo especificado. El nombre de archivo se establece anexando los 8 primeros caracteres de la <xref:System.Diagnostics.EventLog.Log%2A> propiedad con la extensión de nombre de archivo "evt".  
  
 El origen debe ser único en el equipo local; un nuevo nombre de origen no puede coincidir con un nombre de origen existente o un nombre de registro de eventos existente. Cada origen puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, la aplicación podría requerir configurados para diferentes registros de eventos o archivos de recursos de varios orígenes.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
 Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada, en lugar de eliminar el origen existente.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarlo a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen de `MySource` en el equipo `MyServer`y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> no es un nombre de equipo válido.  
  
 \- o -  
  
 <paramref name="source" /> es una cadena vacía ("") o <see langword="null" />.  
  
 \- o -  
  
 <paramref name="logName" /> no es un nombre de registro de eventos válido. Los nombres de los registros de eventos deben estar compuestos por caracteres imprimibles, excluidos "*", "?" o "\\".  
  
 \- o -  
  
 <paramref name="logName" /> no es válido para la creación del registro de usuario. Los nombres de registro de eventos AppEvent, SysEvent y SecEvent están reservados para uso del sistema.  
  
 \- o -  
  
 El nombre del registro coincide con el nombre de un origen de eventos ya existente.  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.  
  
 \- o -  
  
 Los 8 primeros caracteres de <paramref name="logName" /> coinciden con los 8 primeros caracteres del nombre de un registro de eventos ya existente en el equipo especificado.  
  
 \- o -  
  
 No puede registrarse el origen porque ya existe en el equipo especificado.  
  
 \- o -  
  
 El nombre del origen coincide con el nombre de un origen de eventos ya existente.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir en el equipo especificado la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita un recurso de registro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro que se va a eliminar. Posibles valores: Aplicación, Seguridad, Sistema o cualquier registro de eventos personalizado del equipo.</param>
        <summary>Quita un registro de eventos del equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando el registro que desea eliminar está en el equipo local. Puede eliminar cualquier registro en el equipo, siempre que tengan los permisos adecuados.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Quita el registro especificado por `logName` desde el equipo local. Si desea eliminar sólo el origen registrado en un registro, llame a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Si solo desea eliminar las entradas del registro, llame a <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> y <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> son `static` métodos, por lo que se pueden llamar en la propia clase. No es necesario crear una nueva instancia de <xref:System.Diagnostics.EventLog> para llamar a cualquiera de los métodos.  
  
 El <xref:System.Diagnostics.EventLog.Delete%2A> método elimina primero el archivo que contiene el contenido del registro. A continuación, obtiene acceso al registro y quita todos los orígenes de eventos registrados para este registro. Si se vuelve a crear el registro en un momento posterior, debe registrar los orígenes de eventos de nuevo, si se van a reutilizar. Si no registra los orígenes de eventos y otros usuarios de escritura a un origen de eventos sin especificar un nombre de registro, se creará el origen del evento en el registro de eventos de aplicación. Por lo tanto, las aplicaciones que anteriormente podían escribir entradas en el registro eliminado y vuelto a crear escribirá en el registro de aplicación en su lugar, ya que ahora contiene el origen del evento.  
  
> [!NOTE]
>  Volver a crear un registro de eventos puede ser un proceso difícil. Procure no eliminar ninguno de los registros de eventos creados por el sistema, como el registro de aplicación.  
  
 Eliminación de un registro mediante una llamada a <xref:System.Diagnostics.EventLog.Delete%2A> elimina automáticamente los orígenes registrados en ese registro. Esto puede hacer que otras aplicaciones que utilicen dicho registro no funciona.  
  
   
  
## Examples  
 En el ejemplo siguiente se elimina un registro del equipo local. En el ejemplo se determina el registro de su origen.  
  
> [!NOTE]
>  Puede escribir más de un origen para un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> es una cadena vacía ("") o <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir en el equipo local la clave del Registro para el registro de eventos.  
  
 \- o -  
  
 El registro no existe en el equipo local.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El registro de eventos no se ha borrado correctamente.  
  
 O bien  
  
 No puede abrirse el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro que se va a eliminar. Posibles valores: Aplicación, Seguridad, Sistema y cualquier registro de eventos personalizado del equipo especificado.</param>
        <param name="machineName">Nombre del equipo del que se va a eliminar el registro o "." para el equipo local.</param>
        <summary>Quita un registro de eventos del equipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando el registro que desea eliminar está en un equipo remoto. Puede eliminar cualquier registro en el equipo, siempre que tengan los permisos adecuados.  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> Quita el registro especificado por `logName` desde el equipo especificado por `machineName`. Si desea eliminar sólo el origen registrado en un registro, llame a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Si solo desea eliminar las entradas del registro, llame a <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> y <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> son `static` métodos, por lo que se pueden llamar en la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a cualquiera de los métodos.  
  
 Este método elimina primero el archivo que contiene el contenido del registro. A continuación, obtiene acceso al registro y quita todos los orígenes de eventos registrados para este registro. Si se vuelve a crear el registro en un momento posterior, debe registrar los orígenes de eventos de nuevo, si se van a reutilizar. Si no registra los orígenes de eventos y otros usuarios de escritura a un origen de eventos sin especificar un nombre de registro, se creará el origen del evento en el registro de eventos de aplicación. Por lo tanto, las aplicaciones que anteriormente podían escribir entradas en el registro eliminado y vuelto a crear escribirá en el registro de aplicación en su lugar, ya que ahora contiene el origen del evento.  
  
> [!NOTE]
>  Volver a crear un registro de eventos puede ser un proceso difícil. Procure no eliminar ninguno de los registros de eventos creados por el sistema, como el registro de aplicación.  
  
 Eliminación de un registro mediante una llamada a <xref:System.Diagnostics.EventLog.Delete%2A> elimina automáticamente los orígenes registrados en ese registro. Esto puede hacer que otras aplicaciones que utilicen dicho registro no funciona.  
  
   
  
## Examples  
 En el ejemplo siguiente se elimina un registro del equipo especificado. En el ejemplo se determina el registro de su origen.  
  
> [!NOTE]
>  Puede escribir más de un origen para un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> es una cadena vacía ("") o <see langword="null" />.  
  
 \- o -  
  
 <paramref name="machineName" /> no es un nombre de equipo válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir en el equipo especificado la clave del Registro para el registro de eventos.  
  
 \- o -  
  
 El registro no existe en el equipo especificado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El registro de eventos no se ha borrado correctamente.  
  
 O bien  
  
 No puede abrirse el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita del registro de eventos un registro del origen de eventos de una aplicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre con el que se registra la aplicación en el sistema de registro de eventos.</param>
        <summary>Quita del registro de eventos del equipo local el registro del origen de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para quitar el registro de un <xref:System.Diagnostics.EventLog.Source%2A> desde el equipo local. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Obtiene acceso al registro en el equipo local y quita el registro de la aplicación como un origen válido de eventos.  
  
 Puede quitar el componente como un origen de eventos válido si ya no necesita escribir entradas en el registro. Por ejemplo, podría hacerlo si necesita cambiar el componente de un registro a otro. Porque sólo se puede registrar un origen a un registro a la vez, el cambio de registro requiere que se quite el registro actual.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sólo quita el origen registrado en un registro. Si desea quitar el registro de sí mismo, llame a <xref:System.Diagnostics.EventLog.Delete%2A>. Si solo desea eliminar las entradas del registro, llame a <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> y <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> son `static` métodos, por lo que se pueden llamar en la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a cualquiera de los métodos.  
  
 Eliminación de un registro mediante una llamada a <xref:System.Diagnostics.EventLog.Delete%2A> elimina automáticamente los orígenes registrados en ese registro. Esto puede hacer que otras aplicaciones que utilicen dicho registro no funciona.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarlo a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se elimina un origen desde el equipo local. El ejemplo determina el registro de su origen y, a continuación, elimina el registro.  
  
> [!NOTE]
>  Puede escribir más de un origen para un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="source" /> no existe en el Registro del equipo local.  
  
 \- o -  
  
 No se dispone de acceso de escritura en la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre con el que se registra la aplicación en el sistema de registro de eventos.</param>
        <param name="machineName">Nombre del equipo del que hay que quitar el registro o "." para el equipo local.</param>
        <summary>Quita del equipo especificado el registro del origen de eventos de la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para quitar el registro de un <xref:System.Diagnostics.EventLog.Source%2A> desde un equipo remoto. <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> Obtiene acceso al registro en el equipo especificado por `machineName` y quita el registro de la aplicación como un origen válido de eventos.  
  
 Puede quitar el componente como un origen de eventos válido si ya no necesita escribir entradas en el registro. Por ejemplo, podría hacerlo si necesita cambiar el componente de un registro a otro. Porque sólo se puede registrar un origen a un registro a la vez, el cambio de registro requiere que se quite el registro actual.  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> sólo quita el origen registrado en un registro. Si desea quitar el registro de sí mismo, llame a <xref:System.Diagnostics.EventLog.Delete%2A>. Si solo desea eliminar las entradas del registro, llame a <xref:System.Diagnostics.EventLog.Clear%2A>. <xref:System.Diagnostics.EventLog.Delete%2A> y <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> son `static` métodos, por lo que se pueden llamar en la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a cualquiera de los métodos.  
  
 Eliminación de un registro mediante una llamada a <xref:System.Diagnostics.EventLog.Delete%2A> elimina automáticamente los orígenes registrados en ese registro. Esto puede hacer que otras aplicaciones que utilicen dicho registro no funciona.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarlo a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se elimina un origen desde el equipo especificado. El ejemplo determina el registro de su origen y, a continuación, elimina el registro.  
  
> [!NOTE]
>  Puede escribir más de un origen para un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="machineName" /> no es válido.  
  
 \- o -  
  
 El parámetro <paramref name="source" /> no existe en el Registro del equipo especificado.  
  
 \- o -  
  
 No se dispone de acceso de escritura en la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.InvalidOperationException">
          No se puede eliminar <paramref name="source" /> porque en el Registro, la clave del Registro primaria para <paramref name="source" /> no contiene una subclave con el mismo nombre.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados utilizados por el objeto <see cref="T:System.Diagnostics.EventLog" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a este método público `Dispose()` método y <xref:System.Object.Finalize%2A> método. `Dispose()` se invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el `disposing` del parámetro es true, este método libera todos los recursos retenidos por los objetos administrados que este <xref:System.Diagnostics.EventLog> referencias. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Al reemplazar <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si <see cref="T:System.Diagnostics.EventLog" /> recibe notificaciones de eventos <see cref="E:System.Diagnostics.EventLog.EntryWritten" />.</summary>
        <value>
          Es <see langword="true" /> si <see cref="T:System.Diagnostics.EventLog" /> recibe la notificación cuando se escribe una entrada en el registro; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> propiedad determina si el <xref:System.Diagnostics.EventLog> genera eventos cuando se escriben entradas en el registro. Cuando la propiedad es `true`, componentes que reciben el <xref:System.Diagnostics.EventLog.EntryWritten> eventos recibirá notificación cada vez que se escribe una entrada en el registro que se especifica en el <xref:System.Diagnostics.EventLog.Log%2A> propiedad. Si <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> es `false`, se genera ningún evento.  
  
> [!NOTE]
>  Puede recibir notificaciones de eventos solo cuando se escriben entradas en el equipo local. No puede recibir notificaciones de entradas escritas en equipos remotos.  
  
   
  
## Examples  
 El siguiente ejemplo se controla un <xref:System.Diagnostics.EventLog.EntryWritten> eventos.  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El registro de eventos está en un equipo remoto.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina la inicialización de <see cref="T:System.Diagnostics.EventLog" /> utilizada en un formulario o empleada por otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] diseño entorno usa este método para finalizar la inicialización de un componente utilizado en un formulario o por otro componente. El <xref:System.Diagnostics.EventLog.BeginInit%2A> método comienza la inicialización. Mediante el <xref:System.Diagnostics.EventLog.BeginInit%2A> y <xref:System.Diagnostics.EventLog.EndInit%2A> métodos impide que el control que se va a usar antes de que esté totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el contenido del registro de eventos.</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLogEntryCollection" /> que incluye las entradas del registro de eventos. Cada entrada se asocia a una instancia de la clase <see cref="T:System.Diagnostics.EventLogEntry" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Diagnostics.EventLog.Entries%2A> miembro al leer desde el registro de eventos.  
  
 Dado que la propiedad es de solo lectura, no se puede modificar una entrada o escribir en el registro usando <xref:System.Diagnostics.EventLog.Entries%2A>. En su lugar, especifique un <xref:System.Diagnostics.EventLog.Source%2A> y llame a <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir una nueva entrada de registro. Puede usar <xref:System.Diagnostics.EventLog.Entries%2A> para contar el número de entradas en el registro de eventos y ver cada uno de ellos <xref:System.Diagnostics.EventLogEntry> en la colección. Use el indizado <xref:System.Diagnostics.EventLogEntryCollection.Item%2A> miembro para recuperar información sobre una entrada específica, como <xref:System.Diagnostics.EventLogEntry.Message%2A>, <xref:System.Diagnostics.EventLogEntry.Category%2A>, <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>, o <xref:System.Diagnostics.EventLogEntry.EntryType%2A>.  
  
 No es necesario especificar un <xref:System.Diagnostics.EventLog.Source%2A> cuando sólo se lee de un registro. Sólo se puede especificar el <xref:System.Diagnostics.EventLog.Log%2A> nombre y <xref:System.Diagnostics.EventLog.MachineName%2A> propiedades (nombre de equipo del servidor) para el <xref:System.Diagnostics.EventLog> instancia. En cualquier caso, el <xref:System.Diagnostics.EventLog.Entries%2A> miembro se rellena automáticamente con la lista del registro de eventos de entradas. Puede seleccionar el índice apropiado para un elemento de esta lista para leer entradas individuales.  
  
 Una diferencia importante entre leer y escribir entradas del registro es que no es necesario llamar explícitamente a un método de lectura. Después de la <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A> se especifican, el <xref:System.Diagnostics.EventLog.Entries%2A> propiedad se rellena automáticamente. Si cambia el valor de la <xref:System.Diagnostics.EventLog.Log%2A> o <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad, el <xref:System.Diagnostics.EventLog.Entries%2A> propiedad se vuelve a llenar la próxima vez que se lee.  
  
> [!NOTE]
>  No tienen que especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro. Si no se especifica la <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local, ".", se da por hecho.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee las entradas en el registro de eventos, "MyNewLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se escribe una entrada en un registro de eventos en el equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener las notificaciones de eventos, debe establecer <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> a `true`. Solo puede recibir notificaciones de eventos cuando se escriben entradas en el equipo local. No puede recibir notificaciones de entradas escritas en equipos remotos.  
  
 Cuando se crea un delegado <xref:System.Diagnostics.EventLog.EntryWritten>, se identifica el método que controlará el evento. Para asociar el evento al controlador, se debe agregar una instancia del delegado al evento. Se llama al controlador de eventos cada vez que se produce el evento, hasta que se quite al delegado. Para obtener más información sobre cómo controlar eventos con delegados, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El sistema responde a <xref:System.Diagnostics.EventLog.WriteEntry%2A> sólo si el último evento de escritura se produjo al menos, seis segundos previamente. Esto implica sólo aparecerá uno <xref:System.Diagnostics.EventLog.EntryWritten> notificación de eventos dentro de un intervalo de seis segundos, incluso si más de un evento de cambio de registro se produce. Si se inserta un intervalo de espera lo suficientemente prolongado (unos 10 segundos) entre las llamadas a <xref:System.Diagnostics.EventLog.WriteEntry%2A>, es menos probable que se pierda un evento. Sin embargo, si se producen eventos de escritura con más frecuencia, puede que no reciba la notificación de eventos hasta el siguiente intervalo. Normalmente, las notificaciones de eventos que faltan no se pierden, pero que se retrasa.  
  
   
  
## Examples  
 En el ejemplo siguiente se controla una evento escrito de entrada.  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si existe el registro especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Nombre del registro que se va a buscar. Posibles valores: Aplicación, Seguridad, Sistema, otros registros específicos de aplicaciones (como los asociados a Active Directory) o cualquier registro personalizado del equipo.</param>
        <summary>Determina si el registro existe en el equipo local.</summary>
        <returns>
          <see langword="true" /> si el registro existe en el equipo local; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para determinar si existe un registro en el equipo local. Si desea determinar si existe un origen en el equipo local, utilice <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Dado que este método obtiene acceso al registro, debe tener los permisos adecuados en el equipo local; en caso contrario, la consulta devuelve `false`.  
  
 Ya no se puede proporcionar un nuevo registro el nombre de un registro existente en el mismo equipo, utilice este método antes de crear un nuevo registro para determinar si el especificado `logName` ya existe en el equipo local. El `logName` parámetro no distingue mayúsculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> es un `static` método, por lo que puede llamarse en la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">LogName es <see langword="null" /> o el valor está vacío.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">Registro que se va a buscar. Posibles valores: Aplicación, Seguridad, Sistema, otros registros específicos de aplicaciones (como los asociados a Active Directory) o cualquier registro personalizado del equipo.</param>
        <param name="machineName">Nombre del equipo en el que se va a buscar el registro o "." para el equipo local.</param>
        <summary>Determina si el registro existe en el equipo especificado.</summary>
        <returns>
          <see langword="true" /> si el registro existe en el equipo especificado; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para determinar si existe un registro en un equipo remoto. Si desea determinar si existe un origen en un equipo remoto, use <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
 Dado que este método obtiene acceso al registro, debe tener los permisos adecuados en el equipo especificado; en caso contrario, la consulta devuelve `false`.  
  
 Ya no se puede proporcionar un nuevo registro el nombre de un registro existente en el mismo equipo, utilice este método antes de crear un nuevo registro para determinar si uno con los valores especificados `logName` ya existe en el servidor especificado por el `machineName` parámetro. El `logName` y `machineName` parámetros no distinguen mayúsculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> es un `static` método, por lo que puede llamarse en la propia clase. No es necesario crear una nueva instancia de <xref:System.Diagnostics.EventLog> para llamar a <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="machineName" /> no es un formato válido. Asegúrese de que ha utilizado la sintaxis adecuada para el equipo en el que está buscando.  
  
 O bien  
  
 El parámetro <paramref name="logName" /> es <see langword="null" /> o el valor está vacío.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matriz de los registros de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Busca todos los registros de eventos en el equipo local y crea una matriz de objetos <see cref="T:System.Diagnostics.EventLog" /> que contiene la lista.</summary>
        <returns>Matriz de tipo <see cref="T:System.Diagnostics.EventLog" /> que representa los registros del equipo local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz de <xref:System.Diagnostics.EventLog> objetos es una instantánea de todos los registros de eventos en el equipo local cuando la llamada a <xref:System.Diagnostics.EventLog.GetEventLogs%2A> se realiza. Esto no es una colección dinámica, por lo que no refleja la eliminación o la creación de registros en tiempo real. Debe comprobar que un registro de la matriz existe antes de leer o escribir en él. La matriz normalmente incluye al menos tres registros: aplicación, sistema y seguridad. Si se han creado registros personalizados en el equipo local, aparecerán en la matriz también.  
  
 Para recuperar la lista de registros de eventos, debe tener los permisos adecuados. Estos permisos son idénticos a las que se requieren para llamar a <xref:System.Diagnostics.EventLog.Exists%2A> y <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumera los registros de eventos definidos en el equipo local y muestra los detalles de configuración para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">No se dispone de acceso de lectura al Registro.  
  
 O bien  
  
 No existe ningún servicio de registro de eventos en el equipo.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Equipo en el que buscar registros de eventos.</param>
        <summary>Busca todos los registros de eventos en el equipo dado y crea una matriz de objetos <see cref="T:System.Diagnostics.EventLog" /> que contiene la lista.</summary>
        <returns>Matriz de tipo <see cref="T:System.Diagnostics.EventLog" /> que representa los registros del equipo dado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz de <xref:System.Diagnostics.EventLog> objetos es una instantánea de todos los registros de eventos en el equipo especificado por el `machineName` parámetro cuando la llamada a <xref:System.Diagnostics.EventLog.GetEventLogs%2A> se realiza. Esto no es una colección dinámica, por lo que no refleja la eliminación o la creación de registros en tiempo real. Debe comprobar que un registro de la matriz existe antes de leer o escribir en él. La matriz normalmente incluye al menos tres registros: aplicación, sistema y seguridad. Si ha creado registros personalizados en el equipo especificado, aparecen en la matriz también.  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> es un `static` método, por lo que puede llamarse en el <xref:System.Diagnostics.EventLog> propia clase. No es necesario crear una instancia de un <xref:System.Diagnostics.EventLog> objeto que se va a realizar una llamada al método.  
  
 Para recuperar la lista de registros de eventos, debe tener los permisos adecuados. Estos permisos son idénticos a las que se requieren para llamar a <xref:System.Diagnostics.EventLog.Exists%2A> y <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene una lista de registros en el equipo "myServer". A continuación, muestra el nombre de cada registro.  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="machineName" /> no es un nombre de equipo válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se dispone de acceso de lectura al Registro.  
  
 O bien  
  
 No existe ningún servicio de registro de eventos en el equipo.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del registro del que se lee o en el que se escribe.</summary>
        <value>Nombre del registro. Puede ser Aplicación, Sistema, Seguridad o el nombre de un registro personalizado. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Existen tres archivos de registro de forma predeterminada en el servidor: aplicación, sistema y seguridad. Aplicaciones y servicios utilizan el archivo de registro de aplicación. Controladores de dispositivos utilizan el archivo de registro del sistema. El sistema genera eventos de auditoría de aciertos y errores en el registro de seguridad cuando la auditoría está activada. Si tiene otras aplicaciones instaladas, como Active Directory en Windows Server, puede haber otros archivos de registro de forma predeterminada. Además, puede crear archivos de registro personalizados en un equipo local o remoto. Los registros personalizados ayudan a organizar las entradas de una forma más detallada que se permite cuando los componentes escriben eventos en el registro de aplicación predeterminado.  
  
> [!NOTE]
>  Nombres de registro están limitados a ocho caracteres. Según el sistema, MyLogSample1 y MyLogSample2 son el mismo registro.  
  
 Si se escribe en un registro de eventos, no es suficiente especificar el <xref:System.Diagnostics.EventLog.Log%2A> propiedad. Debe asociar un <xref:System.Diagnostics.EventLog.Source%2A> propiedad con el recurso de registro de eventos para conectarse a un registro concreto. No es necesario especificar un <xref:System.Diagnostics.EventLog.Source%2A> cuando sólo se lee de un registro, pero un origen de eventos debe estar asociado con el recurso de registro de eventos en el registro del servidor. Sólo se puede especificar el <xref:System.Diagnostics.EventLog.Log%2A> nombre y <xref:System.Diagnostics.EventLog.MachineName%2A> (nombre de equipo del servidor) para leer de él.  
  
> [!NOTE]
>  No tienen que especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro. Si no se especifica la <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho.  
  
 Si el <xref:System.Diagnostics.EventLog.Source%2A> propiedad no se ha especificado, una llamada a <xref:System.Diagnostics.EventLog.Log%2A> devuelve una cadena vacía si <xref:System.Diagnostics.EventLog.Log%2A> no se estableció explícitamente (estableciendo la <xref:System.Diagnostics.EventLog.Log%2A> propiedad, o a través del constructor). Si el <xref:System.Diagnostics.EventLog.Source%2A> se ha especificado, <xref:System.Diagnostics.EventLog.Log%2A> devuelve el nombre del registro en el que se registró ese origen.  
  
 Un origen solo se pueden registrar para un registro a la vez. Si el <xref:System.Diagnostics.EventLog.Source%2A> se estableció la propiedad de una instancia de <xref:System.Diagnostics.EventLog>, no se puede cambiar la <xref:System.Diagnostics.EventLog.Log%2A> propiedad para que <xref:System.Diagnostics.EventLog> sin cambiar el valor de <xref:System.Diagnostics.EventLog.Source%2A> o llamando a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> primero. Si cambia la <xref:System.Diagnostics.EventLog.Log%2A> propiedad después de la <xref:System.Diagnostics.EventLog.Source%2A> propiedad se ha establecido, escribir una entrada del registro produce una excepción.  
  
 El sistema operativo almacena los registros de eventos como archivos. Cuando usas <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para crear un nuevo registro de eventos, el archivo asociado se almacena en el directorio %SystemRoot%\System32\Config del equipo especificado. El nombre de archivo se establece anexando los 8 primeros caracteres de la <xref:System.Diagnostics.EventLog.Log%2A> propiedad con la extensión de nombre de archivo "evt".  
  
 No se puede crear un nuevo registro mediante la <xref:System.Diagnostics.EventLog.Log%2A> propiedad independiente (sin especificar un origen para el registro). Puede llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, pasando un nuevo nombre de registro como un parámetro y, a continuación, llamar a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. Sin embargo, la intención es normalmente crear (y escribir entradas en) nuevos registros específicos de la aplicación, o para leer de registros existentes.  
  
 Si el <xref:System.Diagnostics.EventLog.Log%2A> cambia el valor, se cierra el registro de eventos y se liberan todos los identificadores de evento.  
  
> [!CAUTION]
>  Si establece la <xref:System.Diagnostics.EventLog.Log%2A> propiedad en el nombre de un registro que no existe, el sistema asocia la <xref:System.Diagnostics.EventLog> en el registro de aplicación, pero no advertirá de que se está utilizando un registro distinto del especificado.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee las entradas en el registro de eventos, "NewEventLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre descriptivo del registro de eventos.</summary>
        <value>Nombre que representa el registro de eventos en el visor de eventos del sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  En Windows Vista y versiones posteriores, los usuarios no tienen permiso para tener acceso al registro de seguridad. Si está ejecutando Windows Vista o posterior como un usuario, obtendrá un <xref:System.Security.SecurityException> al intentar obtener acceso al nombre de presentación para un evento en el registro de seguridad.  
>   
>  En Windows Vista y versiones posteriores, el Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso el registro de seguridad, primero debe elevar el nivel los privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumeran los registros de eventos definidos en el equipo local y muestra el <xref:System.Diagnostics.EventLog.LogDisplayName%2A> para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.EventLog.Log" /> especificada no existe en el Registro para este equipo.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">la capacidad de leer la clave del registro especificada. Enumeración asociada: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a la clave de registro especificada si es una clave remota. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos.</param>
        <param name="machineName">Nombre del equipo en el que se debe buscar o "." para el equipo local.</param>
        <summary>Obtiene el nombre del registro en el que se registra el origen especificado.</summary>
        <returns>Nombre del registro asociado al origen especificado en el Registro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El origen de eventos indica qué registra el evento. Es a menudo el nombre de la aplicación o el nombre de un subcomponente de la aplicación, si la aplicación es grande. Aplicaciones y servicios deben escribir en el registro de aplicación o un registro personalizado. Controladores de dispositivos deben escribir en el registro del sistema.  
  
 Cuando se crea un nuevo origen, que solo se puede escribir en un registro a la vez, el sistema registra la aplicación con el registro de eventos como un origen válido de entradas. El <xref:System.Diagnostics.EventLog.Source%2A> propiedad puede ser cualquier cadena, pero no se puede usar el nombre de otros orígenes en el equipo. Un intento de crear un duplicado <xref:System.Diagnostics.EventLog.Source%2A> valor produce una excepción. Sin embargo, un único registro de eventos puede tener muchos orígenes diferentes, escribir en él.  
  
   
  
## Examples  
 En el ejemplo siguiente se elimina un origen desde el equipo local. El ejemplo determina el registro de su origen y, a continuación, elimina el registro.  
  
> [!NOTE]
>  Puede escribir más de un origen para un registro de eventos. Antes de eliminar un registro personalizado, asegúrese de que no hay ningún origen de escritura en el registro.  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del equipo en el que se van a leer o en el que se van a escribir los eventos.</summary>
        <value>Nombre del servidor en el que reside el registro de eventos. El valor predeterminado es el equipo local (".").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se escribe en un registro de eventos, debe asociar un <xref:System.Diagnostics.EventLog.Source%2A> con el objeto de registro de eventos para conectarse a un registro concreto. No es necesario especificar el <xref:System.Diagnostics.EventLog.Source%2A> propiedad cuando sólo se lee de un registro. Sólo se puede especificar el <xref:System.Diagnostics.EventLog.Log%2A> nombre y <xref:System.Diagnostics.EventLog.MachineName%2A> (nombre de equipo del servidor).  
  
> [!NOTE]
>  No es necesario especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro. Si no se especifica la <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho.  
  
 Un origen solo se pueden registrar para un registro a la vez. Si el <xref:System.Diagnostics.EventLog.Source%2A> se estableció la propiedad de una instancia de <xref:System.Diagnostics.EventLog>, no se puede cambiar la <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad para que <xref:System.Diagnostics.EventLog> sin cambiar el valor de <xref:System.Diagnostics.EventLog.Source%2A> o llamando a <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> primero. Si cambia la <xref:System.Diagnostics.EventLog.MachineName%2A> propiedad, el <xref:System.Diagnostics.EventLog> cierra todos los identificadores y se vuelve a adjuntar al registro y al origen en el nuevo equipo.  
  
 El <xref:System.Diagnostics.EventLog.MachineName%2A> valor no puede ser una cadena vacía. Si no se establece explícitamente, el valor predeterminado es el equipo local (".").  
  
   
  
## Examples  
 En el ejemplo siguiente se lee las entradas en el registro de eventos, "NewEventLog", en un equipo especificado.  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de equipo no es válido.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño máximo del registro de eventos, en kilobytes.</summary>
        <value>Tamaño máximo del registro de eventos, en kilobytes. El valor predeterminado es 512, lo que indica que el tamaño máximo de archivo es de 512 kilobytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propiedad representa el límite de tamaño del archivo de registro de eventos. Cuando el registro de eventos alcanza el límite de tamaño, se ignora el número <xref:System.Diagnostics.EventLog.OverflowAction%2A> valor determina si se descartan las nuevas entradas, o si las nuevas entradas sobrescriben las entradas más antiguas.  
  
> [!NOTE]
>  Esta propiedad representa un valor de configuración para el registro de eventos representado por esta instancia. Cuando el registro de eventos alcanza su tamaño máximo, esta propiedad especifica la forma en que el sistema operativo controla las nuevas entradas escritas por todos los orígenes de eventos registrados para el registro de eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumera los registros de eventos definidos en el equipo local y muestra los detalles de configuración para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado es menor que 64, mayor que 4194240 o no es un múltiplo par de 64.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> no es un nombre de registro válido.  
  
 \- o -  
  
 No se ha podido abrir en el equipo de destino la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de días que se deben conservar las entradas en el registro de eventos.</summary>
        <value>Número de días que se conservan las entradas del registro de eventos. El valor predeterminado es 7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> propiedad para examinar la configuración actual de un registro de eventos. Use <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> para cambiar el número mínimo de días que se debe conservar cada entrada en el registro de eventos.  
  
 El <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor depende del comportamiento de desbordamiento configurado el registro de eventos. Si el <xref:System.Diagnostics.OverflowAction> propiedad para un registro de eventos se establece en <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, la <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor es 0. Si el <xref:System.Diagnostics.OverflowAction> propiedad para un registro de eventos se establece en <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, la <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor es -1. Si el <xref:System.Diagnostics.OverflowAction> propiedad para un registro de eventos se establece en <xref:System.Diagnostics.OverflowAction.OverwriteOlder>, la <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valor es mayor que cero y representa el número de días para conservar las entradas de registro de eventos cuando el registro de eventos está lleno.  
  
 El comportamiento de desbordamiento sólo se produce cuando un registro de eventos alcanza su límite de tamaño. Cuando un <xref:System.Diagnostics.EventLog> tiene su <xref:System.Diagnostics.EventLog.OverflowAction%2A> establecido en <xref:System.Diagnostics.OverflowAction.OverwriteOlder>y el registro de eventos alcanza su tamaño máximo, a continuación, las nuevas entradas se escriben solo si pueden reemplazar otras cuya antigüedad supere el <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> período. Conservar las entradas de eventos durante un período mínimo es adecuado cuando el registro de eventos se archiva con regularidad. En caso contrario, se arriesga a perder entradas nuevas cuando el registro de eventos alcanza su límite. Para evitar la pérdida de información de eventos nuevo, establezca los días de retención mínimo para eventos basándose en la programación de archivo para un determinado registro de eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumera los registros de eventos definidos en el equipo local y muestra los detalles de configuración para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">Comportamiento de desbordamiento para la escritura de entradas nuevas en el registro de eventos.</param>
        <param name="retentionDays">Número mínimo de días que se conserva cada entrada del registro de eventos. Solo se usa este parámetro si <c>action</c> se establece en <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</param>
        <summary>Cambia el comportamiento configurado para la escritura de entradas nuevas cuando el registro de eventos alcanza su tamaño máximo de archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de desbordamiento para un registro de eventos especifica qué sucede si hay nuevas entradas a escribirse en un registro que ha alcanzado el tamaño máximo de archivo.  
  
> [!NOTE]
>  El comportamiento de desbordamiento surte efecto sólo cuando un registro de eventos alcanza su tamaño máximo de archivo. El comportamiento de desbordamiento no afecta a la escritura de una nueva entrada en un registro que pueda alojar entradas de registro de eventos adicionales.  
  
 El <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método configura el comportamiento de desbordamiento de un registro de eventos. <xref:System.Diagnostics.EventLog> instancia. Después de llamar a este método para el registro de eventos especificado por el <xref:System.Diagnostics.EventLog.Log%2A> propiedad, el <xref:System.Diagnostics.EventLog.OverflowAction%2A> y <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> valores de propiedad reflejan el comportamiento de desbordamiento recién configurado.  
  
> [!NOTE]
>  Esta propiedad representa un valor de configuración para el registro de eventos representado por esta instancia. Cuando el registro de eventos alcanza su tamaño máximo, esta propiedad especifica la forma en que el sistema operativo controla las nuevas entradas escritas por todos los orígenes de eventos registrados para el registro de eventos.  
  
 Establecer el `action` parámetro <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> para indicar que una entrada nueva sobrescribirá la entrada más antigua cuando el <xref:System.Diagnostics.EventLog> alcanza su tamaño máximo. Si el `action` parámetro está establecido en <xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, el `retentionDays` se omite el valor del parámetro.  
  
 Establecer el `action` parámetro <xref:System.Diagnostics.OverflowAction.OverwriteOlder> para indicar que cada entrada nueva sobrescribirá las entradas más antiguas cuando la <xref:System.Diagnostics.EventLog> alcanza su tamaño máximo. Especifique el número de días que deben conservarse los sucesos en el registro usando el `retentionDays` parámetro. Los eventos escritos en el intervalo de retención no se sobrescriben con las nuevas entradas.  
  
 Establecer el `action` parámetro <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> para descartar nuevos eventos cuando se alcanza el tamaño máximo del registro. Si el `action` parámetro está establecido en <xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, el `retentionDays` se omite el valor del parámetro.  
  
> [!CAUTION]
>  Si se establece la directiva de desbordamiento en <xref:System.Diagnostics.OverflowAction.DoNotOverwrite> especifica que se descartarán las entradas nuevas cuando el registro de eventos está lleno. Si utiliza esta opción, asegúrese del registro de eventos con regularidad se archiva y desactivado para evitar que se alcance el límite de tamaño máximo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la directiva de desbordamiento configurada para un registro de eventos especificado y permite al usuario seleccionar una nueva configuración de directiva de desbordamiento para el registro de eventos.  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> no es un valor <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> es menor que 1 o mayor que 365. </exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> no es un nombre de registro válido.  
  
 \- o -  
  
 No se ha podido abrir en el equipo de destino la clave del Registro para el registro de eventos.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el comportamiento configurado para el almacenamiento de entradas nuevas cuando el registro de eventos haya alcanzado su tamaño máximo de archivo.</summary>
        <value>Valor de <see cref="T:System.Diagnostics.OverflowAction" /> que especifica el comportamiento de almacenamiento configurado para las entradas nuevas cuando el registro de eventos haya alcanzado su tamaño máximo. El valor predeterminado es <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registros de eventos aumentan de tamaño como nuevos eventos se escriben en ellos. Cada registro de eventos tiene un límite de tamaño máximo configurado; el <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A> propiedad define el número máximo de kilobytes permitidos para el tamaño de archivo de registro de eventos.  
  
 Use la <xref:System.Diagnostics.EventLog.OverflowAction%2A> valor de propiedad para examinar el comportamiento de desbordamiento configurado para un registro de eventos en su tamaño máximo. Use la <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A> método para cambiar el comportamiento de desbordamiento para un registro de eventos.  
  
> [!NOTE]
>  El comportamiento de desbordamiento surte efecto sólo cuando un registro de eventos alcanza su tamaño máximo de archivo. El comportamiento de desbordamiento no afecta a la escritura de una nueva entrada en un registro que pueda alojar entradas de registro de eventos adicionales.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumera los registros de eventos definidos en el equipo local y muestra los detalles de configuración para cada registro de eventos.  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">Ruta de acceso completa a un archivo de recursos localizado.</param>
        <param name="resourceId">Identificador de recursos que indiza una cadena localizada dentro del archivo de recursos.</param>
        <summary>Especifica el nombre localizado del registro de eventos, que aparece en el Visor de eventos del servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> para registrar y mostrar un nombre traducido en el Visor de eventos para el registro de eventos personalizado.  
  
 El identificador de recurso especificado debe corresponder a una cadena localizada que se definen en el archivo de recursos. El Visor de eventos muestra el nombre de registro de eventos personalizado utilizando la cadena adaptada y la configuración de la referencia cultural actual. Por ejemplo, puede definir varios nombres de registro de eventos localizados para referencias culturales diferentes en el archivo de recursos. El Visor de eventos muestra la cadena localizada que corresponde a la configuración de referencia cultural del usuario actual.  
  
 Si el Visor de eventos no se puede cargar la cadena adaptada desde el archivo de recursos, o si se ha registrado ningún nombre para mostrar para el registro de eventos, el Visor de eventos muestra el nombre de registro de eventos definido en <xref:System.Diagnostics.EventLog.Log%2A>.  
  
> [!NOTE]
>  No es necesario registrar un nombre para mostrar para los registros de eventos predefinidos. El sistema operativo registra los nombres para mostrar localizado para los registros de eventos de aplicación, sistema y seguridad.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina si el origen de eventos denominado `SampleApplicationSource` está registrado en el equipo local. Si el origen del evento no existe, el ejemplo establece el archivo de recursos de mensaje para el origen y crea el nuevo origen de eventos. Por último, en el ejemplo se establece el nombre para mostrar localizado para el registro de eventos utilizando el valor de identificador de recurso en `DisplayNameMsgId` y la ruta de acceso del archivo de recursos en `messageFile`.  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 En el ejemplo se usa el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto de mensaje es el origen desde el que se creó el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto de categoría, mensaje de evento y las cadenas de inserción de parámetro. En concreto, el identificador de recursos 5001 se define para el nombre localizado del registro de eventos.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> no es un nombre de registro válido.  
  
 \- o -  
  
 No se ha podido abrir en el equipo de destino la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para administrar la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre de origen que se va a registrar y utilizar al escribir en el registro de eventos.</summary>
        <value>Nombre registrado con el registro de eventos como origen de entradas. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El origen de eventos indica qué registra el evento. Es a menudo el nombre de la aplicación o el nombre de un subcomponente de la aplicación, si la aplicación es grande. Aplicaciones y servicios deben escribir en el registro de aplicación o un registro personalizado. Controladores de dispositivos deben escribir en el registro del sistema.  
  
 Solo debe especificar un origen de eventos si va a escribir en un registro de eventos. Antes de escribir una entrada en un registro de eventos, debe registrar el origen de eventos con el registro de eventos como un origen válido de eventos. Cuando se escribe una entrada del registro, el sistema utiliza el <xref:System.Diagnostics.EventLog.Source%2A> propiedad que se va a buscar el registro adecuado en el que se va a colocar la entrada. Si está leyendo el registro de eventos, puede especificar el <xref:System.Diagnostics.EventLog.Source%2A>, o un <xref:System.Diagnostics.EventLog.Log%2A> y <xref:System.Diagnostics.EventLog.MachineName%2A>.  
  
> [!NOTE]
>  No tienen que especificar el <xref:System.Diagnostics.EventLog.MachineName%2A> si se conecta a un registro en el equipo local. Si no se especifica la <xref:System.Diagnostics.EventLog.MachineName%2A>, el equipo local (".") se da por hecho.  
  
 Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> y <xref:System.Diagnostics.EventLog.WriteEntry%2A> para escribir eventos en un registro de eventos. Debe especificar un origen de eventos para escribir eventos; debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Puede crear un origen de eventos para un registro de eventos existente o un nuevo registro de eventos. Cuando se crea un nuevo origen para un registro de eventos, el sistema registra el origen para este registro, pero no se crea el registro hasta que la primera entrada se escribe en él.  
  
 El origen debe ser único en el equipo local; un nuevo nombre de origen no puede coincidir con un nombre de origen existente o un nombre de registro de eventos existente. Cada origen puede escribir en un único registro de eventos a la vez; Sin embargo, la aplicación puede utilizar varios orígenes para escribir en varios registros de eventos. Por ejemplo, la aplicación podría requerir configurados para diferentes registros de eventos o archivos de recursos de varios orígenes.  
  
 Si cambia la <xref:System.Diagnostics.EventLog.Source%2A> valor, la <xref:System.Diagnostics.EventLog> para que se registra se cierra y se liberan todos los identificadores de evento.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
 Para cambiar los detalles de configuración de un origen existente, debe eliminar el origen y, a continuación, vuelva a crearla con la nueva configuración. Si otras aplicaciones o componentes utilizan el origen existente, cree un nuevo origen con la configuración actualizada, en lugar de eliminar el origen existente.  
  
> [!NOTE]
>  Si un origen ya se ha asignado a un registro y volver a asignarlo a un nuevo registro, debe reiniciar el equipo para que los cambios surtan efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen de `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca un origen de eventos dado en el registro de un equipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos.</param>
        <summary>Determina si un origen de eventos está registrado en el equipo local.</summary>
        <returns>
          <see langword="true" /> si el origen de eventos está registrado en el equipo local; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para determinar si existe un origen de eventos en el equipo local. Si desea determinar si existe un registro en el equipo local, utilice <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Dado que este método obtiene acceso al registro, debe tener los permisos adecuados en el equipo local; en caso contrario, un <xref:System.Security.SecurityException> se iniciará.  
  
> [!NOTE]
>  Para buscar un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que se deben buscar todos los registros de eventos, como la seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tienen permiso para tener acceso al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  A partir de Windows Vista, Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso a los contadores de rendimiento, primero debe elevar el nivel los privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
> [!NOTE]
>  Un servicio que se esté ejecutando en el <xref:System.ServiceProcess.ServiceAccount.LocalSystem> cuenta no tiene los privilegios necesarios para ejecutar este método. La solución consiste en comprobar si existe el origen del evento en el <xref:System.ServiceProcess.ServiceInstaller>, y si no existe, para crear el origen en el programa de instalación.  
  
 Ya no se puede proporcionar un nuevo origen el nombre de un origen existente en el mismo equipo, utilice este método antes de intentar llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para asegurarse de que un origen con el nombre especificado por `source` no existe en el equipo local. El `source` parámetro no distingue mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen de `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          No se ha encontrado <paramref name="source" />, aunque no se ha podido buscar en algunos de los registros de eventos o en ninguno.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos.</param>
        <param name="machineName">Nombre del equipo en el se debe buscar o "." para el equipo local.</param>
        <summary>Determina si un origen de eventos está registrado en un equipo especificado.</summary>
        <returns>
          Es <see langword="true" /> si el origen de eventos está registrado en el equipo dado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para determinar si existe un origen de eventos en el equipo especificado por el `machineName` parámetro. Si desea determinar si existe un registro en el equipo especificado, utilice <xref:System.Diagnostics.EventLog.Exists%2A>.  
  
 Dado que este método obtiene acceso al registro, debe tener los permisos adecuados en el servidor especificado; en caso contrario, un <xref:System.Security.SecurityException> se iniciará.  
  
> [!NOTE]
>  Para buscar un origen de eventos en Windows Vista y versiones posteriores o Windows Server 2003, debe tener privilegios administrativos.  
>   
>  El motivo de este requisito es que se deben buscar todos los registros de eventos, como la seguridad, para determinar si el origen del evento es único. A partir de Windows Vista, los usuarios no tienen permiso para tener acceso al registro de seguridad; por lo tanto, un <xref:System.Security.SecurityException> se produce.  
>   
>  A partir de Windows Vista, Control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Para ejecutar el código que tiene acceso a los contadores de rendimiento, primero debe elevar el nivel los privilegios de usuario estándar a administrador. Para ello, inicie una aplicación haciendo clic con el botón derecho en el icono de la aplicación e indique que desea ejecutarla como administrador.  
  
> [!NOTE]
>  Un servicio que se esté ejecutando en el <xref:System.ServiceProcess.ServiceAccount.LocalSystem> cuenta no tiene los privilegios necesarios para ejecutar este método. La solución consiste en comprobar si existe el origen del evento en el <xref:System.ServiceProcess.ServiceInstaller>, y si no existe, para crear el origen en el programa de instalación.  
  
 Ya no se puede proporcionar un nuevo origen el nombre de un origen existente en el mismo equipo, utilice este método antes de intentar llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> para asegurarse de que un origen con el nombre especificado por `source` no existe en el equipo. El `source` y `machineName` parámetros no distinguen mayúsculas de minúsculas.  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> es un `static` método, por lo que puede llamarse en la propia clase. No es necesario crear una instancia de <xref:System.Diagnostics.EventLog> para llamar a <xref:System.Diagnostics.EventLog.SourceExists%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen de `MySource` en el equipo `MyServer`y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> no es un nombre de equipo válido.</exception>
        <exception cref="T:System.Security.SecurityException">
          No se ha encontrado <paramref name="source" />, aunque no se ha podido buscar en algunos de los registros de eventos o en ninguno.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto utilizado para calcular las referencias de las llamadas del controlador de eventos emitidas como resultado de un evento escrito en una entrada de <see cref="T:System.Diagnostics.EventLog" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> utilizado para calcular las referencias de las llamadas del controlador de eventos emitidas como resultado de un evento <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> del registro de eventos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> es `null`, métodos que controlan la <xref:System.Diagnostics.EventLog.EntryWritten> eventos se llaman en un subproceso del grupo de subprocesos del sistema. Para obtener más información sobre grupos de subprocesos del sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Cuando el <xref:System.Diagnostics.EventLog.EntryWritten> evento está controlado por un Windows Forms visual componente, como un botón, acceso al componente en el grupo de subprocesos de sistema no funcionen o se podría producir una excepción. Evitarlo estableciendo <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> a un componente de Windows Forms, lo que hace que los métodos que controlan la <xref:System.Diagnostics.EventLog.EntryWritten> evento al que se llama en el mismo subproceso en el que se creó el componente.  
  
 Si el <xref:System.Diagnostics.EventLog> se utiliza dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] en un diseñador de formularios Windows Forms, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> se establece automáticamente en el control que contiene el <xref:System.Diagnostics.EventLog>. Por ejemplo, si coloca un <xref:System.Diagnostics.EventLog> en un diseñador de Form1 (que hereda de <xref:System.Windows.Forms.Form>) la <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> propiedad de <xref:System.Diagnostics.EventLog> se establece en la instancia de Form1.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe una entrada en el registro de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <summary>Escribe una entrada de tipo de información, con un texto de mensaje determinado, en el registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada de información en el registro de eventos asociado a este <xref:System.Diagnostics.EventLog> instancia. Si desea especificar cualquier otro <xref:System.Diagnostics.EventLogEntryType>, utilice una sobrecarga diferente del <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> instancia antes de llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema debe registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> propiedad no se estableció en su <xref:System.Diagnostics.EventLog> instancia, el registro toma como valor predeterminado el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones enumeradas anteriormente se generan por errores generados durante el proceso de registrar el <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen de `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
 O bien  
  
 El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
 \- o -  
  
 El origen ya está registrado para otro registro de eventos.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Escribe en el registro de eventos una entrada de error, advertencia, información, auditoría correcta o auditoría incorrecta con el texto de mensaje dado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada de un <xref:System.Diagnostics.EventLogEntryType> al registro de eventos. El `type` se indica mediante un icono y el texto de la columna de tipo en el Visor de eventos para un registro.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> instancia antes de llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema debe registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> propiedad no se estableció en su <xref:System.Diagnostics.EventLog> instancia, el registro toma como valor predeterminado el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones mencionadas se generan por errores generados durante el proceso de registro del <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe una entrada de advertencia en un registro de eventos, "MyNewLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
 O bien  
  
 El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
 \- o -  
  
 El origen ya está registrado para otro registro de eventos.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <summary>Escribe una entrada de tipo de información con un texto de mensaje determinado en el registro de eventos utilizando el origen de eventos registrado que se haya especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada de información en el registro de eventos con un origen que ya está registrado como un origen de eventos para el registro adecuado. Si desea especificar cualquier otro <xref:System.Diagnostics.EventLogEntryType>, utilice una sobrecarga diferente del <xref:System.Diagnostics.EventLog.WriteEntry%2A>.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
>   
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea el origen de `MySource` si aún no existe y escribe una entrada en el registro de eventos `MyNewLog`.  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
 \- o -  
  
 El valor <paramref name="source" /> es <see langword="null" />.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <summary>Escribe una entrada con el identificador de eventos definido por la aplicación y el texto de mensaje dado en el registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada con un definido por la aplicación `eventID` al registro de eventos. El `eventID` junto con el origen de identificar de forma exclusiva un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Los visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y sugerir qué acciones emprender.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Además del identificador de evento, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y el texto de la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> instancia antes de llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema debe registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> propiedad no se estableció en su <xref:System.Diagnostics.EventLog> instancia, el registro toma como valor predeterminado el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones mencionadas se generan por errores generados durante el proceso de registro del <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
 O bien  
  
 El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
 \- o -  
  
 El origen ya está registrado para otro registro de eventos.  
  
 \- o -  
  
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <summary>Escribe en el registro de eventos una entrada de error, advertencia, información, auditoría correcta o auditoría incorrecta con el texto de mensaje dado mediante el origen de eventos registrado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada de un <xref:System.Diagnostics.EventLogEntryType> en el registro de eventos mediante un origen ya registrado como un origen de eventos para el registro adecuado. El `type` se indica mediante un icono y el texto de la columna de tipo en el Visor de eventos para un registro.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe una entrada de advertencia en un registro de eventos, "MyNewLog", en el equipo local.  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
 \- o -  
  
 El valor <paramref name="source" /> es <see langword="null" />.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <param name="category">Subcategoría específica de la aplicación asociada al mensaje.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado, el identificador de eventos definido por la aplicación y la categoría definida por la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada con un definido por la aplicación `category` al registro de eventos. El Visor de eventos usa la categoría para filtrar los eventos escritos por un origen de eventos. El Visor de eventos puede mostrar la categoría como un valor numérico, o puede utilizar la categoría como un identificador de recursos para mostrar una cadena de categoría adaptada.  
  
> [!NOTE]
>  El `category` parámetro debe ser un valor positivo. Valores de categoría negativos aparecen como un número positivo complementario del Visor en el evento. Por ejemplo, -10 aparece como 65.526, -1 como 65.535.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Para mostrar cadenas de categoría adaptadas en el Visor de eventos, debe utilizar un origen de eventos configurado con un archivo de recursos de categoría y establezca el `category` a un identificador de recurso en el archivo de recursos de categoría. Si el origen del evento no tiene un archivo de recursos de categoría configurado o especificado `category` no indiza una cadena en el archivo de recursos de categoría, el Visor de eventos muestra el valor numérico de categoría para esa entrada. Configurar el archivo de recursos de categoría, junto con el número de cadenas de categoría en el archivo de recursos, mediante el <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventSourceCreationData> clase.  
  
 Además de la categoría, puede especificar un identificador de evento para el evento que se escriben en el registro de eventos. Los identificadores de eventos, junto con el origen de eventos, identifican de forma exclusiva un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Los visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y sugerir qué acciones emprender.  
  
 Por último, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y el texto de la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> instancia antes de llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema debe registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> propiedad no se estableció en su <xref:System.Diagnostics.EventLog> instancia, el registro toma como valor predeterminado el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones mencionadas se generan por errores generados durante el proceso de registro del <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
 O bien  
  
 El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
 \- o -  
  
 El origen ya está registrado para otro registro de eventos.  
  
 \- o -  
  
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado y el identificador de eventos definido por la aplicación mediante el origen de eventos registrado que se especifique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada con un definido por la aplicación `eventID` en el registro de eventos mediante un origen ya registrado como un origen de eventos para el registro adecuado. El `eventID`, junto con el origen, identificar de forma exclusiva un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Los visores de eventos presentan estas cadenas al usuario para ayudar al usuario a comprender qué salió mal y sugerir qué acciones emprender.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
 Además del identificador de eventos, esta sobrecarga de <xref:System.Diagnostics.EventLog.WriteEntry%2A> le permite especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y el texto de la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
 \- o -  
  
 El valor <paramref name="source" /> es <see langword="null" />.  
  
 \- o -  
  
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <param name="category">Subcategoría específica de la aplicación asociada al mensaje.</param>
        <param name="rawData">Matriz de bytes que incluye los datos binarios asociados a la entrada.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado, el identificador de eventos definido por la aplicación y la categoría definida por la aplicación y anexa datos binarios al mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para escribir datos de específica del evento definido por la aplicación en el registro de eventos. El Visor de eventos no interpreta estos datos; Muestra los datos sin procesar solamente en un formato hexadecimal y de texto combinado. Usar datos específicos del evento con moderación, incluyéndolos solamente si está seguro de que serán útiles para alguien que depure el problema. También puede usar datos específicos del evento para almacenar información de que la aplicación puede procesar independientemente el Visor de eventos. Por ejemplo, podría escribir un visor específicamente para los eventos o escribir un programa que busca en el archivo de registro y crea informes que incluyen información de los datos específicos del evento.  
  
 Además de los datos binarios, puede especificar una categoría definida por la aplicación y un identificador de eventos definido por la aplicación. El Visor de eventos usa la categoría para filtrar los eventos escritos por un origen de eventos. El Visor de eventos puede mostrar la categoría como un valor numérico, o puede utilizar la categoría como un identificador de recursos para mostrar una cadena de categoría adaptada.  
  
> [!NOTE]
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
> [!NOTE]
>  El `category` parámetro debe ser un valor positivo. Valores de categoría negativos aparecen como un número positivo complementario del Visor en el evento. Por ejemplo, -10 aparece como 65.526, -1 como 65.535.  
  
 Para mostrar cadenas de categoría adaptadas en el Visor de eventos, debe utilizar un origen de eventos configurado con un archivo de recursos de categoría y establezca el `category` a un identificador de recurso en el archivo de recursos de categoría. Si el origen del evento no tiene un archivo de recursos de categoría configurado o especificado `category` no indiza una cadena en el archivo de recursos de categoría, el Visor de eventos muestra el valor numérico de categoría para esa entrada. Configurar el archivo de recursos de categoría, junto con el número de cadenas de categoría en el archivo de recursos, mediante el <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventSourceCreationData> clase.  
  
 Los identificadores de eventos, junto con el origen de eventos, identifican de forma exclusiva un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Los visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y sugerir qué acciones emprender.  
  
 Por último, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y el texto de la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de poder escribir entradas en el registro. Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen.  
  
 Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 Si el origen especificado en el <xref:System.Diagnostics.EventLog.Source%2A> propiedad de este <xref:System.Diagnostics.EventLog> instancia no está registrada en el equipo que el componente está escribiendo, <xref:System.Diagnostics.EventLog.WriteEntry%2A> llamadas <xref:System.Diagnostics.EventLog.CreateEventSource%2A> y registra el origen.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> instancia antes de llamar a <xref:System.Diagnostics.EventLog.CreateEventSource%2A> o <xref:System.Diagnostics.EventLog.WriteEntry%2A>, el equipo local (".") se da por hecho.  
  
 Si el sistema debe registrar el <xref:System.Diagnostics.EventLog.Source%2A> mediante una llamada a <xref:System.Diagnostics.EventLog.WriteEntry%2A> y <xref:System.Diagnostics.EventLog.Log%2A> propiedad no se estableció en su <xref:System.Diagnostics.EventLog> instancia, el registro toma como valor predeterminado el registro de aplicación.  
  
> [!NOTE]
>  Muchas de las excepciones mencionadas se generan por errores generados durante el proceso de registro del <xref:System.Diagnostics.EventLog.Source%2A>.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor del mensaje (la cadena de texto) podría no ser los esperados si el equipo remoto no está ejecutando .NET Framework.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
 O bien  
  
 El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
 \- o -  
  
 El origen ya está registrado para otro registro de eventos.  
  
 \- o -  
  
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <param name="category">Subcategoría específica de la aplicación asociada al mensaje.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado, el identificador de eventos definido por la aplicación y la categoría definida por la aplicación mediante el origen de eventos registrado específico. El Visor de eventos puede usar el parámetro <paramref name="category" /> para filtrar los eventos del registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada con un definido por la aplicación `category` en el registro de eventos con un origen que ya está registrado como un origen de eventos para el registro adecuado. El Visor de eventos usa la categoría para filtrar los eventos escritos por un origen de eventos. El Visor de eventos puede mostrar la categoría como un valor numérico, o puede utilizar la categoría como un identificador de recursos para mostrar una cadena de categoría adaptada.  
  
> [!NOTE]
>  El `category` parámetro debe ser un valor positivo. Valores de categoría negativos aparecen como un número positivo complementario del Visor en el evento. Por ejemplo, -10 aparece como 65.526, -1 como 65.535.  
  
 Para mostrar cadenas de categoría adaptadas en el Visor de eventos, debe utilizar un origen de eventos configurado con un archivo de recursos de categoría y establezca el `category` a un identificador de recurso en el archivo de recursos de categoría. Si el origen del evento no tiene un archivo de recursos de categoría configurado o especificado `category` no indiza una cadena en el archivo de recursos de categoría, el Visor de eventos muestra el valor numérico de categoría para esa entrada. Configurar el archivo de recursos de categoría, junto con el número de cadenas de categoría en el archivo de recursos, mediante el <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventSourceCreationData> clase.  
  
 Además de la categoría, puede especificar un identificador de evento para el evento que se escriben en el registro de eventos. Los identificadores de eventos, junto con el origen de eventos, identifican de forma exclusiva un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Los visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y sugerir qué acciones emprender.  
  
 Por último, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y el texto de la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
>   
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
 \- o -  
  
 El valor <paramref name="source" /> es <see langword="null" />.  
  
 \- o -  
  
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Origen mediante el que se registra la aplicación en el equipo especificado.</param>
        <param name="message">Cadena que se va a escribir en el registro de eventos.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Diagnostics.EventLogEntryType" />.</param>
        <param name="eventID">Identificador específico de la aplicación para el evento.</param>
        <param name="category">Subcategoría específica de la aplicación asociada al mensaje.</param>
        <param name="rawData">Matriz de bytes que incluye los datos binarios asociados a la entrada.</param>
        <summary>Escribe en el registro de eventos una entrada con el texto de mensaje dado, el identificador de eventos definido por la aplicación y la categoría definida por la aplicación (mediante el origen de eventos registrado especificado) y anexa datos binarios al mensaje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir datos de específica del evento definido por la aplicación en el registro de eventos mediante un origen ya registrado como un origen de eventos para el registro adecuado. El Visor de eventos no interpreta estos datos; Muestra los datos sin procesar solamente en un formato hexadecimal y de texto combinado. Usar datos específicos del evento con moderación; incluir solo si está seguro de que serán útiles. También puede usar datos específicos del evento para almacenar información de que la aplicación puede procesar independientemente el Visor de eventos. Por ejemplo, podría escribir un visor específicamente para los eventos o escribir un programa que busca en el archivo de registro y crea informes que incluyen información de los datos específicos del evento.  
  
 Además de los datos binarios, puede especificar una categoría definida por la aplicación y un identificador de eventos definido por la aplicación. El Visor de eventos usa la categoría para filtrar los eventos escritos por un origen de eventos. El Visor de eventos puede mostrar la categoría como un valor numérico, o puede utilizar la categoría como un identificador de recursos para mostrar una cadena de categoría adaptada.  
  
> [!NOTE]
>  El `category` parámetro debe ser un valor positivo. Valores de categoría negativos aparecen como un número positivo complementario del Visor en el evento. Por ejemplo, -10 aparecerá como 65.526, -1 como 65.535.  
  
 Para mostrar cadenas de categoría adaptadas en el Visor de eventos, debe utilizar un origen de eventos configurado con un archivo de recursos de categoría y establezca el `category` a un identificador de recurso en el archivo de recursos de categoría. Si el origen del evento no tiene un archivo de recursos de categoría configurado o especificado `category` no indiza una cadena en el archivo de recursos de categoría, el Visor de eventos muestra el valor numérico de categoría para esa entrada. Configurar el archivo de recursos de categoría, junto con el número de cadenas de categoría en el archivo de recursos, mediante el <xref:System.Diagnostics.EventLogInstaller> o <xref:System.Diagnostics.EventSourceCreationData> clase.  
  
 Los identificadores de eventos, junto con el origen de eventos, identifican de forma exclusiva un evento. Cada aplicación puede definir sus propios eventos numerados y las cadenas de descripción a la que se asignan. Los visores de eventos muestran estos valores de cadena para ayudar al usuario a comprender qué salió mal y sugerir qué acciones emprender.  
  
 Por último, puede especificar un <xref:System.Diagnostics.EventLogEntryType> para el evento que se escriben en el registro de eventos. El `type` se indica mediante un icono y el texto de la columna de tipo en el Visor de eventos para un registro. Este parámetro indica si el tipo de evento es error, advertencia, información, auditoría de aciertos o auditoría de errores.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. El <xref:System.Diagnostics.EventLog.WriteEntry%2A> método escribe la cadena especificada directamente en el registro de eventos; no usa un archivo de recursos de mensajes localizable. Use la <xref:System.Diagnostics.EventLog.WriteEvent%2A> método escribir eventos mediante un archivo de recursos de mensaje traducido.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si el `message` parámetro contiene un carácter null, el mensaje en el registro de eventos se termina en el carácter null.  
>   
>  El `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
 \- o -  
  
 El valor <paramref name="source" /> es <see langword="null" />.  
  
 \- o -  
  
 <paramref name="eventID" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 La cadena de mensaje es más de 31.839 bytes (32.766 bytes en los sistemas operativos Windows anterior a Windows Vista).  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> no es un <see cref="T:System.Diagnostics.EventLogEntryType" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe una entrada de evento localizada en el registro de eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Instancia de <see cref="T:System.Diagnostics.EventInstance" /> que representa una entrada localizada del registro de eventos.</param>
        <param name="values">Matriz de cadenas que se van a fusionar mediante combinación para formar el texto del mensaje de la entrada del registro de eventos.</param>
        <summary>Escribe una entrada localizada en el registro de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para escribir una entrada localizada en el registro de eventos. Especificar las propiedades de eventos con identificadores de recursos en lugar de valores de cadena. El Visor de eventos usa los identificadores de recursos para mostrar las cadenas correspondientes del archivo de recursos localizado para la <xref:System.Diagnostics.EventLog.Source%2A>. Debe registrar el origen con el archivo de recursos correspondiente antes de escribir eventos con identificadores de recursos.  
  
 La entrada `instance` instancia especifica las propiedades y el mensaje de evento. Establecer el <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` de entrada para el mensaje definido en el archivo de recursos de mensaje de origen. Opcionalmente, puede establecer la <xref:System.Diagnostics.EventInstance.CategoryId%2A> y <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrada para definir el tipo de categoría y eventos de la entrada del evento. También puede especificar una matriz de cadenas independientes del lenguaje para insertar en el texto del mensaje traducido. Establecer `values` a `null` si el mensaje de evento no contenga marcadores de formato para las cadenas de reemplazo.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. El origen especificado debe estar configurado para escribir entradas adaptadas en el registro; el origen debe tener como mínimo un archivo de recursos de mensaje definido.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Use la <xref:System.Diagnostics.EventLog.WriteEntry%2A> método si su aplicación escribe valores de cadena directamente en el registro de eventos.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor de la `message` cadena no puede ser el esperado si el equipo remoto no está ejecutando .NET Framework. Además, el `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe dos entradas al registro de eventos de auditoría `myNewLog`. En el ejemplo se crea un nuevo origen de eventos y un registro de eventos si no existen en el equipo local. El texto del mensaje de evento se especifica utilizando un identificador de recursos en un archivo de recursos.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 En el ejemplo se usa el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto de mensaje es el origen desde el que se creó el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto de categoría, mensaje de evento y las cadenas de inserción de parámetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
 O bien  
  
 El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
 \- o -  
  
 El origen ya está registrado para otro registro de eventos.  
  
 \- o -  
  
 <paramref name="instance.InstanceId" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 <paramref name="values" /> tiene más de 256 elementos.  
  
 \- o -  
  
 Uno de los elementos <paramref name="values" /> tiene más de 32766 bytes.  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Instancia de <see cref="T:System.Diagnostics.EventInstance" /> que representa una entrada localizada del registro de eventos.</param>
        <param name="data">Matriz de bytes que incluye los datos binarios asociados a la entrada.</param>
        <param name="values">Matriz de cadenas que se van a fusionar mediante combinación para formar el texto del mensaje de la entrada del registro de eventos.</param>
        <summary>Escribe una entrada de registro de eventos con los datos de evento dados, con cadenas de reemplazo de mensajes y con datos binarios asociados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada adaptada con otros datos específicos del evento en el registro de eventos. Especificar las propiedades de eventos con identificadores de recursos en lugar de valores de cadena. El Visor de eventos usa los identificadores de recursos para mostrar las cadenas correspondientes del archivo de recursos localizado para la <xref:System.Diagnostics.EventLog.Source%2A>. Debe registrar el origen con el archivo de recursos correspondiente antes de escribir eventos con identificadores de recursos.  
  
 La entrada `instance` instancia especifica las propiedades y el mensaje de evento. Establecer el <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` de entrada para el mensaje definido en el archivo de recursos de mensaje de origen. Opcionalmente, puede establecer la <xref:System.Diagnostics.EventInstance.CategoryId%2A> y <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrada para definir el tipo de categoría y eventos de la entrada del evento. También puede especificar una matriz de cadenas independientes del lenguaje para insertar en el texto del mensaje traducido. Establecer `values` a `null` si el mensaje de evento no contenga marcadores de formato para las cadenas de reemplazo.  
  
 Especificar datos binarios con un evento cuando sea necesario proporcionar detalles adicionales para el evento. Por ejemplo, use la `data` parámetro para incluir información sobre un error específico. El Visor de eventos no interpreta los datos del evento asociado; Muestra los datos en un formato hexadecimal y de texto combinado. Usar datos específicos del evento con moderación; incluir solo si está seguro de que serán útiles. También puede usar datos específicos del evento para almacenar información de que la aplicación puede procesar independientemente el Visor de eventos. Por ejemplo, podría escribir un visor específicamente para los eventos o escribir un programa que busca en el registro de eventos y crea informes que incluyen información de los datos específicos del evento.  
  
 Debe establecer el <xref:System.Diagnostics.EventLog.Source%2A> propiedad en su <xref:System.Diagnostics.EventLog> componente antes que el componente antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. El origen especificado debe estar configurado para escribir entradas adaptadas en el registro; el origen debe tener como mínimo un archivo de recursos de mensaje definido.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
> [!NOTE]
>  Si no especifica un <xref:System.Diagnostics.EventLog.MachineName%2A> para su <xref:System.Diagnostics.EventLog> instancia antes de llamar a <xref:System.Diagnostics.EventLog.WriteEvent%2A>, el equipo local (".") se da por hecho.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Use la <xref:System.Diagnostics.EventLog.WriteEntry%2A> método si su aplicación escribe valores de cadena directamente en el registro de eventos.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
> [!NOTE]
>  Si escribe una entrada en un equipo remoto, el valor de la `message` cadena no puede ser el esperado si el equipo remoto no está ejecutando .NET Framework. Además, el `message` cadena no puede contener %*n*, donde *n* es un valor entero (por ejemplo, %1), porque el Visor de eventos lo trata como una cadena de inserción. Dado que un protocolo de Internet versión 6 (IPv6) puede contener esta secuencia de caracteres, no puede registrar un mensaje de evento que contiene una dirección IPv6.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe dos entradas al registro de eventos de auditoría `myNewLog`. En el ejemplo se crea un nuevo origen de eventos y un registro de eventos si no existen en el equipo local. El texto del mensaje de evento se especifica utilizando un identificador de recursos en un archivo de recursos.  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 En el ejemplo se usa el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto de mensaje es el origen desde el que se creó el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto de categoría, mensaje de evento y las cadenas de inserción de parámetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aún no se ha establecido la propiedad <see cref="P:System.Diagnostics.EventLog.Source" /> de <see cref="T:System.Diagnostics.EventLog" />.  
  
 O bien  
  
 El método ha intentado registrar un origen de eventos nuevo, pero el nombre de equipo de <see cref="P:System.Diagnostics.EventLog.MachineName" /> no es válido.  
  
 \- o -  
  
 El origen ya está registrado para otro registro de eventos.  
  
 \- o -  
  
 <paramref name="instance.InstanceId" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 <paramref name="values" /> tiene más de 256 elementos.  
  
 \- o -  
  
 Uno de los elementos <paramref name="values" /> tiene más de 32766 bytes.  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos registrado para la aplicación en el equipo especificado.</param>
        <param name="instance">Instancia de <see cref="T:System.Diagnostics.EventInstance" /> que representa una entrada localizada del registro de eventos.</param>
        <param name="values">Matriz de cadenas que se van a fusionar mediante combinación para formar el texto del mensaje de la entrada del registro de eventos.</param>
        <summary>Escribe una entrada de registro de eventos con las cadenas de reemplazo de mensaje y los datos de evento proporcionados, para lo que utiliza el origen de eventos registrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada localizada en el registro de eventos mediante un origen ya registrado como un origen de eventos para el registro adecuado. Especificar las propiedades de eventos con identificadores de recursos en lugar de valores de cadena. El Visor de eventos usa los identificadores de recursos para mostrar las cadenas correspondientes del archivo de recursos localizado para el origen. Debe registrar el origen con el archivo de recursos correspondiente antes de escribir eventos con identificadores de recursos.  
  
 La entrada `instance` instancia especifica las propiedades y el mensaje de evento. Establecer el <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` de entrada para el mensaje definido en el archivo de recursos de mensaje de origen. Opcionalmente, puede establecer la <xref:System.Diagnostics.EventInstance.CategoryId%2A> y <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrada para definir el tipo de categoría y eventos de la entrada del evento. También puede especificar una matriz de cadenas independientes del lenguaje para insertar en el texto del mensaje traducido. Establecer `values` a `null` si el mensaje de evento no contenga marcadores de formato para las cadenas de reemplazo.  
  
 El origen especificado debe estar registrado para un registro de eventos antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. El origen especificado debe estar configurado para escribir entradas adaptadas en el registro; el origen debe tener como mínimo un archivo de recursos de mensaje definido.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Use la <xref:System.Diagnostics.EventLog.WriteEntry%2A> método si su aplicación escribe valores de cadena directamente en el registro de eventos.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe una entrada de evento de información y una entrada de evento de advertencia en un registro de eventos existente. El texto del mensaje de evento se especifica utilizando un identificador de recursos en un archivo de recursos. En el ejemplo se da por supuesto que el archivo de recursos correspondiente se ha registrado para el origen.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 En el ejemplo se usa el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto de mensaje es el origen desde el que se creó el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto de categoría, mensaje de evento y las cadenas de inserción de parámetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
 \- o -  
  
 El valor <paramref name="source" /> es <see langword="null" />.  
  
 \- o -  
  
 <paramref name="instance.InstanceId" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 <paramref name="values" /> tiene más de 256 elementos.  
  
 \- o -  
  
 Uno de los elementos <paramref name="values" /> tiene más de 32766 bytes.  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">Nombre del origen de eventos registrado para la aplicación en el equipo especificado.</param>
        <param name="instance">Instancia de <see cref="T:System.Diagnostics.EventInstance" /> que representa una entrada localizada del registro de eventos.</param>
        <param name="data">Matriz de bytes que incluye los datos binarios asociados a la entrada.</param>
        <param name="values">Matriz de cadenas que se van a fusionar mediante combinación para formar el texto del mensaje de la entrada del registro de eventos.</param>
        <summary>Escribe una entrada de registro con los datos de evento dados, con cadenas de reemplazo de mensajes y con datos binarios asociados y, además, utiliza el origen de eventos registrado que se especifica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para escribir una entrada adaptada con otros datos específicos del evento en el registro de eventos mediante un origen ya registrado como un origen de eventos para el registro adecuado. Especificar las propiedades de eventos con identificadores de recursos en lugar de valores de cadena. El Visor de eventos usa los identificadores de recursos para mostrar las cadenas correspondientes del archivo de recursos localizado para el origen. Debe registrar el origen con el archivo de recursos correspondiente antes de escribir eventos con identificadores de recursos.  
  
 La entrada `instance` instancia especifica las propiedades y el mensaje de evento. Establecer el <xref:System.Diagnostics.EventInstance.InstanceId%2A> de la `instance` de entrada para el mensaje definido en el archivo de recursos de mensaje de origen. Opcionalmente, puede establecer la <xref:System.Diagnostics.EventInstance.CategoryId%2A> y <xref:System.Diagnostics.EventInstance.EntryType%2A> de la `instance` entrada para definir el tipo de categoría y eventos de la entrada del evento. También puede especificar una matriz de cadenas independientes del lenguaje para insertar en el texto del mensaje traducido. Establecer `values` a `null` si el mensaje de evento no contenga marcadores de formato para las cadenas de reemplazo.  
  
 Especificar datos binarios con un evento cuando sea necesario proporcionar detalles adicionales para el evento. Por ejemplo, use la `data` parámetro para incluir información sobre un error específico. El Visor de eventos no interpreta los datos del evento asociado; Muestra los datos en un formato hexadecimal y de texto combinado. Usar datos específicos del evento con moderación; incluir solo si está seguro de que serán útiles. También puede usar datos específicos del evento para almacenar información de que la aplicación puede procesar independientemente el Visor de eventos. Por ejemplo, podría escribir un visor específicamente para los eventos o escribir un programa que busca en el registro de eventos y crea informes que incluyen información de los datos específicos del evento.  
  
 El origen especificado debe estar registrado para un registro de eventos antes de usar <xref:System.Diagnostics.EventLog.WriteEvent%2A>. El origen especificado debe estar configurado para escribir entradas adaptadas en el registro; el origen debe tener como mínimo un archivo de recursos de mensaje definido.  
  
 Debe crear y configurar el origen del evento antes de escribir la primera entrada con el origen. Crear el nuevo origen de eventos durante la instalación de la aplicación. Esto permite que el sistema operativo actualizar la lista de orígenes de eventos registrados y su configuración. Si el sistema operativo no ha actualizado su lista de orígenes de eventos y se intenta escribir un evento con el nuevo origen, que se producirá un error en la operación de escritura. Puede configurar un nuevo origen mediante un <xref:System.Diagnostics.EventLogInstaller>, o mediante el <xref:System.Diagnostics.EventLog.CreateEventSource%2A> método. Debe tener derechos administrativos en el equipo para crear un nuevo origen de eventos.  
  
 El origen debe configurarse para escribir entradas adaptadas o cadenas directas. Use la <xref:System.Diagnostics.EventLog.WriteEntry%2A> método si su aplicación escribe valores de cadena directamente en el registro de eventos.  
  
 Si su aplicación escribe las entradas con identificadores de recursos y valores de cadena, debe registrarse dos orígenes diferentes. Por ejemplo, configure un origen con archivos de recursos y, a continuación, usar ese origen en el <xref:System.Diagnostics.EventLog.WriteEvent%2A> método para escribir entradas mediante identificadores de recursos en el registro de eventos. A continuación, cree un origen diferente sin archivos de recursos y usarlo en el <xref:System.Diagnostics.EventLog.WriteEntry%2A> método para escribir cadenas directamente en el registro de eventos utilizando ese origen.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe una entrada de evento de información y una entrada de evento de advertencia en un registro de eventos existente. El texto del mensaje de evento se especifica utilizando un identificador de recursos en un archivo de recursos. En el ejemplo se da por supuesto que el archivo de recursos correspondiente se ha registrado para el origen.  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 En el ejemplo se usa el siguiente archivo de texto de mensaje, integrado en la biblioteca de recursos EventLogMsgs.dll. Un archivo de texto de mensaje es el origen desde el que se creó el archivo de recursos de mensaje. El archivo de texto de mensaje define los identificadores de recursos y el texto de categoría, mensaje de evento y las cadenas de inserción de parámetro.  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="source" /> es una cadena vacía ("").  
  
 \- o -  
  
 El valor <paramref name="source" /> es <see langword="null" />.  
  
 \- o -  
  
 <paramref name="instance.InstanceId" /> es menor que cero o mayor que <see cref="F:System.UInt16.MaxValue" />.  
  
 \- o -  
  
 <paramref name="values" /> tiene más de 256 elementos.  
  
 \- o -  
  
 Uno de los elementos <paramref name="values" /> tiene más de 32766 bytes.  
  
 \- o -  
  
 El nombre de origen produce una ruta de clave del Registro con una longitud superior a 254 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha podido abrir la clave del Registro para el registro de eventos.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">El sistema operativo ha notificado un error al escribir la entrada de evento en el registro. No hay ningún código de error de Windows disponible.</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">para escribir la información de registro de eventos en el equipo. Enumeración asociada: <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>