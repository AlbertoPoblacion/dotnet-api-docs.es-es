<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58cf5f02c19c3c52ac8d26e1ed52e28a450d7b17" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36676173" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides access to local and remote processes and enables you to start and stop local system processes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Diagnostics.Process> componente proporciona acceso a un proceso que se ejecuta en un equipo. Un proceso, en los términos más simples, es una aplicación en ejecución. Un subproceso es la unidad básica a la que el sistema operativo asigna tiempo de procesador. Un subproceso puede ejecutar cualquier parte del código del proceso, incluidos los elementos que se está ejecutadas actualmente por otro subproceso.  
  
 El <xref:System.Diagnostics.Process> componente es una herramienta útil para iniciar, detener, controlar y supervisar aplicaciones. Puede usar el <xref:System.Diagnostics.Process> componente, para obtener una lista de los procesos que se ejecutan, o se puede iniciar un nuevo proceso. Un <xref:System.Diagnostics.Process> componente se utiliza para tener acceso a los procesos del sistema. Después de un <xref:System.Diagnostics.Process> se ha inicializado el componente, se puede utilizar para obtener información sobre el proceso en ejecución. Dicha información incluye el conjunto de subprocesos, los módulos cargados (archivos .dll y .exe), y está usando la información de rendimiento, como la cantidad de memoria del proceso.  
  
 Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
> [!NOTE]
>  procesos de 32 bits no pueden tener acceso a los módulos de un proceso de 64 bits. Si intenta obtener información acerca de un proceso de 64 bits de un proceso de 32 bits, obtendrá un <xref:System.ComponentModel.Win32Exception> excepción. Un proceso de 64 bits, por otro lado, puede tener acceso a los módulos de un proceso de 32 bits.  
  
 El componente del proceso obtiene información sobre un grupo de propiedades a la vez. Después de la <xref:System.Diagnostics.Process> componente ha obtenido información sobre un miembro de ningún grupo, almacenarán en caché los valores de las demás propiedades de ese grupo y no obtiene nueva información sobre los demás miembros del grupo hasta que llame a la <xref:System.Diagnostics.Process.Refresh%2A> método. Por lo tanto, no se garantiza un valor de propiedad sea más reciente que la última llamada a la <xref:System.Diagnostics.Process.Refresh%2A> método. Los detalles del grupo dependen del sistema operativo.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe iniciar cualquier proceso que se encuentra en esa ubicación de dicha ruta de acceso completos. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agregarlo mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
 Un proceso del sistema se identifica en el sistema mediante su identificador de proceso. Al igual que muchos de los recursos de Windows, un proceso también se identifica mediante su identificador, que podría no ser único en el equipo. Un identificador es el término genérico para un identificador de un recurso. El sistema operativo conserva el identificador de proceso, que se obtiene acceso a través de la <xref:System.Diagnostics.Process.Handle%2A> propiedad de la <xref:System.Diagnostics.Process> componente, incluso cuando el proceso ha terminado. Por lo tanto, puede obtener la información administrativa del proceso, como el <xref:System.Diagnostics.Process.ExitCode%2A> (normalmente, cero para correcto o un código de error distinto de cero) y la <xref:System.Diagnostics.Process.ExitTime%2A>. Identificadores son un recurso muy valioso, por lo que la pérdida de identificadores es mucho más dañina que la pérdida de memoria.  
  
> [!NOTE]
>  Esta clase contiene una petición de vínculo y una petición de herencia en el nivel de clase que se aplica a todos los miembros. Un <xref:System.Security.SecurityException> se produce cuando el llamador inmediato o la clase derivada no tiene permiso de plena confianza. Para obtener más información acerca de las peticiones de seguridad, consulte [peticiones de vínculo](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Notas de la  
 En .NET Framework, el <xref:System.Diagnostics.Process> clase usa de manera predeterminada <xref:System.Console> codificaciones, que suelen ser código codificaciones de páginas, para las secuencias de entrada, salida y error. Por ejemplo de código, en los sistemas cuya referencia cultural es inglés (Estados Unidos), página de códigos 437 es la codificación predeterminada para el <xref:System.Console> clase. Sin embargo, [!INCLUDE[net_core](~/includes/net-core-md.md)] pueden crear solo un subconjunto limitado de estas codificaciones disponible. Si este es el caso, utiliza <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> como la codificación predeterminada.  
  
 Si un <xref:System.Diagnostics.Process> objeto depende de codificaciones de páginas de código concretos, puede seguir ponerlos a disposición mediante las acciones siguientes *antes de* llamar a cualquier <xref:System.Diagnostics.Process> métodos:  
  
1.  Agregue una referencia al ensamblado System.Text.Encoding.CodePages.dll al proyecto.  
  
2.  Recuperar el <xref:System.Text.EncodingProvider> objeto desde el <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propiedad.  
  
3.  Pasar el <xref:System.Text.EncodingProvider> el objeto a la <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> método para hacer que las codificaciones adicionales admitidas por el proveedor de codificación disponible.  
  
 El <xref:System.Diagnostics.Process> clase, a continuación, utilizará automáticamente la codificación predeterminada del sistema en lugar de UTF8, siempre que haya registrado el proveedor de codificación antes de llamar a cualquier <xref:System.Diagnostics.Process> métodos.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza una instancia de la <xref:System.Diagnostics.Process> clase para iniciar un proceso.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 En el ejemplo siguiente se usa el <xref:System.Diagnostics.Process> clase sí mismo y a una variable static <xref:System.Diagnostics.Process.Start%2A> método para iniciar un proceso.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 El siguiente ejemplo de F # define un `runProc` función que inicia un proceso, captura toda la información de salida y el error y registra el número de milisegundos que se ha ejecutado el proceso.  El `runProc` función tiene tres parámetros: el nombre de aplicación que se va a iniciar, los argumentos para proporcionar a la aplicación y el directorio de inicio.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 El código para el `runProc` escribió función [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) y está disponible en la [licencia pública de Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Esta clase no puede ser usada por código de confianza parcial.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">de plena confianza para los herederos. Esta clase no puede heredarse mediante código de confianza parcial.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se especifica la <xref:System.Diagnostics.Process.MachineName%2A> propiedad, el valor predeterminado es el equipo local (".").  
  
 Tiene dos opciones para asociar un nuevo <xref:System.Diagnostics.Process> componente con un proceso en el equipo. La primera opción es utilizar el constructor para crear el <xref:System.Diagnostics.Process> componente, establecer los miembros correspondientes de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llame al método <xref:System.Diagnostics.Process.Start%2A> para asociar el <xref:System.Diagnostics.Process> con un nuevo proceso del sistema. La segunda opción es asociar el <xref:System.Diagnostics.Process> con un proceso en ejecución sistema mediante el uso de <xref:System.Diagnostics.Process.GetProcessById%2A> o uno de los <xref:System.Diagnostics.Process.GetProcesses%2A> valores devueltos.  
  
 Si utiliza un `static` sobrecarga de la <xref:System.Diagnostics.Process.Start%2A> crea un nuevo método para iniciar un nuevo proceso del sistema, el método <xref:System.Diagnostics.Process> componente y lo asocia al proceso.  
  
 Cuando el <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> propiedad está establecida en su valor predeterminado, `true`, puede empezar a aplicaciones y documentos de forma similar al uso de la `Run` cuadro de diálogo de las ventanas `Start` menú. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> es `false`, puede iniciar archivos ejecutables.  
  
 Se puede iniciar cualquier archivo ejecutable que se puede llamar desde la línea de comandos de dos maneras: estableciendo los miembros correspondientes de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llamar a la <xref:System.Diagnostics.Process.Start%2A> método sin parámetros, o pasando el parámetro apropiado para el `static` <xref:System.Diagnostics.Process.Start%2A> miembro.  
  
 Puede crear un <xref:System.Diagnostics.Process> componente mediante el constructor, uno de los métodos estático <xref:System.Diagnostics.Process.Start%2A> sobrecargas o cualquiera de los <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, o <xref:System.Diagnostics.Process.GetProcessesByName%2A> métodos. Después de hacer esto, tendrá una vista en el proceso asociado. No es una vista dinámica que se actualiza automáticamente cuando las propiedades del proceso han cambiado en la memoria. En su lugar, debe llamar a <xref:System.Diagnostics.Process.Refresh%2A> para el componente que desea actualizar la <xref:System.Diagnostics.Process> información sobre propiedades de la aplicación.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base priority of the associated process.</summary>
        <value>Prioridad base, que se calcula a partir de <see cref="P:System.Diagnostics.Process.PriorityClass" /> del proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.BasePriority%2A> del proceso es la prioridad inicial para los subprocesos creados dentro del proceso asociado. Puede ver información acerca de la prioridad base a través del contador prioridad Base del Monitor de sistema.  
  
 En función del tiempo transcurrido u otro tipo de estímulo, el sistema operativo puede cambiar la prioridad base cuando un proceso debe colocarse delante de otros.  
  
 El <xref:System.Diagnostics.Process.BasePriority%2A> propiedad le permite ver la prioridad inicial asignada a un proceso. Sin embargo, porque es de solo lectura, no se puede usar el <xref:System.Diagnostics.Process.BasePriority%2A> para establecer la prioridad del proceso. Para cambiar la prioridad, use la <xref:System.Diagnostics.Process.PriorityClass%2A> propiedad. El <xref:System.Diagnostics.Process.BasePriority%2A> pueden verse con el Monitor de sistema, mientras el <xref:System.Diagnostics.Process.PriorityClass%2A> no es. Tanto el <xref:System.Diagnostics.Process.BasePriority%2A> y <xref:System.Diagnostics.Process.PriorityClass%2A> se pueden ver mediante programación. En la tabla siguiente muestra la relación entre <xref:System.Diagnostics.Process.BasePriority%2A> valores y <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not started, so there is no process ID.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.StandardError%2A> secuencia puede leerse de forma sincrónica o asincrónica. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, y <xref:System.IO.StreamReader.ReadToEnd%2A> realizar operaciones de lectura sincrónica en el flujo de salida de error del proceso. Estos sincrónico leen las operaciones no se completan hasta que el asociado <xref:System.Diagnostics.Process> escribe en su <xref:System.Diagnostics.Process.StandardError%2A> transmitir por secuencias o cierra la secuencia.  
  
 En cambio, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> las operaciones de lectura asincrónica se inicia en el <xref:System.Diagnostics.Process.StandardError%2A> secuencia. Este método permite que el controlador de eventos designado para la salida de la secuencia y vuelve inmediatamente al llamador, que puede realizar otro trabajo mientras los resultados de la secuencia se dirigen al controlador de eventos.  
  
 Siga estos pasos para llevar a cabo operaciones de lectura asincrónica en <xref:System.Diagnostics.Process.StandardError%2A> para un <xref:System.Diagnostics.Process> :  
  
1.  Establezca <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> en `false`.  
  
2.  Establezca <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> en `true`.  
  
3.  Agregue el controlador de eventos para el <xref:System.Diagnostics.Process.ErrorDataReceived> eventos. El controlador de eventos debe coincidir con el <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> firma de delegado.  
  
4.  Iniciar el <xref:System.Diagnostics.Process>.  
  
5.  Llame a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para el <xref:System.Diagnostics.Process>. Esta llamada inicia las operaciones de lectura asincrónicas en <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Cuando se llama inicio de operaciones de lectura asincrónica, el controlador de eventos cada vez que el asociado <xref:System.Diagnostics.Process> escribe una línea de texto a su <xref:System.Diagnostics.Process.StandardError%2A> secuencia.  
  
 Puede cancelar una operación de lectura asincrónica mediante una llamada a <xref:System.Diagnostics.Process.CancelErrorRead%2A>. La operación de lectura se puede cancelar el autor de llamada o por el controlador de eventos. Después de cancelar, se puede llamar a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> nuevo para reanudar las operaciones de lectura asincrónica.  
  
> [!NOTE]
>  No se pueden mezclar las operaciones de lectura sincrónicas o asincrónicas en una secuencia redirigida. Una vez la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas las lectura más operaciones en esa secuencia deben ser del mismo modo. Por ejemplo, no siga <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> con una llamada a <xref:System.IO.StreamReader.ReadLine%2A> en el <xref:System.Diagnostics.Process.StandardError%2A> flujo, o viceversa. Sin embargo, puede leer dos secuencias diferentes en modos diferentes. Por ejemplo, puede llamar a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> y, a continuación, llame a <xref:System.IO.StreamReader.ReadLine%2A> para el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `net view` comando para enumerar los recursos de red disponibles en un equipo remoto. El usuario proporciona el nombre del equipo de destino como un argumento de línea de comandos. El usuario también puede proporcionar un nombre de archivo de salida de error. En el ejemplo se recopila la salida del comando net, espera a que el proceso finalice y, a continuación, escribe los resultados en la consola. Si el usuario proporciona el archivo de errores opcional, el ejemplo escribe errores en el archivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia puede leerse de forma sincrónica o asincrónica. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, y <xref:System.IO.StreamReader.ReadToEnd%2A> realizar operaciones de lectura sincrónica en el flujo de salida del proceso. Estos sincrónico leen las operaciones no se completan hasta que el asociado <xref:System.Diagnostics.Process> escribe en su <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir por secuencias o cierra la secuencia.  
  
 En cambio, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> las operaciones de lectura asincrónica se inicia en el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia. Este método permite que un controlador de eventos designado para la salida de la secuencia y vuelve inmediatamente al llamador, que puede realizar otro trabajo mientras los resultados de la secuencia se dirigen al controlador de eventos.  
  
 Siga estos pasos para llevar a cabo operaciones de lectura asincrónica en <xref:System.Diagnostics.Process.StandardOutput%2A> para un <xref:System.Diagnostics.Process> :  
  
1.  Establezca <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> en `false`.  
  
2.  Establezca <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> en `true`.  
  
3.  Agregue el controlador de eventos para el <xref:System.Diagnostics.Process.OutputDataReceived> eventos. El controlador de eventos debe coincidir con el <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> firma de delegado.  
  
4.  Iniciar el <xref:System.Diagnostics.Process>.  
  
5.  Llame a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para el <xref:System.Diagnostics.Process>. Esta llamada inicia las operaciones de lectura asincrónicas en <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Cuando se llama inicio de operaciones de lectura asincrónica, el controlador de eventos cada vez que el asociado <xref:System.Diagnostics.Process> escribe una línea de texto a su <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia.  
  
 Puede cancelar una operación de lectura asincrónica mediante una llamada a <xref:System.Diagnostics.Process.CancelOutputRead%2A>. La operación de lectura se puede cancelar el autor de llamada o por el controlador de eventos. Después de cancelar, se puede llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> nuevo para reanudar las operaciones de lectura asincrónica.  
  
> [!NOTE]
>  No se pueden mezclar las operaciones de lectura sincrónicas o asincrónicas en una secuencia redirigida. Una vez la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas las lectura más operaciones en esa secuencia deben ser del mismo modo. Por ejemplo, no siga <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> con una llamada a <xref:System.IO.StreamReader.ReadLine%2A> en el <xref:System.Diagnostics.Process.StandardOutput%2A> flujo, o viceversa. Sin embargo, puede leer dos secuencias diferentes en modos diferentes. Por ejemplo, puede llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> y, a continuación, llame a <xref:System.IO.StreamReader.ReadLine%2A> para el <xref:System.Diagnostics.Process.StandardError%2A> secuencia.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo realizar operaciones de lectura asincrónica en la redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> flujo de la `sort` comando. El `sort` comando es una aplicación de consola que lee y ordena la entrada de texto.  
  
 En el ejemplo se crea un delegado de eventos para el `SortOutputHandler` controlador de eventos y lo asocia a la <xref:System.Diagnostics.Process.OutputDataReceived> eventos. El controlador de eventos recibe líneas de texto de la redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia, se da formato al texto y se escribe el texto en la pantalla.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.  \- or -  An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> inicia una operación de lectura asincrónica en la <xref:System.Diagnostics.Process.StandardError%2A> secuencia. <xref:System.Diagnostics.Process.CancelErrorRead%2A> finaliza la operación de lectura asincrónica.  
  
 Después de cancelar, se puede reanudar la operación de lectura asincrónica mediante una llamada a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> nuevo.  
  
 Cuando se llama a <xref:System.Diagnostics.Process.CancelErrorRead%2A>, todas las operaciones para de lectura en curso <xref:System.Diagnostics.Process.StandardError%2A> se han completado y, a continuación, se deshabilita el controlador de eventos. Todos los redirigen aún más la salida a <xref:System.Diagnostics.Process.StandardError%2A> se guarda en un búfer. Si volver a habilitar el controlador de eventos con una llamada a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, se envían los resultados guardados al controlador de eventos y reanudan las operaciones de lectura asincrónicas. Si desea cambiar el controlador de eventos antes de reanudar las operaciones de lectura asincrónicas, debe quitar el controlador de eventos existente antes de agregar el nuevo controlador de eventos:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  No se pueden mezclar las operaciones de lectura sincrónicas o asincrónicas en el redirigida <xref:System.Diagnostics.Process.StandardError%2A> secuencia. Una vez la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas las lectura más operaciones en esa secuencia deben ser del mismo modo. Si se cancela una operación de lectura asincrónica en <xref:System.Diagnostics.Process.StandardError%2A> y, a continuación, necesita leer de la secuencia de nuevo, debe usar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para reanudar las operaciones de lectura asincrónicas. No siga <xref:System.Diagnostics.Process.CancelErrorRead%2A> con una llamada a sincrónico leer métodos de <xref:System.Diagnostics.Process.StandardError%2A> como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia el `nmake` comando con el usuario los argumentos proporcionados. Los flujos de error y de salida se leen de forma asincrónica; las líneas de texto recopilados se muestran en la consola, así como escritas en un archivo de registro. Si la salida del comando supera un número especificado de líneas, se cancelan las operaciones de lectura asincrónicas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> inicia una operación de lectura asincrónica en la <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia. <xref:System.Diagnostics.Process.CancelOutputRead%2A> finaliza la operación de lectura asincrónica.  
  
 Después de cancelar, puede reanudar las operaciones de lectura asincrónicas mediante una llamada a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> nuevo.  
  
 Cuando se llama a <xref:System.Diagnostics.Process.CancelOutputRead%2A>, todas las operaciones para de lectura en curso <xref:System.Diagnostics.Process.StandardOutput%2A> se han completado y, a continuación, se deshabilita el controlador de eventos. Todos los redirigen aún más la salida a <xref:System.Diagnostics.Process.StandardOutput%2A> se guarda en un búfer. Si volver a habilitar el controlador de eventos con una llamada a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, se envían los resultados guardados al controlador de eventos y reanudan las operaciones de lectura asincrónicas. Si desea cambiar el controlador de eventos antes de reanudar las operaciones de lectura asincrónicas, debe quitar el controlador de eventos existente antes de agregar el nuevo controlador de eventos:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  No se pueden mezclar las operaciones de lectura sincrónicas o asincrónicas en el redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia. Una vez la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas las lectura más operaciones en esa secuencia deben ser del mismo modo. Si se cancela una operación de lectura asincrónica en <xref:System.Diagnostics.Process.StandardOutput%2A> y, a continuación, necesita leer de la secuencia de nuevo, debe usar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para reanudar las operaciones de lectura asincrónicas. No siga <xref:System.Diagnostics.Process.CancelOutputRead%2A> con una llamada a sincrónico leer métodos de <xref:System.Diagnostics.Process.StandardOutput%2A> como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia el `nmake` comando con el usuario los argumentos proporcionados. Los flujos de error y de salida se leen de forma asincrónica; las líneas de texto recopilados se muestran en la consola, así como escritas en un archivo de registro. Si la salida del comando supera un número especificado de líneas, se cancelan las operaciones de lectura asincrónicas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees all the resources that are associated with this component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.Close%2A> método hace que el proceso para detener la espera de salida si esperó, cierra el identificador de proceso y borra propiedades específicas del proceso. <xref:System.Diagnostics.Process.Close%2A> no se cierra de lectura de entrada o salida de error estándar y escritura en caso de que se hace referencia externamente.  
  
> [!NOTE]
>  El método <xref:System.Diagnostics.Process.Dispose%2A> llama a <xref:System.Diagnostics.Process.Close%2A>. Colocar el <xref:System.Diagnostics.Process> objeto en un `using` bloque se deshace de los recursos sin la necesidad de llamar a <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, recupera el uso de memoria física del proceso asociado a intervalos de 2 segundos durante un máximo de 10 segundos. En el ejemplo se detecta si el proceso se cierra antes de que hayan transcurrido 10 segundos. En el ejemplo se cierra el proceso si se está ejecutando todavía después de 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes a process that has a user interface by sending a close message to its main window.</summary>
        <returns>
          <see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se está ejecutando un proceso, el bucle de mensajes está en un estado de espera. El bucle de mensajes se ejecuta cada vez que se envía un mensaje de Windows al proceso por el sistema operativo. Al llamar a <xref:System.Diagnostics.Process.CloseMainWindow%2A> envía una solicitud para cerrar la ventana principal, que, en una aplicación con formato correcto, cierra las ventanas secundarias y revoca la ejecución de todos los bucles de mensajes para la aplicación. La solicitud para salir del proceso mediante una llamada a <xref:System.Diagnostics.Process.CloseMainWindow%2A> no fuerza la aplicación se cierre. La aplicación puede pedir confirmación del usuario antes de salir, o puede rechazar salir. Para forzar la aplicación para salir, use la <xref:System.Diagnostics.Process.Kill%2A> método. El comportamiento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> es idéntico de un usuario cierra la ventana principal de una aplicación mediante el menú de sistema. Por lo tanto, la solicitud para salir del proceso, el cierre de la ventana principal no obliga a la aplicación a salir inmediatamente.  
  
 Datos modificados por el proceso o los recursos asignados al proceso pueden perderse si se llama a <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> hace que una terminación anómala del proceso y debe usarse solo cuando sea necesario. <xref:System.Diagnostics.Process.CloseMainWindow%2A> habilita una finalización ordenada del proceso y cierra todas las ventanas, por lo que es preferible para las aplicaciones con una interfaz. Si <xref:System.Diagnostics.Process.CloseMainWindow%2A> se produce un error, puede usar <xref:System.Diagnostics.Process.Kill%2A> para finalizar el proceso. <xref:System.Diagnostics.Process.Kill%2A> es la única forma de terminar los procesos que no tienen interfaces gráficas.  
  
 Puede llamar a <xref:System.Diagnostics.Process.Kill%2A> y <xref:System.Diagnostics.Process.CloseMainWindow%2A> únicamente para los procesos que se ejecutan en el equipo local. No puede hacer procesos en equipos remotos para salir. Solo se puede ver información de los procesos que se ejecutan en equipos remotos.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, recupera el uso de memoria física del proceso asociado cada 2 segundos durante un máximo de 10 segundos. En el ejemplo se detecta si el proceso se cierra antes de que hayan transcurrido 10 segundos. En el ejemplo se cierra el proceso si se está ejecutando todavía después de 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Release all resources used by this process.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</summary>
        <value>Es <see langword="true" /> si el evento <see cref="E:System.Diagnostics.Process.Exited" /> debe provocarse cuando termine el proceso asociado (al salir o al llamar a <see cref="M:System.Diagnostics.Process.Kill" />); de lo contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />. Tenga en cuenta que la <see cref="E:System.Diagnostics.Process.Exited" /> evento se desencadena incluso si el valor de <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> es <see langword="false" /> cuando el proceso se cierra durante o antes de que el usuario realice un <see cref="P:System.Diagnostics.Process.HasExited" /> comprobar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
El <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad indica si el componente se debe notificar cuando el sistema operativo ha cerrado un proceso. El <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad se utiliza en procesos asincrónicos para notificar a la aplicación que un proceso ha terminado. Para forzar la aplicación para que espere un evento de cierre (que interrumpa el procesamiento de la aplicación hasta que se ha producido el evento de salida) de forma sincrónica, use la <xref:System.Diagnostics.Process.WaitForExit%2A> método.

> [!NOTE]
> Si está usando Visual Studio y haga doble clic en un <xref:System.Diagnostics.Process> componente en el proyecto, un <xref:System.Diagnostics.Process.Exited> delegado de eventos y el controlador de eventos se generan automáticamente. Conjuntos de código adicional del <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad `false`. Debe cambiar esta propiedad en `true` para que el controlador de eventos que se ejecuta cuando se cierra el proceso asociado.

Si el componente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> valor es `true`, o cuando <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> es `false` y un <xref:System.Diagnostics.Process.HasExited%2A> comprobación se invoca el componente, el componente puede tener acceso a la información administrativa para el proceso asociado, que sigue siendo almacena el sistema operativo. Dicha información incluye el <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.ExitCode%2A>.

Después de que termine el proceso asociado, el <xref:System.Diagnostics.Process.Handle%2A> del componente ya no apunta a un recurso de proceso existente. En su lugar, solo se puede utilizar para tener acceso a información del sistema operativo sobre el recurso de proceso. El sistema operativo es consciente de que hay identificadores de procesos terminados que aún no ha lanzado <xref:System.Diagnostics.Process> componentes, por lo que mantiene la <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.Handle%2A> información en la memoria.

Hay un costo asociado a ver un proceso salir. Si <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> es `true`, el <xref:System.Diagnostics.Process.Exited> evento se desencadena cuando finaliza el proceso asociado. Los procedimientos para la <xref:System.Diagnostics.Process.Exited> eventos que se ejecutan en ese momento.

A veces, la aplicación inicia un proceso, pero no requiere la notificación de su cierre. Por ejemplo, la aplicación puede iniciar el Bloc de notas para permitir al usuario realizar la edición de texto pero no realiza ninguna otra de uso de la aplicación en el Bloc de notas. Puede evitar la notificación al salir del proceso porque no es relevante para el funcionamiento continuo de la aplicación. Establecer <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> a `false` puede ahorrar recursos del sistema.

## Examples  
En el ejemplo de código siguiente se crea un proceso que imprime un archivo. Establece el <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad para hacer que el proceso generar el <xref:System.Diagnostics.Process.Exited> eventos cuando salga. El <xref:System.Diagnostics.Process.Exited> controlador de eventos muestra información del proceso.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos procesos del sistema operativo se ejecuten en un modo especial. Al intentar leer las propiedades de o adjuntar a estos procesos no es posible a menos que se llamó a <xref:System.Diagnostics.Process.EnterDebugMode%2A> en el componente. Llamar a <xref:System.Diagnostics.Process.LeaveDebugMode%2A> cuando ya no necesita acceso a estos procesos que se ejecutan en modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.ErrorDataReceived> evento indica que el proceso asociado ha escrito en su redirigida <xref:System.Diagnostics.Process.StandardError%2A> secuencia.  
  
 El evento sólo se produce durante las operaciones de lectura asincrónicas en <xref:System.Diagnostics.Process.StandardError%2A>. Para iniciar las operaciones de lectura asincrónicas, debe redirigir el <xref:System.Diagnostics.Process.StandardError%2A> secuencia de un <xref:System.Diagnostics.Process>, agregue el controlador de eventos para el <xref:System.Diagnostics.Process.ErrorDataReceived> eventos y llamadas <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Por lo tanto, la <xref:System.Diagnostics.Process.ErrorDataReceived> señales de eventos cada vez que el proceso escribe una línea en el redirigida <xref:System.Diagnostics.Process.StandardError%2A> transmitir por secuencias, hasta que el proceso se cierra o se llama <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  La aplicación que se está procesando la salida asincrónica debe llamar a la <xref:System.Diagnostics.Process.WaitForExit> método para asegurarse de que se ha vaciado el búfer de salida. Tenga en cuenta que si se especifica un tiempo de espera mediante el uso de la <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> sobrecarga *no* Asegúrese de que se ha vaciado el búfer de salida.
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `net view` comando para enumerar los recursos de red disponibles en un equipo remoto. El usuario proporciona el nombre del equipo de destino como un argumento de línea de comandos. El usuario también puede proporcionar un nombre de archivo de salida de error. En el ejemplo se recopila la salida del comando net, espera a que el proceso finalice y, a continuación, escribe los resultados en la consola. Si el usuario proporciona el archivo de errores opcional, el ejemplo escribe errores en el archivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value that the associated process specified when it terminated.</summary>
        <value>Código especificado por el proceso asociado al terminar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.ExitCode%2A> para obtener el estado devuelto por el proceso del sistema al terminar. Puede utilizar el código de salida mucho como un valor de entero devuelto una `main()` procedimiento.  
  
 El <xref:System.Diagnostics.Process.ExitCode%2A> el valor de un proceso refleja la convención específica implementada por el desarrollador de aplicaciones de ese proceso. Si utiliza el valor de código de salida para tomar decisiones en el código, asegúrese de que conoce la convención de código de salida utilizada por el proceso de aplicación.  
  
 Los desarrolladores suelen indican una salida correcta por un <xref:System.Diagnostics.Process.ExitCode%2A> valor de cero y errores designados por valores distintos de cero que el método de llamada puede usar para identificar la causa de una terminación anómala del proceso. No es necesario seguir estas directrices, pero constituyen la convención.  
  
 Si intenta obtener la <xref:System.Diagnostics.Process.ExitCode%2A> antes de que el proceso ha terminado, el intento de produce una excepción. Examine el <xref:System.Diagnostics.Process.HasExited%2A> primero para verificar si el proceso asociado ha terminado.  
  
> [!NOTE]
>  Cuando se ha redirigido la salida estándar para controladores de eventos asincrónicos, es posible que el procesamiento de salida no se haya completado cuando <xref:System.Diagnostics.Process.HasExited%2A> devuelve `true`. Para asegurarse de que se ha completado el control de eventos asincrónico, llame a la <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que no toma ningún parámetro antes de comprobar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Puede usar el <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A> método para hacer que un proceso asociado termine.  
  
 Hay dos maneras de que se va a notificar cuando termine el proceso asociado: forma sincrónica y asincrónica. La notificación sincrónica se basa en una llamada la <xref:System.Diagnostics.Process.WaitForExit%2A> método para pausar el procesamiento de la aplicación hasta que el componente asociado se cierra. Notificación asincrónica se basa en el <xref:System.Diagnostics.Process.Exited> eventos. Cuando se utiliza la notificación asincrónica, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> debe establecerse en `true` para el <xref:System.Diagnostics.Process> componente para recibir una notificación de que el proceso ha terminado.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not exited.  -or-  The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a process exits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.Exited> evento indica que terminó el proceso asociado. Esta repetición significa que el proceso finalizado (se anula) o cerrado correctamente. Este evento puede ocurrir solamente si el valor de la <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad es `true`.  
  
 Hay dos maneras de que se va a notificar cuando termine el proceso asociado: forma sincrónica y asincrónica. La notificación sincrónica significa llamar a la <xref:System.Diagnostics.Process.WaitForExit%2A> método para bloquear el subproceso actual hasta que el proceso se cierra. Notificación asincrónica utiliza el <xref:System.Diagnostics.Process.Exited> evento, que permite que el subproceso que realiza la llamada continuar la ejecución mientras tanto. En el último caso, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> debe establecerse en `true` para la aplicación que realiza la llamada recibir el evento Exited.  
  
 Cuando el sistema operativo cierra un proceso, notifica a todos los demás procesos que se han registrado los controladores para el evento Exited. En este momento, el identificador del proceso que acaba de salir puede utilizarse para tener acceso a algunas propiedades como <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.HasExited%2A> que el sistema operativo mantiene hasta que libere completamente este identificador.  
  
> [!NOTE]
>  Incluso si tiene un identificador de un proceso terminado, no se puede llamar <xref:System.Diagnostics.Process.Start%2A> nuevo para volver a conectar con el mismo proceso. Al llamar a <xref:System.Diagnostics.Process.Start%2A> automáticamente libera el proceso asociado y se conecta a un proceso con el mismo archivo pero totalmente nueva <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Para obtener más información sobre el uso de la <xref:System.Diagnostics.Process.Exited> de eventos en aplicaciones de Windows Forms, vea la <xref:System.Diagnostics.Process.SynchronizingObject%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un proceso que imprime un archivo. Genera el <xref:System.Diagnostics.Process.Exited> eventos cuando termina el proceso porque la <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad se estableció cuando se creó el proceso. El <xref:System.Diagnostics.Process.Exited> controlador de eventos muestra información del proceso.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process exited.</summary>
        <value>
          <see cref="T:System.DateTime" /> que indica cuándo terminó el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no ha terminado el proceso, al intentar recuperar el <xref:System.Diagnostics.Process.ExitTime%2A> propiedad produce una excepción. Use <xref:System.Diagnostics.Process.HasExited%2A> antes de obtener la <xref:System.Diagnostics.Process.ExitTime%2A> propiedad para determinar si el proceso asociado ha finalizado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un proceso que imprime un archivo. El proceso provoca la <xref:System.Diagnostics.Process.Exited> eventos cuando cierra y el controlador de eventos se muestra el <xref:System.Diagnostics.Process.ExitTime%2A> procesan la propiedad y otra información.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un nuevo <xref:System.Diagnostics.Process> instancia y asociarla al recurso del proceso en el equipo local.  
  
 Al igual que el similar <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, y <xref:System.Diagnostics.Process.GetProcesses%2A> métodos, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> asocia un recurso existente a un nuevo <xref:System.Diagnostics.Process> componente.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera información del proceso actual, procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un nuevo <xref:System.Diagnostics.Process> componente y asociarla a un recurso de proceso en el equipo local. El recurso del proceso debe existir ya en el equipo, porque <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> no crea un recurso del sistema, sino que asocia un recurso a una aplicación generada <xref:System.Diagnostics.Process> componente. Un proceso <xref:System.Diagnostics.Process.Id%2A> puede recuperarse únicamente para un proceso que se está ejecutando actualmente en el equipo. Después de que finalice el proceso, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> produce una excepción si se le pasa un identificador caducado.  
  
 En cualquier equipo en particular, el identificador de un proceso es único. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Devuelve un proceso como máximo. Si desea obtener todos los procesos que ejecutan una aplicación concreta, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Si existen varios procesos en el equipo que ejecuta la aplicación especificada, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> devuelve una matriz que contiene todos los procesos asociados. Puede consultar cada uno de estos procesos a su vez para obtener su identificador. El identificador de proceso puede verse en la `Processes` panel del Administrador de tareas de Windows. La `PID` columna muestra el identificador de proceso que se asigna a un proceso.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera información del proceso actual, procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">The system-unique identifier of a process resource.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</summary>
        <returns>A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un nuevo <xref:System.Diagnostics.Process> componente y asociarla a un recurso de proceso en un equipo remoto en la red. El recurso del proceso debe existir ya en el equipo especificado, porque <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> no crea un recurso del sistema, sino que asocia un recurso a una aplicación generada <xref:System.Diagnostics.Process> componente. Un proceso <xref:System.Diagnostics.Process.Id%2A> puede recuperarse únicamente para un proceso que se está ejecutando actualmente en el equipo. Después de que finalice el proceso, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> produce una excepción si se le pasa un identificador caducado.  
  
 En cualquier equipo en particular, el identificador de un proceso es único. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Devuelve un proceso como máximo. Si desea obtener todos los procesos que ejecutan una aplicación concreta, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Si existen varios procesos en el equipo que ejecuta la aplicación especificada, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> devuelve una matriz que contiene todos los procesos asociados. Puede consultar cada uno de estos procesos a su vez para obtener su identificador. El identificador de proceso puede verse en la `Processes` panel del Administrador de tareas de Windows. La `PID` columna muestra el identificador de proceso que se asigna a un proceso.  
  
 Si no especifica un `machineName`, se utiliza el equipo local. Como alternativa, puede especificar el equipo local estableciendo `machineName` en el valor "." o en una cadena vacía ("").  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera información del proceso actual, procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The process specified by the <paramref name="processId" /> parameter is not running. The identifier might be expired.  -or-  The <paramref name="machineName" /> parameter syntax is invalid. The name might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The process was not started by this object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear una matriz de nuevos <xref:System.Diagnostics.Process> componentes y asociarlos a todos los recursos de proceso en el equipo local. Los recursos de proceso deben existir ya en el equipo local, porque <xref:System.Diagnostics.Process.GetProcesses%2A> no crea recursos del sistema, sino que asocia los recursos generados por la aplicación <xref:System.Diagnostics.Process> componentes. Dado que el propio sistema operativo está ejecutando procesos en segundo plano, esta matriz nunca está vacía.  
  
 Si no desea recuperar todos los procesos que se ejecutan en el equipo, puede limitar su número utilizando el <xref:System.Diagnostics.Process.GetProcessById%2A> o <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> crea un <xref:System.Diagnostics.Process> componente que está asociado al proceso identificado en el sistema mediante el identificador de proceso que se pasa al método. <xref:System.Diagnostics.Process.GetProcessesByName%2A> crea una matriz de <xref:System.Diagnostics.Process> componentes cuyos recursos de proceso asociados comparten el archivo ejecutable se pasa al método.  
  
> [!NOTE]
>  Varios servicios de Windows se pueden cargar en la misma instancia del proceso de Host de servicio (svchost.exe). GetProcesses no identifica los servicios individuales; Para ello, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera información del proceso actual, procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">The computer from which to read the list of processes.</param>
        <summary>Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear una matriz de nuevos <xref:System.Diagnostics.Process> componentes y asociarlos a todos los recursos de proceso en el equipo especificado (normalmente, es remoto). Los recursos de proceso deben existir ya en el equipo local, porque <xref:System.Diagnostics.Process.GetProcesses%2A> no crea recursos del sistema, sino que asocia los recursos generados por la aplicación <xref:System.Diagnostics.Process> componentes. Dado que el propio sistema operativo está ejecutando procesos en segundo plano, esta matriz nunca está vacía.  
  
 Si no desea recuperar todos los procesos que se ejecutan en el equipo, puede limitar su número utilizando el <xref:System.Diagnostics.Process.GetProcessById%2A> o <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> crea un <xref:System.Diagnostics.Process> componente que está asociado al proceso identificado en el sistema mediante el identificador de proceso que se pasa al método. <xref:System.Diagnostics.Process.GetProcessesByName%2A> crea una matriz de <xref:System.Diagnostics.Process> componentes cuyos recursos de proceso asociados comparten el archivo ejecutable se pasa al método.  
  
 Esta sobrecarga de la <xref:System.Diagnostics.Process.GetProcesses%2A> método generalmente se utiliza para recuperar la lista de recursos de proceso que se ejecuta en un equipo remoto conectado a la red, pero también puede especificar el equipo local pasando ".".  
  
> [!NOTE]
>  Varios servicios de Windows se pueden cargar en la misma instancia del proceso de Host de servicio (svchost.exe). GetProcesses no identifica los servicios individuales; Para ello, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera información del proceso actual, procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear una matriz de nuevos <xref:System.Diagnostics.Process> componentes y asociarlos a todos los recursos de proceso que ejecutan el mismo archivo ejecutable en el equipo local. Los recursos de proceso deben existir ya en el equipo, porque <xref:System.Diagnostics.Process.GetProcessesByName%2A> no crea recursos del sistema, sino que asocia ellos generados por la aplicación <xref:System.Diagnostics.Process> componentes. Un `processName` se puede especificar un archivo ejecutable que no se está ejecutando en el equipo local, por lo que la matriz que devuelve el método puede estar vacía.  
  
 El nombre del proceso es un nombre descriptivo para el proceso, como Outlook, que no incluye la extensión .exe o la ruta de acceso. <xref:System.Diagnostics.Process.GetProcessesByName%2A> es útil para obtener y manipular todos los procesos que están asociados con el mismo archivo ejecutable. Por ejemplo, puede pasar un nombre de archivo ejecutable como el `processName` parámetro, para cerrar todas las instancias en ejecución de ese archivo ejecutable.  
  
 Aunque un proceso <xref:System.Diagnostics.Process.Id%2A> es único para un recurso de proceso único en el sistema, varios procesos en el equipo local pueden ejecutar la aplicación especificada por el `processName` parámetro. Por lo tanto, <xref:System.Diagnostics.Process.GetProcessById%2A> devuelve un proceso a lo sumo, pero <xref:System.Diagnostics.Process.GetProcessesByName%2A> devuelve una matriz que contiene todos los procesos asociados. Si es necesario manipular el proceso con llamadas a API estándar, puede consultar cada uno de estos procesos a su vez para obtener su identificador. No se puede obtener acceso a recursos de proceso a través del nombre de proceso por sí sola, pero, una vez que haya recuperado la matriz de <xref:System.Diagnostics.Process> componentes que se han asociado con los recursos de proceso, puede iniciar, finalizar y manipular los recursos del sistema.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera información del proceso actual, procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">The friendly name of the process.</param>
        <param name="machineName">The name of a computer on the network.</param>
        <summary>Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</summary>
        <returns>An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear una matriz de nuevos <xref:System.Diagnostics.Process> componentes y asociarlos a todos los recursos de proceso que ejecutan el mismo archivo ejecutable en el equipo especificado. Los recursos de proceso deben existir ya en el equipo, porque <xref:System.Diagnostics.Process.GetProcessesByName%2A> no crea recursos del sistema, sino que asocia ellos generados por la aplicación <xref:System.Diagnostics.Process> componentes. Un `processName` se puede especificar un archivo ejecutable que no se está ejecutando en el equipo local, por lo que la matriz que devuelve el método puede estar vacía.  
  
 El nombre del proceso es un nombre descriptivo para el proceso, como Outlook, que no incluye la extensión .exe o la ruta de acceso. <xref:System.Diagnostics.Process.GetProcessesByName%2A> es útil para obtener y manipular todos los procesos que están asociados con el mismo archivo ejecutable. Por ejemplo, puede pasar un nombre de archivo ejecutable como el `processName` parámetro, para cerrar todas las instancias en ejecución de ese archivo ejecutable.  
  
 Aunque un proceso <xref:System.Diagnostics.Process.Id%2A> es único para un recurso de proceso único en el sistema, varios procesos en el equipo local pueden ejecutar la aplicación especificada por el `processName` parámetro. Por lo tanto, <xref:System.Diagnostics.Process.GetProcessById%2A> devuelve un proceso a lo sumo, pero <xref:System.Diagnostics.Process.GetProcessesByName%2A> devuelve una matriz que contiene todos los procesos asociados. Si es necesario manipular el proceso con llamadas a API estándar, puede consultar cada uno de estos procesos a su vez para obtener su identificador. No se puede obtener acceso a recursos de proceso a través del nombre de proceso por sí sola, pero, una vez que haya recuperado la matriz de <xref:System.Diagnostics.Process> componentes que se han asociado con los recursos de proceso, puede iniciar, finalizar y manipular los recursos del sistema.  
  
 Puede utilizar esta sobrecarga para obtener procesos en el equipo local, así como en un equipo remoto. Utilice "." para especificar el equipo local. Existe otra sobrecarga que usa el equipo local de forma predeterminada.  
  
 Puede tener acceso a los procesos en equipos remotos solo para ver la información, tales como estadísticas, acerca de los procesos. No se puede cerrar, terminar (mediante <xref:System.Diagnostics.Process.Kill%2A>), o iniciar procesos en equipos remotos.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera información del proceso actual, procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter syntax is invalid. It might have length zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="machineName" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The operating system platform does not support this operation on remote computers.</exception>
        <exception cref="T:System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle of the associated process.</summary>
        <value>Identificador que el sistema operativo asignó al proceso asociado cuando este se inició. El sistema usa este identificador para hacer un seguimiento de los atributos del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación puede obtener un identificador a un proceso que puede usarse como un parámetro para muchas funciones de control e información del proceso. Puede utilizar este identificador para inicializar un <xref:System.Threading.WaitHandle> o llamar a métodos nativos con la plataforma de invocación.  
  
 Este identificador de proceso es privado para la aplicación, en otras palabras, no se puede compartir los identificadores de proceso. Un proceso también tiene un proceso <xref:System.Diagnostics.Process.Id%2A> que, a diferencia del <xref:System.Diagnostics.Process.Handle%2A>, es único y, por lo tanto, válida en todo el sistema.  
  
 Sólo los procesos iniciados mediante una llamada a <xref:System.Diagnostics.Process.Start%2A> establecer el <xref:System.Diagnostics.Process.Handle%2A> propiedad de los correspondientes <xref:System.Diagnostics.Process> instancias.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process has not been started or has exited. The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of handles opened by the process.</summary>
        <value>Número de identificadores de sistema operativo abiertos por el proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los identificadores proporcionan una manera para que un proceso hacer referencia a objetos. Un proceso puede obtener identificadores de archivos, recursos, colas de mensajes y muchos otros objetos del sistema operativo. El sistema operativo reclama la memoria asociada al proceso solo cuando el recuento de identificadores es cero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the associated process has been terminated.</summary>
        <value>Es <see langword="true" /> si el proceso del sistema operativo al que hace referencia el componente <see cref="T:System.Diagnostics.Process" /> terminó; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de `true` para <xref:System.Diagnostics.Process.HasExited%2A> indica que el proceso asociado ha terminado, normalmente o de forma anómala. Puede solicitar o forzar el proceso asociado termine mediante una llamada a <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Si un identificador está abierto para el proceso, el sistema operativo libera la memoria de proceso cuando el proceso ha terminado, pero conserva la información administrativa sobre el proceso, como el identificador, el código de salida y la hora de salida. Para obtener esta información, puede usar el <xref:System.Diagnostics.Process.ExitCode%2A> y <xref:System.Diagnostics.Process.ExitTime%2A> propiedades. Estas propiedades se rellenan automáticamente para los procesos iniciados por este componente. La información administrativa se libera cuando todos los <xref:System.Diagnostics.Process> componentes que están asociados con el proceso del sistema se destruyen y manipuladores nada más para el proceso terminado.  
  
 Un proceso puede terminar independientemente del código. Si se inició el proceso con este componente, el sistema actualiza el valor de <xref:System.Diagnostics.Process.HasExited%2A> automáticamente, incluso si el proceso asociado se cierra de forma independiente.  
  
> [!NOTE]
>  Cuando se ha redirigido la salida estándar para controladores de eventos asincrónicos, es posible que el procesamiento de salida no se habrá completado cuando esta propiedad devuelve `true`. Para asegurarse de que se ha completado el control de eventos asincrónico, llame a la <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que no toma ningún parámetro antes de comprobar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, recupera el uso de memoria física del proceso asociado cada 2 segundos durante un máximo de 10 segundos. En el ejemplo se detecta si el proceso se cierra antes de que hayan transcurrido 10 segundos. En el ejemplo se cierra el proceso si se está ejecutando todavía después de 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with the object.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">The exit code for the process could not be retrieved.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the unique identifier for the associated process.</summary>
        <value>Identificador único generado por el sistema del proceso al que hace referencia esta instancia de <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El proceso <xref:System.Diagnostics.Process.Id%2A> no es válido si no se está ejecutando el proceso asociado. Por lo tanto, debe asegurarse de que el proceso se está ejecutando antes de intentar recuperar el <xref:System.Diagnostics.Process.Id%2A> propiedad. Hasta que finaliza el proceso, el identificador del proceso identifica de forma única el proceso en todo el sistema.  
  
 Puede conectar un proceso que se ejecuta en un equipo local o remoto a una nueva <xref:System.Diagnostics.Process> instancia pasando el identificador de proceso para el <xref:System.Diagnostics.Process.GetProcessById%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> es un `static` método que crea un nuevo componente y establece la <xref:System.Diagnostics.Process.Id%2A> propiedad para el nuevo <xref:System.Diagnostics.Process> instancia automáticamente.  
  
 Identificadores de proceso pueden ser reutilizados por el sistema. La <xref:System.Diagnostics.Process.Id%2A> valor de la propiedad es único solo mientras se está ejecutando el proceso asociado. Después de que el proceso ha finalizado, el sistema puede reutilizar la <xref:System.Diagnostics.Process.Id%2A> valor de propiedad para un proceso no relacionado.  
  
 Dado que el identificador es único en el sistema, puede pasar a otros subprocesos como alternativa a pasar un <xref:System.Diagnostics.Process> instancia. Esta acción puede ahorrar recursos del sistema, aún se garantiza que el proceso está correctamente identificado.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo obtener el <xref:System.Diagnostics.Process.Id%2A> para todas las instancias de una aplicación en ejecución. El código crea una nueva instancia del Bloc de notas, enumera todas las instancias del Bloc de notas y, a continuación, permite al usuario que escriba el <xref:System.Diagnostics.Process.Id%2A> número para quitar una instancia concreta.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Immediately stops the associated process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> obliga a que termine el proceso, mientras que <xref:System.Diagnostics.Process.CloseMainWindow%2A> sólo solicita la terminación. Cuando se está ejecutando un proceso con una interfaz gráfica, el bucle de mensajes está en un estado de espera. El bucle de mensajes se ejecuta cada vez que se envía un mensaje de Windows al proceso por el sistema operativo. Al llamar a <xref:System.Diagnostics.Process.CloseMainWindow%2A> envía una solicitud para cerrar la ventana principal, que, en una aplicación con formato correcto, cierra las ventanas secundarias y revoca la ejecución de todos los bucles de mensajes para la aplicación. La solicitud para salir del proceso mediante una llamada a <xref:System.Diagnostics.Process.CloseMainWindow%2A> no fuerza la aplicación se cierre. La aplicación puede pedir confirmación del usuario antes de salir, o puede rechazar salir. Para forzar la aplicación para salir, use la <xref:System.Diagnostics.Process.Kill%2A> método. El comportamiento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> es idéntico de un usuario cierra la ventana principal de una aplicación mediante el menú de sistema. Por lo tanto, la solicitud para salir del proceso, el cierre de la ventana principal no obliga a la aplicación a salir inmediatamente.  
  
> [!NOTE]
>  El <xref:System.Diagnostics.Process.Kill%2A> método se ejecuta de forma asincrónica. Después de llamar a la <xref:System.Diagnostics.Process.Kill%2A> método, llame a la <xref:System.Diagnostics.Process.WaitForExit%2A> método para esperar el proceso para salir o compruebe el <xref:System.Diagnostics.Process.HasExited%2A> propiedad para determinar si el proceso ha terminado.  
  
 Datos modificados por el proceso o los recursos asignados al proceso pueden perderse si se llama a <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> hace que una terminación anómala del proceso y debe usarse solo cuando sea necesario. <xref:System.Diagnostics.Process.CloseMainWindow%2A> habilita una finalización ordenada del proceso y cierra todas las ventanas, por lo que es preferible para las aplicaciones con una interfaz. Si <xref:System.Diagnostics.Process.CloseMainWindow%2A> se produce un error, puede usar <xref:System.Diagnostics.Process.Kill%2A> para finalizar el proceso. <xref:System.Diagnostics.Process.Kill%2A> es la única forma de terminar los procesos que no tienen interfaces gráficas.  
  
 Puede llamar a <xref:System.Diagnostics.Process.Kill%2A> y <xref:System.Diagnostics.Process.CloseMainWindow%2A> únicamente para los procesos que se ejecutan en el equipo local. No puede hacer procesos en equipos remotos para salir. Solo se puede ver información de los procesos que se ejecutan en equipos remotos.  
  
> [!NOTE]
>  Si la llamada a la <xref:System.Diagnostics.Process.Kill%2A> método se realiza mientras se está terminando el proceso actualmente, un <xref:System.ComponentModel.Win32Exception> se produce para acceso denegado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The associated process could not be terminated.  -or-  The process is terminating.  -or-  The associated process is a Win16 executable.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer. The method is available only for processes running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has already exited.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos procesos del sistema operativo se ejecuten en un modo especial. Al intentar leer las propiedades de o adjuntar a estos procesos no es posible a menos que se llamó a <xref:System.Diagnostics.Process.EnterDebugMode%2A> en el componente. Llamar a <xref:System.Diagnostics.Process.LeaveDebugMode%2A> cuando ya no necesita acceso a estos procesos que se ejecutan en modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the computer the associated process is running on.</summary>
        <value>Nombre del equipo en el que se está ejecutando el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede ver datos estadísticos y la información del proceso para procesos que se ejecutan en equipos remotos, pero no puede llamar a <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, o <xref:System.Diagnostics.Process.Kill%2A> en equipos remotos.  
  
> [!NOTE]
>  Cuando el proceso asociado se ejecuta en el equipo local, esta propiedad devuelve un punto (".") para el nombre del equipo. Debe utilizar el <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad que se va a obtener el nombre de equipo correcto.  
  
   
  
## Examples  
 Para utilizar el ejemplo siguiente, primero debe iniciar al menos una instancia del Bloc de notas en un equipo remoto. En el ejemplo se solicita el nombre del equipo remoto en el que se ejecuta el Bloc de notas y, a continuación, muestra los respectivos <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, y <xref:System.Diagnostics.Process.MachineName%2A> propiedades para cada instancia.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the main module for the associated process.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessModule" /> utilizado para iniciar el proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un módulo de proceso representa un archivo.dll o .exe que se carga en un proceso determinado. El <xref:System.Diagnostics.Process.MainModule%2A> propiedad le permite ver información acerca del archivo ejecutable utilizado para iniciar el proceso, incluidos el nombre del módulo, el nombre de archivo y los detalles de memoria del módulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">A 32-bit process is trying to access the modules of a 64-bit process.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the window handle of the main window of the associated process.</summary>
        <value>Identificador de ventana generado por el sistema para la ventana principal del proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ventana principal es la ventana abierta por el proceso que actualmente tiene el foco (el <xref:System.Windows.Forms.Form.TopLevel%2A> formulario). Debe utilizar el <xref:System.Diagnostics.Process.Refresh%2A> método para actualizar la <xref:System.Diagnostics.Process> objeto que se va a obtener el identificador de ventana principal actual si ha cambiado. En general, porque el identificador de ventana se almacena en caché, utilice <xref:System.Diagnostics.Process.Refresh%2A> con antelación para garantizar que se recuperará el identificador actual.  
  
 Puede obtener el <xref:System.Diagnostics.Process.MainWindowHandle%2A> propiedad únicamente para los procesos que se ejecutan en el equipo local. El <xref:System.Diagnostics.Process.MainWindowHandle%2A> propiedad es un valor que identifica de forma inequívoca la ventana que está asociada con el proceso.  
  
 Un proceso tiene una ventana principal asociada sólo si el proceso tiene una interfaz gráfica. Si el proceso asociado no tiene una ventana principal, el <xref:System.Diagnostics.Process.MainWindowHandle%2A> valor es cero. El valor también es cero para los procesos que se han ocultado, es decir, procesos que no son visibles en la barra de tareas. Esto puede ser el caso para los procesos que aparecen como iconos en el área de notificación, en el extremo derecho de la barra de tareas.  
  
 Si acaba de iniciar un proceso y desea utilizar su identificador de ventana principal, considere la posibilidad de usar el <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que el proceso termine de iniciarse, asegurándose de que se ha creado el identificador de ventana principal. De lo contrario, se producirá una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the caption of the main window of the process.</summary>
        <value>Título de la ventana principal del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un proceso tiene una ventana principal asociada sólo si el proceso tiene una interfaz gráfica. Si el proceso asociado no tiene una ventana principal (por lo que <xref:System.Diagnostics.Process.MainWindowHandle%2A> es cero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> es una cadena vacía (""). Si acaba de iniciar un proceso y desea utilizar el título de la ventana principal, considere la posibilidad de usar el <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que el proceso termine de iniciarse, asegurándose de que se ha creado el identificador de ventana principal. De lo contrario, el sistema produce una excepción.  
  
> [!NOTE]
>  La ventana principal es la ventana que tiene actualmente el foco; Tenga en cuenta que esto puede no ser la ventana principal del proceso. Debe utilizar el <xref:System.Diagnostics.Process.Refresh%2A> método para actualizar la <xref:System.Diagnostics.Process> objeto que se va a obtener el identificador de ventana principal actual si ha cambiado.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas y recupera el título de la ventana principal del proceso.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowable working set size, in bytes, for the associated process.</summary>
        <value>Tamaño máximo permitido para el espacio de trabajo del proceso en la memoria expresado en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El espacio de trabajo de un proceso es el conjunto de páginas de memoria actualmente visibles para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para que utilice sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos comprenden las páginas que contienen todas las instrucciones que se ejecuta la aplicación, incluidas las páginas de los archivos .dll y los archivos system.dll. A medida que aumenta el tamaño del conjunto de trabajo, aumenta la demanda de memoria.  
  
 Un proceso dispone de los tamaños de espacio de trabajo mínimo y máximo. Cada vez que se crea un recurso de proceso, el sistema reserva una cantidad de memoria igual que el mínimo tamaño del conjunto para el proceso de trabajo. El Administrador de memoria virtual intenta mantener al menos la cantidad mínima de memoria residente cuando el proceso está activo, pero nunca mantiene supera el tamaño máximo.  
  
 El sistema establece el conjunto de tamaños de trabajo predeterminado. Puede modificar estos tamaños utilizando la <xref:System.Diagnostics.Process.MaxWorkingSet%2A> y <xref:System.Diagnostics.Process.MinWorkingSet%2A> los miembros. Sin embargo, estos valores de configuración garantiza que la memoria será reservada o residente.  
  
> [!NOTE]
>  Al aumentar el tamaño del espacio de trabajo de un proceso, tomar la memoria física fuera el resto del sistema. Asegurarse de que no requiere un tamaño de conjunto de trabajo mínimo o máximo que sea demasiado grande, ya que puede degradar el rendimiento del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The maximum working set size is invalid. It must be greater than or equal to the minimum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the minimum allowable working set size, in bytes, for the associated process.</summary>
        <value>Tamaño mínimo necesario para el espacio de trabajo del proceso en la memoria expresado en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El espacio de trabajo de un proceso es el conjunto de páginas de memoria actualmente visibles para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para que utilice sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos comprenden las páginas que contienen todas las instrucciones que se ejecuta la aplicación, incluidas las páginas de los archivos .dll y los archivos system.dll. A medida que aumenta el tamaño del conjunto de trabajo, aumenta la demanda de memoria.  
  
 Un proceso dispone de los tamaños de espacio de trabajo mínimo y máximo. Cada vez que se crea un recurso de proceso, el sistema reserva una cantidad de memoria igual que el mínimo tamaño del conjunto para el proceso de trabajo. El Administrador de memoria virtual intenta mantener al menos la cantidad mínima de memoria residente cuando el proceso está activo, pero nunca mantiene supera el tamaño máximo.  
  
 El sistema establece el conjunto de tamaños de trabajo predeterminado. Puede modificar estos tamaños utilizando la <xref:System.Diagnostics.Process.MaxWorkingSet%2A> y <xref:System.Diagnostics.Process.MinWorkingSet%2A> los miembros. Sin embargo, estos valores de configuración garantiza que la memoria será reservada o residente.  
  
> [!NOTE]
>  Al aumentar el tamaño del espacio de trabajo de un proceso, tomar la memoria física fuera el resto del sistema. Asegurarse de que no requiere un tamaño de conjunto de trabajo mínimo o máximo que sea demasiado grande, ya que puede degradar el rendimiento del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The minimum working set size is invalid. It must be less than or equal to the maximum working set size.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Working set information cannot be retrieved from the associated process resource.  -or-  The process identifier or process handle is zero because the process has not been started.</exception>
        <exception cref="T:System.NotSupportedException">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.  -or-  The process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the modules that have been loaded by the associated process.</summary>
        <value>Matriz de tipo <see cref="T:System.Diagnostics.ProcessModule" /> que representa los módulos cargados por el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un módulo de proceso representa un archivo.dll o .exe que se carga en un proceso determinado. Un <xref:System.Diagnostics.ProcessModule> instancia le permite ver información sobre un módulo, incluidos el nombre del módulo, el nombre de archivo y los detalles de memoria del módulo.  
  
 Un proceso puede cargar varios módulos en memoria. Por ejemplo, los archivos .exe que cargan archivos .dll adicionales tienen varios módulos.  
  
 Después de iniciar el proceso, esta colección está vacía hasta que el sistema ha cargado el proceso. Si el proceso tiene una ventana principal, puede llamar a <xref:System.Diagnostics.Process.WaitForInputIdle%2A> antes de recuperar esta propiedad para asegurarse de que la colección está vacía cuando se obtiene la lista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process. These processes do not have modules.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>Cantidad de memoria, en bytes, que el sistema asignó para el proceso asociado que no se puede escribir en el archivo de paginación de la memoria virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</summary>
        <value>Tamaño de la memoria del sistema, expresado en bytes, que se asignó para el proceso asociado que no puede escribirse en el archivo de paginación de la memoria virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria no paginada del sistema utilizada por el proceso, en bytes. Memoria del sistema es la memoria física usada por el sistema operativo y se divide en bloques paginados y no paginados. Las asignaciones de memoria no paginada permanecen en memoria del sistema y no se paginan en el archivo de paginación de memoria virtual.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes del bloque no paginado** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> es el método de API que genera el <xref:System.Diagnostics.Process.Exited> eventos. Al llamar a <xref:System.Diagnostics.Process.OnExited%2A> hace que el <xref:System.Diagnostics.Process.Exited> que se produzca evento y es la única forma de provocar el evento con el <xref:System.Diagnostics.Process> componente. <xref:System.Diagnostics.Process.OnExited%2A> se utiliza principalmente al derivar clases desde el componente.  
  
 Como alternativa a <xref:System.Diagnostics.Process.OnExited%2A>, puede escribir su propio controlador de eventos. Cree su propio delegado de controlador de eventos y su propio método de control de eventos.  
  
> [!NOTE]
>  Si está utilizando el entorno de Visual Studio, un delegado de controlador de eventos (AddOnExited) y un método de control de eventos (Process1_Exited) se crean automáticamente cuando se arrastra un <xref:System.Diagnostics.Process> componente a un formulario y haga doble clic en el icono. El código crea para ejecutar cuando el <xref:System.Diagnostics.Process.Exited> caso se introduce en el procedimiento Process1_Exited. No es necesario crear la <xref:System.Diagnostics.Process.OnExited%2A> miembro, porque se implementa automáticamente.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener información general, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Diagnostics.Process.OnExited%2A> método en una clase derivada.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.OutputDataReceived> evento indica que el asociado <xref:System.Diagnostics.Process> ha escrito una línea, terminar con un carácter de nueva línea, para su redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia.  
  
 El evento está habilitado durante las operaciones de lectura asincrónicas en <xref:System.Diagnostics.Process.StandardOutput%2A>. Para iniciar las operaciones de lectura asincrónicas, debe redirigir el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia de un <xref:System.Diagnostics.Process>, agregue el controlador de eventos para el <xref:System.Diagnostics.Process.OutputDataReceived> eventos y llamadas <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Por lo tanto, la <xref:System.Diagnostics.Process.OutputDataReceived> señales de eventos cada vez que el proceso escribe una línea en el redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir por secuencias, hasta que el proceso se cierra o se llama <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  La aplicación que se está procesando la salida asincrónica debe llamar a la <xref:System.Diagnostics.Process.WaitForExit%2A> método para asegurarse de que se ha vaciado el búfer de salida.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo realizar operaciones de lectura asincrónica en la redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> flujo de la `ipconfig` comando.  
  
 En el ejemplo se crea un delegado de eventos para el `OutputHandler` controlador de eventos y lo asocia a la <xref:System.Diagnostics.Process.OutputDataReceived> eventos. El controlador de eventos recibe líneas de texto de la redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia, se da formato al texto y se guarda en una cadena de salida que se muestra más adelante en la ventana de la consola del ejemplo.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>Cantidad de memoria, en bytes, asignada por el proceso asociado que se puede escribir en el archivo de paginación de la memoria virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of paged memory, in bytes, allocated for the associated process.</summary>
        <value>Tamaño de la memoria, expresado en bytes, que se asignó en el archivo de paginación de la memoria virtual para el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria en el archivo de paginación de memoria virtual utilizado por el proceso, en bytes. El sistema operativo utiliza el archivo de paginación de memoria virtual junto con una memoria física para administrar el espacio de direcciones virtuales para cada proceso. Cuando la memoria paginable no está en uso, se pueden transferir al archivo de paginación de memoria virtual en el disco. Para obtener el tamaño de memoria utilizada por el sistema operativo para el proceso, utilice el <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> propiedad.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes del archivo de página** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas y, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>Cantidad de memoria, en bytes, que el sistema asignó para el proceso asociado que se puede escribir en el archivo de paginación de la memoria virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</summary>
        <value>Tamaño de la memoria del sistema, expresado en bytes, que se asignó para el proceso asociado que puede escribirse en el archivo de paginación de la memoria virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de la memoria paginable del sistema utilizada por el proceso, en bytes. Memoria del sistema es la memoria física usada por el sistema operativo y se divide en bloques paginados y no paginados. Cuando la memoria paginable no está en uso, se pueden transferir al archivo de paginación de memoria virtual en el disco. Para obtener el tamaño de la memoria utilizada por el proceso de la aplicación, use la <xref:System.Diagnostics.Process.PagedMemorySize64%2A> propiedad.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes del bloque paginado** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>Cantidad máxima de memoria, en bytes, asignada por el proceso asociado que se podría escribir en el archivo de paginación de la memoria virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</summary>
        <value>Tamaño de memoria máximo, expresado en bytes, que se asignó en el archivo de paginación de la memoria virtual para el proceso asociado desde su inicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño máximo de memoria en el archivo de paginación de memoria virtual utilizado por el proceso desde su inicio, en bytes. El sistema operativo utiliza el archivo de paginación de memoria virtual junto con una memoria física para administrar el espacio de direcciones virtuales para cada proceso. Cuando la memoria paginable no está en uso, se pueden transferir al archivo de paginación de memoria virtual en el disco.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **uso máximo de Bytes del archivo de página** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>Cantidad máxima de memoria virtual, en bytes, solicitada por el proceso asociado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</summary>
        <value>Tamaño máximo de memoria virtual, expresado en bytes, que se asignó para el proceso asociado desde su inicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño máximo de memoria virtual usada por el proceso desde su inicio, en bytes. El sistema operativo asigna espacio de direcciones virtuales para cada proceso a las páginas cargados en la memoria física, o a páginas almacenadas en el archivo de paginación de memoria virtual en el disco.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **uso máximo de Bytes virtuales** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the peak working set size for the associated process, in bytes.</summary>
        <value>Cantidad máxima de memoria física que el proceso asociado precisa de una sola vez, expresada en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El espacio de trabajo de un proceso es el conjunto de páginas de memoria actualmente visibles para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para que utilice sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos comprenden las páginas que contienen todas las instrucciones que se ejecuta el proceso, incluidos los módulos de proceso y las bibliotecas del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum amount of physical memory, in bytes, used by the associated process.</summary>
        <value>Tamaño máximo de memoria física, expresado en bytes, que se asignó para el proceso asociado desde su inicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño máximo de utilizado por el proceso desde su inicio, en bytes de memoria de conjunto de trabajo. El espacio de trabajo de un proceso es el conjunto de páginas de memoria actualmente visibles para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para que utilice sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos comprenden las páginas que contienen todas las instrucciones que se ejecuta el proceso, incluidas las instrucciones de los módulos de proceso y las bibliotecas del sistema.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **máximo del espacio de trabajo** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</summary>
        <value>Es <see langword="true" /> si la prioridad del proceso debe aumentarse dinámicamente cuando este salga del estado de espera; de lo contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se ejecuta un subproceso en un proceso para el que la clase de prioridad tiene uno de los valores de enumeración de prioridad dinámica (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), el sistema aumenta temporalmente la prioridad del subproceso cuando éste sale del estado de espera. Esta acción evita que otros procesos interrumpir el procesamiento del subproceso actual. El <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> configuración afecta a todos los subprocesos existentes y a los subprocesos creados posteriormente por el proceso. Para restaurar el comportamiento normal, establezca el <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propiedad `false`.  
  
> [!NOTE]
>  Aumento excesivo de la prioridad puede reducir los recursos para funciones de red, causando problemas con otras tareas del sistema operativo y esenciales del sistema operativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Priority boost information could not be retrieved from the associated process resource.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the overall priority category for the associated process.</summary>
        <value>Categoría de prioridad del proceso asociado a partir de la cual se calcula el <see cref="P:System.Diagnostics.Process.BasePriority" /> del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una clase de prioridad del proceso abarca una variedad de niveles de prioridad de subproceso. Número de subprocesos con prioridades diferentes que se ejecutan en el proceso que se ejecuta con relación a la clase de prioridad del proceso. Win32 usa cuatro clases de prioridad con siete niveles de prioridad base por clase. Estas clases de prioridad de proceso se capturan en el <xref:System.Diagnostics.ProcessPriorityClass> enumeración, que le permite establece la prioridad del proceso <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. En función del tiempo transcurrido u otro tipo de estímulo, el nivel de prioridad base se puede cambiar el sistema operativo cuando un proceso necesita ponerse delante de otros para tener acceso al procesador. Además, puede establecer el <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> para aumentar temporalmente el nivel de prioridad de subprocesos que se han realizado fuera del estado de espera. La prioridad se restablece cuando el proceso vuelve al estado de espera.  
  
 El <xref:System.Diagnostics.Process.BasePriority%2A> propiedad le permite ver la prioridad inicial que se asigna a un proceso. Sin embargo, porque es de solo lectura, no se puede usar el <xref:System.Diagnostics.Process.BasePriority%2A> propiedad para establecer la prioridad de un proceso. Para cambiar la prioridad, use la <xref:System.Diagnostics.Process.PriorityClass%2A> propiedad, que obtiene o establece la categoría de prioridad general del proceso.  
  
 La clase de prioridad no se pueden ver mediante el Monitor de sistema. En la tabla siguiente muestra la relación entre el <xref:System.Diagnostics.Process.BasePriority%2A> y <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Process priority information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</exception>
        <exception cref="T:System.PlatformNotSupportedException">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me). These platforms do not support those values for the priority class.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>Número de bytes asignados por el proceso asociado que no pueden compartirse con otros procesos.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of private memory, in bytes, allocated for the associated process.</summary>
        <value>Tamaño de la memoria, expresado en bytes, que se asignó para el proceso asociado que no puede compartirse con otros procesos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria utilizada por el proceso, en bytes, que no puede compartirse con otros procesos.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes privados** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the privileged processor time for this process.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> que indica la cantidad de tiempo que el proceso ha invertido en la ejecución de código dentro del núcleo del sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the process.</summary>
        <value>Nombre que el sistema usa para identificar el proceso ante el usuario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.ProcessName%2A> propiedad contiene un nombre de archivo ejecutable, como Outlook, que no incluye la extensión .exe o la ruta de acceso. Es útil para obtener y manipular todos los procesos que están asociados con el mismo archivo ejecutable.  
  
> [!NOTE]
>  En [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] sistemas operativos, el <xref:System.Diagnostics.Process.ProcessName%2A> propiedad puede aparecer truncada y 15 caracteres si no se puede obtener la información del módulo de proceso.  
  
 Puede llamar a <xref:System.Diagnostics.Process.GetProcessesByName%2A>, pasándole un nombre de archivo ejecutable, para recuperar una matriz que contiene las instancias en ejecución en el equipo especificado. Puede utilizar esta matriz, por ejemplo, para cerrar todas las instancias en ejecución del archivo ejecutable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">The process is not on this computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the processors on which the threads in this process can be scheduled to run.</summary>
        <value>Máscara de bits que representa los procesadores en los que pueden ejecutarse los subprocesos del proceso asociado. El valor predeterminado depende del número de procesadores del equipo. El valor predeterminado es 2 <sup>n</sup> -1, donde n es el número de procesadores.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En Windows 2000 y versiones posteriores, un subproceso de un proceso puede migrar de un procesador a otro, con cada migración vuelve a cargar la caché del procesador. Con cargas elevadas, especificar qué procesador debe ejecutar un subproceso concreto puede mejorar el rendimiento al reducir el número de veces que se vuelve a cargar la caché del procesador. La asociación entre un procesador y un subproceso se llama la afinidad del procesador.  
  
 Cada procesador se representa como un bit. Bit 0 es el procesador uno, el bit 1 es el procesador dos y así sucesivamente. Si un bit se establece en el valor 1, se selecciona el procesador correspondiente para la asignación de subprocesos. Al establecer el <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor a cero, el sistema operativo de la programación de conjunto de algoritmos la afinidad del subproceso. Cuando el <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor se establece en cualquier valor distinto de cero, el valor se interpreta como una máscara de bits que especifica los procesadores que se pueden seleccionar.  
  
 En la tabla siguiente se muestra una selección de <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valores para un sistema con ocho procesadores.  
  
|Máscara de bits|Valor binario|Procesadores válidos|  
|-------------|------------------|-------------------------|  
|0 x 0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 y 2|  
|0x0007|00000000 00000111|1, 2 y 3|  
|0x0009|00000000 00001001|1 y 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 y 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.  -or-  The process identifier or process handle is zero. (The process has not been started.)</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.  -or-  The process has exited.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Discards any information about the associated process that has been cached inside the process component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de <xref:System.Diagnostics.Process.Refresh%2A> se llama, la primera solicitud para obtener información acerca de cada propiedad hace que el componente del proceso obtener un nuevo valor del proceso asociado.  
  
 Cuando un <xref:System.Diagnostics.Process> componente está asociado a un recurso de proceso, los valores de propiedad de la <xref:System.Diagnostics.Process> inmediatamente se rellenan según el estado del proceso asociado. Si posteriormente cambia la información acerca del proceso asociado, dichos cambios no se reflejan en el <xref:System.Diagnostics.Process> del componente almacenado en memoria caché de valores. El <xref:System.Diagnostics.Process> componente es una instantánea del recurso de proceso en el momento en que están asociados. Para ver los valores actuales para el proceso asociado, llame a la <xref:System.Diagnostics.Process.Refresh%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, recupera el uso de memoria física del proceso asociado cada 2 segundos durante un máximo de 10 segundos. En el ejemplo se detecta si el proceso se cierra antes de que hayan transcurrido 10 segundos. En el ejemplo se cierra el proceso si se está ejecutando todavía después de 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the user interface of the process is responding.</summary>
        <value>Es <see langword="true" /> si la interfaz de usuario del proceso asociado está respondiendo al sistema; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un proceso tiene una interfaz de usuario, la <xref:System.Diagnostics.Process.Responding%2A> propiedad pone en contacto con la interfaz de usuario para determinar si el proceso está respondiendo a los proporcionados por el usuario. Si la interfaz no responde inmediatamente, la <xref:System.Diagnostics.Process.Responding%2A> propiedad devuelve `false`. Utilice esta propiedad para determinar si la interfaz del proceso asociado ha dejado de responder.  
  
 Si el proceso no tiene un <xref:System.Diagnostics.Process.MainWindowHandle%2A>, esta propiedad devuelve `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the native handle to this process.</summary>
        <value>Identificador nativo de este proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El identificador sólo está disponible si el componente que realiza la llamada inició el proceso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Terminal Services session identifier for the associated process.</summary>
        <value>Identificador de la sesión de Terminal Services para el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.SessionId%2A> propiedad identifica la sesión en el que se está ejecutando la aplicación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">There is no session associated with this process.</exception>
        <exception cref="T:System.InvalidOperationException">There is no process associated with this session identifier.  -or-  The associated process is not on this machine.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the error output of the application.</summary>
        <value>
          <see cref="T:System.IO.StreamReader" /> que puede utilizarse para leer la secuencia de error estándar de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un <xref:System.Diagnostics.Process> escribe texto en su secuencia de error estándar, que el texto se muestra normalmente en la consola. Redirigiendo el <xref:System.Diagnostics.Process.StandardError%2A> secuencia, puede manipular o suprimir la salida de error de un proceso. Por ejemplo, puede filtrar el texto, formato de manera diferente o escribir la salida en la consola y un archivo de registro designado.  
  
> [!NOTE]
>  Usar <xref:System.Diagnostics.Process.StandardError%2A>, debe establecer <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, y debe establecer <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> a `true`. En caso contrario, se leía el <xref:System.Diagnostics.Process.StandardError%2A> flujo produce una excepción.  
  
 El redirigida <xref:System.Diagnostics.Process.StandardError%2A> secuencia puede leerse de forma sincrónica o asincrónica. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, y <xref:System.IO.StreamReader.ReadToEnd%2A> realizar operaciones de lectura sincrónica en el flujo de salida de error del proceso. Estos sincrónico leen las operaciones no se completan hasta que el asociado <xref:System.Diagnostics.Process> escribe en su <xref:System.Diagnostics.Process.StandardError%2A> transmitir por secuencias o cierra la secuencia.  
  
 En cambio, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> las operaciones de lectura asincrónica se inicia en el <xref:System.Diagnostics.Process.StandardError%2A> secuencia. Este método permite que un controlador de eventos designado para la salida de la secuencia y vuelve inmediatamente al llamador, que puede realizar otro trabajo mientras los resultados de la secuencia se dirigen al controlador de eventos.  
  
 Sincrónica lee operaciones introducen una dependencia entre el llamador que lee de la <xref:System.Diagnostics.Process.StandardError%2A> escribir en esa secuencia de proceso de flujo y el elemento secundario. Estas dependencias pueden dar lugar a que las condiciones de interbloqueo. Cuando el llamador lee de la secuencia redirigida de un proceso secundario, que depende el elemento secundario. El llamador espera en la operación de lectura hasta que el elemento secundario se escribe en la secuencia o cierra la secuencia. Cuando el proceso secundario escribe suficientes datos para rellenar su secuencia redirigida, depende del elemento primario. El proceso secundario espera la siguiente operación de escritura hasta que el elemento primario lee la secuencia completa o cierra la secuencia. El interbloqueo se produce cuando el llamador y el proceso secundario se esperan entre sí para completar una operación y ninguno puede continuar. Puede evitar los interbloqueos mediante la evaluación de las dependencias entre el llamador y el proceso secundario.  
  
 El siguiente código de C#, por ejemplo, muestra cómo leer una secuencia redirigida y espere a que termine el proceso secundario.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 El ejemplo de código, evita una condición de interbloqueo mediante una llamada a `p.StandardError.ReadToEnd` antes de `p.WaitForExit`. Puede producirse una situación de interbloqueo si el elemento primario procesa llamadas `p.WaitForExit` antes de `p.StandardError.ReadToEnd` y el proceso secundario escribe texto suficiente para rellenar la secuencia redirigida. El proceso primario espera indefinidamente por el proceso secundario salir. El proceso secundario espera indefinidamente para que el elemento primario leer desde el completo <xref:System.Diagnostics.Process.StandardError%2A> secuencia.  
  
 Hay un problema similar cuando se lee todo el texto de la salida estándar y los flujos de error estándar. El siguiente código de C#, por ejemplo, realiza una operación de lectura en ambas secuencias.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 El ejemplo de código, evita la situación de interbloqueo mediante la realización asincrónica de las operaciones de lectura en el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia. Una condición de interbloqueo se produce si el elemento primario procesa llamadas `p.StandardOutput.ReadToEnd` seguido de `p.StandardError.ReadToEnd` y el proceso secundario escribe texto suficiente para rellenar su secuencia de error. El proceso primario espera indefinidamente por el proceso secundario cerrar su <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia. El proceso secundario espera indefinidamente para que el elemento primario leer desde el completo <xref:System.Diagnostics.Process.StandardError%2A> secuencia.  
  
 Puede usar operaciones de lectura asincrónica para evitar estas dependencias y la posibilidad de un interbloqueo. Como alternativa, puede evitar la situación de interbloqueo creando dos subprocesos y leer los resultados de cada secuencia en un subproceso independiente.  
  
> [!NOTE]
>  No se pueden mezclar las operaciones de lectura sincrónicas o asincrónicas en una secuencia redirigida. Una vez la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas las lectura más operaciones en esa secuencia deben ser del mismo modo. Por ejemplo, no siga <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> con una llamada a <xref:System.IO.StreamReader.ReadLine%2A> en el <xref:System.Diagnostics.Process.StandardError%2A> flujo, o viceversa. Sin embargo, puede leer dos secuencias diferentes en modos diferentes. Por ejemplo, puede llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> y, a continuación, llame a <xref:System.IO.StreamReader.ReadLine%2A> para el <xref:System.Diagnostics.Process.StandardError%2A> secuencia.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `net use` comando, junto con un usuario ha suministrado o argumento para asignar un recurso de red. A continuación, lee la secuencia de error estándar del comando net y lo escribe en la consola.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to write the input of the application.</summary>
        <value>
          <see cref="T:System.IO.StreamWriter" /> que puede utilizarse para escribir la secuencia de entrada estándar de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Diagnostics.Process> puede leer texto de entrada de su flujo de entrada estándar, normalmente el teclado. Redirigiendo el <xref:System.Diagnostics.Process.StandardInput%2A> secuencia, puede especificar mediante programación la entrada. Por ejemplo, en lugar de utilizar el teclado, puede proporcionar texto con el contenido de un archivo designado o resultado de otra aplicación.  
  
> [!NOTE]
>  Usar <xref:System.Diagnostics.Process.StandardInput%2A>, debe establecer <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, y debe establecer <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> a `true`. De lo contrario, escribir en el <xref:System.Diagnostics.Process.StandardInput%2A> flujo produce una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo redirigir el <xref:System.Diagnostics.Process.StandardInput%2A> flujo de un proceso. En el ejemplo se inicia el `sort` con entrada redirigida. A continuación, pide al usuario para el texto y pasa eso a la `sort` procesos por medio de la redirigida <xref:System.Diagnostics.Process.StandardInput%2A> secuencia. El `sort` resultados se muestran al usuario en la consola.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a stream used to read the textual output of the application.</summary>
        <value>
          <see cref="T:System.IO.StreamReader" /> que puede utilizarse para leer la secuencia de salida estándar de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un <xref:System.Diagnostics.Process> escribe texto en la secuencia estándar, que el texto se muestra normalmente en la consola. Redirigiendo el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia, puede manipular o suprimir la salida de un proceso. Por ejemplo, puede filtrar el texto, formato de manera diferente o escribir la salida en la consola y un archivo de registro designado.  
  
> [!NOTE]
>  Usar <xref:System.Diagnostics.Process.StandardOutput%2A>, debe establecer <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, y debe establecer <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> a `true`. En caso contrario, se leía el <xref:System.Diagnostics.Process.StandardOutput%2A> flujo produce una excepción.  
  
 El redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia puede leerse de forma sincrónica o asincrónica. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, y <xref:System.IO.StreamReader.ReadToEnd%2A> realizar operaciones de lectura sincrónica en el flujo de salida del proceso. Estos sincrónico leen las operaciones no se completan hasta que el asociado <xref:System.Diagnostics.Process> escribe en su <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir por secuencias o cierra la secuencia.  
  
 En cambio, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> las operaciones de lectura asincrónica se inicia en el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia. Este método permite que un controlador de eventos designado para la salida de la secuencia y vuelve inmediatamente al llamador, que puede realizar otro trabajo mientras los resultados de la secuencia se dirigen al controlador de eventos.  
  
 Sincrónica lee operaciones introducen una dependencia entre el llamador que lee de la <xref:System.Diagnostics.Process.StandardOutput%2A> escribir en esa secuencia de proceso de flujo y el elemento secundario. Estas dependencias pueden dar lugar a que las condiciones de interbloqueo. Cuando el llamador lee de la secuencia redirigida de un proceso secundario, que depende el elemento secundario. El llamador espera en la operación de lectura hasta que el elemento secundario se escribe en la secuencia o cierra la secuencia. Cuando el proceso secundario escribe suficientes datos para rellenar su secuencia redirigida, depende del elemento primario. El proceso secundario espera la siguiente operación de escritura hasta que el elemento primario lee la secuencia completa o cierra la secuencia. El interbloqueo se produce cuando el llamador y el proceso secundario se esperan entre sí para completar una operación y ninguno puede continuar. Puede evitar los interbloqueos mediante la evaluación de las dependencias entre el llamador y el proceso secundario.  
  
 El siguiente código de C#, por ejemplo, muestra cómo leer una secuencia redirigida y espere a que termine el proceso secundario.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 El ejemplo de código, evita una condición de interbloqueo mediante una llamada a `p.StandardOutput.ReadToEnd` antes de `p.WaitForExit`. Puede producirse una situación de interbloqueo si el elemento primario procesa llamadas `p.WaitForExit` antes de `p.StandardOutput.ReadToEnd` y el proceso secundario escribe texto suficiente para rellenar la secuencia redirigida. El proceso primario espera indefinidamente por el proceso secundario salir. El proceso secundario espera indefinidamente para que el elemento primario leer desde el completo <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia.  
  
 Hay un problema similar cuando se lee todo el texto de la salida estándar y los flujos de error estándar. El siguiente código de C#, por ejemplo, realiza una operación de lectura en ambas secuencias.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 El ejemplo de código, evita la situación de interbloqueo mediante la realización asincrónica de las operaciones de lectura en el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia. Una condición de interbloqueo se produce si el elemento primario procesa llamadas `p.StandardOutput.ReadToEnd` seguido de `p.StandardError.ReadToEnd` y el proceso secundario escribe texto suficiente para rellenar su secuencia de error. El proceso primario espera indefinidamente por el proceso secundario cerrar su <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia. El proceso secundario espera indefinidamente para que el elemento primario leer desde el completo <xref:System.Diagnostics.Process.StandardError%2A> secuencia.  
  
 Puede usar operaciones de lectura asincrónica para evitar estas dependencias y la posibilidad de un interbloqueo. Como alternativa, puede evitar la situación de interbloqueo creando dos subprocesos y leer los resultados de cada secuencia en un subproceso independiente.  
  
> [!NOTE]
>  No se pueden mezclar las operaciones de lectura sincrónicas o asincrónicas en una secuencia redirigida. Una vez la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas las lectura más operaciones en esa secuencia deben ser del mismo modo. Por ejemplo, no siga <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> con una llamada a <xref:System.IO.StreamReader.ReadLine%2A> en el <xref:System.Diagnostics.Process.StandardOutput%2A> flujo, o viceversa. Sin embargo, puede leer dos secuencias diferentes en modos diferentes. Por ejemplo, puede llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> y, a continuación, llame a <xref:System.IO.StreamReader.ReadLine%2A> para el <xref:System.Diagnostics.Process.StandardError%2A> secuencia.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta el comando ipconfig.exe y redirige la salida estándar a la ventana de la consola del ejemplo.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.  \- or -  The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</summary>
        <returns>
          <see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para iniciar un recurso de proceso y asociarlo con el actual <xref:System.Diagnostics.Process> componente. El valor devuelto `true` indica que se inició un nuevo recurso de proceso. Si el recurso del proceso especificado por el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> miembro de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad ya se está ejecutando en el equipo, no se inicia ningún recurso de proceso adicional. En su lugar, el que se ejecuta el recurso de proceso se reutiliza y `false` se devuelve.  
  
 Puede iniciar una aplicación ClickOnce especificando la ubicación (por ejemplo, una dirección Web) desde el que instaló originalmente la aplicación. No se inicie una aplicación ClickOnce especificando su ubicación de instalación en el disco duro.  
  
> [!NOTE]
>  Si usa Visual Studio, esta sobrecarga de la <xref:System.Diagnostics.Process.Start%2A> método es la que insertar en el código después de arrastrar un <xref:System.Diagnostics.Process> componente en el diseñador. Use la `Properties` ventana para expandir la `StartInfo` categoría y escribir el valor correcto en el `FileName` propiedad. Los cambios aparecerán en el formulario `InitializeComponent` procedimiento.  
  
 Esta sobrecarga de <xref:System.Diagnostics.Process.Start%2A> no es un `static` método. Se debe llamar desde una instancia de la <xref:System.Diagnostics.Process> clase. Antes de llamar a <xref:System.Diagnostics.Process.Start%2A>, primero debe especificar <xref:System.Diagnostics.Process.StartInfo%2A> información sobre propiedades de este <xref:System.Diagnostics.Process> instancia, porque esa información se usa para determinar el recurso de proceso para iniciar.  
  
 Las demás sobrecargas de la <xref:System.Diagnostics.Process.Start%2A> método están `static` miembros. No es necesario crear una instancia de la <xref:System.Diagnostics.Process> componente antes de llamar a esas sobrecargas del método. En su lugar, puede llamar a <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> clase propio y un nuevo <xref:System.Diagnostics.Process> se crea un componente si se inició el proceso. O bien, `null` se devuelve si se reutiliza un proceso. El recurso del proceso se asocia automáticamente con la nueva <xref:System.Diagnostics.Process> componente que es devuelto por la <xref:System.Diagnostics.Process.Start%2A> método.  
  
 El <xref:System.Diagnostics.Process.StartInfo%2A> miembros se pueden usar para duplicar la funcionalidad de la `Run` cuadro de diálogo de las ventanas `Start` menú. Todo lo que puede escribirse en una línea de comandos se puede iniciar estableciendo los valores apropiados el <xref:System.Diagnostics.Process.StartInfo%2A> propiedad. El único <xref:System.Diagnostics.Process.StartInfo%2A> propiedad que se debe establecer es la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad. El <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad no tiene que ser un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación que está instalada en el sistema. Por ejemplo, el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad puede tener la extensión .txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word.  
  
 En la línea de comandos, puede especificar acciones que deben realizarse para ciertos tipos de archivos. Por ejemplo, puede imprimir documentos o editar archivos de texto. Especificar estas acciones mediante la <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> miembro de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad. Para otros tipos de archivos, puede especificar argumentos de línea de comandos al iniciar el archivo desde el `Run` cuadro de diálogo. Por ejemplo, puede pasar una dirección URL como argumento si se especifica su explorador como el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Estos argumentos se pueden especificar en el <xref:System.Diagnostics.Process.StartInfo%2A> la propiedad <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> miembro.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe iniciar cualquier proceso que se encuentra en esa ubicación de dicha ruta de acceso completos. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agregarlo mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
> [!NOTE]
>  Código de control de página y del servidor Web de ASP.NET se ejecuta en el contexto del proceso de trabajo ASP.NET en el servidor Web.  Si usas el <xref:System.Diagnostics.Process.Start%2A> método en una página Web ASP.NET o un control de servidor, el nuevo proceso se ejecuta en el servidor Web con permisos restringidos. El proceso no se inicia en el mismo contexto que el explorador del cliente y no tiene acceso al escritorio del usuario.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, deberá cerrarla o se arriesga a perder recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad.  
  
 Aquí es necesaria una nota sobre los Estados de apartamento de los subprocesos administrados. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> es `true` en el componente de proceso <xref:System.Diagnostics.Process.StartInfo%2A> propiedad, asegúrese de que ha establecido un modelo de subprocesos en la aplicación estableciendo el atributo `[STAThread]` en el `main()` método. En caso contrario, un subproceso administrado puede estar en un `unknown` estado o colocar en la `MTA` estado, que entra en conflicto con esta última <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> que se va a `true`. Algunos métodos requieren que el estado del apartamento no sea `unknown`. Si el estado no se establece explícitamente, cuando la aplicación detecta este tipo de método, el valor predeterminado es `MTA`, y una vez establecido, no se puede cambiar el estado del apartamento. Sin embargo, `MTA` produce una excepción que se produzca cuando el shell del sistema operativo administra el subproceso.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza una instancia de la <xref:System.Diagnostics.Process> clase para iniciar un proceso.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.
-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</param>
        <summary>Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para iniciar un recurso de proceso mediante la especificación de un <xref:System.Diagnostics.ProcessStartInfo> instancia. La sobrecarga asocia el recurso a un nuevo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. Utilice esta sobrecarga con un <xref:System.Diagnostics.ProcessStartInfo> parámetro es una alternativa a los pasos explícitos de crear un nuevo <xref:System.Diagnostics.Process> instancia, establecer su <xref:System.Diagnostics.Process.StartInfo%2A> propiedades y llamar al método <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 Con un <xref:System.Diagnostics.ProcessStartInfo> instancia como el parámetro le permite llamar a <xref:System.Diagnostics.Process.Start%2A> con el máximo control sobre lo que se pasa en la llamada para iniciar el proceso. Si tiene que pasar un nombre de archivo o un nombre de archivo y argumentos, no es necesario crear un nuevo <xref:System.Diagnostics.ProcessStartInfo> de instancia, aunque es posible. El único <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> propiedad que se debe establecer es la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad. El <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad no es necesario representar un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación que está instalada en el sistema. Por ejemplo, el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad puede tener la extensión .txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word.  
  
 Puede iniciar una aplicación ClickOnce especificando la ubicación (por ejemplo, una dirección Web) desde el que instaló originalmente la aplicación. No se inicie una aplicación ClickOnce especificando su ubicación de instalación en el disco duro.  
  
 Si el <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> y <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propiedades de la <xref:System.Diagnostics.Process.StartInfo%2A> instancia están establecidas, el no administrado `CreateProcessWithLogonW` se llama a función, que inicia el proceso en una nueva ventana aunque se utilicen los <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> es el valor de la propiedad `true` o la <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> es el valor de la propiedad <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Si el <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> propiedad es `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> propiedad debe estar en formato de UPN, *usuario*@*nombreDeDominioDNS*.   
  
 A diferencia de las otras sobrecargas, la sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que no tiene parámetros no es un `static` miembro. Utilizar esta sobrecarga cuando ya haya creado un <xref:System.Diagnostics.Process> instancia, información de inicio especificada (incluido el nombre de archivo) y desea iniciar un recurso de proceso y asociar dicho plan existente <xref:System.Diagnostics.Process> instancia. Utilice uno de los `static` sobrecargas cuando desee crear un nuevo <xref:System.Diagnostics.Process> componente en lugar de iniciar un proceso para un componente existente. Esta sobrecarga y la sobrecarga que no tiene parámetros le permiten especificar la información de inicio para el recurso de proceso mediante el uso de un <xref:System.Diagnostics.ProcessStartInfo> instancia.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe iniciar cualquier proceso que se encuentra en esa ubicación de dicha ruta de acceso completos. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agregarlo mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
> [!NOTE]
>  Código de control de página y del servidor Web de ASP.NET se ejecuta en el contexto del proceso de trabajo ASP.NET en el servidor Web.  Si usas el <xref:System.Diagnostics.Process.Start%2A> método en una página Web ASP.NET o un control de servidor, el nuevo proceso se ejecuta en el servidor Web con permisos restringidos. El proceso no se inicia en el mismo contexto que el explorador del cliente y no tiene acceso al escritorio del usuario.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, deberá cerrarla o se arriesga a perder recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad.  
  
 Aquí es necesaria una nota sobre los Estados de apartamento de los subprocesos administrados. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> es `true` en el `startInfo` parámetro, asegúrese de que ha establecido un modelo de subprocesos en la aplicación estableciendo el atributo `[STAThread]` en el `main()` método. En caso contrario, un subproceso administrado puede estar en un `unknown` estado o colocar en la `MTA` estado, que entra en conflicto con esta última <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> que se va a `true`. Algunos métodos requieren que el estado del apartamento no sea `unknown`. Si el estado no se establece explícitamente, cuando la aplicación detecta este tipo de método, el valor predeterminado es `MTA`, y una vez establecido, no se puede cambiar el estado del apartamento. Sin embargo, `MTA` produce una excepción que se produzca cuando el shell del sistema operativo administra el subproceso.  
  
   
  
## Examples  
 En primer lugar, en el ejemplo siguiente se genera una instancia de Internet Explorer y muestra el contenido de la carpeta Favoritos en el explorador. A continuación, se inician algunas otras instancias de Internet Explorer y se muestra algunas páginas o sitios específicos. Por último, inicia Internet Explorer con la ventana minimizada mientras se navega a un sitio específico.  
  
 Para obtener ejemplos adicionales de otros usos de este método, consulte las propiedades individuales de la <xref:System.Diagnostics.ProcessStartInfo> clase.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.  -or-  The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="startInfo" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of a document or application file to run in the process.</param>
        <summary>Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para iniciar un recurso de proceso mediante la especificación de su nombre de archivo. La sobrecarga asocia el recurso a un nuevo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. La sobrecarga es una alternativa a los pasos explícitos de crear un nuevo <xref:System.Diagnostics.Process> instancia, establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> miembro de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llamar al método <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 Puede iniciar una aplicación ClickOnce estableciendo el `fileName` parámetro a la ubicación (por ejemplo, una dirección Web) desde el que instaló originalmente la aplicación. No se inicie una aplicación ClickOnce especificando su ubicación de instalación en el disco duro.  
  
 A partir de un proceso mediante la especificación de su nombre de archivo es similar a escribir la información de la `Run` cuadro de diálogo de las ventanas `Start` menú. Por lo tanto, el nombre de archivo no es necesario representar un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación instalada en el sistema. Por ejemplo, el nombre de archivo puede tener una extensión. txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word. De forma similar, en la misma forma en que la `Run` cuadro de diálogo puede aceptar un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en la `fileName` parámetro. Por ejemplo, puede establecer el `fileName` parámetro "Notepad.exe" o "Notepad".  
  
 Esta sobrecarga no permite argumentos de línea de comandos para el proceso. Si tiene que especificar uno o más argumentos de línea de comandos para el proceso, use la <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> o <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecargas.  
  
 A diferencia de las otras sobrecargas, la sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que no tiene parámetros no es un `static` miembro. Utilizar esta sobrecarga cuando ya haya creado un <xref:System.Diagnostics.Process> instancia, información de inicio especificada (incluido el nombre de archivo) y desea iniciar un recurso de proceso y asociar dicho plan existente <xref:System.Diagnostics.Process> instancia. Utilice uno de los `static` sobrecargas cuando desee crear un nuevo <xref:System.Diagnostics.Process> componente en lugar de iniciar un proceso para un componente existente. Esta sobrecarga y la sobrecarga que no tiene parámetros permiten especificar el nombre de archivo del recurso del proceso para iniciar.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe iniciar cualquier proceso que se encuentra en esa ubicación de dicha ruta de acceso completos. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agregarlo mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
> [!NOTE]
>  Código de control de página y del servidor Web de ASP.NET se ejecuta en el contexto del proceso de trabajo ASP.NET en el servidor Web.  Si usas el <xref:System.Diagnostics.Process.Start%2A> método en una página Web ASP.NET o un control de servidor, el nuevo proceso se ejecuta en el servidor Web con permisos restringidos. El proceso no se inicia en el mismo contexto que el explorador del cliente y no tiene acceso al escritorio del usuario.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, deberá cerrarla o se arriesga a perder recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad.  
  
 Aquí es necesaria una nota sobre los Estados de apartamento de los subprocesos administrados. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> es `true` en el componente de proceso <xref:System.Diagnostics.Process.StartInfo%2A> propiedad, asegúrese de que ha establecido un modelo de subprocesos en la aplicación estableciendo el atributo `[STAThread]` en el `main()` método. En caso contrario, un subproceso administrado puede estar en un `unknown` estado o colocar en la `MTA` estado, que entra en conflicto con esta última <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> que se va a `true`. Algunos métodos requieren que el estado del apartamento no sea `unknown`. Si el estado no se establece explícitamente, cuando la aplicación detecta este tipo de método, el valor predeterminado es `MTA`, y una vez establecido, no se puede cambiar el estado del apartamento. Sin embargo, `MTA` produce una excepción que se produzca cuando el shell del sistema operativo administra el subproceso.  
  
   
  
## Examples  
 En primer lugar, en el ejemplo siguiente se genera una instancia de Internet Explorer y muestra el contenido de la carpeta Favoritos en el explorador. A continuación, se inician algunas otras instancias de Internet Explorer y se muestra algunas páginas o sitios específicos. Por último, inicia Internet Explorer con la ventana minimizada mientras se navega a un sitio específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para iniciar un recurso de proceso mediante la especificación de su nombre de archivo y los argumentos de línea de comandos. La sobrecarga asocia el recurso a un nuevo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. La sobrecarga es una alternativa a los pasos explícitos de crear un nuevo <xref:System.Diagnostics.Process> instancia, establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> y <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> los miembros de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llamar al método <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 A partir de un proceso mediante la especificación de su nombre de archivo y los argumentos es similar a escribir el nombre de archivo y los argumentos de línea de comandos en el `Run` cuadro de diálogo de las ventanas `Start` menú. Por lo tanto, el nombre de archivo no es necesario representar un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación instalada en el sistema. Por ejemplo, el nombre de archivo puede tener una extensión. txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word. De forma similar, en la misma forma en que la `Run` cuadro de diálogo puede aceptar un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en la `fileName` parámetro. Por ejemplo, puede establecer el `fileName` parámetro "Notepad.exe" o "Notepad". Si el `fileName` parámetro representa un archivo ejecutable, el `arguments` parámetro podría representar un archivo para actuar sobre ella, por ejemplo, el archivo de texto en `Notepad.exe myfile.txt`. Si el `fileName` parámetro representa un archivo de comandos (.cmd), el `arguments` parámetro debe incluir un "`/c`"o"`/k`" argumento para especificar si la ventana de comandos se cierra o permanece al finalizar.  
  
 A diferencia de las otras sobrecargas, la sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que no tiene parámetros no es un `static` miembro. Utilizar esta sobrecarga cuando ya haya creado un <xref:System.Diagnostics.Process> instancia, información de inicio especificada (incluido el nombre de archivo) y desea iniciar un recurso de proceso y asociar dicho plan existente <xref:System.Diagnostics.Process> instancia. Utilice uno de los `static` sobrecargas cuando desee crear un nuevo <xref:System.Diagnostics.Process> componente en lugar de iniciar un proceso para un componente existente. Esta sobrecarga y la sobrecarga que no tiene parámetros permiten especificar el nombre de archivo del recurso del proceso para iniciar y los argumentos de línea de comandos que se pasan.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe iniciar cualquier proceso que se encuentra en esa ubicación de dicha ruta de acceso completos. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agregarlo mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
> [!NOTE]
>  Código de control de página y del servidor Web de ASP.NET se ejecuta en el contexto del proceso de trabajo ASP.NET en el servidor Web.  Si usas el <xref:System.Diagnostics.Process.Start%2A> método en una página Web ASP.NET o un control de servidor, el nuevo proceso se ejecuta en el servidor Web con permisos restringidos. El proceso no se inicia en el mismo contexto que el explorador del cliente y no tiene acceso al escritorio del usuario.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, deberá cerrarla o se arriesga a perder recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad...  
  
 Aquí es necesaria una nota sobre los Estados de apartamento de los subprocesos administrados. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> es `true` en el componente de proceso <xref:System.Diagnostics.Process.StartInfo%2A> propiedad, asegúrese de que ha establecido un modelo de subprocesos en la aplicación estableciendo el atributo `[STAThread]` en el `main()` método. En caso contrario, un subproceso administrado puede estar en un `unknown` estado o colocar en la `MTA` estado, que entra en conflicto con esta última <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> que se va a `true`. Algunos métodos requieren que el estado del apartamento no sea `unknown`. Si el estado no se establece explícitamente, cuando la aplicación detecta este tipo de método, el valor predeterminado es `MTA`, y una vez establecido, no se puede cambiar el estado del apartamento. Sin embargo, `MTA` produce una excepción que se produzca cuando el shell del sistema operativo administra el subproceso.  
  
   
  
## Examples  
 En primer lugar, en el ejemplo siguiente se genera una instancia de Internet Explorer y muestra el contenido de la carpeta Favoritos en el explorador. A continuación, se inician algunas otras instancias de Internet Explorer y se muestra algunas páginas o sitios específicos. Por último, inicia Internet Explorer con la ventana minimizada mientras se navega a un sitio específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The PATH environment variable has a string containing quotes.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear un nuevo proceso y su subproceso principal especificando su nombre de archivo, el nombre de usuario, la contraseña y el dominio. El nuevo proceso, a continuación, ejecuta el archivo ejecutable especificado en el contexto de seguridad de las credenciales especificadas (usuario, dominio y contraseña).  
  
> [!NOTE]
>  Cuando el archivo ejecutable se encuentra en una unidad remota, debe identificar el recurso compartido de red mediante el uso de un identificador uniforme de recursos (URI), no una letra de unidad vinculado.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. La sobrecarga es una alternativa a los pasos explícitos de crear un nuevo <xref:System.Diagnostics.Process> instancia, establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, y <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propiedades de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llamar al método <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 De forma similar, en la misma forma en que la **ejecutar** cuadro de diálogo puede aceptar un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en la `fileName` parámetro. Por ejemplo, puede establecer el `fileName` parámetro "Notepad.exe" o "Notepad". Si el `fileName` parámetro representa un archivo ejecutable, el `arguments` parámetro podría representar un archivo para actuar sobre ella, por ejemplo, el archivo de texto en `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  El nombre de archivo debe representar un archivo ejecutable en el <xref:System.Diagnostics.Process.Start%2A> las sobrecargas que tienen `userName`, `password`, y `domain` parámetros.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, deberá cerrarla o se arriesga a perder recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad...  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de esta sobrecarga para iniciar un archivo ejecutable y también muestra el inicio de un <xref:System.ComponentModel.Win32Exception> cuando se realiza un intento para iniciar una aplicación asociada a un archivo no ejecutable.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file.</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of an application file to run in the process.</param>
        <param name="arguments">Command-line arguments to pass when starting the process.</param>
        <param name="userName">The user name to use when starting the process.</param>
        <param name="password">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</param>
        <param name="domain">The domain to use when starting the process.</param>
        <summary>Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</summary>
        <returns>A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started. Note that a new process that’s started alongside already running instances of the same process will be independent from the others. In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />. In this case, the started process may have activated an existing instance of itself and then exited.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear un nuevo proceso y su subproceso principal especificando su nombre de archivo de argumentos de línea de comandos, nombre de usuario, contraseña y dominio. El nuevo proceso, a continuación, ejecuta el archivo ejecutable especificado en el contexto de seguridad de las credenciales especificadas (usuario, dominio y contraseña).  
  
> [!NOTE]
>  Cuando el archivo ejecutable se encuentra en una unidad remota, debe identificar el recurso compartido de red mediante el uso de un identificador uniforme de recursos (URI), no una letra de unidad vinculado.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. La sobrecarga es una alternativa a los pasos explícitos de crear un nuevo <xref:System.Diagnostics.Process> instancia, establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, y <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propiedades de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llamar al método <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 De forma similar, en la misma forma en que la **ejecutar** cuadro de diálogo puede aceptar un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en la `fileName` parámetro. Por ejemplo, puede establecer el `fileName` parámetro "Notepad.exe" o "Notepad". Si el `fileName` parámetro representa un archivo ejecutable, el `arguments` parámetro podría representar un archivo para actuar sobre ella, por ejemplo, el archivo de texto en `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  El nombre de archivo debe representar un archivo ejecutable en el <xref:System.Diagnostics.Process.Start%2A> las sobrecargas que tienen `userName`, `password`, y `domain` parámetros.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, deberá cerrarla o se arriesga a perder recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No file name was specified.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when opening the associated file.  -or-  The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080. The error message associated with this exception can be one of the following: "The data area passed to a system call is too small." or "Access is denied."</exception>
        <exception cref="T:System.ObjectDisposedException">The process object has already been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Method not supported on Linux or macOS (.NET Core only).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> que representa los datos con los que iniciar el proceso. Estos argumentos incluyen el nombre del archivo ejecutable o del documento que se usó para iniciar el proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> representa el conjunto de parámetros que se usarán para iniciar un proceso. Cuando <xref:System.Diagnostics.Process.Start%2A> se llama, el <xref:System.Diagnostics.Process.StartInfo%2A> se utiliza para especificar que se inicie el proceso. Solo es necesario <xref:System.Diagnostics.Process.StartInfo%2A> miembro que se va a establecer es el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad. Iniciar un proceso mediante la especificación de la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad es similar a escribir la información de la **ejecutar** cuadro de diálogo de las ventanas **iniciar** menú. Por lo tanto, la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad no es necesario representar un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación instalada en el sistema. Por ejemplo el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> puede tener la extensión .txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word. De forma similar, en la misma forma en que la **ejecutar** cuadro de diálogo puede aceptar un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> miembro. Por ejemplo, puede establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad en "Notepad.exe" o "Notepad".  
  
 Puede iniciar una aplicación ClickOnce estableciendo el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad a la ubicación (por ejemplo, una dirección Web) desde el que instaló originalmente la aplicación. No se inicie una aplicación ClickOnce especificando su ubicación de instalación en el disco duro.  
  
 Si el nombre de archivo afecta a un archivo no ejecutable, como un archivo .doc, puede incluir un verbo que especifique qué acción se debe realizar en el archivo. Por ejemplo, podría establecer el <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> a "Print" para un archivo que termine con la extensión .doc. El nombre de archivo especificado en el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad no necesita tener una extensión si introduce manualmente un valor para el <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> propiedad. Sin embargo, si usa el <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> propiedad para determinar los verbos que están disponibles, debe incluir la extensión.  
  
 Puede cambiar los parámetros especificados en la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad hasta el momento en que se llama a la <xref:System.Diagnostics.Process.Start%2A> método en el proceso. Después de iniciar el proceso, cambiar el <xref:System.Diagnostics.Process.StartInfo%2A> valores no afecta ni reiniciar el proceso asociado. Si se llama a la <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> método con el <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> y <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> conjunto de propiedades y el no administrado `CreateProcessWithLogonW` se llama a función, que inicia el proceso en una nueva ventana aunque se utilicen los <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> es el valor de la propiedad `true` o la <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> es el valor de la propiedad <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Si no utilizó el <xref:System.Diagnostics.Process.Start%2A> método para iniciar un proceso, el <xref:System.Diagnostics.Process.StartInfo%2A> propiedad no refleja los parámetros utilizados para iniciar el proceso. Por ejemplo, si usa <xref:System.Diagnostics.Process.GetProcesses%2A> para obtener una matriz de procesos que se ejecutan en el equipo, el <xref:System.Diagnostics.Process.StartInfo%2A> propiedad de cada <xref:System.Diagnostics.Process> no contiene el nombre del archivo original o los argumentos que se usan para iniciar el proceso.  
  
 Cuando se inicia el proceso, el nombre de archivo es el archivo que rellena el (solo lectura) <xref:System.Diagnostics.Process.MainModule%2A> propiedad. Si desea recuperar el archivo ejecutable que está asociado con el proceso una vez iniciado el proceso, utilice el <xref:System.Diagnostics.Process.MainModule%2A> propiedad. Si desea establecer el archivo ejecutable de un <xref:System.Diagnostics.Process> de la instancia para que no se ha iniciado un proceso asociado, utilice el <xref:System.Diagnostics.Process.StartInfo%2A> la propiedad <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> miembro. Porque los miembros de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad son los argumentos que se pasan a la <xref:System.Diagnostics.Process.Start%2A> método de un proceso, cambiar el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad después de que ha iniciado el proceso asociado no se restablecerá la <xref:System.Diagnostics.Process.MainModule%2A> propiedad. Estas propiedades se usan solo para inicializar el proceso asociado.  
  
   
  
## Examples  
 El ejemplo siguiente rellena un <xref:System.Diagnostics.Process.StartInfo%2A> con los archivos que se va a ejecutar, la acción se realiza en él y si debe mostrar una interfaz de usuario. Para obtener ejemplos adicionales, consulte las páginas de referencia para las propiedades de la <xref:System.Diagnostics.ProcessStartInfo> clase.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the time that the associated process was started.</summary>
        <value>Objeto que indica cuándo se inició el proceso. Si no se está ejecutando el proceso, se produce una excepción.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.InvalidOperationException">The process has exited.  -or-  The process has not been started.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred in the call to the Windows function.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> que se usa para calcular las referencias de las llamadas del controlador de eventos emitidas como resultado de un evento <see cref="E:System.Diagnostics.Process.Exited" /> del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> es `null`, métodos que controlan la <xref:System.Diagnostics.Process.Exited> eventos se llaman en un subproceso del grupo de subprocesos del sistema. Para obtener más información acerca de los grupos de subprocesos del sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Cuando el <xref:System.Diagnostics.Process.Exited> evento está controlado por un componente visual de formularios Windows Forms, como un <xref:System.Windows.Forms.Button>, acceso al componente en el grupo de subprocesos de sistema no funcionen o se podría producir una excepción. Evitarlo estableciendo <xref:System.Diagnostics.Process.SynchronizingObject%2A> a un componente de Windows Forms, lo que hace que los métodos que controlan la <xref:System.Diagnostics.Process.Exited> evento al que se llama en el mismo subproceso en el que se creó el componente.  
  
 Si el <xref:System.Diagnostics.Process> se utiliza dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] en un diseñador de formularios Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> se establece automáticamente en el control que contiene el <xref:System.Diagnostics.Process>. Por ejemplo, si coloca un <xref:System.Diagnostics.Process> en un diseñador para `Form1` (que hereda de <xref:System.Windows.Forms.Form>) la <xref:System.Diagnostics.Process.SynchronizingObject%2A> propiedad de <xref:System.Diagnostics.Process> se establece en la instancia de `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Normalmente, esta propiedad se establece cuando el componente se coloca dentro de un control o formulario, porque esos componentes están enlazados a un subproceso concreto.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the set of threads that are running in the associated process.</summary>
        <value>Matriz de tipo <see cref="T:System.Diagnostics.ProcessThread" /> que representa los subprocesos del sistema operativo que se están ejecutando actualmente en el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un subproceso ejecuta código en un proceso. Cada proceso se inicia con un único subproceso, el subproceso principal. Cualquier subproceso puede crear subprocesos adicionales. Los subprocesos dentro de un proceso comparten el espacio de direcciones del proceso.  
  
 Use <xref:System.Diagnostics.ProcessThread> para obtener todos los subprocesos asociados con el proceso actual. El subproceso principal no es necesariamente en el índice cero de la matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.  -or-  The associated process has exited.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formats the process's name as a string, combined with the parent component type, if applicable.</summary>
        <returns>The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the total processor time for this process.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> indica la cantidad de tiempo que el proceso asociado ha empleado en utilizar la CPU. Este valor es la suma de <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> y <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user processor time for this process.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> que indica la cantidad de tiempo que el proceso asociado ha empleado en ejecutar código en la parte de la aplicación que corresponde al proceso (no en el núcleo del sistema operativo).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <exception cref="T:System.NotSupportedException">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the size of the process's virtual memory, in bytes.</summary>
        <value>Cantidad de memoria virtual, en bytes, solicitada por el proceso asociado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of the virtual memory, in bytes, allocated for the associated process.</summary>
        <value>Tamaño de memoria virtual, expresado en bytes, que se asignó para el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria virtual usada por el proceso, en bytes. El sistema operativo asigna espacio de direcciones virtuales para cada proceso a las páginas cargados en la memoria física, o a páginas almacenadas en el archivo de paginación de memoria virtual en el disco.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes virtuales** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited. To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.  For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> hace que el subproceso actual espere hasta que termine el proceso asociado.  Se debe llamar después de que todos los demás métodos se llaman en el proceso. Para evitar el bloqueo del subproceso actual, use el evento <xref:System.Diagnostics.Process.Exited>.  
  
 Este método indica la <xref:System.Diagnostics.Process> componente que espere un período de tiempo para el proceso y controladores de eventos salir de infinito. Esto puede hacer que una aplicación deje de responder. Por ejemplo, si se llama a <xref:System.Diagnostics.Process.CloseMainWindow%2A> para un proceso que tiene una interfaz de usuario, la solicitud para el sistema operativo para finalizar el proceso asociado podría no controlarse si el proceso se escribe en nunca entrase en el bucle de mensajes.  
  
> [!NOTE]
>  En el [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] y versiones anteriores, el <xref:System.Diagnostics.Process.WaitForExit> sobrecarga esperó <xref:System.Int32.MaxValue> milisegundos (aproximadamente 24 días), no indefinidamente. Además, las versiones anteriores no esperaba a los controladores de eventos salir si toda la <xref:System.Int32.MaxValue> se alcanzó el tiempo.  
  
 Esta sobrecarga se asegura de que se ha completado todo el procesamiento, incluido el control de eventos asincrónicos para la salida estándar redirigida. Debe utilizar esta sobrecarga después de llamar a la <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> sobrecarga cuando la salida estándar se ha redirigido a controladores de eventos asincrónicos.  
  
 Cuando se termina un proceso asociado (es decir, cuando se cierra por el sistema operativo a través de una terminación normal o anómala), el sistema almacena información administrativa sobre el proceso y regresa al componente que se había llamado <xref:System.Diagnostics.Process.WaitForExit>. El <xref:System.Diagnostics.Process> componente, a continuación, puede obtener acceso a la información, que incluye el <xref:System.Diagnostics.Process.ExitTime%2A>, mediante el uso de la <xref:System.Diagnostics.Process.Handle%2A> para el proceso terminado.  
  
 Dado que el proceso asociado ha terminado, la <xref:System.Diagnostics.Process.Handle%2A> propiedad del componente ya no apunta a un recurso de proceso existente. En su lugar, el identificador puede usarse solo para tener acceso a información del sistema operativo sobre el recurso de proceso. El sistema es compatible con identificadores de procesos terminados que no han sido publicados por <xref:System.Diagnostics.Process> componentes, por lo que mantiene la <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.Handle%2A> información en la memoria hasta que el <xref:System.Diagnostics.Process> componente específicamente libera los recursos. Por esta razón, siempre que se llama a <xref:System.Diagnostics.Process.Start%2A> para un <xref:System.Diagnostics.Process> de la instancia, llame a <xref:System.Diagnostics.Process.Close%2A> cuando el proceso asociado ha terminado y ya no necesita toda la información administrativa sobre él. <xref:System.Diagnostics.Process.Close%2A> Libera la memoria asignada para el proceso terminado.  
  
   
  
## Examples  
 Vea la sección Comentarios de la <xref:System.Diagnostics.Process.StandardError%2A> página de referencia de propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">The amount of time, in milliseconds, to wait for the associated process to exit. The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</param>
        <summary>Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</summary>
        <returns>
          <see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> hace que el subproceso actual espere hasta que termine el proceso asociado. Se debe llamar después de que todos los demás métodos se llaman en el proceso. Para evitar el bloqueo del subproceso actual, use el evento <xref:System.Diagnostics.Process.Exited>.  
  
 Este método indica la <xref:System.Diagnostics.Process> componente que espere una cantidad finita de tiempo para el proceso termine. Si el proceso asociado no termina al final del intervalo de porque se denegó la solicitud para terminar, `false` se devuelve al procedimiento que realiza la llamada. Puede especificar <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para `milliseconds`, y <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> se comportará igual que el <xref:System.Diagnostics.Process.WaitForExit> de sobrecarga. Si se pasa 0 (cero) al método, devuelve `true` sólo si el proceso ya ha terminado; de lo contrario, devuelve inmediatamente `false`.  
  
> [!NOTE]
>  En el [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] y versiones anteriores, si `milliseconds` era -1, el <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> sobrecarga esperó <xref:System.Int32.MaxValue> milisegundos (aproximadamente 24 días), no indefinidamente.  
  
 Cuando se ha redirigido la salida estándar para controladores de eventos asincrónicos, es posible que el procesamiento de salida no se habrá completado cuando este método devuelve. Para asegurarse de que se ha completado el control de eventos asincrónico, llame a la <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que no toma ningún parámetro después de recibir un `true` de esta sobrecarga. Para ayudar a garantizar que el <xref:System.Diagnostics.Process.Exited> evento se administra correctamente en aplicaciones de Windows Forms, establezca la <xref:System.Diagnostics.Process.SynchronizingObject%2A> propiedad.  
  
 Cuando se cierra un proceso asociado (cierra el sistema operativo a través de una terminación normal o anómala), el sistema almacena información administrativa sobre el proceso y regresa al componente que se hubiera llamado <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. El <xref:System.Diagnostics.Process> componente, a continuación, puede obtener acceso a la información, que incluye el <xref:System.Diagnostics.Process.ExitTime%2A>, mediante el uso de la <xref:System.Diagnostics.Process.Handle%2A> para el proceso terminado.  
  
 Dado que el proceso asociado ha terminado, la <xref:System.Diagnostics.Process.Handle%2A> propiedad del componente ya no apunta a un recurso de proceso existente. En su lugar, el identificador puede usarse solo para tener acceso a información del sistema operativo sobre el recurso de proceso. El sistema es compatible con identificadores de procesos terminados que no han sido publicados por <xref:System.Diagnostics.Process> componentes, por lo que mantiene la <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.Handle%2A> información en la memoria hasta que el <xref:System.Diagnostics.Process> componente específicamente libera los recursos. Por esta razón, siempre que se llama a <xref:System.Diagnostics.Process.Start%2A> para un <xref:System.Diagnostics.Process> de la instancia, llame a <xref:System.Diagnostics.Process.Close%2A> cuando el proceso asociado ha terminado y ya no necesita toda la información administrativa sobre él. <xref:System.Diagnostics.Process.Close%2A> Libera la memoria asignada para el proceso terminado.  
  
   
  
## Examples  
 Vea el ejemplo de código para el <xref:System.Diagnostics.Process.ExitCode%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
        <exception cref="T:System.SystemException">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.  -or-  There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.  -or-  You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle> para forzar el procesamiento de la aplicación para esperar hasta que el bucle de mensajes ha devuelto al estado inactivo. Cuando se está ejecutando un proceso con una interfaz de usuario, el bucle de mensajes se ejecuta cada vez que se envía un mensaje de Windows al proceso por el sistema operativo. El proceso, a continuación, se devuelve en el bucle de mensajes. Se dice que un proceso estará en un estado de inactividad cuando está esperando mensajes dentro de un bucle de mensajes. Este estado es útil, por ejemplo, cuando la aplicación debe esperar para que iniciar el proceso terminar de crear su ventana principal antes de que la aplicación se comunica con esa ventana.  
  
 Si un proceso no tiene un bucle de mensajes, <xref:System.Diagnostics.Process.WaitForInputIdle> produce una <xref:System.InvalidOperationException>.  
  
 El <xref:System.Diagnostics.Process.WaitForInputIdle> sobrecarga indica la <xref:System.Diagnostics.Process> componente para que espere indefinidamente hasta que el proceso esté inactivo en el bucle de mensajes. Esta instrucción puede hacer que una aplicación deje de responder. Por ejemplo, si el proceso se escribe en siempre cierra su bucle de mensajes de inmediato, como se muestra en el fragmento de código `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle. A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</param>
        <summary>Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state. This overload applies only to processes with a user interface and, therefore, a message loop.</summary>
        <returns>
          <see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> para forzar el procesamiento de la aplicación para esperar hasta que el bucle de mensajes ha devuelto al estado inactivo. Cuando se está ejecutando un proceso con una interfaz de usuario, el bucle de mensajes se ejecuta cada vez que se envía un mensaje de Windows al proceso por el sistema operativo. El proceso, a continuación, se devuelve en el bucle de mensajes. Se dice que un proceso estará en un estado de inactividad cuando está esperando mensajes dentro de un bucle de mensajes. Este estado es útil, por ejemplo, cuando la aplicación debe esperar para que iniciar el proceso terminar de crear su ventana principal antes de que la aplicación se comunica con esa ventana.  
  
 Si un proceso no tiene un bucle de mensajes, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> produce una <xref:System.InvalidOperationException>.  
  
 El <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> sobrecarga indica la <xref:System.Diagnostics.Process> componente que espere una cantidad finita de tiempo para el proceso esté inactivo en el bucle de mensajes. Si el proceso asociado no pasa a estar inactivo por el final del intervalo porque el bucle todavía está procesando mensajes, `false` se devuelve al procedimiento que realiza la llamada.  
  
 Para obtener más información sobre el control de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The process does not have a graphical interface.  -or-  An unknown error occurred. The process failed to enter an idle state.  -or-  The process has already exited.  -or-  No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the associated process's physical memory usage, in bytes.</summary>
        <value>Cantidad total de memoria física que el proceso asociado está usando, expresada en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de utilizada por el proceso, en bytes de memoria de conjunto de trabajo. El espacio de trabajo de un proceso es el conjunto de páginas de memoria actualmente visibles para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para que utilice sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos comprenden las páginas que contienen todas las instrucciones que se ejecuta el proceso, incluidos los módulos de proceso y las bibliotecas del sistema.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una instancia del Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory, in bytes, allocated for the associated process.</summary>
        <value>Tamaño de memoria física, expresado en bytes, que se asignó para el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de utilizada por el proceso, en bytes de memoria de conjunto de trabajo. El espacio de trabajo de un proceso es el conjunto de páginas de memoria actualmente visibles para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para que utilice sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos comprenden las páginas que contienen todas las instrucciones que se ejecuta el proceso, incluidas las instrucciones de los módulos de proceso y las bibliotecas del sistema.  
  
 Esta propiedad puede utilizarse para supervisar el uso de memoria en equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **espacio de trabajo** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. A continuación, en el ejemplo se recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando finaliza el proceso y muestra sus estadísticas de memoria de código y una memoria máxima de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">de plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>