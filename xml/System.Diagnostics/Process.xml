<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="10bf0daa3bd3743fd402cdd8f360d421086b0ea5" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48662931" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona acceso a procesos locales y remotos, y permite iniciar y detener procesos del sistema local.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Diagnostics.Process> componente proporciona acceso a un proceso que se ejecuta en un equipo. Un proceso, en términos más simples, es una aplicación en ejecución. Un subproceso es la unidad básica a la que el sistema operativo asigna tiempo de procesador. Un subproceso puede ejecutar cualquier parte del código del proceso, incluidas las partes que se está ejecutadas actualmente por otro subproceso.  
  
 El <xref:System.Diagnostics.Process> componente es una herramienta útil para iniciar, detener, controlar y supervisar aplicaciones. Puede usar el <xref:System.Diagnostics.Process> componente para obtener una lista de los procesos que se ejecutan, o bien puede iniciar un nuevo proceso. Un <xref:System.Diagnostics.Process> componente se utiliza para tener acceso a los procesos del sistema. Después de un <xref:System.Diagnostics.Process> se ha inicializado el componente, se puede usar para obtener información sobre el proceso en ejecución. Dicha información incluye el conjunto de subprocesos, los módulos cargados (archivos .dll y .exe), y está usando la información de rendimiento como la cantidad de memoria del proceso.  
  
 Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `finally` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
> [!NOTE]
>  los procesos de 32 bits no pueden tener acceso a los módulos de un proceso de 64 bits. Si se intenta obtener información acerca de un proceso de 64 bits de un proceso de 32 bits, obtendrá un <xref:System.ComponentModel.Win32Exception> excepción. Un proceso de 64 bits, por otro lado, puede tener acceso a los módulos de un proceso de 32 bits.  
  
 El componente del proceso obtiene información sobre un grupo de propiedades a la vez. Después de la <xref:System.Diagnostics.Process> componente ha obtenido información sobre un miembro de ningún grupo, almacenarán en caché los valores de las demás propiedades de ese grupo y no obtiene nueva información acerca de los demás miembros del grupo hasta que llame a la <xref:System.Diagnostics.Process.Refresh%2A> método. Por lo tanto, un valor de propiedad no se garantiza que sea más reciente que la última llamada a la <xref:System.Diagnostics.Process.Refresh%2A> método. Los detalles del grupo dependen del sistema operativo.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe calificar totalmente esa ruta de acceso al iniciar cualquier proceso que se encuentra en esa ubicación. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agréguela mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
 Un proceso del sistema se identifica en el sistema mediante su identificador de proceso. Al igual que muchos de los recursos de Windows, un proceso también se identifica mediante su identificador, que podría no ser único en el equipo. Un identificador es el término genérico para un identificador de un recurso. El sistema operativo conserva el identificador de proceso, que se accede mediante el <xref:System.Diagnostics.Process.Handle%2A> propiedad de la <xref:System.Diagnostics.Process> componente, incluso cuando el proceso ha terminado. Por lo tanto, puede obtener la información administrativa del proceso, como el <xref:System.Diagnostics.Process.ExitCode%2A> (normalmente, cero para el éxito o un código de error distinto de cero) y el <xref:System.Diagnostics.Process.ExitTime%2A>. Identificadores son un recurso muy valioso, por lo que es mucho más dañina que pierde memoria la pérdida de identificadores.  
  
> [!NOTE]
>  Esta clase contiene una petición de vínculo y una petición de herencia en el nivel de clase que se aplica a todos los miembros. Un <xref:System.Security.SecurityException> se produce cuando el llamador inmediato o la clase derivada no tiene permiso de plena confianza. Para obtener más información acerca de las peticiones de seguridad, consulte [peticiones de vínculo](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Notas de la  
 En .NET Framework, el <xref:System.Diagnostics.Process> clase usa de manera predeterminada <xref:System.Console> codificaciones, que suelen ser código codificaciones de páginas, para los flujos de entrada, salida y error. Por ejemplo de código, en los sistemas cuya referencia cultural es inglés (Estados Unidos), página de códigos 437 es la codificación predeterminada para el <xref:System.Console> clase. Sin embargo, [!INCLUDE[net_core](~/includes/net-core-md.md)] puede realizar solo un subconjunto limitado de estas codificaciones disponibles. Si este es el caso, usa <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> como la codificación predeterminada.  
  
 Si un <xref:System.Diagnostics.Process> objeto depende de codificaciones de páginas de código específico, puede seguir ponerlos a disposición mediante el siguiente procedimiento *antes* llamar a cualquier <xref:System.Diagnostics.Process> métodos:  
  
1.  Agregue una referencia al ensamblado System.Text.Encoding.CodePages.dll al proyecto.  
  
2.  Recuperar el <xref:System.Text.EncodingProvider> objeto desde el <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propiedad.  
  
3.  Pase el <xref:System.Text.EncodingProvider> de objeto para el <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> método para hacer que las codificaciones adicionales admitidas por el proveedor de codificación disponible.  
  
 El <xref:System.Diagnostics.Process> clase, a continuación, usarán automáticamente la codificación predeterminada del sistema en lugar de UTF8, siempre que haya registrado el proveedor de codificación antes de llamar a cualquier <xref:System.Diagnostics.Process> métodos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa una instancia de la <xref:System.Diagnostics.Process> clase para iniciar un proceso.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 En el ejemplo siguiente se usa el <xref:System.Diagnostics.Process> clase propia y estático <xref:System.Diagnostics.Process.Start%2A> método para iniciar un proceso.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 El siguiente ejemplo de F # define un `runProc` función que inicia un proceso, captura toda la información de salida y error y registra el número de milisegundos que se ha ejecutado el proceso.  El `runProc` función tiene tres parámetros: el nombre de aplicación para iniciar, los argumentos para proporcionar a la aplicación y el directorio de inicio.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 El código para el `runProc` función fue escrita por [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) y está disponible en el [licencia pública de Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Esta clase no puede usarse por código de confianza parcial.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para plena confianza para los herederos. No se puede heredar esta clase por código de confianza parcial.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">Uso de la clase del proceso de .NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no especifica la <xref:System.Diagnostics.Process.MachineName%2A> propiedad, el valor predeterminado es el equipo local, (".").  
  
 Tiene dos opciones para asociar un nuevo <xref:System.Diagnostics.Process> componente con un proceso en el equipo. La primera opción es utilizar el constructor para crear el <xref:System.Diagnostics.Process> componente, establecer los miembros correspondientes de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llame a <xref:System.Diagnostics.Process.Start%2A> para asociar el <xref:System.Diagnostics.Process> con un nuevo proceso del sistema. La segunda opción consiste en asociar la <xref:System.Diagnostics.Process> con un proceso del sistema en ejecución mediante el uso de <xref:System.Diagnostics.Process.GetProcessById%2A> o uno de los <xref:System.Diagnostics.Process.GetProcesses%2A> devuelven valores.  
  
 Si usa un `static` sobrecarga de la <xref:System.Diagnostics.Process.Start%2A> crea un nuevo método para iniciar un nuevo proceso del sistema, el método <xref:System.Diagnostics.Process> componente y lo asocia con el proceso.  
  
 Cuando el <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> propiedad está establecida en su valor predeterminado, `true`, puede iniciar documentos y aplicaciones de manera que es similar a usar el `Run` cuadro de diálogo de la Windows `Start` menú. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> es `false`, puede iniciar archivos ejecutables.  
  
 Se puede iniciar cualquier archivo ejecutable que se puede llamar desde la línea de comandos de dos maneras: estableciendo los miembros correspondientes de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y una llamada a la <xref:System.Diagnostics.Process.Start%2A> método sin parámetros, o pasando el parámetro adecuado para el `static` <xref:System.Diagnostics.Process.Start%2A> miembro.  
  
 Puede crear un <xref:System.Diagnostics.Process> componente mediante el constructor, uno de los métodos estático <xref:System.Diagnostics.Process.Start%2A> sobrecargas o cualquiera de los <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, o <xref:System.Diagnostics.Process.GetProcessesByName%2A> métodos. Cuando termine, tendrá una vista en el proceso asociado. Esto no es una vista dinámica que se actualiza automáticamente cuando han cambiado las propiedades del proceso en la memoria. En su lugar, debe llamar a <xref:System.Diagnostics.Process.Refresh%2A> del componente actualizar la <xref:System.Diagnostics.Process> información de la propiedad en la aplicación.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la prioridad base del proceso asociado.</summary>
        <value>Prioridad base, que se calcula a partir de <see cref="P:System.Diagnostics.Process.PriorityClass" /> del proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.BasePriority%2A> del proceso es la prioridad inicial para los subprocesos creados dentro del proceso asociado. Puede ver información acerca de la prioridad base a través del contador de prioridad Base del Monitor de sistema.  
  
 Según el tiempo transcurrido o de otro aumenta, el sistema operativo, puede cambiar la prioridad base cuando un proceso debe colocarse delante de otros.  
  
 El <xref:System.Diagnostics.Process.BasePriority%2A> propiedad le permite ver la prioridad inicial asignada a un proceso. Sin embargo, dado que es de solo lectura, no se puede usar el <xref:System.Diagnostics.Process.BasePriority%2A> para establecer la prioridad del proceso. Para cambiar la prioridad, use el <xref:System.Diagnostics.Process.PriorityClass%2A> propiedad. El <xref:System.Diagnostics.Process.BasePriority%2A> pueden verse mediante el Monitor de sistema, mientras el <xref:System.Diagnostics.Process.PriorityClass%2A> no. Tanto el <xref:System.Diagnostics.Process.BasePriority%2A> y <xref:System.Diagnostics.Process.PriorityClass%2A> se pueden ver mediante programación. En la tabla siguiente se muestra la relación entre <xref:System.Diagnostics.Process.BasePriority%2A> valores y <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de la propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para obtener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ha terminado.  
  
O bien 
El proceso no se ha iniciado, por lo que no hay un identificador del proceso.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia las operaciones de lectura asincrónica en la secuencia de <see cref="P:System.Diagnostics.Process.StandardError" /> redirigida de la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.StandardError%2A> flujo se puede leer de forma sincrónica o asincrónica. Los métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, y <xref:System.IO.StreamReader.ReadToEnd%2A> realizar operaciones de lectura sincrónica en el flujo de salida de error del proceso. Estos sincrónica leer no lleva a cabo operaciones hasta que el asociado <xref:System.Diagnostics.Process> escribe en su <xref:System.Diagnostics.Process.StandardError%2A> transmitir o cierra la secuencia.  
  
 En cambio, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> las operaciones de lectura asincrónica comienza en el <xref:System.Diagnostics.Process.StandardError%2A> stream. Este método permite que el controlador de eventos designado para la salida de la secuencia y devuelve inmediatamente al llamador, que puede realizar otro trabajo mientras se dirige la salida de la secuencia al controlador de eventos.  
  
 Siga estos pasos para realizar operaciones de lectura asincrónica en <xref:System.Diagnostics.Process.StandardError%2A> para un <xref:System.Diagnostics.Process> :  
  
1.  Establezca <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> en `false`.  
  
2.  Establezca <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> en `true`.  
  
3.  Agregar el controlador de eventos para el <xref:System.Diagnostics.Process.ErrorDataReceived> eventos. El controlador de eventos debe coincidir con el <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> firma de delegado.  
  
4.  Iniciar el <xref:System.Diagnostics.Process>.  
  
5.  Llame a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para el <xref:System.Diagnostics.Process>. Esta llamada inicia las operaciones de lectura asincrónicas en <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Cuando se llama a start de operaciones de lectura asincrónica, el controlador de eventos cada vez asociado <xref:System.Diagnostics.Process> escribe una línea de texto a su <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
 Puede cancelar una operación de lectura asincrónica mediante una llamada a <xref:System.Diagnostics.Process.CancelErrorRead%2A>. La operación de lectura se puede cancelar el llamador o por el controlador de eventos. Después de cancelar, se puede llamar a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> nuevo para reanudar las operaciones de lectura asincrónicas.  
  
> [!NOTE]
>  No se pueden mezclar operaciones sincrónicas y asincrónicas de lectura en una secuencia redirigida. Una vez que la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas lectura aún más las operaciones en esa secuencia deben ser del mismo modo. Por ejemplo, no siga <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> con una llamada a <xref:System.IO.StreamReader.ReadLine%2A> en el <xref:System.Diagnostics.Process.StandardError%2A> secuencia, o viceversa. Sin embargo, puede leer dos secuencias diferentes en distintos modos. Por ejemplo, puede llamar a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> y, a continuación, llame a <xref:System.IO.StreamReader.ReadLine%2A> para el <xref:System.Diagnostics.Process.StandardOutput%2A> stream.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `net view` comando para enumerar los recursos de red disponibles en un equipo remoto. El usuario proporciona el nombre del equipo de destino como un argumento de línea de comandos. El usuario también puede proporcionar un nombre de archivo de salida de error. En el ejemplo se recopila la salida del comando net, espera a que el proceso finalice y, a continuación, escriben los resultados en la consola. Si el usuario proporciona el archivo de error opcional, el ejemplo escribe errores en el archivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> es <see langword="false" />.  
  
\- o - 
Ya hay una operación de lectura asincrónica en curso en la secuencia de <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
\- o - 
Una operación de lectura sincrónica ha utilizado la secuencia de <see cref="P:System.Diagnostics.Process.StandardError" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia las operaciones de lectura asincrónica en la secuencia de <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigida de la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.StandardOutput%2A> flujo se puede leer de forma sincrónica o asincrónica. Los métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, y <xref:System.IO.StreamReader.ReadToEnd%2A> realizar operaciones de lectura sincrónica en el flujo de salida del proceso. Estos sincrónica leer no lleva a cabo operaciones hasta que el asociado <xref:System.Diagnostics.Process> escribe en su <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir o cierra la secuencia.  
  
 En cambio, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> las operaciones de lectura asincrónica comienza en el <xref:System.Diagnostics.Process.StandardOutput%2A> stream. Este método permite que un controlador de eventos designado para la salida de la secuencia y devuelve inmediatamente al llamador, que puede realizar otro trabajo mientras se dirige la salida de la secuencia al controlador de eventos.  
  
 Siga estos pasos para realizar operaciones de lectura asincrónica en <xref:System.Diagnostics.Process.StandardOutput%2A> para un <xref:System.Diagnostics.Process> :  
  
1.  Establezca <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> en `false`.  
  
2.  Establezca <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> en `true`.  
  
3.  Agregar el controlador de eventos para el <xref:System.Diagnostics.Process.OutputDataReceived> eventos. El controlador de eventos debe coincidir con el <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> firma de delegado.  
  
4.  Iniciar el <xref:System.Diagnostics.Process>.  
  
5.  Llame a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para el <xref:System.Diagnostics.Process>. Esta llamada inicia las operaciones de lectura asincrónicas en <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Cuando se llama a start de operaciones de lectura asincrónica, el controlador de eventos cada vez asociado <xref:System.Diagnostics.Process> escribe una línea de texto a su <xref:System.Diagnostics.Process.StandardOutput%2A> stream.  
  
 Puede cancelar una operación de lectura asincrónica mediante una llamada a <xref:System.Diagnostics.Process.CancelOutputRead%2A>. La operación de lectura se puede cancelar el llamador o por el controlador de eventos. Después de cancelar, se puede llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> nuevo para reanudar las operaciones de lectura asincrónicas.  
  
> [!NOTE]
>  No se pueden mezclar operaciones sincrónicas y asincrónicas de lectura en una secuencia redirigida. Una vez que la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas lectura aún más las operaciones en esa secuencia deben ser del mismo modo. Por ejemplo, no siga <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> con una llamada a <xref:System.IO.StreamReader.ReadLine%2A> en el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia, o viceversa. Sin embargo, puede leer dos secuencias diferentes en distintos modos. Por ejemplo, puede llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> y, a continuación, llame a <xref:System.IO.StreamReader.ReadLine%2A> para el <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo realizar operaciones de lectura asincrónica en la redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia de la `sort` comando. El `sort` comando es una aplicación de consola que lee y ordena la entrada de texto.  
  
 El ejemplo crea un delegado de eventos para el `SortOutputHandler` controlador de eventos y lo asocia a la <xref:System.Diagnostics.Process.OutputDataReceived> eventos. El controlador de eventos recibe líneas de texto de la redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> stream, da formato al texto y escribe el texto en la pantalla.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> es <see langword="false" />.  
  
\- o - 
Ya hay una operación de lectura asincrónica en curso en la secuencia de <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
\- o - 
Una operación de lectura sincrónica ha utilizado la secuencia de <see cref="P:System.Diagnostics.Process.StandardOutput" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela la operación de lectura asincrónica en la secuencia redirigida de <see cref="P:System.Diagnostics.Process.StandardError" /> de una aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> se inicia una operación de lectura asincrónica en la <xref:System.Diagnostics.Process.StandardError%2A> stream. <xref:System.Diagnostics.Process.CancelErrorRead%2A> finaliza la operación de lectura asincrónica.  
  
 Después de cancelar, se puede reanudar la operación de lectura asincrónica llamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> nuevo.  
  
 Cuando se llama a <xref:System.Diagnostics.Process.CancelErrorRead%2A>, todas las operaciones de lectura de en curso <xref:System.Diagnostics.Process.StandardError%2A> se completan y, a continuación, se deshabilita el controlador de eventos. Todos aún más redirigen la salida a <xref:System.Diagnostics.Process.StandardError%2A> se guardan en un búfer. Si volver a habilitar el controlador de eventos con una llamada a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, se envían los resultados guardados para el controlador de eventos y reanudan las operaciones de lectura asincrónicas. Si desea cambiar el controlador de eventos antes de reanudar las operaciones de lectura asincrónicas, debe quitar el controlador de eventos existente antes de agregar el nuevo controlador de eventos:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  No se pueden mezclar las operaciones de lectura sincrónicas y asincrónicas en el redirigida <xref:System.Diagnostics.Process.StandardError%2A> stream. Una vez que la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas lectura aún más las operaciones en esa secuencia deben ser del mismo modo. Si se cancela una operación de lectura asincrónica en <xref:System.Diagnostics.Process.StandardError%2A> y, a continuación, debe volver a leer desde el flujo, debe usar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para reanudar las operaciones de lectura asincrónicas. No siga <xref:System.Diagnostics.Process.CancelErrorRead%2A> con una llamada a la sincrónica, lea los métodos de <xref:System.Diagnostics.Process.StandardError%2A> como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia el `nmake` comando con el usuario los argumentos proporcionados. Los flujos de error y de salida se leen de forma asincrónica; las líneas de texto recopilados se muestra en la consola, así como escritas en un archivo de registro. Si la salida del comando supera un número especificado de líneas, se cancelan las operaciones de lectura asincrónicas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La secuencia de <see cref="P:System.Diagnostics.Process.StandardError" /> no está habilitada para las operaciones de lectura asincrónica.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela la operación de lectura asincrónica en la secuencia redirigida de <see cref="P:System.Diagnostics.Process.StandardOutput" /> de una aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> se inicia una operación de lectura asincrónica en la <xref:System.Diagnostics.Process.StandardOutput%2A> stream. <xref:System.Diagnostics.Process.CancelOutputRead%2A> finaliza la operación de lectura asincrónica.  
  
 Después de cancelar, puede reanudar las operaciones de lectura asincrónicas llamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> nuevo.  
  
 Cuando se llama a <xref:System.Diagnostics.Process.CancelOutputRead%2A>, todas las operaciones de lectura de en curso <xref:System.Diagnostics.Process.StandardOutput%2A> se completan y, a continuación, se deshabilita el controlador de eventos. Todos aún más redirigen la salida a <xref:System.Diagnostics.Process.StandardOutput%2A> se guardan en un búfer. Si volver a habilitar el controlador de eventos con una llamada a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, se envían los resultados guardados para el controlador de eventos y reanudan las operaciones de lectura asincrónicas. Si desea cambiar el controlador de eventos antes de reanudar las operaciones de lectura asincrónicas, debe quitar el controlador de eventos existente antes de agregar el nuevo controlador de eventos:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  No se pueden mezclar las operaciones de lectura sincrónicas y asincrónicas en el redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> stream. Una vez que la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas lectura aún más las operaciones en esa secuencia deben ser del mismo modo. Si se cancela una operación de lectura asincrónica en <xref:System.Diagnostics.Process.StandardOutput%2A> y, a continuación, debe volver a leer desde el flujo, debe usar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para reanudar las operaciones de lectura asincrónicas. No siga <xref:System.Diagnostics.Process.CancelOutputRead%2A> con una llamada a la sincrónica, lea los métodos de <xref:System.Diagnostics.Process.StandardOutput%2A> como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, o <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia el `nmake` comando con el usuario los argumentos proporcionados. Los flujos de error y de salida se leen de forma asincrónica; las líneas de texto recopilados se muestra en la consola, así como escritas en un archivo de registro. Si la salida del comando supera un número especificado de líneas, se cancelan las operaciones de lectura asincrónicas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La secuencia de <see cref="P:System.Diagnostics.Process.StandardOutput" /> no está habilitada para las operaciones de lectura asincrónica.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos asociados a este componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.Close%2A> método hace que el proceso detener la espera para salir si lo estaba esperando, cierra el identificador de proceso y borra las propiedades específicas del proceso. <xref:System.Diagnostics.Process.Close%2A> no cierra los lectores de error, entrada y salida estándares y escritores en caso de que se hace referencia externamente.  
  
> [!NOTE]
>  El método <xref:System.Diagnostics.Process.Dispose%2A> llama a <xref:System.Diagnostics.Process.Close%2A>. Colocar el <xref:System.Diagnostics.Process> objeto en un `using` bloque elimina los recursos sin necesidad de llamar a <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. A continuación, se recupera el uso de memoria física del proceso asociado a intervalos de 2 segundos durante un máximo de 10 segundos. El ejemplo detecta si el proceso se cierra antes de transcurridos 10 segundos. El ejemplo cierra el proceso si se está ejecutando todavía después de 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra un proceso que contiene una interfaz de usuario mediante el envío de un mensaje de cierre a su ventana principal.</summary>
        <returns>Es <see langword="true" /> si el mensaje de cierre se envió correctamente; es <see langword="false" /> si el proceso asociado no tiene una ventana principal o si la ventana principal está deshabilitada (por ejemplo, si se está mostrando un cuadro de diálogo modal).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se está ejecutando un proceso, el bucle de mensajes está en un estado de espera. El bucle de mensajes se ejecuta cada vez que se envía un mensaje de Windows para el proceso por el sistema operativo. Una llamada a <xref:System.Diagnostics.Process.CloseMainWindow%2A> envía una solicitud a cerca de la ventana principal, que, en una aplicación tiene el formato correcto, cierre las ventanas secundarias y revoca la ejecución de todos los bucles de mensajes para la aplicación. La solicitud para salir del proceso mediante una llamada a <xref:System.Diagnostics.Process.CloseMainWindow%2A> no fuerza la aplicación se cierre. La aplicación puede pedir confirmación del usuario antes de salir, o puede rechazar salir. Para forzar la aplicación para salir, use el <xref:System.Diagnostics.Process.Kill%2A> método. El comportamiento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> es idéntico de un usuario cierra la ventana principal de la aplicación mediante el menú del sistema. Por lo tanto, la solicitud para salir del proceso al cerrar la ventana principal no obliga a la aplicación a salir inmediatamente.  
  
 Los datos modificados por el proceso o los recursos asignados al proceso pueden perderse si se llama a <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> provoca una terminación anómala del proceso y debe usarse solo cuando sea necesario. <xref:System.Diagnostics.Process.CloseMainWindow%2A> habilita una finalización ordenada del proceso y cierra todas las ventanas, por lo que es preferible para las aplicaciones con una interfaz. Si <xref:System.Diagnostics.Process.CloseMainWindow%2A> se produce un error, puede usar <xref:System.Diagnostics.Process.Kill%2A> para finalizar el proceso. <xref:System.Diagnostics.Process.Kill%2A> es la única forma de terminar los procesos que no tienen interfaces gráficas.  
  
 Puede llamar a <xref:System.Diagnostics.Process.Kill%2A> y <xref:System.Diagnostics.Process.CloseMainWindow%2A> únicamente para los procesos que se ejecutan en el equipo local. No puede hacer que los procesos en equipos remotos para salir. Solo se puede ver información de los procesos que se ejecutan en equipos remotos.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. A continuación, se recupera el uso de memoria física del proceso asociado a 2 intervalos de segundos durante un máximo de 10 segundos. El ejemplo detecta si el proceso se cierra antes de transcurridos 10 segundos. El ejemplo cierra el proceso si se está ejecutando todavía después de 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de la propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para obtener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya se cerró.  
  
O bien 
No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera todos los recursos utilizados por este proceso.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece si el evento <see cref="E:System.Diagnostics.Process.Exited" /> debe provocarse cuando termine el proceso.</summary>
        <value>Es <see langword="true" /> si el evento <see cref="E:System.Diagnostics.Process.Exited" /> debe provocarse cuando termine el proceso asociado (al salir o al llamar a <see cref="M:System.Diagnostics.Process.Kill" />); de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />. Tenga en cuenta que el <see cref="E:System.Diagnostics.Process.Exited" /> evento se desencadena incluso si el valor de <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> es <see langword="false" /> cuando el proceso se cierra durante o antes de que el usuario realice un <see cref="P:System.Diagnostics.Process.HasExited" /> comprobar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
El <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad sugiere si el componente debe recibir una notificación cuando el sistema operativo ha cerrado un proceso. El <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad se utiliza en el procesamiento asincrónico para notificar a la aplicación que un proceso ha terminado. Para forzar que la aplicación para que espere un evento de cierre (que interrumpa el procesamiento de la aplicación hasta que se ha producido el evento de salida) de forma sincrónica, use el <xref:System.Diagnostics.Process.WaitForExit%2A> método.

> [!NOTE]
> Si está utilizando Visual Studio y haga doble clic en un <xref:System.Diagnostics.Process> componente en el proyecto, un <xref:System.Diagnostics.Process.Exited> delegado de evento y controlador de eventos se generan automáticamente. Conjuntos de código adicional del <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad `false`. Debe cambiar esta propiedad en `true` para que el controlador de eventos que se ejecuta cuando se cierra el proceso asociado.

Si el componente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> valor es `true`, o cuando <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> es `false` y un <xref:System.Diagnostics.Process.HasExited%2A> comprobación se invoca el componente, el componente puede tener acceso a la información administrativa para el proceso asociado, que permanece almacena el sistema operativo. Dicha información incluye el <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.ExitCode%2A>.

Después de que termine el proceso asociado, el <xref:System.Diagnostics.Process.Handle%2A> del componente ya no apunta a un recurso de proceso existente. En su lugar, sólo puede utilizarse para tener acceso a información del sistema operativo sobre el recurso de proceso. El sistema operativo es saber que hay identificadores de procesos terminados que aún no ha lanzado <xref:System.Diagnostics.Process> componentes, por lo que mantiene la <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.Handle%2A> información en la memoria.

Hay un costo asociado siguiendo un proceso termine. Si <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> es `true`, el <xref:System.Diagnostics.Process.Exited> evento se produce cuando finaliza el proceso asociado. Los procedimientos para la <xref:System.Diagnostics.Process.Exited> eventos que se ejecutan en ese momento.

A veces, la aplicación inicia un proceso, pero no requiere la notificación de su cierre. Por ejemplo, la aplicación puede iniciar el Bloc de notas para permitir al usuario realizar la edición de texto pero no hacer uso de la aplicación en el Bloc de notas. Puede elegir evitar la notificación cuando se cierra el proceso porque no es relevante para el funcionamiento continuo de la aplicación. Establecer <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> a `false` puede ahorrar recursos del sistema.

## Examples  
En el ejemplo de código siguiente se crea un proceso que imprime un archivo. Establece el <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad que hace que el proceso generar el <xref:System.Diagnostics.Process.Exited> eventos cuando se cierra. El <xref:System.Diagnostics.Process.Exited> controlador de eventos muestra información de proceso.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Coloca un componente <see cref="T:System.Diagnostics.Process" /> en estado de interacción con los procesos del sistema operativo que se ejecutan en un modo especial; para ello, habilita la propiedad nativa <see langword="SeDebugPrivilege" /> en el actual subproceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos procesos del sistema operativo se ejecutan en un modo especial. Intentar leer las propiedades de o asociar a estos procesos no es posible a menos que se ha llamado <xref:System.Diagnostics.Process.EnterDebugMode%2A> en el componente. Llamar a <xref:System.Diagnostics.Process.LeaveDebugMode%2A> cuando ya no necesita acceso a estos procesos que se ejecutan en modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando una aplicación escribe en su secuencia redirigida de <see cref="P:System.Diagnostics.Process.StandardError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.ErrorDataReceived> evento indica que el proceso asociado ha escrito en su redirigida <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
 El evento sólo se produce durante las operaciones de lectura asincrónicas en <xref:System.Diagnostics.Process.StandardError%2A>. Para iniciar operaciones de lectura asincrónica, debe redirigir el <xref:System.Diagnostics.Process.StandardError%2A> secuencia de un <xref:System.Diagnostics.Process>, agregar el controlador de eventos para el <xref:System.Diagnostics.Process.ErrorDataReceived> evento y llamar a <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. A partir de entonces, el <xref:System.Diagnostics.Process.ErrorDataReceived> las señales de eventos cada vez que el proceso escribe una línea en el redirigida <xref:System.Diagnostics.Process.StandardError%2A> transmitir, hasta que el proceso se cierra o se llama <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  La aplicación que se está procesando la salida asincrónica debe llamar a la <xref:System.Diagnostics.Process.WaitForExit> método para asegurarse de que se ha vaciado el búfer de salida. Tenga en cuenta que si se especifica un tiempo de espera mediante el uso de la <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> sobrecarga *no* asegurarse de que se ha vaciado el búfer de salida.
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `net view` comando para enumerar los recursos de red disponibles en un equipo remoto. El usuario proporciona el nombre del equipo de destino como un argumento de línea de comandos. El usuario también puede proporcionar un nombre de archivo de salida de error. En el ejemplo se recopila la salida del comando net, espera a que el proceso finalice y, a continuación, escriben los resultados en la consola. Si el usuario proporciona el archivo de error opcional, el ejemplo escribe errores en el archivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor especificado por el proceso asociado al terminar.</summary>
        <value>Código especificado por el proceso asociado al terminar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.ExitCode%2A> para obtener el estado devuelto por el proceso del sistema al terminar. Puede usar el código de salida mucho, como un valor de entero devuelto una `main()` procedimiento.  
  
 El <xref:System.Diagnostics.Process.ExitCode%2A> el valor de un proceso refleja la convención específica implementada por el desarrollador de aplicaciones para ese proceso. Si usa el valor del código de salida para tomar decisiones en el código, asegúrese de que conoce la convención de código de salida usada por el proceso de aplicación.  
  
 Los desarrolladores suelen indican una salida correcta por un <xref:System.Diagnostics.Process.ExitCode%2A> valor de cero y designar errores por valores distintos de cero que se puede usar el método de llamada para identificar la causa de una terminación anómala del proceso. No es necesario seguir estas directrices, pero son la convención.  
  
 Si se intenta obtener el <xref:System.Diagnostics.Process.ExitCode%2A> antes de que el proceso ha terminado, el intento produce una excepción. Examine el <xref:System.Diagnostics.Process.HasExited%2A> propiedad primero para comprobar si el proceso asociado ha terminado.  
  
> [!NOTE]
>  Cuando se ha redirigido la salida estándar para controladores de eventos asincrónicos, es posible que el procesamiento de salida no se haya completado cuando <xref:System.Diagnostics.Process.HasExited%2A> devuelve `true`. Para asegurarse de que se ha completado el control de eventos asincrónicos, llame a la <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que no toma ningún parámetro antes de comprobar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Puede usar el <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A> método para hacer que un proceso asociado termine.  
  
 Hay dos maneras de recibir notificaciones cuando se cierra el proceso asociado: sincrónica y asincrónica. La notificación sincrónica se basa en una llamada la <xref:System.Diagnostics.Process.WaitForExit%2A> método para detener el procesamiento de la aplicación hasta que se cierra el componente asociado. Notificación asincrónica se basa en el <xref:System.Diagnostics.Process.Exited> eventos. Cuando se usa la notificación asincrónica, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> debe establecerse en `true` para el <xref:System.Diagnostics.Process> componente para recibir la notificación de que el proceso ha terminado.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El proceso no ha terminado.  
  
O bien 
El proceso <see cref="P:System.Diagnostics.Process.Handle" /> no es válido.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.ExitCode" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando termina un proceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.Exited> evento indica que el proceso asociado ha terminado. Este suceso significa que el proceso finalizado (anula) o cerrado correctamente. Este evento sólo puede producirse si el valor de la <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad es `true`.  
  
 Hay dos maneras de recibir notificaciones cuando se cierra el proceso asociado: sincrónica y asincrónica. La notificación sincrónica significa llamar a la <xref:System.Diagnostics.Process.WaitForExit%2A> método para bloquear el subproceso actual hasta que finaliza el proceso. Notificación asincrónica usa el <xref:System.Diagnostics.Process.Exited> evento, que permite que el subproceso que realiza la llamada continuar la ejecución mientras tanto. En el último caso, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> debe establecerse en `true` para la aplicación que realiza la llamada para recibir el evento cerrado.  
  
 Cuando el sistema operativo se cierra un proceso, notifica a todos los demás procesos que se han registrado los controladores para el evento cerrado. En este momento, el identificador del proceso que acaba de salir puede utilizarse para tener acceso a algunas propiedades como <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.HasExited%2A> que el sistema operativo mantiene hasta que lo libera completamente ese identificador.  
  
> [!NOTE]
>  Incluso si tiene un identificador de un proceso terminado, no puede llamar a <xref:System.Diagnostics.Process.Start%2A> nuevo para volver a conectar con el mismo proceso. Una llamada a <xref:System.Diagnostics.Process.Start%2A> automáticamente libera el proceso asociado y se conecta a un proceso con el mismo archivo pero totalmente nueva <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Para obtener más información sobre el uso de la <xref:System.Diagnostics.Process.Exited> eventos en aplicaciones de Windows Forms, vea el <xref:System.Diagnostics.Process.SynchronizingObject%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un proceso que imprime un archivo. Genera el <xref:System.Diagnostics.Process.Exited> evento cuando finaliza el proceso porque el <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propiedad se estableció cuando creó el proceso. El <xref:System.Diagnostics.Process.Exited> controlador de eventos muestra información de proceso.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el momento en el que terminó el proceso asociado.</summary>
        <value>
          <see cref="T:System.DateTime" /> indica cuándo terminó el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no ha terminado el proceso, intenta recuperar el <xref:System.Diagnostics.Process.ExitTime%2A> propiedad produce una excepción. Use <xref:System.Diagnostics.Process.HasExited%2A> antes de obtener el <xref:System.Diagnostics.Process.ExitTime%2A> propiedad para determinar si el proceso asociado ha finalizado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un proceso que imprime un archivo. El proceso provoca la <xref:System.Diagnostics.Process.Exited> eventos cuando se cierra y el controlador de eventos se muestra el <xref:System.Diagnostics.Process.ExitTime%2A> procesan la propiedad y otra información.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <exception cref="T:System.NotSupportedException">Está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.ExitTime" /> de un proceso que se ejecuta en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un nuevo componente <see cref="T:System.Diagnostics.Process" /> y lo asocia al proceso que está activo en ese momento.</summary>
        <returns>Nuevo componente <see cref="T:System.Diagnostics.Process" /> que está asociado al recurso del proceso que se está ejecutando en la aplicación que realiza la llamada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un nuevo <xref:System.Diagnostics.Process> de instancia y su asociación con el recurso de proceso en el equipo local.  
  
 Al igual que el similar <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, y <xref:System.Diagnostics.Process.GetProcesses%2A> métodos, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> asocia un recurso existente a un nuevo <xref:System.Diagnostics.Process> componente.  
  
   
  
## Examples  
 El ejemplo siguiente recupera información del proceso actual, los procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo componente <see cref="T:System.Diagnostics.Process" /> y lo asocia al recurso de proceso existente que se especifique.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">Identificador de un recurso de proceso único en el sistema.</param>
        <summary>Devuelve un nuevo componente <see cref="T:System.Diagnostics.Process" />, dado un identificador de un proceso en el equipo local.</summary>
        <returns>Componente <see cref="T:System.Diagnostics.Process" /> asociado al recurso del proceso local que se identifica mediante el parámetro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un nuevo <xref:System.Diagnostics.Process> componente y asociarla a un recurso de proceso en el equipo local. El recurso del proceso ya debe existir en el equipo, porque <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> no crea un recurso del sistema, sino que asocia un recurso a una aplicación generada <xref:System.Diagnostics.Process> componente. Un proceso <xref:System.Diagnostics.Process.Id%2A> se puede recuperar solo para un proceso que se está ejecutando actualmente en el equipo. Después de que finalice el proceso, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> produce una excepción si se le pasa un identificador caducado.  
  
 En cualquier equipo en particular, el identificador de un proceso es único. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Devuelve un proceso como máximo. Si desea obtener todos los procesos que ejecutan una aplicación concreta, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Si existen varios procesos en el equipo que ejecuta la aplicación especificada, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> devuelve una matriz que contiene todos los procesos asociados. Puede consultar cada uno de estos procesos a su vez para obtener su identificador. El identificador de proceso se puede ver en el `Processes` panel del Administrador de tareas de Windows. La `PID` columna muestra el identificador de proceso que se asigna a un proceso.  
  
 El `processId` parámetro es un <xref:System.Int32> (un entero 32 bits con signo), aunque la API de Windows subyacente utiliza un `DWORD` (un entero de 32 bits sin signo) para API similares. Esto es por motivos históricos.
  
## Examples  
 El ejemplo siguiente recupera información del proceso actual, los procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El proceso especificado por el parámetro <paramref name="processId" /> no se está ejecutando. Es posible que el identificador haya expirado.</exception>
        <exception cref="T:System.InvalidOperationException">Este objeto no inició el proceso.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">Identificador de un recurso de proceso único en el sistema.</param>
        <param name="machineName">Nombre de un equipo en la red.</param>
        <summary>Devuelve un nuevo componente <see cref="T:System.Diagnostics.Process" />, dados un identificador de proceso y el nombre de un equipo en la red.</summary>
        <returns>Componente <see cref="T:System.Diagnostics.Process" /> asociado a un recurso de proceso remoto que se identifica mediante el parámetro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un nuevo <xref:System.Diagnostics.Process> componente y asociarla a un recurso de proceso en un equipo remoto en la red. El recurso del proceso ya debe existir en el equipo especificado, porque <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> no crea un recurso del sistema, sino que asocia un recurso a una aplicación generada <xref:System.Diagnostics.Process> componente. Un proceso <xref:System.Diagnostics.Process.Id%2A> se puede recuperar solo para un proceso que se está ejecutando actualmente en el equipo. Después de que finalice el proceso, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> produce una excepción si se le pasa un identificador caducado.  
  
 En cualquier equipo en particular, el identificador de un proceso es único. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Devuelve un proceso como máximo. Si desea obtener todos los procesos que ejecutan una aplicación concreta, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Si existen varios procesos en el equipo que ejecuta la aplicación especificada, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> devuelve una matriz que contiene todos los procesos asociados. Puede consultar cada uno de estos procesos a su vez para obtener su identificador. El identificador de proceso se puede ver en el `Processes` panel del Administrador de tareas de Windows. La `PID` columna muestra el identificador de proceso que se asigna a un proceso.  
  
 Si no especifica un `machineName`, se usa el equipo local. Como alternativa, puede especificar el equipo local estableciendo `machineName` en el valor "." o en una cadena vacía ("").  
  
 El `processId` parámetro es un <xref:System.Int32> (un entero 32 bits con signo), aunque la API de Windows subyacente utiliza un `DWORD` (un entero de 32 bits sin signo) para API similares. Esto es por motivos históricos.   
  
## Examples  
 El ejemplo siguiente recupera información del proceso actual, los procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El proceso especificado por el parámetro <paramref name="processId" /> no se está ejecutando. Puede que el identificador haya expirado.  
  
O bien 
La sintaxis del parámetro <paramref name="machineName" /> no es válida. El nombre puede tener longitud cero (0).</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="machineName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Este objeto no inició el proceso.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matriz de nuevos componentes <see cref="T:System.Diagnostics.Process" /> y los asocia a recursos de proceso existentes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo componente <see cref="T:System.Diagnostics.Process" /> para cada recurso de proceso del equipo local.</summary>
        <returns>Matriz de tipo <see cref="T:System.Diagnostics.Process" /> que representa todos los recursos del proceso que se ejecutan en el equipo local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para crear una matriz de nuevos <xref:System.Diagnostics.Process> componentes y asociarlos a todos los recursos de proceso en el equipo local. Los recursos de proceso ya deben existir en el equipo local, porque <xref:System.Diagnostics.Process.GetProcesses%2A> no crea los recursos del sistema, sino que asocia los recursos generados por la aplicación <xref:System.Diagnostics.Process> componentes. Dado que el propio sistema operativo se está ejecutando procesos en segundo plano, esta matriz nunca está vacía.  
  
 Si no desea recuperar todos los procesos en ejecución en el equipo, puede limitar su número utilizando el <xref:System.Diagnostics.Process.GetProcessById%2A> o <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> crea un <xref:System.Diagnostics.Process> componente que está asociado con el proceso identificado en el sistema mediante el identificador de proceso que se pasa al método. <xref:System.Diagnostics.Process.GetProcessesByName%2A> crea una matriz de <xref:System.Diagnostics.Process> componentes cuyos recursos de proceso asociados comparten el archivo ejecutable se pasa al método.  
  
> [!NOTE]
>  Varios servicios de Windows se pueden cargar en la misma instancia del proceso de Host de servicios (svchost.exe). GetProcesses no identifica a los servicios individuales; Para ello, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente recupera información del proceso actual, los procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Equipo desde el que se lee la lista de procesos.</param>
        <summary>Crea un nuevo componente <see cref="T:System.Diagnostics.Process" /> para cada recurso de proceso en el equipo especificado.</summary>
        <returns>Matriz de tipo <see cref="T:System.Diagnostics.Process" /> que representa todos los recursos del proceso que se ejecutan en el equipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para crear una matriz de nuevos <xref:System.Diagnostics.Process> componentes y asociarlos a todos los recursos de proceso en el equipo especificado (normalmente remoto). Los recursos de proceso ya deben existir en el equipo local, porque <xref:System.Diagnostics.Process.GetProcesses%2A> no crea los recursos del sistema, sino que asocia los recursos generados por la aplicación <xref:System.Diagnostics.Process> componentes. Dado que el propio sistema operativo se está ejecutando procesos en segundo plano, esta matriz nunca está vacía.  
  
 Si no desea recuperar todos los procesos en ejecución en el equipo, puede limitar su número utilizando el <xref:System.Diagnostics.Process.GetProcessById%2A> o <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> crea un <xref:System.Diagnostics.Process> componente que está asociado con el proceso identificado en el sistema mediante el identificador de proceso que se pasa al método. <xref:System.Diagnostics.Process.GetProcessesByName%2A> crea una matriz de <xref:System.Diagnostics.Process> componentes cuyos recursos de proceso asociados comparten el archivo ejecutable se pasa al método.  
  
 Esta sobrecarga de la <xref:System.Diagnostics.Process.GetProcesses%2A> método generalmente se usa para recuperar la lista de recursos de proceso que se ejecutan en un equipo remoto en la red, pero puede especificar el equipo local, pasando ".".  
  
> [!NOTE]
>  Varios servicios de Windows se pueden cargar en la misma instancia del proceso de Host de servicios (svchost.exe). GetProcesses no identifica a los servicios individuales; Para ello, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente recupera información del proceso actual, los procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintaxis del parámetro <paramref name="machineName" /> no es válida. Puede tener longitud cero (0).</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="machineName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma del sistema operativo no admite esta operación en equipos remotos.</exception>
        <exception cref="T:System.InvalidOperationException">Hay problemas de acceso a la API de contadores de rendimiento utilizada para obtener información sobre procesos. Esta excepción es específica de Windows NT, Windows 2000 y Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Hubo un problema al intentar obtener acceso a una API del sistema subyacente.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una matriz de nuevos componentes <see cref="T:System.Diagnostics.Process" /> y los asocia a los recursos de proceso existentes que comparten el nombre del proceso especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Nombre descriptivo del proceso.</param>
        <summary>Crea una matriz de nuevos componentes <see cref="T:System.Diagnostics.Process" /> y los asocia a todos los recursos de proceso del equipo local que comparten el nombre de proceso especificado.</summary>
        <returns>Matriz de tipo <see cref="T:System.Diagnostics.Process" /> que representa los recursos del proceso que ejecutan la aplicación o el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para crear una matriz de nuevos <xref:System.Diagnostics.Process> componentes y asociarlos a todos los recursos de proceso que ejecutan el mismo archivo ejecutable en el equipo local. Los recursos de proceso ya deben existir en el equipo, porque <xref:System.Diagnostics.Process.GetProcessesByName%2A> no crea los recursos del sistema, sino que asocia los generados por la aplicación <xref:System.Diagnostics.Process> componentes. Un `processName` se puede especificar un archivo ejecutable que no se está ejecutando en el equipo local, por lo que la matriz que devuelve el método puede estar vacía.  
  
 El nombre del proceso es un nombre descriptivo para el proceso, como Outlook, que no incluye la extensión .exe ni la ruta de acceso. <xref:System.Diagnostics.Process.GetProcessesByName%2A> es útil para obtener y manipular todos los procesos que están asociados con el mismo archivo ejecutable. Por ejemplo, puede pasar un nombre de archivo ejecutable como el `processName` parámetro con el fin de cerrar todas las instancias en ejecución de ese archivo.  
  
 Aunque un proceso <xref:System.Diagnostics.Process.Id%2A> es único en un recurso de proceso en el sistema, varios procesos en el equipo local pueden ejecutar la aplicación especificada por el `processName` parámetro. Por lo tanto, <xref:System.Diagnostics.Process.GetProcessById%2A> devuelve un proceso a lo sumo, pero <xref:System.Diagnostics.Process.GetProcessesByName%2A> devuelve una matriz que contiene todos los procesos asociados. Si necesita manipular el proceso con llamadas API estándar, puede consultar cada uno de estos procesos a su vez para obtener su identificador. No se puede obtener acceso a recursos de proceso a través del nombre de proceso por sí sola pero, una vez que haya recuperado una matriz de <xref:System.Diagnostics.Process> componentes que se han asociado con los recursos de proceso, puede iniciar, finalizar y manipular los recursos del sistema.  
  
   
  
## Examples  
 El ejemplo siguiente recupera información del proceso actual, los procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Hay problemas de acceso a la API de contadores de rendimiento utilizada para obtener información sobre procesos. Esta excepción es específica de Windows NT, Windows 2000 y Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">Nombre descriptivo del proceso.</param>
        <param name="machineName">Nombre de un equipo en la red.</param>
        <summary>Crea una matriz de nuevos componentes <see cref="T:System.Diagnostics.Process" /> y los asocia a todos los recursos de proceso de un equipo remoto que comparten el nombre del proceso especificado.</summary>
        <returns>Matriz de tipo <see cref="T:System.Diagnostics.Process" /> que representa los recursos del proceso que ejecutan la aplicación o el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para crear una matriz de nuevos <xref:System.Diagnostics.Process> componentes y asociarlos a todos los recursos de proceso que ejecutan el mismo archivo ejecutable en el equipo especificado. Los recursos de proceso ya deben existir en el equipo, porque <xref:System.Diagnostics.Process.GetProcessesByName%2A> no crea los recursos del sistema, sino que asocia los generados por la aplicación <xref:System.Diagnostics.Process> componentes. Un `processName` se puede especificar un archivo ejecutable que no se está ejecutando en el equipo local, por lo que la matriz que devuelve el método puede estar vacía.  
  
 El nombre del proceso es un nombre descriptivo para el proceso, como Outlook, que no incluye la extensión .exe ni la ruta de acceso. <xref:System.Diagnostics.Process.GetProcessesByName%2A> es útil para obtener y manipular todos los procesos que están asociados con el mismo archivo ejecutable. Por ejemplo, puede pasar un nombre de archivo ejecutable como el `processName` parámetro con el fin de cerrar todas las instancias en ejecución de ese archivo.  
  
 Aunque un proceso <xref:System.Diagnostics.Process.Id%2A> es único en un recurso de proceso en el sistema, varios procesos en el equipo local pueden ejecutar la aplicación especificada por el `processName` parámetro. Por lo tanto, <xref:System.Diagnostics.Process.GetProcessById%2A> devuelve un proceso a lo sumo, pero <xref:System.Diagnostics.Process.GetProcessesByName%2A> devuelve una matriz que contiene todos los procesos asociados. Si necesita manipular el proceso con llamadas API estándar, puede consultar cada uno de estos procesos a su vez para obtener su identificador. No se puede obtener acceso a recursos de proceso a través del nombre de proceso por sí sola pero, una vez que haya recuperado una matriz de <xref:System.Diagnostics.Process> componentes que se han asociado con los recursos de proceso, puede iniciar, finalizar y manipular los recursos del sistema.  
  
 Puede utilizar esta sobrecarga para obtener procesos en el equipo local, así como en un equipo remoto. Use "." para especificar el equipo local. Existe otra sobrecarga que utiliza el equipo local de forma predeterminada.  
  
 Puede tener acceso a los procesos en equipos remotos solo para ver información sobre los procesos, por ejemplo, estadísticas. No se puede cerrar, terminar (mediante <xref:System.Diagnostics.Process.Kill%2A>), o iniciar procesos en equipos remotos.  
  
   
  
## Examples  
 El ejemplo siguiente recupera información del proceso actual, los procesos que se ejecutan en el equipo local, todas las instancias del Bloc de notas que se ejecutan en el equipo local y un proceso específico en el equipo local. A continuación, recupera información de los mismos procesos en un equipo remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La sintaxis del parámetro <paramref name="machineName" /> no es válida. Puede tener longitud cero (0).</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="machineName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma del sistema operativo no admite esta operación en equipos remotos.</exception>
        <exception cref="T:System.InvalidOperationException">Hay problemas de acceso a la API de contadores de rendimiento utilizada para obtener información sobre procesos. Esta excepción es específica de Windows NT, Windows 2000 y Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Hubo un problema al intentar obtener acceso a una API del sistema subyacente.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador nativo del proceso asociado.</summary>
        <value>Identificador que el sistema operativo asignó al proceso asociado cuando éste se inició. El sistema utiliza este identificador para hacer un seguimiento de los atributos del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación puede obtener un identificador a un proceso que se puede usar como un parámetro para muchas funciones de control e información del proceso. Puede usar este identificador para inicializar un <xref:System.Threading.WaitHandle> o para llamar a métodos nativos con plataforma de invocación.  
  
 Este identificador de proceso es privado para la aplicación, en otras palabras, no se pueden compartir los identificadores de proceso. Un proceso también tiene un proceso <xref:System.Diagnostics.Process.Id%2A> que, a diferencia del <xref:System.Diagnostics.Process.Handle%2A>, es único y, por lo tanto, válido en todo el sistema.  
  
 Sólo los procesos iniciados mediante una llamada a <xref:System.Diagnostics.Process.Start%2A> establecer el <xref:System.Diagnostics.Process.Handle%2A> propiedad de los correspondientes <xref:System.Diagnostics.Process> instancias.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El proceso no se ha iniciado o ha terminado. No puede leerse la propiedad <see cref="P:System.Diagnostics.Process.Handle" /> porque no hay ningún proceso asociado a esta instancia de <see cref="T:System.Diagnostics.Process" />.  
  
O bien 
La instancia de <see cref="T:System.Diagnostics.Process" /> ha quedado asociada a un proceso en ejecución, pero no se tienen los permisos necesarios para obtener un identificador con derechos de acceso total.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.Handle" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de identificadores abiertos por el proceso.</summary>
        <value>Número de identificadores de sistema operativo abiertos por el proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los identificadores proporcionan una forma de un proceso hacer referencia a objetos. Un proceso puede obtener identificadores de archivos, recursos, las colas de mensajes y muchos otros objetos del sistema operativo. El sistema operativo reclama la memoria asociada con el proceso solo cuando el recuento de identificadores es cero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de la propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para obtener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el proceso asociado ha finalizado.</summary>
        <value>Es <see langword="true" /> si el proceso del sistema operativo al que hace referencia el componente <see cref="T:System.Diagnostics.Process" /> ha terminado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de `true` para <xref:System.Diagnostics.Process.HasExited%2A> indica que el proceso asociado ha terminado con normalidad o de forma anómala. Puede solicitar o forzar el proceso asociado termine llamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Si un identificador está abierto para el proceso, el sistema operativo libera la memoria de proceso cuando el proceso se ha cerrado, pero conserva la información administrativa sobre el proceso, como el identificador, el código de salida y la hora de salida. Para obtener esta información, puede usar el <xref:System.Diagnostics.Process.ExitCode%2A> y <xref:System.Diagnostics.Process.ExitTime%2A> propiedades. Estas propiedades se rellenan automáticamente para los procesos iniciados por este componente. La información administrativa se libera cuando todas las <xref:System.Diagnostics.Process> componentes que están asociados con el proceso del sistema se destruyen y contener no más identificadores para el proceso terminado.  
  
 Puede terminar un proceso independientemente del código. Si ha comenzado el proceso con este componente, el sistema actualiza el valor de <xref:System.Diagnostics.Process.HasExited%2A> automáticamente, incluso si el proceso asociado se cierra de forma independiente.  
  
> [!NOTE]
>  Cuando se ha redirigido la salida estándar para controladores de eventos asincrónicos, es posible que el procesamiento de salida no se habrá completado cuando esta propiedad devuelve `true`. Para asegurarse de que se ha completado el control de eventos asincrónicos, llame a la <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que no toma ningún parámetro antes de comprobar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. A continuación, se recupera el uso de memoria física del proceso asociado a 2 intervalos de segundos durante un máximo de 10 segundos. El ejemplo detecta si el proceso se cierra antes de transcurridos 10 segundos. El ejemplo cierra el proceso si se está ejecutando todavía después de 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No hay ningún proceso asociado al objeto.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">No se pudo recuperar el código de salida del proceso.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.HasExited" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador único del proceso asociado.</summary>
        <value>Identificador único generado por el sistema del proceso al que hace referencia esta instancia de <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El proceso <xref:System.Diagnostics.Process.Id%2A> no es válido si no se está ejecutando el proceso asociado. Por lo tanto, debe asegurarse de que el proceso se está ejecutando antes de intentar recuperar el <xref:System.Diagnostics.Process.Id%2A> propiedad. Hasta que finaliza el proceso, el identificador de proceso identifica el proceso en todo el sistema.  
  
 Puede conectar un proceso que se ejecuta en un equipo local o remoto a una nueva <xref:System.Diagnostics.Process> instancia pasando el identificador de proceso para el <xref:System.Diagnostics.Process.GetProcessById%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> es un `static` método que crea un nuevo componente y establece el <xref:System.Diagnostics.Process.Id%2A> propiedad para el nuevo <xref:System.Diagnostics.Process> automáticamente la instancia.  
  
 Identificadores de proceso pueden ser reutilizados por el sistema. El <xref:System.Diagnostics.Process.Id%2A> valor de propiedad es único solo mientras se ejecuta el proceso asociado. Una vez que termina el proceso, el sistema puede volver a usar el <xref:System.Diagnostics.Process.Id%2A> valor de propiedad para un proceso no relacionado.  
  
 Dado que el identificador es único en el sistema, puede pasar a otros subprocesos como alternativa a pasar un <xref:System.Diagnostics.Process> instancia. Esta acción puede ahorrar recursos del sistema al tiempo que garantiza que el proceso está identificado correctamente.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo obtener el <xref:System.Diagnostics.Process.Id%2A> para todas las instancias de una aplicación en ejecución. El código crea una nueva instancia del Bloc de notas, se enumeran todas las instancias del Bloc de notas y, a continuación, permite al usuario que escriba el <xref:System.Diagnostics.Process.Id%2A> número para quitar una instancia específica.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha establecido la propiedad <see cref="P:System.Diagnostics.Process.Id" /> del proceso.  
  
O bien 
No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de la propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para obtener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Detiene inmediatamente el proceso asociado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> fuerza una terminación del proceso, mientras que <xref:System.Diagnostics.Process.CloseMainWindow%2A> sólo solicita la terminación. Cuando se está ejecutando un proceso con una interfaz gráfica, el bucle de mensajes está en un estado de espera. El bucle de mensajes se ejecuta cada vez que se envía un mensaje de Windows para el proceso por el sistema operativo. Una llamada a <xref:System.Diagnostics.Process.CloseMainWindow%2A> envía una solicitud a cerca de la ventana principal, que, en una aplicación tiene el formato correcto, cierre las ventanas secundarias y revoca la ejecución de todos los bucles de mensajes para la aplicación. La solicitud para salir del proceso mediante una llamada a <xref:System.Diagnostics.Process.CloseMainWindow%2A> no fuerza la aplicación se cierre. La aplicación puede pedir confirmación del usuario antes de salir, o puede rechazar salir. Para forzar la aplicación para salir, use el <xref:System.Diagnostics.Process.Kill%2A> método. El comportamiento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> es idéntico de un usuario cierra la ventana principal de la aplicación mediante el menú del sistema. Por lo tanto, la solicitud para salir del proceso al cerrar la ventana principal no obliga a la aplicación a salir inmediatamente.  
  
> [!NOTE]
>  El <xref:System.Diagnostics.Process.Kill%2A> método se ejecuta de forma asincrónica. Después de llamar a la <xref:System.Diagnostics.Process.Kill%2A> método, llame a la <xref:System.Diagnostics.Process.WaitForExit%2A> método para esperar el proceso salir o comprobar el <xref:System.Diagnostics.Process.HasExited%2A> propiedad para determinar si el proceso ha terminado.  
  
 Los datos modificados por el proceso o los recursos asignados al proceso pueden perderse si se llama a <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> provoca una terminación anómala del proceso y deben usarse solo cuando sea necesario. <xref:System.Diagnostics.Process.CloseMainWindow%2A> habilita una finalización ordenada del proceso y cierra todas las ventanas, por lo que es preferible para las aplicaciones con una interfaz. Si <xref:System.Diagnostics.Process.CloseMainWindow%2A> se produce un error, puede usar <xref:System.Diagnostics.Process.Kill%2A> para finalizar el proceso. <xref:System.Diagnostics.Process.Kill%2A> es la única forma de terminar los procesos que no tienen interfaces gráficas.  
  
 Puede llamar a <xref:System.Diagnostics.Process.Kill%2A> y <xref:System.Diagnostics.Process.CloseMainWindow%2A> únicamente para los procesos que se ejecutan en el equipo local. No puede hacer que los procesos en equipos remotos para salir. Solo se puede ver información de los procesos que se ejecutan en equipos remotos.  
  
> [!NOTE]
>  Si la llamada a la <xref:System.Diagnostics.Process.Kill%2A> método se realiza mientras el proceso está finalizando actualmente, un <xref:System.ComponentModel.Win32Exception> se produce para acceso denegado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se pudo terminar el proceso secundario.  
  
O bien 
El proceso está finalizando.  
  
O bien 
El proceso asociado es un ejecutable de Win16.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando llamar al método <see cref="M:System.Diagnostics.Process.Kill" /> para un proceso que se está ejecutando en un equipo remoto. El método está disponible solo para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ya ha terminado.  
  
O bien 
No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un componente <see cref="T:System.Diagnostics.Process" /> del estado que le permite interactuar con procesos del sistema operativo que se ejecuten en un modo especial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos procesos del sistema operativo se ejecutan en un modo especial. Intentar leer las propiedades de o asociar a estos procesos no es posible a menos que se ha llamado <xref:System.Diagnostics.Process.EnterDebugMode%2A> en el componente. Llamar a <xref:System.Diagnostics.Process.LeaveDebugMode%2A> cuando ya no necesita acceso a estos procesos que se ejecutan en modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del equipo en el que se está ejecutando el proceso asociado.</summary>
        <value>Nombre del equipo en el que se está ejecutando el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede ver datos estadísticos y la información de proceso para procesos que se ejecutan en equipos remotos, pero no puede llamar a <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, o <xref:System.Diagnostics.Process.Kill%2A> en equipos remotos.  
  
> [!NOTE]
>  Cuando el proceso asociado se ejecuta en el equipo local, esta propiedad devuelve un punto (".") para el nombre del equipo. Debe usar el <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propiedad va a obtener el nombre de equipo correcto.  
  
   
  
## Examples  
 Para usar el ejemplo siguiente, primero debe iniciar al menos una instancia del Bloc de notas en un equipo remoto. El ejemplo, solicita el nombre del equipo remoto en el que se está ejecutando el Bloc de notas y, a continuación, muestra los respectivos <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, y <xref:System.Diagnostics.Process.MachineName%2A> propiedades para cada instancia.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el módulo principal del proceso asociado.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessModule" /> utilizado para iniciar el proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un módulo de proceso representa un archivo.dll o .exe que se carga en un proceso determinado. El <xref:System.Diagnostics.Process.MainModule%2A> propiedad le permite ver información acerca del archivo ejecutable que se usa para iniciar el proceso, incluidos el nombre del módulo, el nombre de archivo y los detalles de memoria del módulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.MainModule" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Un proceso de 32 bits está intentando obtener acceso a los módulos de un proceso de 64 bits.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium Edition (Windows Me); establezca <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para tener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.Process.Id" /> del proceso no está disponible.  
  
O bien 
El proceso ha terminado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador de ventana de la ventana principal del proceso asociado.</summary>
        <value>Identificador de ventana generado por el sistema para la ventana principal del proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ventana principal es la ventana abierta por el proceso que tiene actualmente el foco (el <xref:System.Windows.Forms.Form.TopLevel%2A> formulario). Debe usar el <xref:System.Diagnostics.Process.Refresh%2A> método para actualizar la <xref:System.Diagnostics.Process> va a obtener el identificador de ventana principal actual, si ha cambiado. En general, porque el identificador de ventana se almacena en caché, utilice <xref:System.Diagnostics.Process.Refresh%2A> con antelación para garantizar que podrá recuperar el identificador actual.  
  
 Puede obtener el <xref:System.Diagnostics.Process.MainWindowHandle%2A> propiedad únicamente para los procesos que se ejecutan en el equipo local. El <xref:System.Diagnostics.Process.MainWindowHandle%2A> propiedad es un valor que identifica la ventana que está asociada con el proceso.  
  
 Un proceso tiene una ventana principal asociada sólo si el proceso tiene una interfaz gráfica. Si el proceso asociado no tiene una ventana principal, el <xref:System.Diagnostics.Process.MainWindowHandle%2A> valor es cero. El valor también es cero para los procesos que se han ocultado, es decir, los procesos que no están visibles en la barra de tareas. Esto puede ser el caso de los procesos que aparecen como iconos en el área de notificación, en el extremo derecho de la barra de tareas.  
  
 Si acaba de iniciar un proceso y desea utilizar su identificador de ventana principal, considere la posibilidad de usar el <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que el proceso termine de iniciarse, lo que garantiza que se ha creado el identificador de ventana principal. De lo contrario, se producirá una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> no está definida porque el proceso ha terminado.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para tener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el título de la ventana principal del proceso.</summary>
        <value>Título de la ventana principal del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un proceso tiene una ventana principal asociada sólo si el proceso tiene una interfaz gráfica. Si el proceso asociado no tiene una ventana principal (por lo que <xref:System.Diagnostics.Process.MainWindowHandle%2A> es cero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> es una cadena vacía (""). Si acaba de iniciar un proceso y desea utilizar el título de ventana principal, considere la posibilidad de usar el <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que el proceso termine de iniciarse, lo que garantiza que se ha creado el identificador de ventana principal. De lo contrario, el sistema produce una excepción.  
  
> [!NOTE]
>  La ventana principal es la ventana que tiene actualmente el foco; Tenga en cuenta que esto podría no ser la ventana principal del proceso. Debe usar el <xref:System.Diagnostics.Process.Refresh%2A> método para actualizar la <xref:System.Diagnostics.Process> va a obtener el identificador de ventana principal actual, si ha cambiado.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas y recupera el título de la ventana principal del proceso.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> no está definida porque el proceso ha terminado.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para tener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño del espacio de trabajo máximo permitido, en bytes, para el proceso asociado.</summary>
        <value>Tamaño máximo permitido para el espacio de trabajo del proceso en la memoria expresado en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El espacio de trabajo de un proceso es el conjunto de páginas de memoria visibles actualmente para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para usar sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos incluyen las páginas que contienen todas las instrucciones que se ejecuta la aplicación, incluidas las páginas de los archivos .dll y los archivos system.dll. A medida que aumenta el tamaño del conjunto de trabajo, la demanda de memoria aumenta.  
  
 Un proceso con tamaños de espacio de trabajo mínimo y máximo. Cada vez que se crea un recurso de proceso, el sistema de reserva una cantidad de memoria igual que el mínimo tamaño del conjunto para el proceso de trabajo. El Administrador de memoria virtual intenta mantener al menos la cantidad mínima de memoria residente cuando el proceso está activo, pero nunca mantiene más que el tamaño máximo.  
  
 El sistema establece la tamaños de espacio de trabajo predeterminada. Puede modificar estos tamaños utilizando la <xref:System.Diagnostics.Process.MaxWorkingSet%2A> y <xref:System.Diagnostics.Process.MinWorkingSet%2A> miembros. Sin embargo, establecer estos valores no garantiza que la memoria reservada o residentes.  
  
> [!NOTE]
>  Al aumentar el tamaño de un proceso de trabajo, tome la memoria física del resto del sistema. Asegúrese de que no solicitan un tamaño de trabajo mínimo o máximo que sea demasiado grande, ya que puede degradar el rendimiento del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño máximo del conjunto de trabajo no es válido. Debe ser mayor o igual que el tamaño del espacio de trabajo mínimo.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">La información del espacio de trabajo no se puede recuperar del recurso del proceso asociado.  
  
O bien 
El identificador de proceso o el controlador de proceso es cero porque el proceso no se ha iniciado.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.Process.Id" /> del proceso no está disponible.  
  
O bien 
El proceso ha terminado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño del espacio de trabajo mínimo permitido, en bytes, para el proceso asociado.</summary>
        <value>Tamaño mínimo necesario para el espacio de trabajo del proceso en la memoria expresado en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El espacio de trabajo de un proceso es el conjunto de páginas de memoria visibles actualmente para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para usar sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos incluyen las páginas que contienen todas las instrucciones que se ejecuta la aplicación, incluidas las páginas de los archivos .dll y los archivos system.dll. A medida que aumenta el tamaño del conjunto de trabajo, la demanda de memoria aumenta.  
  
 Un proceso con tamaños de espacio de trabajo mínimo y máximo. Cada vez que se crea un recurso de proceso, el sistema de reserva una cantidad de memoria igual que el mínimo tamaño del conjunto para el proceso de trabajo. El Administrador de memoria virtual intenta mantener al menos la cantidad mínima de memoria residente cuando el proceso está activo, pero nunca mantiene más que el tamaño máximo.  
  
 El sistema establece la tamaños de espacio de trabajo predeterminada. Puede modificar estos tamaños utilizando la <xref:System.Diagnostics.Process.MaxWorkingSet%2A> y <xref:System.Diagnostics.Process.MinWorkingSet%2A> miembros. Sin embargo, establecer estos valores no garantiza que la memoria reservada o residentes.  
  
> [!NOTE]
>  Al aumentar el tamaño de un proceso de trabajo, tome la memoria física del resto del sistema. Asegúrese de que no solicitan un tamaño de trabajo mínimo o máximo que sea demasiado grande, ya que puede degradar el rendimiento del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño mínimo del conjunto de trabajo no es válido. Debe ser menor o igual que el tamaño del espacio de trabajo máximo.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">No se puede recuperar la información del espacio de trabajo desde el recurso del proceso asociado.  
  
O bien 
El identificador de proceso o el controlador de proceso es cero porque el proceso no se ha iniciado.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.Process.Id" /> del proceso no está disponible.  
  
O bien 
El proceso ha terminado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los módulos cargados por el proceso asociado.</summary>
        <value>Matriz de tipo <see cref="T:System.Diagnostics.ProcessModule" /> que representa los módulos cargados por el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un módulo de proceso representa un archivo.dll o .exe que se carga en un proceso determinado. Un <xref:System.Diagnostics.ProcessModule> instancia le permite ver información acerca de un módulo, incluidos el nombre del módulo, el nombre de archivo y los detalles de memoria del módulo.  
  
 Un proceso puede cargar varios módulos en memoria. Por ejemplo, archivos .exe que cargan archivos .dll adicionales tienen varios módulos.  
  
 Después de iniciar el proceso, esta colección está vacía hasta que el sistema ha cargado el proceso. Si el proceso tiene una ventana principal, se puede llamar a <xref:System.Diagnostics.Process.WaitForInputIdle%2A> antes de recuperar esta propiedad para asegurarse de que la colección no está vacío cuando se obtiene la lista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.Modules" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.Process.Id" /> del proceso no está disponible.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para tener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.Modules" /> para el proceso del sistema o el proceso inactivo. Estos procesos no tienen módulos.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de la memoria no paginada del sistema en bytes que se asignó para el proceso asociado.</summary>
        <value>Cantidad de memoria, en bytes, que el sistema asignó para el proceso asociado que no se puede escribir en el archivo de paginación de la memoria virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de la memoria no paginada del sistema en bytes que se asignó para el proceso asociado.</summary>
        <value>El tamaño de la memoria del sistema, expresado en bytes, que se ha asignado para el proceso asociado que no puede escribirse en el archivo de paginación de la memoria virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria no paginada del sistema utilizado por el proceso, en bytes. Memoria del sistema es la memoria física usada por el sistema operativo y se divide en grupos paginados y no paginados. Las asignaciones de memoria no paginada permanecen en memoria del sistema y no se paginan al archivo de paginación de memoria virtual.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes del bloque no paginado** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera el evento <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> es el método de API que genera el <xref:System.Diagnostics.Process.Exited> eventos. Una llamada a <xref:System.Diagnostics.Process.OnExited%2A> hace que el <xref:System.Diagnostics.Process.Exited> eventos que se produzca y es la única manera de generar el evento con el <xref:System.Diagnostics.Process> componente. <xref:System.Diagnostics.Process.OnExited%2A> se utiliza principalmente al derivar clases desde el componente.  
  
 Como alternativa a <xref:System.Diagnostics.Process.OnExited%2A>, puede escribir su propio controlador de eventos. Cree su propio delegado de controlador de eventos y su propio método de control de eventos.  
  
> [!NOTE]
>  Si usa el entorno de Visual Studio, un delegado de controlador de eventos (AddOnExited) y un método de control de eventos (Process1_Exited) se crean automáticamente cuando se arrastra un <xref:System.Diagnostics.Process> componente a un formulario y haga doble clic en el icono. El código crea para ejecutar cuando el <xref:System.Diagnostics.Process.Exited> evento tiene lugar se escribe en el procedimiento Process1_Exited. No es necesario crear el <xref:System.Diagnostics.Process.OnExited%2A> miembro, porque se implementa automáticamente.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener información general, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Diagnostics.Process.OnExited%2A> método en una clase derivada.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cada vez que una aplicación escribe una línea en su secuencia <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirigida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.OutputDataReceived> evento indica que el asociado <xref:System.Diagnostics.Process> ha escrito una línea, terminar con un carácter de nueva línea, a su redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> stream.  
  
 El evento está habilitado durante las operaciones de lectura asincrónicas en <xref:System.Diagnostics.Process.StandardOutput%2A>. Para iniciar operaciones de lectura asincrónica, debe redirigir el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia de un <xref:System.Diagnostics.Process>, agregar el controlador de eventos para el <xref:System.Diagnostics.Process.OutputDataReceived> evento y llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. A partir de entonces, el <xref:System.Diagnostics.Process.OutputDataReceived> las señales de eventos cada vez que el proceso escribe una línea en el redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir, hasta que el proceso se cierra o se llama <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  La aplicación que se está procesando la salida asincrónica debe llamar a la <xref:System.Diagnostics.Process.WaitForExit%2A> método para asegurarse de que se ha vaciado el búfer de salida.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo realizar operaciones de lectura asincrónica en la redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia de la `ipconfig` comando.  
  
 El ejemplo crea un delegado de eventos para el `OutputHandler` controlador de eventos y lo asocia a la <xref:System.Diagnostics.Process.OutputDataReceived> eventos. El controlador de eventos recibe líneas de texto de la redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> stream, da formato al texto y lo guarda en una cadena de salida que se muestra más adelante en la ventana de la consola del ejemplo.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de la memoria paginada, en bytes, asignada para el proceso asociado.</summary>
        <value>Cantidad de memoria, en bytes, asignada por el proceso asociado que se puede escribir en el archivo de paginación de la memoria virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de la memoria paginada, en bytes, asignada para el proceso asociado.</summary>
        <value>El tamaño de la memoria, expresado en bytes, asignada en el archivo de paginación de la memoria virtual para el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria en el archivo de paginación de memoria virtual utilizado por el proceso, en bytes. El sistema operativo usa el archivo de paginación de memoria virtual junto con una memoria física para administrar el espacio de direcciones virtuales para cada proceso. Cuando la memoria paginable no está en uso, se pueden transferir al archivo de paginación de memoria virtual en el disco. Para obtener el tamaño de memoria usada por el sistema operativo para el proceso, use el <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> propiedad.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes del archivo de página** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas y, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de la memoria paginable del sistema en bytes que se asignó para el proceso asociado.</summary>
        <value>Cantidad de memoria, en bytes, que el sistema ha asignado para el proceso asociado que se puede escribir en el archivo de paginación de la memoria virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de la memoria paginable del sistema en bytes que se asignó para el proceso asociado.</summary>
        <value>El tamaño de la memoria del sistema, expresado en bytes, que se ha asignado para el proceso asociado que puede escribirse en el archivo de paginación de la memoria virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria paginable del sistema utilizado por el proceso, en bytes. Memoria del sistema es la memoria física usada por el sistema operativo y se divide en grupos paginados y no paginados. Cuando la memoria paginable no está en uso, se pueden transferir al archivo de paginación de memoria virtual en el disco. Para obtener el tamaño de la memoria utilizada por el proceso de la aplicación, use el <xref:System.Diagnostics.Process.PagedMemorySize64%2A> propiedad.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes del bloque paginado** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de memoria máximo en el archivo de paginación de la memoria virtual, en bytes, que usa el proceso asociado.</summary>
        <value>Cantidad máxima de memoria, en bytes, asignada por el proceso asociado que se podría escribir en el archivo de paginación de la memoria virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de memoria máximo en el archivo de paginación de la memoria virtual, en bytes, que usa el proceso asociado.</summary>
        <value>El tamaño de memoria máximo, expresado en bytes, asignado en el archivo de paginación de la memoria virtual para el proceso asociado desde su inicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño máximo de memoria en el archivo de paginación de memoria virtual utilizado por el proceso desde que se inició, en bytes. El sistema operativo usa el archivo de paginación de memoria virtual junto con una memoria física para administrar el espacio de direcciones virtuales para cada proceso. Cuando la memoria paginable no está en uso, se pueden transferir al archivo de paginación de memoria virtual en el disco.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **uso máximo de Bytes del archivo de página** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad máxima de memoria virtual, en bytes, que usa el proceso asociado.</summary>
        <value>Cantidad máxima de memoria virtual, en bytes, solicitada por el proceso asociado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad máxima de memoria virtual, en bytes, que usa el proceso asociado.</summary>
        <value>El tamaño máximo de memoria virtual, expresado en bytes, que se ha asignado para el proceso asociado desde su inicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño máximo de memoria virtual usada por el proceso desde que se inició, en bytes. El sistema operativo asigna espacio de direcciones virtuales para cada proceso a las páginas se cargan en la memoria física, o a las páginas que se almacenan en el archivo de paginación de memoria virtual en el disco.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **uso máximo de Bytes virtuales** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de espacio de trabajo máximo para el proceso asociado, en bytes.</summary>
        <value>Cantidad máxima de memoria física que el proceso asociado precisa de una sola vez, expresada en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El espacio de trabajo de un proceso es el conjunto de páginas de memoria visibles actualmente para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para usar sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos incluyen las páginas que contienen todas las instrucciones que se ejecuta el proceso, incluidos los módulos de proceso y las bibliotecas del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad máxima de la memoria física, en bytes que usa el proceso asociado.</summary>
        <value>El tamaño máximo de memoria física, expresado en bytes, que se ha asignado para el proceso asociado desde su inicio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño máximo de memoria utilizada por el proceso desde que se inició, en bytes del conjunto de trabajo. El espacio de trabajo de un proceso es el conjunto de páginas de memoria visibles actualmente para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para usar sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos incluyen las páginas que contienen todas las instrucciones que se ejecuta el proceso, incluidas las instrucciones de los módulos de proceso y las bibliotecas del sistema.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **máximo del espacio de trabajo** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el sistema operativo debería aumentar temporalmente la prioridad del proceso asociado cuando la ventana principal tenga el foco.</summary>
        <value>Es <see langword="true" /> si la prioridad del proceso debe aumentarse dinámicamente cuando éste salga del estado de espera; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un subproceso se ejecuta en un proceso para el que la clase de prioridad tiene uno de los valores de enumeración de prioridad dinámica (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), el sistema aumenta temporalmente la prioridad del subproceso cuando se saca de un estado de espera. Esta acción evita que otros procesos interrumpir el procesamiento del subproceso actual. El <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> configuración afecta a todos los subprocesos existentes y los subprocesos creados posteriormente por el proceso. Para restaurar el comportamiento normal, establezca el <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propiedad `false`.  
  
> [!NOTE]
>  Aumento excesivo de la prioridad puede reducir los recursos esenciales del sistema operativo y las funciones de red, causando problemas con otras tareas del sistema operativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se pudo recuperar la información de aumento de prioridad desde el recurso del proceso asociado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.  
  
O bien 
El identificador del proceso o el controlador del proceso es cero. (No se ha iniciado el proceso).</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.Process.Id" /> del proceso no está disponible.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la categoría de prioridad general del proceso asociado.</summary>
        <value>Categoría de prioridad del proceso asociado a partir de la cual se calcula la propiedad <see cref="P:System.Diagnostics.Process.BasePriority" /> del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una clase de prioridad del proceso abarca una variedad de niveles de prioridad de subproceso. Subprocesos con prioridades diferentes que se ejecutan en el proceso de ejecución con respecto a la clase de prioridad del proceso. Win32 usa cuatro clases de prioridad con siete niveles de prioridad base por clase. Estas clases de prioridad de proceso se capturan en el <xref:System.Diagnostics.ProcessPriorityClass> enumeración, que le permite establece la prioridad del proceso <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, o <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Según el tiempo transcurrido o de otro aumenta, el nivel de prioridad base puede cambiarse por el sistema operativo cuando un proceso debe colocarse delante de otros para el acceso al procesador. Además, puede establecer el <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> para aumentar temporalmente el nivel de prioridad de subprocesos que se han sacado del estado de espera. La prioridad se restablece cuando el proceso vuelve al estado de espera.  
  
 El <xref:System.Diagnostics.Process.BasePriority%2A> propiedad le permite ver la prioridad inicial que se asigna a un proceso. Sin embargo, dado que es de solo lectura, no se puede usar el <xref:System.Diagnostics.Process.BasePriority%2A> propiedad para establecer la prioridad de un proceso. Para cambiar la prioridad, use el <xref:System.Diagnostics.Process.PriorityClass%2A> propiedad, que obtiene o establece la categoría de prioridad general del proceso.  
  
 La clase de prioridad no se puede ver mediante el Monitor de sistema. En la tabla siguiente se muestra la relación entre el <xref:System.Diagnostics.Process.BasePriority%2A> y <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se pudo establecer o recuperar la información de prioridad del proceso desde el recurso del proceso asociado.  
  
O bien 
El identificador del proceso o el controlador del proceso es cero. (No se ha iniciado el proceso).</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.PriorityClass" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Diagnostics.Process.Id" /> del proceso no está disponible.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Ha establecido la <see cref="P:System.Diagnostics.Process.PriorityClass" /> en <see langword="AboveNormal" /> o <see langword="BelowNormal" /> al usar Windows 98 o Windows Millennium Edition (Windows Me). Estas plataformas no admiten esos valores para la clase de prioridad.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">No se puede establecer la clase de prioridad porque no utiliza un valor válido, como se define en la enumeración <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de memoria privada, en bytes, asignada para el proceso asociado.</summary>
        <value>Número de bytes asignados por el proceso asociado que no pueden compartirse con otros procesos.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de memoria privada, en bytes, asignada para el proceso asociado.</summary>
        <value>El tamaño de la memoria, expresado en bytes, que se ha asignado para el proceso asociado que no puede compartirse con otros procesos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria utilizada por el proceso, en bytes, que no se puede compartir con otros procesos.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes privados** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tiempo de procesador con privilegios de este proceso.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> que indica la cantidad de tiempo que el proceso ha invertido en la ejecución de código dentro del núcleo del sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <exception cref="T:System.NotSupportedException">Está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> de un proceso que se ejecuta en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del proceso.</summary>
        <value>Nombre que el sistema utiliza para identificar el proceso ante el usuario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.ProcessName%2A> propiedad contiene un nombre de archivo ejecutable, como Outlook, que no incluye la extensión .exe ni la ruta de acceso. Resulta útil para obtener y manipular todos los procesos que están asociados con el mismo archivo ejecutable.  
  
> [!NOTE]
>  En [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] los sistemas operativos, el <xref:System.Diagnostics.Process.ProcessName%2A> propiedad puede truncarse a 15 caracteres si no se puede obtener la información del módulo de proceso.  
  
 Puede llamar a <xref:System.Diagnostics.Process.GetProcessesByName%2A>, pasándole un nombre de archivo ejecutable, para recuperar una matriz que contiene cada instancia en ejecución en el equipo especificado. Puede usar esta matriz, por ejemplo, para cerrar todas las instancias en ejecución del archivo ejecutable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El proceso no tiene un identificador, o no hay ningún proceso asociado a <see cref="T:System.Diagnostics.Process" />.  
  
O bien 
El proceso asociado finalizó.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para tener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">El proceso no está en este equipo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los procesadores en los que se puede programar la ejecución de los subprocesos de este proceso.</summary>
        <value>Máscara de bits que representa los procesadores en los que pueden ejecutarse los subprocesos del proceso asociado. El valor predeterminado depende del número de procesadores del equipo. El valor predeterminado es 2 <sup>n</sup> -1, donde n es el número de procesadores.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En Windows 2000 y versiones posteriores, un subproceso en un proceso puede migrar de un procesador a otro, con cada migración vuelve a cargar la caché del procesador. Con cargas elevadas, especificando el procesador que debe ejecutar un subproceso específico puede mejorar el rendimiento al reducir el número de veces que se vuelve a cargar la caché del procesador. La asociación entre un procesador y un subproceso se denomina la afinidad del procesador.  
  
 Cada procesador se representa como un bit. Bit 0 es el procesador uno, el bit 1 es el procesador dos y así sucesivamente. Si un bit se establece en el valor 1, el procesador correspondiente se selecciona para la asignación de subproceso. Al establecer el <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor a cero, el sistema operativo de la programación de conjunto de algoritmos la afinidad del subproceso. Cuando el <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor se establece en cualquier valor distinto de cero, el valor se interpreta como una máscara de bits que especifica los procesadores que se pueden seleccionar.  
  
 En la tabla siguiente se muestra una selección de <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valores para un sistema con ocho procesadores.  
  
|Máscara de bits|Valor binario|Procesadores aptos|  
|-------------|------------------|-------------------------|  
|0 x 0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 y 2|  
|0x0007|00000000 00000111|1, 2 y 3|  
|0x0009|00000000 00001001|1 y 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 y 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se pudo establecer o recuperar la información de <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> desde el recurso del proceso asociado.  
  
O bien 
El identificador del proceso o el controlador del proceso es cero. (No se ha iniciado el proceso).</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso <see cref="P:System.Diagnostics.Process.Id" /> no estaba disponible.  
  
O bien 
El proceso ha terminado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarta cualquier información acerca del proceso asociado que se haya almacenado en caché en el componente del proceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de <xref:System.Diagnostics.Process.Refresh%2A> se llama, la primera solicitud para obtener información sobre cada propiedad hace que el componente de proceso para obtener un nuevo valor del proceso asociado.  
  
 Cuando un <xref:System.Diagnostics.Process> componente está asociado a un recurso de proceso, los valores de propiedad de la <xref:System.Diagnostics.Process> inmediatamente se rellenan según el estado del proceso asociado. Si posteriormente cambia la información sobre el proceso asociado, dichos cambios no se reflejan en el <xref:System.Diagnostics.Process> valor almacenado en caché del componente. El <xref:System.Diagnostics.Process> componente es una instantánea del recurso proceso en el momento en que están asociadas. Para ver los valores actuales para el proceso asociado, llame a la <xref:System.Diagnostics.Process.Refresh%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. A continuación, se recupera el uso de memoria física del proceso asociado a 2 intervalos de segundos durante un máximo de 10 segundos. El ejemplo detecta si el proceso se cierra antes de transcurridos 10 segundos. El ejemplo cierra el proceso si se está ejecutando todavía después de 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la interfaz de usuario del proceso está respondiendo.</summary>
        <value>Es <see langword="true" /> si la interfaz de usuario del proceso asociado está respondiendo al sistema; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un proceso tiene una interfaz de usuario, el <xref:System.Diagnostics.Process.Responding%2A> propiedad pone en contacto con la interfaz de usuario para determinar si el proceso está respondiendo a la entrada del usuario. Si la interfaz no responde inmediatamente, la <xref:System.Diagnostics.Process.Responding%2A> propiedad devuelve `false`. Utilice esta propiedad para determinar si la interfaz del proceso asociado ha dejado de responder.  
  
 Si el proceso no tiene un <xref:System.Diagnostics.Process.MainWindowHandle%2A>, esta propiedad devuelve `true`.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para tener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <exception cref="T:System.NotSupportedException">Se está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.Responding" /> de un proceso que se está ejecutando en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador nativo de este proceso.</summary>
        <value>Identificador nativo de este proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El identificador solo está disponible si el componente que realiza la llamada inicia el proceso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador de la sesión de Servicios de Terminal Server para el proceso asociado.</summary>
        <value>El identificador de la sesión de Servicios de Terminal Server para el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Process.SessionId%2A> propiedad identifica la sesión en el que se está ejecutando la aplicación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">No hay ninguna sesión asociada a este proceso.</exception>
        <exception cref="T:System.InvalidOperationException">No hay ningún proceso asociado a este identificador de sesión.  
  
O bien 
El proceso asociado no está en este equipo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La propiedad <see cref="P:System.Diagnostics.Process.SessionId" /> no es compatible con Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una secuencia utilizada para leer la salida de errores de la aplicación.</summary>
        <value>Un <see cref="T:System.IO.StreamReader" /> que puede utilizarse para leer la secuencia de error estándar de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un <xref:System.Diagnostics.Process> escribe texto en su secuencia de error estándar, que el texto se muestra normalmente en la consola. Al redirigir el <xref:System.Diagnostics.Process.StandardError%2A> stream, puede manipular o suprimir la salida de error de un proceso. Por ejemplo, puede filtrar el texto, formato diferente o escribir la salida en la consola y un archivo de registro designado.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardError%2A>, debe establecer <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, y deberá establecer <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> a `true`. De lo contrario, al leer desde el <xref:System.Diagnostics.Process.StandardError%2A> secuencia produce una excepción.  
  
 El redirigida <xref:System.Diagnostics.Process.StandardError%2A> flujo se puede leer de forma sincrónica o asincrónica. Los métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, y <xref:System.IO.StreamReader.ReadToEnd%2A> realizar operaciones de lectura sincrónica en el flujo de salida de error del proceso. Estos sincrónica leer no lleva a cabo operaciones hasta que el asociado <xref:System.Diagnostics.Process> escribe en su <xref:System.Diagnostics.Process.StandardError%2A> transmitir o cierra la secuencia.  
  
 En cambio, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> las operaciones de lectura asincrónica comienza en el <xref:System.Diagnostics.Process.StandardError%2A> stream. Este método permite que un controlador de eventos designado para la salida de la secuencia y devuelve inmediatamente al llamador, que puede realizar otro trabajo mientras se dirige la salida de la secuencia al controlador de eventos.  
  
 Sincrónico lee operaciones presentan una dependencia entre el llamador que lee desde el <xref:System.Diagnostics.Process.StandardError%2A> secuencia y el elemento secundario procesan la escritura en esa secuencia. Estas dependencias pueden provocar condiciones de interbloqueo. Cuando el llamador lee la secuencia redirigida de un proceso secundario, es dependiente en el elemento secundario. El llamador espera la operación de lectura hasta que el elemento secundario se escribe en la secuencia o cierra la secuencia. Cuando el proceso secundario escribe suficientes datos para rellenar su secuencia redirigida, es dependiente en el elemento primario. El proceso secundario espera la siguiente operación de escritura hasta que el elemento primario lee la secuencia completa o cierra la secuencia. La condición de interbloqueo se produce cuando el llamador y el proceso secundario esperan mutuamente para completar una operación y ninguno puede continuar. Puede evitar los interbloqueos mediante la evaluación de las dependencias entre el llamador y el proceso secundario.  
  
 El siguiente código de C#, por ejemplo, muestra cómo leer una secuencia redirigida y espere a que finalice el proceso secundario.  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 El ejemplo de código, evita una condición de interbloqueo mediante una llamada a `p.StandardError.ReadToEnd` antes `p.WaitForExit`. Puede dar lugar a una condición de interbloqueo si el elemento primario procesa llamadas `p.WaitForExit` antes `p.StandardError.ReadToEnd` y el proceso secundario escribe texto suficiente para rellenar la secuencia redirigida. El proceso primario esperaría indefinidamente para que el proceso secundario salir. El proceso secundario esperaría indefinidamente para que el elemento primario leer desde el completo <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
 Hay un problema similar al leer todo el texto de la salida estándar y flujos de error estándar. El siguiente código de C#, por ejemplo, realiza una operación de lectura en ambas secuencias.  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 El ejemplo de código, evita el interbloqueo mediante la realización asincrónica de las operaciones de lectura en el <xref:System.Diagnostics.Process.StandardOutput%2A> stream. Una condición de interbloqueo se produce si el elemento primario procesa llamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` y el proceso secundario escribe texto suficiente para rellenar la secuencia de error. El proceso primario podía esperar indefinidamente en el proceso secundario cerrar su <xref:System.Diagnostics.Process.StandardOutput%2A> stream. El proceso secundario esperaría indefinidamente para que el elemento primario leer desde el completo <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
 Puede usar operaciones de lectura asincrónica para evitar estas dependencias y la posibilidad de un interbloqueo. Como alternativa, puede evitar el interbloqueo mediante la creación de dos subprocesos y leer la salida de cada secuencia en un subproceso independiente.  
  
> [!NOTE]
>  No se pueden mezclar operaciones sincrónicas y asincrónicas de lectura en una secuencia redirigida. Una vez que la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas lectura aún más las operaciones en esa secuencia deben ser del mismo modo. Por ejemplo, no siga <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> con una llamada a <xref:System.IO.StreamReader.ReadLine%2A> en el <xref:System.Diagnostics.Process.StandardError%2A> secuencia, o viceversa. Sin embargo, puede leer dos secuencias diferentes en distintos modos. Por ejemplo, puede llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> y, a continuación, llame a <xref:System.IO.StreamReader.ReadLine%2A> para el <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `net use` comando junto con un usuario proporciona el argumento para asignar un recurso de red. A continuación, lee la secuencia de error estándar del comando net y lo escribe en la consola.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha definido la redirección de la secuencia de <see cref="P:System.Diagnostics.Process.StandardError" />; asegúrese de que el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> esté establecido en <see langword="true" /> y que el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> esté establecido en <see langword="false" />.  
  
\- o - 
Se ha abierto la secuencia de <see cref="P:System.Diagnostics.Process.StandardError" /> para operaciones de lectura asincrónica con <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una secuencia que se utiliza para escribir la entrada de la aplicación.</summary>
        <value>Un <see cref="T:System.IO.StreamWriter" /> que puede utilizarse para escribir el flujo de entrada estándar de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Diagnostics.Process> puede leer texto de su flujo de entrada estándar, normalmente el teclado. Al redirigir el <xref:System.Diagnostics.Process.StandardInput%2A> stream, puede especificar mediante programación la entrada. Por ejemplo, en lugar de la entrada de teclado, puede proporcionar texto desde el contenido de un archivo designado o resultado de otra aplicación.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardInput%2A>, debe establecer <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, y deberá establecer <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> a `true`. En caso contrario, se escribe en el <xref:System.Diagnostics.Process.StandardInput%2A> secuencia produce una excepción.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo redirigir el <xref:System.Diagnostics.Process.StandardInput%2A> secuencia de un proceso. El ejemplo se inicia el `sort` comando con la entrada redirigida. A continuación, pide al usuario para el texto y pasa eso a la `sort` procesos por medio de la redirigida <xref:System.Diagnostics.Process.StandardInput%2A> stream. El `sort` resultados se muestran al usuario en la consola.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha definido la secuencia de <see cref="P:System.Diagnostics.Process.StandardInput" /> porque el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> está establecido en <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una secuencia usada para leer la salida de texto de la aplicación.</summary>
        <value>Un <see cref="T:System.IO.StreamReader" /> que puede utilizarse para leer el flujo de salida estándar de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un <xref:System.Diagnostics.Process> escribe texto en su secuencia estándar, que el texto se muestra normalmente en la consola. Al redirigir el <xref:System.Diagnostics.Process.StandardOutput%2A> stream, puede manipular o suprimir la salida de un proceso. Por ejemplo, puede filtrar el texto, formato diferente o escribir la salida en la consola y un archivo de registro designado.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardOutput%2A>, debe establecer <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> a `false`, y deberá establecer <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> a `true`. De lo contrario, al leer desde el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia produce una excepción.  
  
 El redirigida <xref:System.Diagnostics.Process.StandardOutput%2A> flujo se puede leer de forma sincrónica o asincrónica. Los métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, y <xref:System.IO.StreamReader.ReadToEnd%2A> realizar operaciones de lectura sincrónica en el flujo de salida del proceso. Estos sincrónica leer no lleva a cabo operaciones hasta que el asociado <xref:System.Diagnostics.Process> escribe en su <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir o cierra la secuencia.  
  
 En cambio, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> las operaciones de lectura asincrónica comienza en el <xref:System.Diagnostics.Process.StandardOutput%2A> stream. Este método permite que un controlador de eventos designado para la salida de la secuencia y devuelve inmediatamente al llamador, que puede realizar otro trabajo mientras se dirige la salida de la secuencia al controlador de eventos.  
  
 Sincrónico lee operaciones presentan una dependencia entre el llamador que lee desde el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia y el elemento secundario procesan la escritura en esa secuencia. Estas dependencias pueden provocar condiciones de interbloqueo. Cuando el llamador lee la secuencia redirigida de un proceso secundario, es dependiente en el elemento secundario. El llamador espera la operación de lectura hasta que el elemento secundario se escribe en la secuencia o cierra la secuencia. Cuando el proceso secundario escribe suficientes datos para rellenar su secuencia redirigida, es dependiente en el elemento primario. El proceso secundario espera la siguiente operación de escritura hasta que el elemento primario lee la secuencia completa o cierra la secuencia. La condición de interbloqueo se produce cuando el llamador y el proceso secundario esperan mutuamente para completar una operación y ninguno puede continuar. Puede evitar los interbloqueos mediante la evaluación de las dependencias entre el llamador y el proceso secundario.  
  
 El siguiente código de C#, por ejemplo, muestra cómo leer una secuencia redirigida y espere a que finalice el proceso secundario.  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 El ejemplo de código, evita una condición de interbloqueo mediante una llamada a `p.StandardOutput.ReadToEnd` antes `p.WaitForExit`. Puede dar lugar a una condición de interbloqueo si el elemento primario procesa llamadas `p.WaitForExit` antes `p.StandardOutput.ReadToEnd` y el proceso secundario escribe texto suficiente para rellenar la secuencia redirigida. El proceso primario esperaría indefinidamente para que el proceso secundario salir. El proceso secundario esperaría indefinidamente para que el elemento primario leer desde el completo <xref:System.Diagnostics.Process.StandardOutput%2A> stream.  
  
 Hay un problema similar al leer todo el texto de la salida estándar y flujos de error estándar. El siguiente código de C#, por ejemplo, realiza una operación de lectura en ambas secuencias.  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 El ejemplo de código, evita el interbloqueo mediante la realización asincrónica de las operaciones de lectura en el <xref:System.Diagnostics.Process.StandardOutput%2A> stream. Una condición de interbloqueo se produce si el elemento primario procesa llamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` y el proceso secundario escribe texto suficiente para rellenar la secuencia de error. El proceso primario podía esperar indefinidamente en el proceso secundario cerrar su <xref:System.Diagnostics.Process.StandardOutput%2A> stream. El proceso secundario esperaría indefinidamente para que el elemento primario leer desde el completo <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
 Puede usar operaciones de lectura asincrónica para evitar estas dependencias y la posibilidad de un interbloqueo. Como alternativa, puede evitar el interbloqueo mediante la creación de dos subprocesos y leer la salida de cada secuencia en un subproceso independiente.  
  
> [!NOTE]
>  No se pueden mezclar operaciones sincrónicas y asincrónicas de lectura en una secuencia redirigida. Una vez que la secuencia redirigida de un <xref:System.Diagnostics.Process> se abre en modo asincrónico o sincrónico, todas lectura aún más las operaciones en esa secuencia deben ser del mismo modo. Por ejemplo, no siga <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> con una llamada a <xref:System.IO.StreamReader.ReadLine%2A> en el <xref:System.Diagnostics.Process.StandardOutput%2A> secuencia, o viceversa. Sin embargo, puede leer dos secuencias diferentes en distintos modos. Por ejemplo, puede llamar a <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> y, a continuación, llame a <xref:System.IO.StreamReader.ReadLine%2A> para el <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
   
  
## Examples  
 El siguiente ejemplo ejecuta el comando ipconfig.exe y redirige la salida estándar a la ventana de la consola del ejemplo.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha definido la redirección de la secuencia de <see cref="P:System.Diagnostics.Process.StandardOutput" />; asegúrese de que el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> esté establecido en <see langword="true" /> y que el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> esté establecido en <see langword="false" />.  
  
\- o - 
Se ha abierto la secuencia de <see cref="P:System.Diagnostics.Process.StandardOutput" /> para operaciones de lectura asincrónica con <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia un recurso de proceso y lo asocia a un componente <see cref="T:System.Diagnostics.Process" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia (o reutiliza) el recurso de proceso especificado en la propiedad <see cref="P:System.Diagnostics.Process.StartInfo" /> de este componente <see cref="T:System.Diagnostics.Process" /> y lo asocia al componente.</summary>
        <returns>Es <see langword="true" /> si se inicia un recurso de proceso; es <see langword="false" /> si no se inicia ningún recurso de proceso nuevo (por ejemplo, si se reutiliza un recurso existente).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para iniciar un recurso de proceso y asociarlo con el actual <xref:System.Diagnostics.Process> componente. El valor devuelto `true` indica que se inició un nuevo recurso de proceso. Si el recurso de proceso especificado por el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> miembro de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad ya se está ejecutando en el equipo, no se inicia ningún recurso de proceso adicionales. En su lugar, el que se ejecuta el recurso de proceso se vuelve a usar y `false` se devuelve.  
  
 Puede iniciar una aplicación ClickOnce especificando la ubicación (por ejemplo, una dirección Web) desde el que instaló originalmente la aplicación. No inicie una aplicación ClickOnce especificando su ubicación de instalación en el disco duro.  
  
> [!NOTE]
>  Si usa Visual Studio, esta sobrecarga de la <xref:System.Diagnostics.Process.Start%2A> método es el que insertar en el código después de arrastrar un <xref:System.Diagnostics.Process> componente en el diseñador. Use la `Properties` ventana para expandir el `StartInfo` categoría y escribir el valor adecuado en el `FileName` propiedad. Los cambios aparecerán en el formulario `InitializeComponent` procedimiento.  
  
 Esta sobrecarga de <xref:System.Diagnostics.Process.Start%2A> no es un `static` método. Se debe llamar desde una instancia de la <xref:System.Diagnostics.Process> clase. Antes de llamar a <xref:System.Diagnostics.Process.Start%2A>, primero debe especificar <xref:System.Diagnostics.Process.StartInfo%2A> información de propiedad para este <xref:System.Diagnostics.Process> instancia, porque esa información se usa para determinar el recurso de proceso para iniciar.  
  
 Las demás sobrecargas de los <xref:System.Diagnostics.Process.Start%2A> son el método `static` miembros. No es necesario crear una instancia de la <xref:System.Diagnostics.Process> componente antes de llamar a las sobrecargas del método. En su lugar, puede llamar a <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> clase propio y un nuevo <xref:System.Diagnostics.Process> se crea un componente si se inició el proceso. O bien, `null` se devuelve si se reutiliza un proceso. El recurso de proceso se asocia automáticamente con el nuevo <xref:System.Diagnostics.Process> componente que es devuelto por la <xref:System.Diagnostics.Process.Start%2A> método.  
  
 El <xref:System.Diagnostics.Process.StartInfo%2A> miembros se pueden usar para duplicar la funcionalidad de la `Run` cuadro de diálogo de la Windows `Start` menú. Todo lo que se pueden escribir en una línea de comandos se puede iniciar mediante el establecimiento de los valores adecuados en el <xref:System.Diagnostics.Process.StartInfo%2A> propiedad. La única <xref:System.Diagnostics.Process.StartInfo%2A> es la propiedad que se debe establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad. El <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad no tiene que ser un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación que está instalada en el sistema. Por ejemplo, el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad puede tener una extensión. txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word.  
  
 En la línea de comandos, puede especificar acciones que deben realizarse para determinados tipos de archivos. Por ejemplo, puede imprimir documentos o editar archivos de texto. Especificar estas acciones mediante la <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> miembro de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad. Para otros tipos de archivos, puede especificar argumentos de línea de comandos al iniciar el archivo desde el `Run` cuadro de diálogo. Por ejemplo, puede pasar una dirección URL como argumento si se especifica en el explorador como el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Estos argumentos se pueden especificar en el <xref:System.Diagnostics.Process.StartInfo%2A> la propiedad <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> miembro.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe calificar totalmente esa ruta de acceso al iniciar cualquier proceso que se encuentra en esa ubicación. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agréguela mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
> [!NOTE]
>  Código de control de página y el servidor Web de ASP.NET se ejecuta en el contexto de proceso de trabajo ASP.NET en el servidor Web.  Si usas el <xref:System.Diagnostics.Process.Start%2A> método en una página Web ASP.NET o un control de servidor, el nuevo proceso se ejecuta en el servidor Web con permisos restringidos. El proceso no se inicia en el mismo contexto que el explorador del cliente y no tiene acceso al escritorio del usuario.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, es posible que deba cerrarlo corre el riesgo de perder los recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad.  
  
 Aquí es necesaria una nota sobre los Estados de apartamento en subprocesos administrados. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> es `true` en el componente de proceso <xref:System.Diagnostics.Process.StartInfo%2A> propiedad, asegúrese de que ha establecido un modelo de subprocesos en la aplicación estableciendo el atributo `[STAThread]` en el `main()` método. En caso contrario, un subproceso administrado puede estar en un `unknown` estado o colocar en el `MTA` estado, que entra en conflicto con esta última <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> que se va a `true`. Algunos métodos requieren que no sea el estado del apartamento `unknown`. Si el estado no se establece explícitamente, cuando la aplicación detecta este tipo de método, el valor predeterminado es `MTA`, y una vez establecido, no se puede cambiar el estado del apartamento. Sin embargo, `MTA` produce una excepción se produce cuando el shell del sistema operativo administra el subproceso.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa una instancia de la <xref:System.Diagnostics.Process> clase para iniciar un proceso.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se especificó ningún nombre de archivo en la propiedad <see cref="T:System.Diagnostics.Process" /> del componente <see cref="P:System.Diagnostics.Process.StartInfo" />.
O bien, el miembro <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> de la propiedad <see cref="P:System.Diagnostics.Process.StartInfo" /> es <see langword="true" />, mientras que <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> o <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> es <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Se produjo un error al abrir el archivo asociado.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de proceso ya se ha desechado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método que no se admite en sistemas operativos sin la compatibilidad de shell, como Nano Server (solo en .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> que contiene la información que se utiliza para iniciar el proceso, incluidos el nombre de archivo y los argumentos de línea de comandos.</param>
        <summary>Inicia el recurso de proceso que se especifica mediante el parámetro que contiene la información de inicio del proceso (por ejemplo, el nombre de archivo del proceso que se va a iniciar) y asocia el recurso a un nuevo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuevo <see cref="T:System.Diagnostics.Process" /> que está asociado al recurso del proceso, o <see langword="null" /> si no se inicia ningún recurso de proceso. Tenga en cuenta que un proceso nuevo que se inicie junto a instancias del mismo proceso ya en ejecución será independiente del resto. Además, Inicio puede devolver un proceso no nulo con su propiedad <see cref="P:System.Diagnostics.Process.HasExited" /> ya establecida en <see langword="true" />. En tal caso, el proceso iniciado puede haber activado una instancia existente de sí mismo y, a continuación, haber salido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para iniciar un recurso de proceso mediante la especificación de un <xref:System.Diagnostics.ProcessStartInfo> instancia. La sobrecarga asocia el recurso a un nuevo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. Utilizar esta sobrecarga con un <xref:System.Diagnostics.ProcessStartInfo> parámetro es una alternativa a los pasos explícitos de crear un nuevo <xref:System.Diagnostics.Process> instancia, establecer su <xref:System.Diagnostics.Process.StartInfo%2A> propiedades y llamar al método <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 Mediante un <xref:System.Diagnostics.ProcessStartInfo> como el parámetro le permite llamar a la instancia <xref:System.Diagnostics.Process.Start%2A> con el máximo control sobre lo que se pasa a la llamada para iniciar el proceso. Si necesita pasar solo un nombre de archivo o un nombre de archivo y argumentos, no es necesario crear un nuevo <xref:System.Diagnostics.ProcessStartInfo> de instancia, aunque es una opción. La única <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> es la propiedad que se debe establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad. El <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad no necesita representar un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación que está instalada en el sistema. Por ejemplo, el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad puede tener una extensión. txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word.  
  
 Puede iniciar una aplicación ClickOnce especificando la ubicación (por ejemplo, una dirección Web) desde el que instaló originalmente la aplicación. No inicie una aplicación ClickOnce especificando su ubicación de instalación en el disco duro.  
  
 Si el <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> y <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propiedades de la <xref:System.Diagnostics.Process.StartInfo%2A> instancia están establecidas, no administrado `CreateProcessWithLogonW` función se llama, que inicia el proceso en una nueva ventana aunque se utilicen los <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> es el valor de propiedad `true` o la <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> es el valor de propiedad <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Si el <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> propiedad es `null`, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> propiedad debe estar en formato UPN, *usuario*@*nombreDeDominioDNS*.   
  
 A diferencia de las otras sobrecargas, la sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que no tiene parámetros no es un `static` miembro. Utilizar esa sobrecarga cuando ya ha creado un <xref:System.Diagnostics.Process> de instancia, información de inicio especificada (incluido el nombre de archivo) y desea iniciar un recurso de proceso y asociarlo a la existente <xref:System.Diagnostics.Process> instancia. Utilice uno de los `static` sobrecarga cuando desee crear un nuevo <xref:System.Diagnostics.Process> componente en lugar de iniciar un proceso para un componente existente. Esta sobrecarga y la sobrecarga que no tiene parámetros le permiten especificar la información de inicio para el recurso de proceso mediante el uso de un <xref:System.Diagnostics.ProcessStartInfo> instancia.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe calificar totalmente esa ruta de acceso al iniciar cualquier proceso que se encuentra en esa ubicación. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agréguela mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
> [!NOTE]
>  Código de control de página y el servidor Web de ASP.NET se ejecuta en el contexto de proceso de trabajo ASP.NET en el servidor Web.  Si usas el <xref:System.Diagnostics.Process.Start%2A> método en una página Web ASP.NET o un control de servidor, el nuevo proceso se ejecuta en el servidor Web con permisos restringidos. El proceso no se inicia en el mismo contexto que el explorador del cliente y no tiene acceso al escritorio del usuario.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, es posible que deba cerrarlo corre el riesgo de perder los recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad.  
  
 Aquí es necesaria una nota sobre los Estados de apartamento en subprocesos administrados. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> es `true` en el `startInfo` parámetro, asegúrese de que ha establecido un modelo de subprocesos en la aplicación estableciendo el atributo `[STAThread]` en el `main()` método. En caso contrario, un subproceso administrado puede estar en un `unknown` estado o colocar en el `MTA` estado, que entra en conflicto con esta última <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> que se va a `true`. Algunos métodos requieren que no sea el estado del apartamento `unknown`. Si el estado no se establece explícitamente, cuando la aplicación detecta este tipo de método, el valor predeterminado es `MTA`, y una vez establecido, no se puede cambiar el estado del apartamento. Sin embargo, `MTA` produce una excepción se produce cuando el shell del sistema operativo administra el subproceso.  
  
   
  
## Examples  
 En primer lugar el ejemplo siguiente genera una instancia de Internet Explorer y muestra el contenido de la carpeta Favoritos en el explorador. A continuación, algunas otras instancias de Internet Explorer se inicia y muestra algunas páginas o sitios específicos. Por último, inicia Internet Explorer con la ventana minimizada mientras se navega a un sitio específico.  
  
 Para obtener ejemplos adicionales de otros usos de este método, consulte las propiedades individuales de la <xref:System.Diagnostics.ProcessStartInfo> clase.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha especificado ningún nombre de archivo en la propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> del parámetro <paramref name="startInfo" />.  
  
O bien 
La propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> del parámetro <paramref name="startInfo" /> es <see langword="true" /> y las propiedades <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> o <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> también son <see langword="true" />.  
  
O bien 
La propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> del parámetro <paramref name="startInfo" /> es <see langword="true" /> y la propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> no es <see langword="null" /> o está vacía, o la propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="startInfo" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de proceso ya se ha desechado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo especificado en la propiedad <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> del parámetro <paramref name="startInfo" /> no se encontró.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Se produjo un error al abrir el archivo asociado.  
  
O bien 
La suma de la longitud de los argumentos y la longitud de la ruta de acceso completa en el proceso supera 2080. El mensaje de error asociado a esta excepción puede ser uno de los siguientes: "el área de datos que se pasa a una llamada del sistema es demasiado pequeña". o "Se denegó el acceso".</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método que no se admite en sistemas operativos sin la compatibilidad de shell, como Nano Server (solo en .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de documento o aplicación que se va a ejecutar en el proceso.</param>
        <summary>Inicia un recurso de proceso con la especificación del nombre de un documento o de un archivo de aplicación y asocia el recurso a un nuevo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuevo <see cref="T:System.Diagnostics.Process" /> que está asociado al recurso del proceso, o <see langword="null" /> si no se inicia ningún recurso de proceso. Tenga en cuenta que un proceso nuevo que se inicie junto a instancias del mismo proceso ya en ejecución será independiente del resto. Además, Inicio puede devolver un proceso no nulo con su propiedad <see cref="P:System.Diagnostics.Process.HasExited" /> ya establecida en <see langword="true" />. En tal caso, el proceso iniciado puede haber activado una instancia existente de sí mismo y, a continuación, haber salido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para iniciar un recurso de proceso mediante la especificación de su nombre de archivo. La sobrecarga asocia el recurso a un nuevo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. La sobrecarga es una alternativa a los pasos explícitos de crear un nuevo <xref:System.Diagnostics.Process> instancia, establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> miembro de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llamar al método <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 Iniciar una aplicación ClickOnce se puede establecer el `fileName` parámetro a la ubicación (por ejemplo, una dirección Web) desde el que instaló originalmente la aplicación. No inicie una aplicación ClickOnce especificando su ubicación de instalación en el disco duro.  
  
 Iniciar un proceso especificando su nombre de archivo es similar a escribir la información de la `Run` cuadro de diálogo de la Windows `Start` menú. Por lo tanto, el nombre de archivo no es necesario representar un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación instalada en el sistema. Por ejemplo, el nombre de archivo puede tener una extensión. txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word. De forma similar, en la misma forma en que el `Run` cuadro de diálogo acepta un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en el `fileName` parámetro. Por ejemplo, puede establecer el `fileName` parámetro "Notepad.exe" o "Notepad".  
  
 Esta sobrecarga no permite argumentos de línea de comandos para el proceso. Si tiene que especificar uno o más argumentos de línea de comandos para el proceso, utilice el <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> o <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecargas.  
  
 A diferencia de las otras sobrecargas, la sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que no tiene parámetros no es un `static` miembro. Utilizar esa sobrecarga cuando ya ha creado un <xref:System.Diagnostics.Process> de instancia, información de inicio especificada (incluido el nombre de archivo) y desea iniciar un recurso de proceso y asociarlo a la existente <xref:System.Diagnostics.Process> instancia. Utilice uno de los `static` sobrecarga cuando desee crear un nuevo <xref:System.Diagnostics.Process> componente en lugar de iniciar un proceso para un componente existente. Esta sobrecarga y la sobrecarga que no tiene parámetros permiten especificar el nombre de archivo del recurso de proceso para iniciar.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe calificar totalmente esa ruta de acceso al iniciar cualquier proceso que se encuentra en esa ubicación. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agréguela mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
> [!NOTE]
>  Código de control de página y el servidor Web de ASP.NET se ejecuta en el contexto de proceso de trabajo ASP.NET en el servidor Web.  Si usas el <xref:System.Diagnostics.Process.Start%2A> método en una página Web ASP.NET o un control de servidor, el nuevo proceso se ejecuta en el servidor Web con permisos restringidos. El proceso no se inicia en el mismo contexto que el explorador del cliente y no tiene acceso al escritorio del usuario.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, es posible que deba cerrarlo corre el riesgo de perder los recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad.  
  
 Aquí es necesaria una nota sobre los Estados de apartamento en subprocesos administrados. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> es `true` en el componente de proceso <xref:System.Diagnostics.Process.StartInfo%2A> propiedad, asegúrese de que ha establecido un modelo de subprocesos en la aplicación estableciendo el atributo `[STAThread]` en el `main()` método. En caso contrario, un subproceso administrado puede estar en un `unknown` estado o colocar en el `MTA` estado, que entra en conflicto con esta última <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> que se va a `true`. Algunos métodos requieren que no sea el estado del apartamento `unknown`. Si el estado no se establece explícitamente, cuando la aplicación detecta este tipo de método, el valor predeterminado es `MTA`, y una vez establecido, no se puede cambiar el estado del apartamento. Sin embargo, `MTA` produce una excepción se produce cuando el shell del sistema operativo administra el subproceso.  
  
   
  
## Examples  
 En primer lugar el ejemplo siguiente genera una instancia de Internet Explorer y muestra el contenido de la carpeta Favoritos en el explorador. A continuación, algunas otras instancias de Internet Explorer se inicia y muestra algunas páginas o sitios específicos. Por último, inicia Internet Explorer con la ventana minimizada mientras se navega a un sitio específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Error al abrir el archivo asociado.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de proceso ya se ha desechado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La variable de entorno PATH tiene una cadena que contiene comillas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de aplicación que se va a ejecutar en el proceso.</param>
        <param name="arguments">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</param>
        <summary>Inicia un recurso de proceso mediante la especificación del nombre de una aplicación y un conjunto de argumentos de línea de comandos, y asocia el recurso a un nuevo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuevo <see cref="T:System.Diagnostics.Process" /> que está asociado al recurso del proceso, o <see langword="null" /> si no se inicia ningún recurso de proceso. Tenga en cuenta que un proceso nuevo que se inicie junto a instancias del mismo proceso ya en ejecución será independiente del resto. Además, Inicio puede devolver un proceso no nulo con su propiedad <see cref="P:System.Diagnostics.Process.HasExited" /> ya establecida en <see langword="true" />. En tal caso, el proceso iniciado puede haber activado una instancia existente de sí mismo y, a continuación, haber salido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para iniciar un recurso de proceso mediante la especificación de su nombre de archivo y argumentos de línea de comandos. La sobrecarga asocia el recurso a un nuevo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. La sobrecarga es una alternativa a los pasos explícitos de crear un nuevo <xref:System.Diagnostics.Process> instancia, establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> y <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> los miembros de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y llamar al método <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 Iniciar un proceso especificando el nombre de archivo y los argumentos es similar a escribir el nombre de archivo y argumentos de línea de comandos en el `Run` cuadro de diálogo de la Windows `Start` menú. Por lo tanto, el nombre de archivo no es necesario representar un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación instalada en el sistema. Por ejemplo, el nombre de archivo puede tener una extensión. txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word. De forma similar, en la misma forma en que el `Run` cuadro de diálogo acepta un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en el `fileName` parámetro. Por ejemplo, puede establecer el `fileName` parámetro "Notepad.exe" o "Notepad". Si el `fileName` parámetro representa un archivo ejecutable, el `arguments` parámetro podría representar un archivo que se va a actuar como el archivo de texto en `Notepad.exe myfile.txt`. Si el `fileName` parámetro representa un archivo de comandos (.cmd), el `arguments` parámetro debe incluir un "`/c`"o"`/k`" argumento para especificar si la ventana de comandos se cierra o se mantiene tras la finalización.  
  
 A diferencia de las otras sobrecargas, la sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que no tiene parámetros no es un `static` miembro. Utilizar esa sobrecarga cuando ya ha creado un <xref:System.Diagnostics.Process> de instancia, información de inicio especificada (incluido el nombre de archivo) y desea iniciar un recurso de proceso y asociarlo a la existente <xref:System.Diagnostics.Process> instancia. Utilice uno de los `static` sobrecarga cuando desee crear un nuevo <xref:System.Diagnostics.Process> componente en lugar de iniciar un proceso para un componente existente. Esta sobrecarga y la sobrecarga que no tiene parámetros permiten especificar el nombre de archivo del recurso de proceso para iniciar y argumentos de línea de comandos que se pasan.  
  
 Si tiene una variable de ruta de acceso declarada en el sistema mediante comillas, debe calificar totalmente esa ruta de acceso al iniciar cualquier proceso que se encuentra en esa ubicación. En caso contrario, el sistema no encontrará la ruta de acceso. Por ejemplo, si `c:\mypath` no está en la ruta de acceso, y agréguela mediante comillas: `path = %path%;"c:\mypath"`, debe calificar totalmente cualquier proceso en `c:\mypath` al iniciarlo.  
  
> [!NOTE]
>  Código de control de página y el servidor Web de ASP.NET se ejecuta en el contexto de proceso de trabajo ASP.NET en el servidor Web.  Si usas el <xref:System.Diagnostics.Process.Start%2A> método en una página Web ASP.NET o un control de servidor, el nuevo proceso se ejecuta en el servidor Web con permisos restringidos. El proceso no se inicia en el mismo contexto que el explorador del cliente y no tiene acceso al escritorio del usuario.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, es posible que deba cerrarlo corre el riesgo de perder los recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad...  
  
 Aquí es necesaria una nota sobre los Estados de apartamento en subprocesos administrados. Cuando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> es `true` en el componente de proceso <xref:System.Diagnostics.Process.StartInfo%2A> propiedad, asegúrese de que ha establecido un modelo de subprocesos en la aplicación estableciendo el atributo `[STAThread]` en el `main()` método. En caso contrario, un subproceso administrado puede estar en un `unknown` estado o colocar en el `MTA` estado, que entra en conflicto con esta última <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> que se va a `true`. Algunos métodos requieren que no sea el estado del apartamento `unknown`. Si el estado no se establece explícitamente, cuando la aplicación detecta este tipo de método, el valor predeterminado es `MTA`, y una vez establecido, no se puede cambiar el estado del apartamento. Sin embargo, `MTA` produce una excepción se produce cuando el shell del sistema operativo administra el subproceso.  
  
   
  
## Examples  
 En primer lugar el ejemplo siguiente genera una instancia de Internet Explorer y muestra el contenido de la carpeta Favoritos en el explorador. A continuación, algunas otras instancias de Internet Explorer se inicia y muestra algunas páginas o sitios específicos. Por último, inicia Internet Explorer con la ventana minimizada mientras se navega a un sitio específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El valor del parámetro <paramref name="fileName" /> o <paramref name="arguments" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Error al abrir el archivo asociado.  
  
O bien 
La suma de la longitud de los argumentos y la longitud de la ruta de acceso completa en el proceso supera 2080. El mensaje de error asociado a esta excepción puede ser uno de los siguientes: "el área de datos que se pasa a una llamada del sistema es demasiado pequeña". o "Se denegó el acceso".</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de proceso ya se ha desechado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">La variable de entorno PATH tiene una cadena que contiene comillas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de aplicación que se va a ejecutar en el proceso.</param>
        <param name="userName">Nombre de usuario que se va a utilizar al iniciarse el proceso.</param>
        <param name="password">
          <see cref="T:System.Security.SecureString" /> que contiene la contraseña que se va a utilizar al iniciarse el proceso.</param>
        <param name="domain">Dominio que se va a utilizar al iniciarse el proceso.</param>
        <summary>Inicia un recurso de proceso mediante la especificación del nombre de una aplicación, un nombre de usuario, una contraseña y un dominio, y asocia el recurso a un nuevo componente de <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuevo <see cref="T:System.Diagnostics.Process" /> que está asociado al recurso del proceso, o <see langword="null" /> si no se inicia ningún recurso de proceso. Tenga en cuenta que un proceso nuevo que se inicie junto a instancias del mismo proceso ya en ejecución será independiente del resto. Además, Inicio puede devolver un proceso no nulo con su propiedad <see cref="P:System.Diagnostics.Process.HasExited" /> ya establecida en <see langword="true" />. En tal caso, el proceso iniciado puede haber activado una instancia existente de sí mismo y, a continuación, haber salido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear un nuevo proceso y su subproceso principal especificando su nombre de archivo, nombre de usuario, contraseña y dominio. El nuevo proceso, a continuación, ejecuta el archivo ejecutable especificado en el contexto de seguridad de las credenciales especificadas (usuario, dominio y contraseña).  
  
> [!NOTE]
>  Cuando el archivo ejecutable se encuentra en una unidad remota, debe identificar el recurso compartido de red mediante el uso de un identificador uniforme de recursos (URI), no una letra de unidad vinculada.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. La sobrecarga es una alternativa a los pasos de creación de un nuevo explícitos <xref:System.Diagnostics.Process> instancia, establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, y <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propiedades de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y una llamada a <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 De forma similar, en la misma forma en que el **ejecutar** cuadro de diálogo acepta un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en el `fileName` parámetro. Por ejemplo, puede establecer el `fileName` parámetro "Notepad.exe" o "Notepad". Si el `fileName` parámetro representa un archivo ejecutable, el `arguments` parámetro podría representar un archivo que se va a actuar como el archivo de texto en `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  El nombre de archivo debe representar un archivo ejecutable en el <xref:System.Diagnostics.Process.Start%2A> sobrecargas que tienen `userName`, `password`, y `domain` parámetros.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, es posible que deba cerrarlo corre el riesgo de perder los recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad...  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de esta sobrecarga para iniciar un archivo ejecutable y también se muestra el inicio de un <xref:System.ComponentModel.Win32Exception> cuando se realiza un intento para iniciar una aplicación asociada a un archivo no ejecutable.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha especificado ningún nombre de archivo.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Se produjo un error al abrir el archivo asociado.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de proceso ya se ha desechado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método no compatible en Linux o macOS (solo en .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nombre de un archivo de aplicación que se va a ejecutar en el proceso.</param>
        <param name="arguments">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</param>
        <param name="userName">Nombre de usuario que se va a usar al iniciarse el proceso.</param>
        <param name="password">
          <see cref="T:System.Security.SecureString" /> que contiene la contraseña que se va a utilizar al iniciarse el proceso.</param>
        <param name="domain">Dominio que se va a utilizar al iniciarse el proceso.</param>
        <summary>Inicia un recurso de proceso mediante la especificación del nombre de una aplicación y un conjunto de argumentos de línea de comandos, un nombre de usuario, una contraseña y un dominio, y asocia el recurso a un nuevo componente de <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Nuevo <see cref="T:System.Diagnostics.Process" /> que está asociado al recurso del proceso, o <see langword="null" /> si no se inicia ningún recurso de proceso. Tenga en cuenta que un proceso nuevo que se inicie junto a instancias del mismo proceso ya en ejecución será independiente del resto. Además, Inicio puede devolver un proceso no nulo con su propiedad <see cref="P:System.Diagnostics.Process.HasExited" /> ya establecida en <see langword="true" />. En tal caso, el proceso iniciado puede haber activado una instancia existente de sí mismo y, a continuación, haber salido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga para crear un nuevo proceso y su subproceso principal especificando su nombre de archivo argumentos de línea de comandos, nombre de usuario, contraseña y dominio. El nuevo proceso, a continuación, ejecuta el archivo ejecutable especificado en el contexto de seguridad de las credenciales especificadas (usuario, dominio y contraseña).  
  
> [!NOTE]
>  Cuando el archivo ejecutable se encuentra en una unidad remota, debe identificar el recurso compartido de red mediante el uso de un identificador uniforme de recursos (URI), no una letra de unidad vinculada.  
  
> [!NOTE]
>  Si la dirección del archivo ejecutable para iniciar es una dirección URL, no se ha iniciado el proceso y `null` se devuelve.  
  
 Esta sobrecarga permite iniciar un proceso sin crear primero un nuevo <xref:System.Diagnostics.Process> instancia. La sobrecarga es una alternativa a los pasos de creación de un nuevo explícitos <xref:System.Diagnostics.Process> instancia, establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, y <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propiedades de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad y una llamada a <xref:System.Diagnostics.Process.Start%2A> para el <xref:System.Diagnostics.Process> instancia.  
  
 De forma similar, en la misma forma en que el **ejecutar** cuadro de diálogo acepta un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en el `fileName` parámetro. Por ejemplo, puede establecer el `fileName` parámetro "Notepad.exe" o "Notepad". Si el `fileName` parámetro representa un archivo ejecutable, el `arguments` parámetro podría representar un archivo que se va a actuar como el archivo de texto en `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  El nombre de archivo debe representar un archivo ejecutable en el <xref:System.Diagnostics.Process.Start%2A> sobrecargas que tienen `userName`, `password`, y `domain` parámetros.  
  
 Siempre que use <xref:System.Diagnostics.Process.Start%2A> para iniciar un proceso, es posible que deba cerrarlo corre el riesgo de perder los recursos del sistema. Cerrar procesos utilizando <xref:System.Diagnostics.Process.CloseMainWindow%2A> o <xref:System.Diagnostics.Process.Kill%2A>. Puede comprobar si un proceso ya se ha cerrado mediante el uso de su <xref:System.Diagnostics.Process.HasExited%2A> propiedad...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha especificado ningún nombre de archivo.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Error al abrir el archivo asociado.  
  
O bien 
La suma de la longitud de los argumentos y la longitud de la ruta de acceso completa en el archivo asociado supera 2080. El mensaje de error asociado a esta excepción puede ser uno de los siguientes: "el área de datos que se pasa a una llamada del sistema es demasiado pequeña". o "Se denegó el acceso".</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto de proceso ya se ha desechado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método no compatible en Linux o macOS (solo en .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece las propiedades que se pasan al método <see cref="M:System.Diagnostics.Process.Start" /> de <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessStartInfo" /> que representa los datos con los que iniciar el proceso. Estos argumentos incluyen el nombre del archivo ejecutable o del documento que se utilizó para iniciar el proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> representa el conjunto de parámetros que se usarán para iniciar un proceso. Cuando <xref:System.Diagnostics.Process.Start%2A> se llama, el <xref:System.Diagnostics.Process.StartInfo%2A> se utiliza para especificar que se inicie el proceso. Solo es necesario <xref:System.Diagnostics.Process.StartInfo%2A> es miembro para establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad. Iniciar un proceso mediante la especificación de la <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad es similar a escribir la información de la **ejecutar** cuadro de diálogo de la Windows **iniciar** menú. Por lo tanto, el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad no necesita representar un archivo ejecutable. Puede ser de cualquier tipo de archivo para el que la extensión se ha asociado con una aplicación instalada en el sistema. Por ejemplo el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> puede tener una extensión. txt si se han asociado los archivos de texto con un editor, como el Bloc de notas, o puede tener la extensión .doc si se han asociado los archivos con una herramienta de procesamiento de textos, como Microsoft Word. De forma similar, en la misma forma en que el **ejecutar** cuadro de diálogo acepta un nombre de archivo ejecutable con o sin la extensión .exe, la extensión .exe es opcional en el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> miembro. Por ejemplo, puede establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad en "Notepad.exe" o "Notepad".  
  
 Iniciar una aplicación ClickOnce se puede establecer el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad a la ubicación (por ejemplo, una dirección Web) desde el que instaló originalmente la aplicación. No inicie una aplicación ClickOnce especificando su ubicación de instalación en el disco duro.  
  
 Si el nombre de archivo incluye un archivo no ejecutable, como un archivo .doc, puede incluir un verbo que especifique qué acción realizar en el archivo. Por ejemplo, puede establecer el <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> a "Print" para un archivo que termina en la extensión .doc. El nombre de archivo especificado en el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad no necesita tener una extensión si especifica manualmente un valor para el <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> propiedad. Sin embargo, si usa el <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> propiedad para determinar los verbos que están disponibles, debe incluir la extensión.  
  
 Puede cambiar los parámetros especificados en el <xref:System.Diagnostics.Process.StartInfo%2A> propiedad hasta el momento en que se llama el <xref:System.Diagnostics.Process.Start%2A> método en el proceso. Después de iniciar el proceso, cambiar el <xref:System.Diagnostics.Process.StartInfo%2A> valores no afecta ni reiniciar el proceso asociado. Si se llama a la <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> método con el <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> y <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propiedades establecidas, no administrado `CreateProcessWithLogonW` función se llama, que inicia el proceso en una nueva ventana aunque se utilicen el <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> es el valor de propiedad `true` o la <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> es el valor de propiedad <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Si no ha usado el <xref:System.Diagnostics.Process.Start%2A> método para iniciar un proceso, el <xref:System.Diagnostics.Process.StartInfo%2A> propiedad no refleja los parámetros utilizados para iniciar el proceso. Por ejemplo, si usa <xref:System.Diagnostics.Process.GetProcesses%2A> para obtener una matriz de los procesos que se ejecutan en el equipo, el <xref:System.Diagnostics.Process.StartInfo%2A> propiedad de cada uno <xref:System.Diagnostics.Process> no contiene el nombre del archivo original o argumentos que se usan para iniciar el proceso.  
  
 Cuando se inicia el proceso, el nombre de archivo es el archivo que rellena la (de solo lectura) <xref:System.Diagnostics.Process.MainModule%2A> propiedad. Si desea recuperar el archivo ejecutable que está asociado con el proceso una vez iniciado el proceso, utilice el <xref:System.Diagnostics.Process.MainModule%2A> propiedad. Si desea establecer el archivo ejecutable de un <xref:System.Diagnostics.Process> de la instancia para que no se ha iniciado un proceso asociado, utilice el <xref:System.Diagnostics.Process.StartInfo%2A> la propiedad <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> miembro. Porque los miembros de la <xref:System.Diagnostics.Process.StartInfo%2A> propiedad son los argumentos que se pasan a la <xref:System.Diagnostics.Process.Start%2A> método de un proceso, cambiar el <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propiedad una vez iniciado el proceso asociado no se restablecerá el <xref:System.Diagnostics.Process.MainModule%2A> propiedad. Estas propiedades se usan solo para inicializar el proceso asociado.  
  
   
  
## Examples  
 En el ejemplo siguiente se rellena un <xref:System.Diagnostics.Process.StartInfo%2A> con el archivo para ejecutar, realizar la acción en él y si debe mostrar una interfaz de usuario. Para obtener ejemplos adicionales, consulte las páginas de referencia para las propiedades de la <xref:System.Diagnostics.ProcessStartInfo> clase.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor especificado por la propiedad <see cref="P:System.Diagnostics.Process.StartInfo" /> es <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el momento en el que se inició el proceso asociado.</summary>
        <value>Objeto que indica cuándo se inició el proceso. Si no se está ejecutando el proceso, se produce una excepción.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <exception cref="T:System.NotSupportedException">Está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.StartTime" /> de un proceso que se ejecuta en un equipo remoto. Esta propiedad está disponible únicamente para los procesos que se ejecutan en el equipo local.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso ha terminado.  
  
O bien 
No se ha iniciado el proceso.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Error durante la llamada a la función de Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto utilizado para calcular las referencias de las llamadas del controlador de eventos emitidas como resultado de un evento de terminación del proceso.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> que se usa para calcular las referencias de las llamadas del controlador de eventos emitidas como resultado de un evento <see cref="E:System.Diagnostics.Process.Exited" /> del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> es `null`, los métodos que controlan el <xref:System.Diagnostics.Process.Exited> evento se denominan en un subproceso del grupo de subprocesos del sistema. Para obtener más información acerca de los grupos de subprocesos del sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Cuando el <xref:System.Diagnostics.Process.Exited> evento está controlado por un componente de Windows Forms visual, como un <xref:System.Windows.Forms.Button>, acceso al componente en el grupo de subprocesos del sistema podrían no funcionar, o se podría producir una excepción. Evitar esta situación estableciendo <xref:System.Diagnostics.Process.SynchronizingObject%2A> a un componente de Windows Forms, lo que hace que los métodos que controlan el <xref:System.Diagnostics.Process.Exited> evento al que se llama en el mismo subproceso en el que se creó el componente.  
  
 Si el <xref:System.Diagnostics.Process> se utiliza dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] en un diseñador de Windows Forms, <xref:System.Diagnostics.Process.SynchronizingObject%2A> se establece automáticamente en el control que contiene el <xref:System.Diagnostics.Process>. Por ejemplo, si coloca un <xref:System.Diagnostics.Process> en un diseñador para `Form1` (que hereda de <xref:System.Windows.Forms.Form>) la <xref:System.Diagnostics.Process.SynchronizingObject%2A> propiedad de <xref:System.Diagnostics.Process> se establece en la instancia de `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Normalmente, esta propiedad se establece cuando el componente se coloca dentro de un control o formulario, porque estos componentes están enlazados a un subproceso específico.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el conjunto de subprocesos que se están ejecutando en el proceso asociado.</summary>
        <value>Matriz de tipo <see cref="T:System.Diagnostics.ProcessThread" /> que representa los subprocesos del sistema operativo que se están ejecutando actualmente en el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un subproceso ejecuta código en un proceso. Cada proceso se inicia con un único subproceso, su subproceso principal. Cualquier subproceso puede crear subprocesos adicionales. Los subprocesos dentro de un proceso comparten el espacio de direcciones del proceso.  
  
 Use <xref:System.Diagnostics.ProcessThread> para obtener todos los subprocesos asociados con el proceso actual. El subproceso principal no es necesariamente en el índice cero de la matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">El proceso no tiene un <see cref="P:System.Diagnostics.Process.Id" /> o no hay ningún proceso asociado a la instancia de <see cref="T:System.Diagnostics.Process" />.  
  
O bien 
El proceso asociado finalizó.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me); establezca el valor de <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> en <see langword="false" /> para tener acceso a esta propiedad en Windows 98 y Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aplica formato de cadena al nombre del proceso, combinándolo con el tipo de componente principal, si es aplicable.</summary>
        <returns>
          <see cref="P:System.Diagnostics.Process.ProcessName" />, combinado con el valor devuelto de <see cref="M:System.Object.ToString" /> del componente base.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" /> no es compatible con Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tiempo de procesador total de este proceso.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> indica la cantidad de tiempo que el proceso asociado ha empleado en utilizar la CPU. Este valor es la suma de <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> y <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <exception cref="T:System.NotSupportedException">Está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> de un proceso que se ejecuta en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tiempo de procesador de usuario de este proceso.</summary>
        <value>
          <see cref="T:System.TimeSpan" /> que indica la cantidad de tiempo que el proceso asociado ha empleado en ejecutar código en la parte de la aplicación que corresponde al proceso (no en el núcleo del sistema operativo).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <exception cref="T:System.NotSupportedException">Está intentando obtener acceso a la propiedad <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> de un proceso que se ejecuta en un equipo remoto. Esta propiedad sólo está disponible para los procesos que se ejecutan en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de la memoria virtual del proceso en bytes.</summary>
        <value>Cantidad de memoria virtual, en bytes, solicitada por el proceso asociado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad de la memoria virtual, en bytes, que se asignó para el proceso asociado.</summary>
        <value>El tamaño de memoria virtual, expresado en bytes, que se ha asignado para el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual de memoria virtual utilizada por el proceso, en bytes. El sistema operativo asigna espacio de direcciones virtuales para cada proceso a las páginas se cargan en la memoria física, o a las páginas que se almacenan en el archivo de paginación de memoria virtual en el disco.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **Bytes virtuales** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece el período de tiempo que se debe esperar hasta que termine el proceso asociado y bloquea el subproceso que se está ejecutando en ese momento hasta que el tiempo de espera se haya agotado o el proceso haya terminado. Para evitar el bloqueo del subproceso actual, use el evento <see cref="E:System.Diagnostics.Process.Exited" />.  
  
Para obtener ejemplos de código, consulte las páginas de referencia de las propiedades <see cref="P:System.Diagnostics.Process.StandardError" /> y <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica al componente <see cref="T:System.Diagnostics.Process" /> que espere indefinidamente hasta que el proceso asociado termine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> hace que el subproceso actual espere hasta que finaliza el proceso asociado.  Debe llamarse después de que todos los demás métodos se llaman en el proceso. Para evitar el bloqueo del subproceso actual, use el evento <xref:System.Diagnostics.Process.Exited>.  
  
 Este método indica la <xref:System.Diagnostics.Process> componente que espere una cantidad infinita de tiempo para el proceso y controladores de eventos salir. Esto puede hacer que una aplicación deje de responder. Por ejemplo, si se llama a <xref:System.Diagnostics.Process.CloseMainWindow%2A> para un proceso que tiene una interfaz de usuario, la solicitud al sistema operativo para terminar el proceso asociado es posible que no se controla si el proceso se escribe en su bucle de mensajes no escriben nunca.  
  
> [!NOTE]
>  En el [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] y versiones anteriores, el <xref:System.Diagnostics.Process.WaitForExit> esperó sobrecarga <xref:System.Int32.MaxValue> milisegundos (aproximadamente 24 días), not indefinidamente. Además, las versiones anteriores no esperaba a los controladores de eventos salir si el completo <xref:System.Int32.MaxValue> se alcanzó el tiempo.  
  
 Esta sobrecarga garantiza que se ha completado todo el procesamiento, incluido el control de eventos asincrónicos para la salida estándar redirigida. Debe usar esta sobrecarga después de llamar a la <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> sobrecarga cuando la salida estándar se ha redirigido a controladores de eventos asincrónicos.  
  
 Cuando se cierra un proceso asociado (es decir, cuando se apaga el sistema de operación a través de una terminación anómala o normal), el sistema almacena información administrativa sobre el proceso y se devuelve al componente que se hubiera llamado a <xref:System.Diagnostics.Process.WaitForExit>. El <xref:System.Diagnostics.Process> componente, a continuación, puede obtener acceso a la información que incluye el <xref:System.Diagnostics.Process.ExitTime%2A>, mediante el uso de la <xref:System.Diagnostics.Process.Handle%2A> para el proceso terminado.  
  
 Dado que el proceso asociado ha terminado, la <xref:System.Diagnostics.Process.Handle%2A> propiedad del componente ya no apunta a un recurso de proceso existente. En su lugar, el identificador puede usarse solo para tener acceso a información del sistema operativo sobre el recurso de proceso. El sistema es compatible con identificadores de procesos terminados que no se han publicado por <xref:System.Diagnostics.Process> componentes, por lo que mantiene la <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.Handle%2A> información en la memoria hasta que el <xref:System.Diagnostics.Process> componente específicamente libera los recursos. Por este motivo, siempre que se llama a <xref:System.Diagnostics.Process.Start%2A> para un <xref:System.Diagnostics.Process> de la instancia, llame a <xref:System.Diagnostics.Process.Close%2A> cuando el proceso asociado ha finalizado y ya no necesita ninguna información administrativa. <xref:System.Diagnostics.Process.Close%2A> Libera la memoria asignada para el proceso terminado.  
  
   
  
## Examples  
 Vea la sección Comentarios de la <xref:System.Diagnostics.Process.StandardError%2A> página de referencia de propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se ha podido obtener acceso al valor de espera.</exception>
        <exception cref="T:System.SystemException">No se ha establecido ningún <see cref="P:System.Diagnostics.Process.Id" /> de proceso y no existe un <see cref="P:System.Diagnostics.Process.Handle" /> desde el que se pueda determinar la propiedad <see cref="P:System.Diagnostics.Process.Id" />.  
  
O bien 
No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.  
  
O bien 
Está intentando llamar a <see cref="M:System.Diagnostics.Process.WaitForExit" /> para un proceso que se ejecuta en un equipo remoto. Este método sólo está disponible para los procesos que se ejecuten en el equipo local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Cantidad de tiempo, en milisegundos, que se esperará hasta que termine el proceso asociado. El valor máximo es el valor mayor posible de un entero de 32 bits, que representa el infinito para el sistema operativo.</param>
        <summary>Indica al componente <see cref="T:System.Diagnostics.Process" /> que espere a que el proceso asociado termine durante el número de milisegundos especificado.</summary>
        <returns>Es <see langword="true" /> si el proceso asociado ha terminado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> hace que el subproceso actual espere hasta que finaliza el proceso asociado. Debe llamarse después de que todos los demás métodos se llaman en el proceso. Para evitar el bloqueo del subproceso actual, use el evento <xref:System.Diagnostics.Process.Exited>.  
  
 Este método indica la <xref:System.Diagnostics.Process> componente que espere una cantidad finita de tiempo para el proceso termine. Si el proceso asociado no sale al final del intervalo porque se denegó la solicitud para terminar, `false` se devuelve al procedimiento que realiza la llamada. Puede especificar <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para `milliseconds`, y <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> se comportará igual que el <xref:System.Diagnostics.Process.WaitForExit> sobrecargar. Si se pasa 0 (cero) al método, devuelve `true` sólo si el proceso ya ha terminado; de lo contrario, devuelve inmediatamente `false`.  
  
> [!NOTE]
>  En el [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] y versiones anteriores, si `milliseconds` era -1, el <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> esperó sobrecarga <xref:System.Int32.MaxValue> milisegundos (aproximadamente 24 días), not indefinidamente.  
  
 Cuando se ha redirigido la salida estándar para controladores de eventos asincrónicos, es posible que el procesamiento de salida no se habrá completado cuando devuelve este método. Para asegurarse de que se ha completado el control de eventos asincrónicos, llame a la <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que no toma ningún parámetro después de recibir un `true` desde esta sobrecarga. Para ayudar a garantizar que el <xref:System.Diagnostics.Process.Exited> evento se controla correctamente en las aplicaciones de Windows Forms, establezca la <xref:System.Diagnostics.Process.SynchronizingObject%2A> propiedad.  
  
 Cuando se cierra un proceso asociado (es apagar el sistema operativo a través de una terminación anómala o normal), el sistema almacena información administrativa sobre el proceso y devuelve al componente que se había llamado <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. El <xref:System.Diagnostics.Process> componente, a continuación, puede obtener acceso a la información que incluye el <xref:System.Diagnostics.Process.ExitTime%2A>, mediante el uso de la <xref:System.Diagnostics.Process.Handle%2A> para el proceso terminado.  
  
 Dado que el proceso asociado ha terminado, la <xref:System.Diagnostics.Process.Handle%2A> propiedad del componente ya no apunta a un recurso de proceso existente. En su lugar, el identificador puede usarse solo para tener acceso a información del sistema operativo sobre el recurso de proceso. El sistema es compatible con identificadores de procesos terminados que no se han publicado por <xref:System.Diagnostics.Process> componentes, por lo que mantiene la <xref:System.Diagnostics.Process.ExitTime%2A> y <xref:System.Diagnostics.Process.Handle%2A> información en la memoria hasta que el <xref:System.Diagnostics.Process> componente específicamente libera los recursos. Por este motivo, siempre que se llama a <xref:System.Diagnostics.Process.Start%2A> para un <xref:System.Diagnostics.Process> de la instancia, llame a <xref:System.Diagnostics.Process.Close%2A> cuando el proceso asociado ha finalizado y ya no necesita ninguna información administrativa. <xref:System.Diagnostics.Process.Close%2A> Libera la memoria asignada para el proceso terminado.  
  
   
  
## Examples  
 Vea el ejemplo de código para el <xref:System.Diagnostics.Process.ExitCode%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">No se ha podido obtener acceso al valor de espera.</exception>
        <exception cref="T:System.SystemException">No se ha establecido ningún <see cref="P:System.Diagnostics.Process.Id" /> de proceso y no existe un <see cref="P:System.Diagnostics.Process.Handle" /> desde el que se pueda determinar la propiedad <see cref="P:System.Diagnostics.Process.Id" />.  
  
O bien 
No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.  
  
O bien 
Está intentando llamar a <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> para un proceso que se ejecuta en un equipo remoto. Este método sólo está disponible para los procesos que se ejecuten en el equipo local.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> es un número negativo distinto de -1 que representa un tiempo de espera infinito.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hace que el componente <see cref="T:System.Diagnostics.Process" /> espere a que el proceso asociado entre en estado de inactividad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que el componente <see cref="T:System.Diagnostics.Process" /> espere indefinidamente a que el proceso asociado entre en estado de inactividad. Esta sobrecarga sólo se aplica a los procesos que tengan una interfaz de usuario y, por tanto, un bucle de mensajes.</summary>
        <returns>Es <see langword="true" /> si el proceso asociado ha alcanzado un estado de inactividad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle> para forzar el procesamiento de la aplicación debe esperar hasta que el bucle de mensajes ha devuelto al estado inactivo. Cuando se está ejecutando un proceso con una interfaz de usuario, el bucle de mensajes se ejecuta cada vez que se envía un mensaje de Windows para el proceso por el sistema operativo. El proceso, a continuación, se devuelve al bucle de mensajes. Se dice que un proceso estará en un estado de inactividad cuando está esperando mensajes dentro de un bucle de mensajes. Este estado es útil, por ejemplo, cuando la aplicación debe esperar un proceso de inicio terminar de crear la ventana principal antes de la aplicación se comunica con esa ventana.  
  
 Si un proceso no tiene un bucle de mensajes, <xref:System.Diagnostics.Process.WaitForInputIdle> produce una <xref:System.InvalidOperationException>.  
  
 El <xref:System.Diagnostics.Process.WaitForInputIdle> sobrecarga indica la <xref:System.Diagnostics.Process> componente que espere indefinidamente a que el proceso esté inactivo en el bucle de mensajes. Esta instrucción puede hacer que una aplicación deje de responder. Por ejemplo, si el proceso se escribe siempre en salir el bucle de mensajes inmediatamente, como se muestra en el fragmento de código `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El proceso no tiene una interfaz gráfica.  
  
O bien 
Error desconocido. El proceso no pudo entrar en un estado inactivo.  
  
O bien 
El proceso ya ha terminado.  
  
O bien 
No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Valor de 1 para <see cref="F:System.Int32.MaxValue" /> que especifica el tiempo, en milisegundos, que se debe esperar para que el proceso asociado esté inactivo. El valor 0 especifica una devolución inmediata, y el valor -1 especifica una espera infinita.</param>
        <summary>Hace que el componente <see cref="T:System.Diagnostics.Process" /> espere a que el proceso asociado entre en estado de inactividad durante el número de milisegundos especificado. Esta sobrecarga sólo se aplica a los procesos que tengan una interfaz de usuario y, por tanto, un bucle de mensajes.</summary>
        <returns>Es <see langword="true" /> si el proceso asociado ha alcanzado el estado de inactividad; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> para forzar el procesamiento de la aplicación debe esperar hasta que el bucle de mensajes ha devuelto al estado inactivo. Cuando se está ejecutando un proceso con una interfaz de usuario, el bucle de mensajes se ejecuta cada vez que se envía un mensaje de Windows para el proceso por el sistema operativo. El proceso, a continuación, se devuelve al bucle de mensajes. Se dice que un proceso estará en un estado de inactividad cuando está esperando mensajes dentro de un bucle de mensajes. Este estado es útil, por ejemplo, cuando la aplicación debe esperar un proceso de inicio terminar de crear la ventana principal antes de la aplicación se comunica con esa ventana.  
  
 Si un proceso no tiene un bucle de mensajes, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> produce una <xref:System.InvalidOperationException>.  
  
 El <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> sobrecarga indica la <xref:System.Diagnostics.Process> componente que espere una cantidad finita de tiempo para el proceso esté inactivo en el bucle de mensajes. Si el proceso asociado no pasa a estar inactivo por el final del intervalo porque el bucle todavía está procesando mensajes, `false` se devuelve al procedimiento que realiza la llamada.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El proceso no tiene una interfaz gráfica.  
  
O bien 
Error desconocido. El proceso no pudo entrar en un estado inactivo.  
  
O bien 
El proceso ya ha terminado.  
  
O bien 
No hay ningún proceso asociado a este objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el uso de memoria física del proceso asociado, en bytes.</summary>
        <value>Cantidad total de memoria física que el proceso asociado está utilizando expresada en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual del uso de memoria del conjunto utilizado por el proceso, en bytes. El espacio de trabajo de un proceso es el conjunto de páginas de memoria visibles actualmente para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para usar sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos incluyen las páginas que contienen todas las instrucciones que se ejecuta el proceso, incluidos los módulos de proceso y las bibliotecas del sistema.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una instancia del Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra el código de salida del proceso.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño de memoria física, expresado en bytes, que se asignó para el proceso asociado.</summary>
        <value>El tamaño de memoria física, expresado en bytes, que se ha asignado para el proceso asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por esta propiedad representa el tamaño actual del uso de memoria del conjunto utilizado por el proceso, en bytes. El espacio de trabajo de un proceso es el conjunto de páginas de memoria visibles actualmente para el proceso en la memoria RAM física. Estas páginas son residentes y están disponibles para una aplicación para usar sin desencadenar un error de página.  
  
 El espacio de trabajo incluye datos compartidos y privados. Los datos compartidos incluyen las páginas que contienen todas las instrucciones que se ejecuta el proceso, incluidas las instrucciones de los módulos de proceso y las bibliotecas del sistema.  
  
 Esta propiedad puede usarse para supervisar el uso de memoria en los equipos con procesadores de 32 bits o 64 bits. El valor de propiedad es equivalente a la **espacio de trabajo** contador de rendimiento para el proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se inicia una instancia de la aplicación en el Bloc de notas. El ejemplo, a continuación, recupera y muestra varias propiedades del proceso asociado. En el ejemplo se detecta cuando se cierra el proceso y muestra sus estadísticas de memoria máxima y el código de salida.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma es Windows 98 o Windows Millennium (Windows Me), que no admiten esta propiedad.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>