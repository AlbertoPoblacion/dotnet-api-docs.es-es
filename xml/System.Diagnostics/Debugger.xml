<Type Name="Debugger" FullName="System.Diagnostics.Debugger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e1989280f9e6aa452a4eeb0a193a001deb119622" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30398209" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Debugger" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Debugger extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Debugger" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Debugger" />
  <TypeSignature Language="C++ CLI" Value="public ref class Debugger sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Debug</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite la comunicación con un depurador. Esta clase no puede heredarse.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Debugger ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Debugger();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Call the static methods directly on this type", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.Debugger" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Break();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica un punto de interrupción a un depurador asociado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se ha asociado ningún depurador, se piden a los usuarios si desean adjuntar a un depurador. Si los usuarios elige Sí, se inicia el depurador. Si se asocia un depurador, el depurador se señala a un evento de punto de interrupción de usuario y el depurador suspende la ejecución del proceso como si hubiera alcanzado un punto de interrupción del depurador.  
  
> [!WARNING]
>  A partir de [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el tiempo de ejecución ya no ejerce un control estricto de iniciación del depurador para la <xref:System.Diagnostics.Debugger.Break%2A> método, pero en su lugar, notifica un error en el subsistema de informe de errores de Windows (WER). WER proporciona muchas opciones para personalizar el problema en la creación de informes, por lo que muchos factores influirá en el modo que WER responde a un error, como la versión del sistema operativo, proceso, sesión, usuario, equipo y de dominio. Si tiene resultados inesperados cuando se llama a la <xref:System.Diagnostics.Debugger.Break%2A> método, compruebe la configuración de WER en su equipo. Para obtener más información sobre cómo personalizar WER, consulte [la configuración de WER](https://msdn.microsoft.com/library/windows/desktop/bb513638.aspx). Si desea asegurarse de que el depurador se inicia independientemente de la configuración de WER, asegúrese de llamar a la <xref:System.Diagnostics.Debugger.Launch%2A> método en su lugar.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo detener el depurador en la llamada a <xref:System.Console.WriteLine%2A>.  
  
```vb  
Debugger.Break()  
Console.WriteLine("Hello, world.")  
```  
  
```csharp  
Debugger.Break();  
Console.WriteLine("Hello, world.");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El <see cref="T:System.Security.Permissions.UIPermission" /> no está establecido para irrumpir en el depurador.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener permiso iniciar a un depurador. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para trabajar con código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefaultCategory">
      <MemberSignature Language="C#" Value="public static readonly string DefaultCategory;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string DefaultCategory" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.Debugger.DefaultCategory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultCategory As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ DefaultCategory;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa la categoría predeterminada de un mensaje con una constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante predeterminada es `null`. <xref:System.Diagnostics.Debugger.DefaultCategory> utiliza <xref:System.Diagnostics.Debugger.Log%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAttached">
      <MemberSignature Language="C#" Value="public static bool IsAttached { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsAttached" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Debugger.IsAttached" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsAttached As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsAttached { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si hay un depurador asociado al proceso.</summary>
        <value>
          <see langword="true" /> si hay un depurador asociado; de lo contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLogging">
      <MemberSignature Language="C#" Value="public static bool IsLogging ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLogging() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.IsLogging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLogging () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLogging();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comprueba si un depurador asociado habilitó el inicio de sesión.</summary>
        <returns>
          <see langword="true" /> si hay un depurador asociado y está habilitado el inicio de sesión; de lo contrario, <see langword="false" />. El depurador asociado es el depurador administrado registrado en la clave del registro <see langword="DbgManagedDebugger" />. Para más información sobre esta clave, vea [Enabling JIT-Attach Debugging](~/docs/framework/debug-trace-profile/enabling-jit-attach-debugging.md) (Habilitar depuración de JIT-Attach).</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Launch">
      <MemberSignature Language="C#" Value="public static bool Launch ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Launch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.Launch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Launch () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Launch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia un depurador y lo asocia al proceso.</summary>
        <returns>
          <see langword="true" /> si se inicia correctamente o si el depurador ya está asociado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si ya hay un depurador asociado, no ocurre nada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.UIPermission" /> no está establecido para iniciar el depurador.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener permiso iniciar a un depurador. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para trabajar con código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
        <altmember cref="T:System.Security.Permissions.UIPermission" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static void Log (int level, string category, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log(int32 level, string category, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.Log(System.Int32,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log (level As Integer, category As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Log(int level, System::String ^ category, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Int32" />
        <Parameter Name="category" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="level">Descripción de la importancia del mensaje.</param>
        <param name="category">Categoría del mensaje.</param>
        <param name="message">Mensaje que se va a mostrar.</param>
        <summary>Envía un mensaje para el depurador asociado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay un depurador asociado, este método no tiene ningún efecto. El depurador puede o no puede informar del mensaje, dependiendo de su configuración.  
  
> [!NOTE]
>  El parámetro de categoría está limitado a 256 caracteres. Cadenas de más de 256 caracteres se truncan.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOfCrossThreadDependency">
      <MemberSignature Language="C#" Value="public static void NotifyOfCrossThreadDependency ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void NotifyOfCrossThreadDependency() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Debugger.NotifyOfCrossThreadDependency" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub NotifyOfCrossThreadDependency ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void NotifyOfCrossThreadDependency();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Debug</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un depurador que la ejecución está a punto de escribir una ruta de acceso que implica una dependencia entre subprocesos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depuradores deben habilitar específicamente las devoluciones de llamada que desean recibir. Un depurador que desea recibir devoluciones de llamada de la dependencia entre subprocesos debe llamar al método.  
  
 Un depurador que ha seleccionado <xref:System.Diagnostics.Debugger.NotifyOfCrossThreadDependency%2A> puede tomar las medidas adecuadas tras la notificación. Por ejemplo, realizar una evaluación de función normalmente requiere inmovilizar todos los subprocesos salvo el subproceso que realiza la evaluación. Si la evaluación de función requiere la ejecución en más de un subproceso, como se podría producir en escenarios de comunicación remota, se bloqueará la evaluación. El <xref:System.Diagnostics.Debugger.NotifyOfCrossThreadDependency%2A> notificación informa al depurador que debe liberar un subproceso o anular la evaluación de función. La notificación está sujeta a la colección después de que este método devuelve.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>