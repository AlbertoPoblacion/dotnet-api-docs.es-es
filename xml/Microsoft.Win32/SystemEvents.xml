<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="747b741b14ca1c1c4215b08c1bcd371740cad132" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52911628" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <TypeSignature Language="F#" Value="type SystemEvents = class" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona acceso a notificaciones de eventos del sistema. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:Microsoft.Win32.SystemEvents> clase proporciona la capacidad para responder a determinados tipos de eventos del sistema.  
  
 Cuando se genera un evento del sistema, todos los delegados asociados al evento se denominan mediante el subproceso que supervisa los eventos del sistema. Por lo tanto, debe realizar las llamadas desde el evento controladores seguros para subprocesos. Si necesita llamar a un evento del sistema que no se expone como un miembro de esta clase, puede usar el <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> método.  
  
> [!CAUTION]
>  No realizan ningún procesamiento mucho tiempo en el subproceso que genera un controlador de eventos del sistema porque podría impedir que otras aplicaciones funcionen.  
  
> [!NOTE]
>  Algunos eventos del sistema no es posible que se producen en [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Asegúrese de comprobar que la aplicación funciona según lo previsto en [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos. El primer ejemplo muestra cómo utilizar los eventos del sistema en una aplicación normal, y el segundo ejemplo muestra cómo usar los eventos del sistema en un servicio de Windows.  
  
 **Ejemplo 1**  
  
 El ejemplo de código siguiente registra el interés en algunos eventos del sistema y, a continuación, espera a que cualquiera de esos eventos se producen. Se produce el resultado que se muestra si el usuario cambia la resolución de pantalla.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Ejemplo 2**  
  
 En el ejemplo de código siguiente se muestra un servicio de Windows muy simple que controla la <xref:Microsoft.Win32.SystemEvents.TimeChanged> y <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> eventos. El ejemplo incluye un servicio denominado `SimpleService`, un formulario denominado `HiddenForm`y un instalador. El formulario proporciona el bucle de mensajes que requiere los eventos del sistema.  
  
> [!NOTE]
>  Los servicios no tiene bucles de mensajes, a menos que pueden interactuar con el escritorio. Si el bucle de mensajes no se proporciona un formulario oculto, como se muestra en este ejemplo, el servicio debe ejecutarse con la cuenta sistema local y se requiere la intervención manual para habilitar la interacción con el escritorio. Es decir, el administrador debe comprobar manualmente la **permitir que el servicio interactúe con el escritorio** casilla de verificación en la **iniciar sesión** ficha del cuadro de diálogo de propiedades de servicio. En ese caso, se proporciona automáticamente un bucle de mensajes. Esta opción está disponible solo cuando el servicio se ejecuta bajo la cuenta sistema local. No se puede habilitar mediante programación la interacción con el escritorio.  
  
 El servicio en este ejemplo inicia un subproceso que ejecuta una instancia de `HiddenForm`. Los eventos se enlazan y se controlan en el formulario. Los eventos se deben enlazar en el evento de carga del formulario, para asegurarse de que el formulario está completamente cargado en primer lugar; en caso contrario, los eventos no se generará.  
  
> [!NOTE]
>  En el ejemplo se proporciona todo el código necesario, incluido el código de inicialización del formulario normalmente generado por los diseñadores de Visual Studio. Si está desarrollando su servicio en Visual Studio, puede omitir la segunda clase parcial y usar el **propiedades** ventana para establecer el alto y ancho del formulario oculto en cero, el estilo de borde <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>y el estado de la ventana <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Para ejecutar el ejemplo:  
  
1.  Compile el código desde la línea de comandos. El nombre que usó para el archivo de origen no es importante.  
  
2.  Instalar el servicio desde la línea de comandos mediante la [Installutil.exe (herramienta Installer)](~/docs/framework/tools/installutil-exe-installer-tool.md) utilidad. Por ejemplo, `InstallUtil example.exe` si el nombre de archivo de origen es `example.cs` o `example.vb`. Debe ser un administrador para instalar el servicio.  
  
3.  Use la consola Servicios para iniciar el servicio.  
  
4.  Cambiar la hora del sistema, o cambiar las preferencias del usuario, como las propiedades de mouse.  
  
5.  Ver los mensajes en el **aplicación** categoría del Visor de eventos.  
  
6.  Use la consola Servicios para detener el servicio.  
  
7.  Desinstalar el servicio de la línea de comandos mediante el `/u` opción. Por ejemplo: `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valores de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberSignature Language="F#" Value="static member CreateTimer : int -&gt; nativeint" Usage="Microsoft.Win32.SystemEvents.CreateTimer interval" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Especifica el intervalo entre notificaciones del temporizador, en milisegundos.</param>
        <summary>Crea un nuevo temporizador de ventana asociado a la ventana de eventos del sistema.</summary>
        <returns>Identificador del nuevo temporizador.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El intervalo es menor o igual que cero.</exception>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente el temporizador o un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanged : EventHandler " Usage="member this.DisplaySettingsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario cambia la configuración de pantalla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo supervisar el <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> eventos. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:Microsoft.Win32.SystemEvents> clase.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplaySettingsChanging : EventHandler " Usage="member this.DisplaySettingsChanging : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la configuración de pantalla está cambiando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberSignature Language="F#" Value="member this.EventsThreadShutdown : EventHandler " Usage="member this.EventsThreadShutdown : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce antes de que finalice el subproceso que escucha los eventos del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena como el subproceso que realiza escuchas de eventos del sistema está a punto de terminar. Los delegados de eventos del sistema se invocan mediante el subproceso que realiza escuchas de eventos del sistema.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberSignature Language="F#" Value="member this.InstalledFontsChanged : EventHandler " Usage="member this.InstalledFontsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario agrega o quita fuentes del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="static member InvokeOnEventsThread : Delegate -&gt; unit" Usage="Microsoft.Win32.SystemEvents.InvokeOnEventsThread method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegado que se va a invocar mediante el subproceso que escucha los eventos del sistema. </param>
        <summary>Invoca al delegado especificado mediante el subproceso que escucha eventos del sistema. </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método siempre que necesite para controlar un evento del sistema que no se expone mediante el <xref:Microsoft.Win32.SystemEvents> clase.  
  
 Cuando se llama a este método, se invocará el delegado especificado por el subproceso que la aplicación utiliza para procesar los eventos del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberSignature Language="F#" Value="static member KillTimer : nativeint -&gt; unit" Usage="Microsoft.Win32.SystemEvents.KillTimer timerId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">Identificador del temporizador que se va a finalizar.</param>
        <summary>Termina el temporizador especificado por el identificador dado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido finalizar correctamente el temporizador o no se ha podido crear un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberSignature Language="F#" Value="member this.LowMemory : EventHandler " Usage="member this.LowMemory : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This event has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el sistema se queda sin RAM disponible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento contiene el mensaje WM_COMPACTING. Este mensaje se envía a todas las ventanas de nivel superior cuando el sistema detecta que se invierte más del 12,5 por ciento de la hora del sistema en un intervalo de 30 a 60 segundos compactar la memoria. Esto indica que la memoria del sistema es baja.  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <block subset="none" type="usage">
          <para>Este mensaje se proporciona únicamente por compatibilidad con aplicaciones de basadas en Windows de 16 bits.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberSignature Language="F#" Value="member this.PaletteChanged : EventHandler " Usage="member this.PaletteChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario cambia a una aplicación que utiliza una paleta diferente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo supervisar el <xref:Microsoft.Win32.SystemEvents.PaletteChanged> eventos. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:Microsoft.Win32.SystemEvents> clase.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberSignature Language="F#" Value="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " Usage="member this.PowerModeChanged : Microsoft.Win32.PowerModeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario suspende o reanuda el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberSignature Language="F#" Value="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " Usage="member this.SessionEnded : Microsoft.Win32.SessionEndedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario cierra una sesión o apaga el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " Usage="member this.SessionEnding : Microsoft.Win32.SessionEndingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario intenta cerrar una sesión o apagar el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se puede cancelar. Establecer el <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> propiedad `true` solicitará que la sesión sigue ejecutándose. No proporciona ninguna garantía de que no finalizará la sesión.  
  
 Si usas <xref:Microsoft.Win32.SystemEvents.SessionEnding> en un formulario de Windows para detectar una desconexión del sistema o un reinicio, no hay ninguna manera determinista para decidir si el <xref:System.Windows.Forms.Form.Closing> evento se desencadenará antes de este evento.  
  
 Si desea realizar alguna tarea especial antes de <xref:System.Windows.Forms.Form.Closing> está activa, debe asegurarse de que <xref:Microsoft.Win32.SystemEvents.SessionEnding> se desencadena antes de <xref:System.Windows.Forms.Form.Closing>. Para ello, tiene que capturar el `WM_QUERYENDSESSION` en el formulario invalidando el `WndProc` función.  En este ejemplo se muestra cómo hacerlo.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Aplicaciones de consola no provocan la <xref:Microsoft.Win32.SystemEvents.SessionEnding> eventos.  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberSignature Language="F#" Value="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " Usage="member this.SessionSwitch : Microsoft.Win32.SessionSwitchEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario registrado actualmente ha cambiado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberSignature Language="F#" Value="member this.TimeChanged : EventHandler " Usage="member this.TimeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario cambia la hora en el reloj del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberSignature Language="F#" Value="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " Usage="member this.TimerElapsed : Microsoft.Win32.TimerElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando ha expirado el intervalo del temporizador de Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " Usage="member this.UserPreferenceChanged : Microsoft.Win32.UserPreferenceChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando han cambiado las preferencias de un usuario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberSignature Language="F#" Value="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " Usage="member this.UserPreferenceChanging : Microsoft.Win32.UserPreferenceChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.SystemEvents</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se van a cambiar las preferencias de un usuario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento se genera solo si se está ejecutando el bombeo de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se inició manualmente, el bombeo de mensajes no se producirá este evento. Para obtener un ejemplo de código que se muestra cómo controlar los eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte el <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Se trata de un evento estático, debe desasociar los controladores de eventos cuando se desecha la aplicación o dará como resultado pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo supervisar el <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> eventos. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:Microsoft.Win32.SystemEvents> clase.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>