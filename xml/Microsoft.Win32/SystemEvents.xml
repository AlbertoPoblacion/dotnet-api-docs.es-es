<Type Name="SystemEvents" FullName="Microsoft.Win32.SystemEvents">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d99d25be1d24abd932081d3e03fd39286f0da69" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037646" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SystemEvents" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SystemEvents extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.SystemEvents" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SystemEvents" />
  <TypeSignature Language="C++ CLI" Value="public ref class SystemEvents sealed" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona acceso a notificaciones de eventos del sistema. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:Microsoft.Win32.SystemEvents> clase proporciona la capacidad de responder a determinados tipos de eventos del sistema.  
  
 Cuando se produzca un evento del sistema, se denominan todos los delegados asociados al evento mediante el subproceso que supervisa los eventos del sistema. Por lo tanto, debe realizar las llamadas desde el evento controladores seguros para subprocesos. Si necesita llamar a un evento del sistema que no se expone como un miembro de esta clase, puede usar el <xref:Microsoft.Win32.SystemEvents.InvokeOnEventsThread%2A> método.  
  
> [!CAUTION]
>  No realizan ningún procesamiento que consumen muchos recursos en el subproceso que genera un controlador de eventos del sistema porque pueden impedir que otras aplicaciones funcionen.  
  
> [!NOTE]
>  Pueden que algunos eventos del sistema no se producen en [!INCLUDE[windowsver](~/includes/windowsver-md.md)]. Asegúrese de comprobar que la aplicación funciona según lo previsto en [!INCLUDE[windowsver](~/includes/windowsver-md.md)].  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos. El primer ejemplo muestra cómo utilizar los eventos del sistema en una aplicación normal, y el segundo ejemplo muestra cómo utilizar los eventos del sistema en un servicio de Windows.  
  
 **Ejemplo 1**  
  
 En el ejemplo de código siguiente se registra el interés en algunos eventos del sistema y, a continuación, espera a que cualquiera de los eventos que se produzca. El resultado que aparece se produce cuando el usuario cambia la resolución de pantalla.  
  
 [!code-cpp[SystemEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#1)]
 [!code-csharp[SystemEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#1)]
 [!code-vb[SystemEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#1)]  
  
 **Ejemplo 2**  
  
 En el ejemplo de código siguiente se muestra un servicio de Windows muy simple que controla la <xref:Microsoft.Win32.SystemEvents.TimeChanged> y <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanged> eventos. El ejemplo incluye un servicio denominado `SimpleService`, un formulario denominado `HiddenForm`y un instalador. El formulario proporciona el bucle de mensajes requerido por los eventos del sistema.  
  
> [!NOTE]
>  Servicios no tienen bucles de mensajes, a menos que puedan interactuar con el escritorio. Si un formulario oculto no proporciona el bucle de mensajes, como en este ejemplo, el servicio se debe ejecutar bajo la cuenta sistema local y se requiere la intervención manual para habilitar la interacción con el escritorio. Es decir, el administrador debe activar manualmente la **permitir que el servicio interactúe con el escritorio** casilla de verificación en la **Log On** ficha del cuadro de diálogo de propiedades de servicio. En ese caso, se proporciona automáticamente un bucle de mensajes. Esta opción está disponible únicamente cuando el servicio se ejecuta bajo la cuenta sistema local. Interacción con el escritorio no se puede habilitar mediante programación.  
  
 El servicio en este ejemplo inicia un subproceso que ejecuta una instancia de `HiddenForm`. Los eventos se enlazan y se controlan en el formulario. Los eventos deben enlazarse en el evento load del formulario, para asegurarse de que el formulario se carga completamente en primer lugar; en caso contrario, no se producen los eventos.  
  
> [!NOTE]
>  En el ejemplo se proporciona todo el código necesario, incluido el código de inicialización del formulario generado normalmente los diseñadores de Visual Studio. Si está desarrollando su servicio en Visual Studio, puede omitir la segunda clase parcial y utilizar el **propiedades** ventana para establecer el alto y ancho del formulario oculto en cero, el estilo de borde para <xref:System.Windows.Forms.FormBorderStyle.None?displayProperty=nameWithType>y el estado de la ventana <xref:System.Windows.Forms.FormWindowState.Minimized?displayProperty=nameWithType>.  
  
 Para ejecutar el ejemplo:  
  
1.  Compile el código desde la línea de comandos. El nombre que utiliza para el archivo de origen no es importante.  
  
2.  Instalar el servicio desde la línea de comandos mediante la [Installutil.exe (herramienta Installer)](~/docs/framework/tools/installutil-exe-installer-tool.md) utilidad. Por ejemplo, `InstallUtil example.exe` si el nombre de archivo de origen es `example.cs` o `example.vb`. Debe ser un administrador para instalar el servicio.  
  
3.  Utilice la consola Servicios para iniciar el servicio.  
  
4.  Cambiar la hora del sistema, o cambiar las preferencias del usuario, como las propiedades de mouse (ratón).  
  
5.  Ver los mensajes en el **aplicación** categoría del Visor de eventos.  
  
6.  Utilice la consola Servicios para detener el servicio.  
  
7.  Desinstale el servicio desde la línea de comandos mediante el `/u` opción. Por ejemplo: `InstallUtil /u example.exe`.  
  
 [!code-csharp[ManagedWindowsService#1](~/samples/snippets/csharp/VS_Snippets_CLR/ManagedWindowsService/cs/source.cs#1)]
 [!code-vb[ManagedWindowsService#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ManagedWindowsService/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valores de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
    <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
    <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
    <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
    <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
  </Docs>
  <Members>
    <Member MemberName="CreateTimer">
      <MemberSignature Language="C#" Value="public static IntPtr CreateTimer (int interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateTimer(int32 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.CreateTimer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTimer (interval As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CreateTimer(int interval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interval" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="interval">Especifica el intervalo entre notificaciones del temporizador, en milisegundos.</param>
        <summary>Crea un nuevo temporizador de ventana asociado a la ventana de eventos del sistema.</summary>
        <returns>Identificador del nuevo temporizador.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El intervalo es menor o igual que cero.</exception>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente el temporizador o un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario cambia la configuración de pantalla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo supervisar el <xref:Microsoft.Win32.SystemEvents.DisplaySettingsChanged> eventos. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:Microsoft.Win32.SystemEvents> clase.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      </Docs>
    </Member>
    <Member MemberName="DisplaySettingsChanging">
      <MemberSignature Language="C#" Value="public static event EventHandler DisplaySettingsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DisplaySettingsChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event DisplaySettingsChanging As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ DisplaySettingsChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la configuración de pantalla está cambiando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="E:Microsoft.Win32.SystemEvents.DisplaySettingsChanged" />
      </Docs>
    </Member>
    <Member MemberName="EventsThreadShutdown">
      <MemberSignature Language="C#" Value="public static event EventHandler EventsThreadShutdown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EventsThreadShutdown" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.EventsThreadShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EventsThreadShutdown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EventsThreadShutdown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce antes de que finalice el subproceso que escucha los eventos del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena como el subproceso que realiza escuchas para los eventos del sistema está a punto de finalizar. Los delegados de eventos del sistema se invocan mediante el subproceso que realiza escuchas para los eventos del sistema.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstalledFontsChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler InstalledFontsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InstalledFontsChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.InstalledFontsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event InstalledFontsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ InstalledFontsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario agrega o quita fuentes del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="InvokeOnEventsThread">
      <MemberSignature Language="C#" Value="public static void InvokeOnEventsThread (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InvokeOnEventsThread(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.InvokeOnEventsThread(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InvokeOnEventsThread (method As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InvokeOnEventsThread(Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegado que se va a invocar mediante el subproceso que escucha los eventos del sistema. </param>
        <summary>Invoca al delegado especificado mediante el subproceso que escucha eventos del sistema. </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar este método siempre que sea necesario controlar un evento del sistema que no se expone mediante el <xref:Microsoft.Win32.SystemEvents> clase.  
  
 Cuando se llama a este método, se invocará el delegado especificado por el subproceso que la aplicación se utiliza para procesar eventos del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="KillTimer">
      <MemberSignature Language="C#" Value="public static void KillTimer (IntPtr timerId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KillTimer(native int timerId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.SystemEvents.KillTimer(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KillTimer (timerId As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KillTimer(IntPtr timerId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timerId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="timerId">Identificador del temporizador que se va a finalizar.</param>
        <summary>Termina el temporizador especificado por el identificador dado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido finalizar correctamente el temporizador o no se ha podido crear un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="LowMemory">
      <MemberSignature Language="C#" Value="public static event EventHandler LowMemory;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LowMemory" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.LowMemory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LowMemory As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LowMemory;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el sistema se queda sin RAM disponible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento contiene el mensaje WM_COMPACTING. Este mensaje se envía a todas las ventanas de nivel superior cuando el sistema detecta que se invierte más del 12,5 por ciento de la hora del sistema en un intervalo de 30 a 60 segundos compactar la memoria. Esto indica que la memoria del sistema es baja.  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <block subset="none" type="usage">
          <para>Este mensaje se proporciona únicamente por compatibilidad con aplicaciones basadas en Windows de 16 bits.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PaletteChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler PaletteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaletteChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PaletteChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PaletteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ PaletteChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario cambia a una aplicación que utiliza una paleta diferente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo supervisar el <xref:Microsoft.Win32.SystemEvents.PaletteChanged> eventos. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:Microsoft.Win32.SystemEvents> clase.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="PowerModeChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.PowerModeChangedEventHandler PowerModeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.PowerModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event PowerModeChanged As PowerModeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::PowerModeChangedEventHandler ^ PowerModeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.PowerModeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario suspende o reanuda el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.PowerModeChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.PowerModes" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnded">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndedEventHandler SessionEnded;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndedEventHandler SessionEnded" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnded" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnded As SessionEndedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndedEventHandler ^ SessionEnded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario cierra una sesión o apaga el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndedEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndedEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionEndingEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionEndingEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionEnding As SessionEndingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionEndingEventHandler ^ SessionEnding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionEndingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario intenta cerrar una sesión o apagar el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se puede cancelar. Establecer el <xref:Microsoft.Win32.SessionEndingEventArgs.Cancel%2A> propiedad `true` solicitará que la sesión sigue ejecutándose. No proporciona ninguna garantía de que no va a finalizar la sesión.  
  
 Si utilizas <xref:Microsoft.Win32.SystemEvents.SessionEnding> en un formulario Windows Forms para detectar una desconexión del sistema o un reinicio, no hay ninguna manera determinista para decidir si el <xref:System.Windows.Forms.Form.Closing> evento se desencadenará antes de este evento.  
  
 Si desea realizar alguna tarea especial antes de <xref:System.Windows.Forms.Form.Closing> está activa, debe asegurarse de que <xref:Microsoft.Win32.SystemEvents.SessionEnding> se activa antes de <xref:System.Windows.Forms.Form.Closing>. Para ello, se tendrá que interceptar el `WM_QUERYENDSESSION` en el formulario reemplazando la `WndProc` función.  Este ejemplo muestra cómo hacerlo.  
  
```vb  
Private Shared WM_QUERYENDSESSION As Integer = &H11  
 Private Shared systemShutdown As Boolean = False  
 Protected Overrides Sub WndProc(ByRef m As System.Windows.Forms.Message)  
     If m.Msg = WM_QUERYENDSESSION Then  
         MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot")  
         systemShutdown = True  
     End If  
     ' If this is WM_QUERYENDSESSION, the closing event should be raised in the base WndProc.  
     MyBase.WndProc(m)  
 End Sub 'WndProc   
 Private Sub Form1_Closing(ByVal sender As System.Object, ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing  
     If (systemShutdown) Then  
     ' Reset the variable because the user might cancel the shutdown.  
         systemShutdown = False  
         If (System.Windows.Forms.DialogResult.Yes = _  
                 MessageBox.Show("My application", "Do you want to save your work before logging off?", MessageBoxButtons.YesNo)) Then  
                 e.Cancel = True  
         Else  
                 e.Cancel = False  
         End If  
     End If  
 End Sub  
  
```  
  
```csharp  
private static int WM_QUERYENDSESSION = 0x11;  
private static bool systemShutdown = false;  
protected override void WndProc(ref System.Windows.Forms.Message m)  
{  
    if (m.Msg==WM_QUERYENDSESSION)  
    {  
        MessageBox.Show("queryendsession: this is a logoff, shutdown, or reboot");  
        systemShutdown = true;  
    }  
  
    // If this is WM_QUERYENDSESSION, the closing event should be  
    // raised in the base WndProc.  
    base.WndProc(ref m);  
  
} //WndProc   
  
private void Form1_Closing(  
    System.Object sender,   
    System.ComponentModel.CancelEventArgs e)  
{  
    if (systemShutdown)  
        // Reset the variable because the user might cancel the   
        // shutdown.  
    {  
        systemShutdown = false;  
        if (DialogResult.Yes==MessageBox.Show("My application",   
            "Do you want to save your work before logging off?",   
            MessageBoxButtons.YesNo))  
        {  
            e.Cancel = true;  
        }  
        else  
        {  
            e.Cancel = false;  
        }  
    }  
}  
```  
  
> [!IMPORTANT]
>  Las aplicaciones de consola no provocan el <xref:Microsoft.Win32.SystemEvents.SessionEnding> eventos.  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.SessionEndingEventArgs" />
        <altmember cref="T:Microsoft.Win32.SessionEndingEventHandler" />
        <altmember cref="T:Microsoft.Win32.SessionEndReasons" />
      </Docs>
    </Member>
    <Member MemberName="SessionSwitch">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.SessionSwitchEventHandler SessionSwitch;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.SessionSwitchEventHandler SessionSwitch" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.SessionSwitch" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event SessionSwitch As SessionSwitchEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::SessionSwitchEventHandler ^ SessionSwitch;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SessionSwitchEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario registrado actualmente ha cambiado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.SessionSwitchEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TimeChanged">
      <MemberSignature Language="C#" Value="public static event EventHandler TimeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TimeChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ TimeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el usuario cambia la hora en el reloj del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="P:System.DateTime.Now" />
      </Docs>
    </Member>
    <Member MemberName="TimerElapsed">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.TimerElapsedEventHandler TimerElapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.TimerElapsedEventHandler TimerElapsed" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.TimerElapsed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event TimerElapsed As TimerElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::TimerElapsedEventHandler ^ TimerElapsed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.TimerElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando ha expirado el intervalo del temporizador de Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventArgs" />
        <altmember cref="T:Microsoft.Win32.TimerElapsedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanged">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangedEventHandler UserPreferenceChanged" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanged As UserPreferenceChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangedEventHandler ^ UserPreferenceChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando han cambiado las preferencias de un usuario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangedEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
    <Member MemberName="UserPreferenceChanging">
      <MemberSignature Language="C#" Value="public static event Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class Microsoft.Win32.UserPreferenceChangingEventHandler UserPreferenceChanging" />
      <MemberSignature Language="DocId" Value="E:Microsoft.Win32.SystemEvents.UserPreferenceChanging" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UserPreferenceChanging As UserPreferenceChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event Microsoft::Win32::UserPreferenceChangingEventHandler ^ UserPreferenceChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Currently does nothing on Mono")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.UserPreferenceChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se van a cambiar las preferencias de un usuario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este evento sólo se desencadena si se está ejecutando el suministro de mensajes. En un servicio de Windows, a menos que se usa un formulario oculto o se ha iniciado el suministro de mensajes manualmente, no se provocarán este evento. Para obtener un ejemplo de código que muestra cómo controlar eventos del sistema mediante el uso de un formulario oculto en un servicio de Windows, consulte la <xref:Microsoft.Win32.SystemEvents> clase.  
  
> [!CAUTION]
>  Porque se trata de un evento estático, debe desasociar los controladores de eventos cuando se elimina la aplicación, o producirá pérdidas de memoria.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo supervisar el <xref:Microsoft.Win32.SystemEvents.UserPreferenceChanging> eventos. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:Microsoft.Win32.SystemEvents> clase.  
  
 [!code-cpp[SystemEvents#2](~/samples/snippets/cpp/VS_Snippets_Winforms/SystemEvents/cpp/SystemEvents.cpp#2)]
 [!code-csharp[SystemEvents#2](~/samples/snippets/csharp/VS_Snippets_Winforms/SystemEvents/CS/SystemEvents.cs#2)]
 [!code-vb[SystemEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/SystemEvents/VB/SystemEvents.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se admiten las notificaciones de eventos del sistema en el contexto actual. Los procesos del servidor, por ejemplo, quizá no admitan las notificaciones globales de eventos del sistema.</exception>
        <exception cref="T:System.Runtime.InteropServices.ExternalException">No se ha podido crear correctamente un subproceso de ventana de eventos del sistema.</exception>
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventArgs" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceChangingEventHandler" />
        <altmember cref="T:Microsoft.Win32.UserPreferenceCategory" />
      </Docs>
    </Member>
  </Members>
</Type>