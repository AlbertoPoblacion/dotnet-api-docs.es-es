<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2c4473049195af8524aad5dcb2364b620c4da94" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36385927" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implements the basic functionality for a personalization provider.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de la clase base abstracta que define la funcionalidad necesaria de un proveedor de personalización. Un proveedor de personalización carga y almacena los datos de personalización en nombre de un <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> instancia.  
  
 La clase base define el comportamiento estándar para una serie de métodos; solamente aquellos métodos que tratan específicamente con el almacén de datos subyacente se marcan abstractas. Esto permite al desarrollador escribir un proveedor personalizado para interactuar con un almacén de datos concreto, sin necesidad de volver a implementar la funcionalidad estándar utilizada por la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> clase.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Puede derivar de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> y proporcionan implementaciones para los métodos abstractos definidos en esta clase. Los métodos abstractos se utilizan específicamente con Guardar y cargar datos en un almacén de datos físico y con administración de almacén de datos. Un proveedor personalizado debe ser capaz de manipular la información de personalización de una manera que distingue <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> datos de <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> datos. Además, un proveedor debe segmentar los datos de personalización por página, así como de aplicación.  Las implementaciones de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> están estrechamente relacionadas con las implementaciones de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> porque algunos métodos del proveedor de personalización devuelven instancias de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />-las clases derivadas. Para facilitar el desarrollo de proveedores personalizados, la <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> clase base incluye una implementación predeterminada de la lógica de personalización y la lógica de serialización/deserialización que utiliza directamente el <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> clase. Como resultado, solo un proveedor personalizado únicamente con el fin de trabajar con un almacén de datos diferente de creación requiere la implementación de los métodos abstractos siguientes:- <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" /> -este método debe poder contar el número de filas de los datos de personalización la base de datos para los parámetros de consulta proporcionado.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" /> -Dada la ruta de acceso y nombre de usuario, este método carga dos objetos binarios grandes (BLOB) de la base de datos: un BLOB de datos compartidos y otro para los datos de usuario. Si se proporcionan el nombre de usuario y la ruta de acceso, no es necesario el <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> control para tener acceso a la información de página que puede proporcionar la información de ruta de acceso y nombre de usuario.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" /> : Debido a la ruta de acceso y nombre de usuario, este eliminaciones de método correspondiente de fila en la base de datos. Si se proporcionan el nombre de usuario y la ruta de acceso, no es necesario el <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> control para tener acceso a la información de página que puede proporcionar la información de ruta de acceso y nombre de usuario.  - <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" /> -Dada la ruta de acceso y nombre de usuario, este método guarda el BLOB proporcionado en la base de datos. Si se proporcionan el nombre de usuario y la ruta de acceso, no es necesario el <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> control para tener acceso a la información de página que puede proporcionar la información de ruta de acceso y nombre de usuario.  En todos estos métodos, si solo se proporciona una ruta de acceso, que indica que se opera en los datos de personalización compartidos para la página. Si una ruta de acceso y un nombre de usuario se pasan a un método, a continuación, los datos de personalización de usuario de la página deben actuar sobre los. En el caso de <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />, siempre se deben cargar los datos compartidos para la ruta de acceso especificada y, opcionalmente, los datos de personalización de usuario para la ruta de acceso también se deben cargar si el nombre de usuario no es <see langword="null" />.  Todos los demás métodos abstractos están diseñados para usarse exclusivamente en las aplicaciones administrativas y no se usan por la infraestructura de elementos Web en tiempo de ejecución. Para obtener un ejemplo de una implementación de un proveedor de personalización, consulte el <see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" /> clase.</para>
    </block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que se trata de un constructor para una clase abstracta, debe reemplazar este método para crear una instancia de una clase que hereda de esta clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>When overridden in a derived class, gets or sets the name of the application configured for the provider.</summary>
        <value>La aplicación configurada para el proveedor de personalización.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se especifica un nombre de aplicación en el archivo de configuración mediante el [elemento providers para la personalización de elementos Web (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195) , el valor del atributo el <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A> se utiliza la propiedad.  
  
> [!CAUTION]
>  Dado que una única instancia del proveedor de personalización predeterminado se usa para todas las solicitudes servidas por un <xref:System.Web.HttpApplication> objeto, puede tener varias solicitudes en ejecución al mismo tiempo, cada intento de establecer la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> valor de propiedad. El <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propiedad no es seguro para subprocesos para varias operaciones de escritura y cambiar la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> valor de propiedad puede provocar un comportamiento inesperado para varios usuarios de una aplicación. Se recomienda evitar el código que permita a los usuarios establezcan la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propiedad a menos que requiera. Establecer el <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A> propiedad puede ser necesaria, por ejemplo, en una aplicación administrativa que administra los datos de personalización para varias aplicaciones.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a list of <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> objects that represent the set of known capabilities used by the Web Parts control set.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> that represents the set of known capabilities used by the Web Parts control set.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actualmente, este método devuelve una lista que contiene dos funciones: <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> y <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>. Se trata de las funciones predeterminadas que se pueden definir en el [elemento authorization para la personalización de elementos Web (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) elemento dentro de la [elemento de personalización de elementos Web (ASP.NET Esquema de configuración)](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) elemento de la[webParts Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) sección de configuración. Si decide implementar una infraestructura de personalización personalizada, puede invalidar este método y definir su propio conjunto de funciones de usuario relacionadas con la autorización.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> that manages the personalization information.</param>
        <param name="loadedState">The personalization state information.</param>
        <summary>Determines whether the initial personalization scope should be <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> or <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> scope.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> indicating whether the current personalization scope is <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> or <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina si el ámbito actual debe ser <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> o <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, dada una referencia a un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> información que ya se ha cargado desde anteriormente en el ciclo de vida de personalización de estado de control y la personalización. Esta información se usa por un <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> instancia para las tareas subsiguientes relacionadas con la personalización.  
  
 Las reglas siguientes se utilizan para determinar el ámbito de personalización:  
  
-   Ámbito se supone inicialmente que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Si no se autentica la cuenta de usuario está ejecutando actualmente, el ámbito está establecido en <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Si se autentica la cuenta de usuario actualmente en ejecución, se produce un procesamiento adicional en orden de prioridad:  
  
    -   Si la página está en modo de devolución de datos, la solicitud de página contiene información de ámbito de una representación anterior de la página. Si esa información de ámbito indica que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> ámbito se utiliza, a continuación, el ámbito se evalúa como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
    -   Si la página que se está ejecuta actualmente tenía control transfieren desde otra página (por ejemplo, si la transferencia del control se produjo debido a que realiza la llamada la <xref:System.Web.HttpServerUtility.Transfer%2A> método; tenga en cuenta que esta comprobación concreta no se produce para el envío entre páginas) y si el previamente ejecutar la página tenía un <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instancia, el ámbito se establece en el valor de la `Personalization.Scope` propiedad desde la anterior <xref:System.Web.UI.WebControls.WebParts.WebPartManager> instancia.  
  
    -   Si no se cumplen los criterios anteriores, el ámbito se evalúa como el valor de la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> propiedad actuales <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control.  
  
 Después de realizar las evaluaciones anteriores y si el ámbito se evalúa como <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> establecer el ámbito, se produce el siguiente procesamiento:  
  
-   Si la cuenta de usuario está ejecutando actualmente tiene el <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> capacidad, el ámbito permanece establecido en <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   Si no dispone de la cuenta de usuario está ejecutando actualmente el <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> capacidad y, a continuación, el ámbito se restablece en <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>.  
  
-   Si el resultado de todas las evaluaciones de ámbito anteriores es <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>, este resultado se almacena como un campo oculto en la página que se está ejecutando actualmente. Este es el mecanismo mediante el cual una página puede reproducir la evaluación de ámbito durante los postbacks posteriores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization information.</param>
        <summary>Returns a dictionary containing <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> instances that represent the personalization-related capabilities of the currently executing user account.</summary>
        <returns>An <see cref="T:System.Collections.IDictionary" /> containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> instances if the user account is authenticated, or <see langword="null" /> if the executing user account is not authenticated.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método utiliza la información de la [elemento authorization para la personalización de elementos Web (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434) elemento dentro de la [personalización elemento para webParts (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) elemento de la[webParts Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c) funciones autorizadas de sección de configuración en el archivo Machine.config o Web.config para determinar un usuario.  
  
 Las funciones del diccionario serán miembros de la <xref:System.Collections.IList> objeto devuelto por la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A> método, que actualmente incluyen el <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> capacidad y la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability> capacidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.  \- or -  The request associated with the page is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> with the personalization information to be queried. This value cannot be <see langword="null" />.</param>
        <param name="query">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> containing a query. This value can be <see langword="null" />.</param>
        <param name="pageIndex">The location where the query starts.</param>
        <param name="pageSize">The number of records to return.</param>
        <param name="totalRecords">The total number of records available.</param>
        <summary>When overridden in a derived class, returns a collection containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-derived objects based on scope and specific query parameters.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> containing zero or more <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />-derived objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es la definición abstracta de un método administrativo para consultar los datos de personalización. Las implementaciones derivadas deben seguir la lógica descrita a continuación.  
  
 El conjunto de elementos devueltos está restringido por la `pageIndex` y `pageSize` parámetros, donde `pageSize` establece el número de registros que se devuelven y `pageIndex` establece qué registros se deben devolver. Por ejemplo, un `pageIndex` de 0 y un `pageSize` de 25 devolverían las primeras 25 apariciones, mientras que un `pageIndex` de 1 y un `pageSize` de 25 devolvería repeticiones 26-50. Si desea recuperar todos los registros disponibles, establezca `pageIndex` en 0 y `pageSize` a <xref:System.Int32.MaxValue>.  
  
 El <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-objetos derivados se devuelven en orden alfabético y se ordenan por una combinación de sus <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> y <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> valores de propiedad, en orden ascendente.  
  
 Este método pasa los caracteres comodín de la consulta en el almacén de datos subyacente. Compatibilidad con caracteres comodín es actualmente depende de cómo cada proveedor controle caracteres como un asterisco (*), un símbolo de porcentaje (%) o un carácter de subrayado (_).  
  
 Normalmente, para almacenes de datos compatibles con SQL, se puede realizar una búsqueda con caracteres comodín en una ruta de acceso parcial con el carácter comodín que aparecen al principio, el final o el centro del texto de la cadena de búsqueda en el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propiedad. Por ejemplo, para buscar todas las rutas de acceso que empiezan por "~/vdir", el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> se establecería la propiedad en "~/vdir%".  
  
 Del mismo modo, una búsqueda con caracteres comodín en un nombre de usuario parcial podría tener el carácter comodín aparecen en cualquier punto de la cadena de texto de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propiedad. Por ejemplo, para buscar todos los nombres de usuario que comienzan con "John", la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> parámetro sería "Juan %".  
  
 Se aplican las siguientes restricciones de consulta:  
  
-   Si solo `scope` se proporciona, y `query` es `null` o todas las propiedades en `query` devolver `null` o valores predeterminados, a continuación, todos los registros que coincidan con el functoid `scope` parámetro se devuelven.  
  
-   Si el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propiedad no es `null`, los registros devueltos también son rutas de acceso en función de filtrado que coinciden con la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> valor.  
  
-   Si el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propiedad no es `null`, los registros devueltos también son nombres de usuario en función de filtrado que coinciden con la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> valor de propiedad.  
  
-   Si el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propiedad no es igual a <xref:System.DateTime.MaxValue>, a continuación, los registros devueltos también se filtran para devolver sólo los registros asociados con los usuarios inactivos. La comparación incluye registros donde el <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> propiedad es menor o igual que el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propiedad.  
  
 Tenga en cuenta que este método no valida combinaciones de parámetros de consulta. Por ejemplo, el código puede solicitar un conjunto de registros de estado de personalización asociado con un nombre de usuario específico en el ámbito compartido. Dado que los nombres de usuario no se asocian con información compartida, la colección devuelta estaría vacía.  
  
 Combinaciones de parámetros que tienen el potencial para devolver una colección no vacía incluyen:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> el ámbito en combinación con la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propiedad.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> el ámbito en combinación con los valores para alguno o todos los <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, y <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propiedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> of the personalization information to be queried. This value cannot be <see langword="null" />.</param>
        <param name="query">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" /> containing a query. This value can be <see langword="null" />.</param>
        <summary>When overridden in a derived class, returns the number of rows in the underlying data store that exist within the specified scope.</summary>
        <returns>The number of rows in the underlying data store that exist for the specified <paramref name="scope" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es la definición abstracta de un método administrativo para recuperar los recuentos de los datos de personalización. Las implementaciones derivadas deben seguir la lógica descrita a continuación.  
  
 Este método pasa los caracteres comodín de la consulta en el almacén de datos subyacente. Compatibilidad con caracteres comodín es actualmente depende de cómo cada proveedor controle caracteres como un asterisco (*), un símbolo de porcentaje (%) o un carácter de subrayado (_).  
  
 Normalmente, para almacenes de datos compatibles con SQL, se puede realizar una búsqueda con caracteres comodín en una ruta de acceso parcial con el carácter comodín que aparecen al principio, el final o el centro del texto de la cadena de búsqueda en el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propiedad. Por ejemplo, para buscar todas las rutas de acceso que empiezan por "~/vdir", el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> se establecería la propiedad en "~/vdir%".  
  
 Del mismo modo, una búsqueda con caracteres comodín en un nombre de usuario parcial podría tener el carácter comodín aparecen en cualquier punto de la cadena de texto de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propiedad. Por ejemplo, para buscar todos los nombres de usuario que comienzan con "John", la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> parámetro sería "Juan %".  
  
 Se aplican las siguientes restricciones de consulta:  
  
-   Si solo `scope` se proporciona, y `query` es `null` o todas las propiedades en `query` devolver `null` o valores predeterminados, a continuación, todos los registros que coincidan con el functoid `scope` se cuentan los parámetros.  
  
-   Si el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propiedad no es `null`, los registros contados también son rutas de acceso en función de filtrado que coinciden con la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> valor.  
  
-   Si el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> propiedad no es `null`, los registros contados también son nombres de usuario en función de filtrado que coinciden con la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A> valor de propiedad.  
  
-   Si el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propiedad no es igual a <xref:System.DateTime.MaxValue>, a continuación, los registros contados se filtran también para devolver sólo los registros asociados con los usuarios inactivos. La comparación incluye registros donde el <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> propiedad es menor o igual que el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propiedad.  
  
 Tenga en cuenta que este método no valida combinaciones de parámetros de consulta. Por ejemplo, el código puede solicitar un recuento de registros de estado de personalización asociado con un nombre de usuario específico en el ámbito compartido. Dado que los nombres de usuario no se asocian con información compartida, el recuento devuelto será cero.  
  
 Entre las combinaciones de parámetros que tienen el potencial para devolver un número distinto de cero se incluyen:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> el ámbito en combinación con la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A> propiedad.  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> el ámbito en combinación con los valores para alguno o todos los <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>, <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>, y <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propiedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]&amp;" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the retrieval key.</param>
        <param name="userName">The user name for personalization information to be used as the retrieval key.</param>
        <param name="sharedDataBlob">The returned data for the <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> scope.</param>
        <param name="userDataBlob">The returned data for the <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> scope.</param>
        <summary>When overridden in a derived class, loads raw personalization data from the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> e implementar este método debe utilizar el `webPartManager`, `path`, y `username` parámetros como claves de recuperación. Independientemente de cómo los datos almacena en el almacén de datos (algunos almacenes de datos podrían realizar algún tipo de almacenamiento inteligente), la personalización se deben devolver los datos como un conjunto empaquetado de bytes en dos matrices. Los datos devueltos deben cumplir las reglas siguientes:  
  
-   Los datos de la <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> ámbito siempre se debe devolver en el `sharedDataBlob` parámetro.  
  
-   Dependiendo de los valores de clave, <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> datos se devuelven en el `userDataBlob` parámetro. No`null` valor para el `userName` parámetro indica que <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> también se deben recuperar datos.  
  
 Un proveedor de personalización que se deriva de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> e implementa este método puede optimizar las interacciones con su almacén de datos mediante la recuperación de todos los datos de personalización de ida y vuelta uno, en lugar de recuperar <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> y <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> datos en dos Separe los viajes de ida y vuelta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="ignoreCurrentUser">A <see cref="T:System.Boolean" /> indicating whether the user name should be passed to the personalization provider.</param>
        <summary>Loads the raw data from the underlying data store and converts that data into a <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> object.</summary>
        <returns>A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> containing personalization data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es el punto de entrada principal utilizado por la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> clase para cargar los datos de personalización. La implementación predeterminada carga los datos sin procesar del almacén de datos subyacente (la funcionalidad se implementa en proveedores derivados) y, a continuación, convierte los datos sin procesar en un <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> instancia.  
  
 Si el `ignoreCurrentUser` parámetro es `true`, ningún nombre de usuario se pasa a la <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A> método. Puede elegir un proveedor de personalización interpretarlo como lo que significa que ese estado de personalización solo con un <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> ámbito se debe recuperar del almacén de datos subyacente.  
  
 Cuando el <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> método se esté ejecutando, llama el <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A> método, y hay tres tipos de errores de deserialización que pueden ocurrir cuando se carga el estado. Cuando se producen estos errores concretos, se inicia ninguna excepción y los eventos de error se registran en su lugar la característica de supervisión de estado (para obtener información sobre el estado de supervisión y obtener acceso a los registros creados por el mismo, vea [información general de supervisión de estado de ASP.NET ](http://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c)). Que se escriben en el registro de eventos de error de deserialización de la causa de tres escenarios siguientes:  
  
-   Error al intentar deserializar un tipo de propiedad que usa una cadena <xref:System.ComponentModel.TypeConverter>.  
  
-   Un error al intentar deserializar un tipo de propiedad que usa la serialización binaria.  
  
-   Un error al intentar deserializar un tipo de propiedad porque no se puede crear una instancia del tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The page associated with <paramref name="webPartManager" /> is <see langword="null" />.  \- or -  The request associated with the page is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the data store key.</param>
        <param name="userName">The user name for personalization information to be used as the data store key.</param>
        <summary>When overridden in a derived class, deletes raw personalization data from the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider> e implementar este método debe utilizar el `webPartManager`, `path`, y `userName` parámetros como claves de almacenamiento. Las implementaciones derivadas deben modificar el almacén de datos para que se eliminen efectivamente los datos de personalización para las claves de almacenamiento proporcionado. Depende de cómo hacerlo físicamente las implementaciones derivadas.  
  
 El proveedor de personalización derivado debe ser capaz de distinguir entre los datos de personalización de forma por página. Además, para el estado de una página determinada, el proveedor de personalización debe poder distinguir entre <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> y <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> definir el ámbito de datos. Si no`null` se proporciona el nombre de usuario, a continuación, la operación de reinicio se aplica a la <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> ámbito; en caso contrario, la operación de reinicio se aplica a la <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> ámbito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <summary>Resets personalization data to the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es el punto de entrada principal utilizado por la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> clase para restablecer los datos de personalización. La implementación predeterminada usa el <xref:System.Web.UI.WebControls.WebParts.WebPartManager> control para determinar la ruta de acceso y nombre de usuario para los datos que se van a restablecer. A continuación, la implementación predeterminada llama el <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="webPartManager" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="webPartManager" /> is not associated with a page.  \- or -  The page is not associated with an in-progress <see cref="T:System.Web.HttpRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" /> of the personalization information to be reset. This value cannot be <see langword="null" />.</param>
        <param name="paths">The paths for personalization information to be deleted.</param>
        <param name="usernames">The user names for personalization information to be deleted.</param>
        <summary>When overridden in a derived class, deletes personalization state from the underlying data store based on the specified parameters.</summary>
        <returns>The number of rows deleted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es la definición abstracta de un método administrativo para eliminar los datos de personalización. Las implementaciones derivadas deben seguir la lógica descrita a continuación.  
  
 Este método no admite ninguna búsqueda de carácter comodín. Si el proveedor de personalización expone datos de un almacén de datos orientado a transacciones, este método debe realizar sus operaciones como una única transacción atómica.  
  
 Solo las siguientes combinaciones de parámetros son válidas:  
  
-   El `scope` parámetro está establecido y todos los demás parámetros se establecen en `null`. Esta combinación elimina todos los datos de personalización de elementos Web asociados con el ámbito de personalización indicado por `scope`.  
  
-   El `scope` se establece el parámetro y el `paths` parámetro contiene al menos un valor. Esta combinación elimina todos los datos de personalización de elementos Web para la ruta de acceso especificada o las rutas de acceso en el ámbito de personalización indicado por `scope`.  
  
-   El `scope` parámetro está establecido en <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, `paths` parámetro se establece y contiene un único valor y el `usernames` parámetro contiene al menos un valor. Esta combinación elimina todos los datos de elementos Web para la ruta especificada que está asociada con el usuario o usuarios contenidos en personalización de usuario `usernames`.  
  
-   El `scope` parámetro está establecido en <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, `paths` parámetro está establecido en `null`y el `usernames` parámetro contiene al menos un valor. Esta combinación elimina todos los datos de elementos Web, de personalización de cada usuario a través de todas las rutas de acceso, asociados con el usuario o usuarios contenidos en `usernames`.  
  
 Cualquier otra combinación de valores de parámetro no es válida y producirá una <xref:System.ArgumentException> excepción. En concreto, no se permiten las dos combinaciones siguientes:  
  
-   El `usernames` parámetro no se pueden proporcionar cuando `scope` está establecido en <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>.  
  
-   El `paths` parámetro no puede contener más de una entrada cuando el `usernames` parámetro no es `null`.  
  
 Cualquier `paths` y `usernames` valores de parámetro incluidos en las matrices respectivas deben cumplir las siguientes reglas de validación. Si cualquier regla de validación producirá un error para cualquier miembro de las matrices de parámetros, un <xref:System.ArgumentException> se produce la excepción. Las reglas de validación son:  
  
-   `null` no se permiten valores.  
  
-   Una cadena vacía ("") no está permitido. Parámetros deben quitarse antes de realizar una comprobación de la cadena vacía.  
  
-   El `usernames` parámetro no puede contener comas (,).  
  
-   La longitud de la `paths` parámetro no puede ser superior a 256 caracteres para una base de datos SQL.  
  
-   La longitud de la `usernames` parámetro no puede ser superior a 256 caracteres para una base de datos SQL.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">The path of the personalization data to be deleted. This value can be <see langword="null" /> but cannot be an empty string ("").</param>
        <param name="userInactiveSinceDate">The date indicating the last time a Web site user changed personalization data.</param>
        <summary>When overridden in a derived class, deletes Web Parts personalization data from the underlying data store based on the specified parameters.</summary>
        <returns>The number of rows deleted from the underlying data store.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es la definición abstracta de un método administrativo para eliminar los datos de personalización. Tenga en cuenta que este método solo afecta a los datos de personalización de usuario y datos no compartido.  
  
 Las implementaciones derivadas deben seguir la lógica descrita a continuación:  
  
-   El `path` parámetro no puede contener caracteres comodín.  
  
-   Si el proveedor expone datos de un almacén de datos orientado a transacciones, este método debe realizar sus operaciones en una única transacción atómica.  
  
-   Si el `path` parámetro es no`null`, después los registros de personalización por usuario solo se asocian a `path` se eliminarán.  
  
-   Solo registros personalización por usuario asociados a los usuarios que se consideran inactivos desde la fecha indicada en el `userInactiveSinceDate` parámetro se eliminarán. En concreto, registros donde <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A> es menor o igual que <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> se eliminan.  
  
-   Si se proporcionan ambos parámetros, se eliminan los registros que coinciden con ambas restricciones.  
  
-   El `path` parámetro puede ser `null`.  
  
-   El `path` parámetro no puede ser una cadena vacía. Se debe recortar antes de realizar esta comprobación.  
  
-   El <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> propiedad no puede ser `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">The <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> managing the personalization data.</param>
        <param name="path">The path for personalization information to be used as the data store key.</param>
        <param name="userName">The user name for personalization information to be used as the key.</param>
        <param name="dataBlob">The byte array of data to be saved.</param>
        <summary>When overridden in a derived class, saves raw personalization data to the underlying data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es la definición abstracta del método utilizado para guardar los datos de personalización sin formato en el almacén de datos subyacente.  
  
 Las implementaciones derivadas deben usar el `webPartManager`, `path`, y `userName` parámetros como claves de almacenamiento. El proveedor de personalización derivado debe ser capaz de distinguir entre los datos de personalización de forma por página. Además, para el estado de una página determinada, el proveedor debe poder distinguir entre <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> y <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> ámbito. Si no`null` se proporciona el nombre de usuario, la `dataBlob` parámetro está en <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> ámbito; en caso contrario, el `dataBlob` se supone que el parámetro en <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared> ámbito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> containing personalization data to be saved.</param>
        <summary>Saves personalization data to a data store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es el punto de entrada principal utilizado por la <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> clase para guardar los datos de personalización.  
  
 La implementación predeterminada de este método usa los métodos de una implementación interna de <xref:System.Web.UI.WebControls.WebParts.PersonalizationState> para empaquetar los datos de personalización en una matriz de bytes. Si los resultados de este empaquetamiento crean un byte vacío de las matrices (porque la extracción de propiedad generó ningún dato de personalización), la implementación predeterminada llama el <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A> método. En caso contrario, la implementación predeterminada llama el <xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="state" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="state" /> object being saved has a different type from the <paramref name="state" /> object that was returned by the <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" /> method.</exception>
      </Docs>
    </Member>
  </Members>
</Type>