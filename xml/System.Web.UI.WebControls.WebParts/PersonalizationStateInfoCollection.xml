<Type Name="PersonalizationStateInfoCollection" FullName="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2f99add5aed605b0f2731bd8473252a97b02a27d" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53390553" /></Metadata><TypeSignature Language="C#" Value="public sealed class PersonalizationStateInfoCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit PersonalizationStateInfoCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PersonalizationStateInfoCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationStateInfoCollection sealed : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type PersonalizationStateInfoCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona una colección de objetos <see cref="T:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo" /> y <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> clase proporciona un contenedor basado en recopilación de un conjunto de <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> y <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> instancias. Estas instancias se recuperan por iterar secuencialmente por la colección, por índice ordinal o por valor de clave.  
  
 Las instancias se indizan en una combinación de ruta de acceso y nombre de usuario. Esto es necesario porque <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> instancias que representan los datos compartidos se indexan según <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> objeto, mientras que <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> instancias se indexan según un <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> objeto y un <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> objeto.  
  
 Los objetos de información se mantienen en la colección en el orden en que se reciben del proveedor. La colección no intenta cambiar el orden de las instancias o mantener un criterio de ordenación concreto dentro de la colección.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PersonalizationStateInfoCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PersonalizationStateInfoCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa una colección vacía.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (data As PersonalizationStateInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ data);" />
      <MemberSignature Language="F#" Value="member this.Add : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo -&gt; unit" Usage="personalizationStateInfoCollection.Add data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />
      </Parameters>
      <Docs>
        <param name="data">Instancia derivada de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> que se va a agregar.</param>
        <summary>Agrega una instancia derivada de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> al final de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método agrega un <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-instancia derivada al final de la colección. Internamente, el recuento de la colección se incrementa en uno. No se invalidan todos los enumeradores actualmente activos en la colección.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La colección está marcada como de sólo lectura.</exception>
        <exception cref="T:System.ArgumentException">Se intentó agregar un objeto a la colección cuando una instancia del mismo estado compartido o por usuario ya existe en la colección.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro de datos es nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="personalizationStateInfoCollection.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todos los elementos de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se invalidan todos los enumeradores actualmente activos en la colección.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La colección está marcada como de sólo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As PersonalizationStateInfo(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] * int -&gt; unit" Usage="personalizationStateInfoCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz en la que se copian los elementos de la colección.</param>
        <param name="index">Ubicación en la que iniciar la operación de copia.</param>
        <summary>Copia los elementos de la colección <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> en una matriz<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />, empezando en la posición especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método si desea crear un <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> matriz. Este método simplemente llama a la <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> y pasa el `array` y `index` parámetros.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos de una colección.</summary>
        <value>Número de elementos de una colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El recuento de los elementos de la colección puede utilizarse para recorrer en iteración la colección, tal como se muestra en el ejemplo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count%2A> propiedad.  
  
 [!code-csharp[WebParts_PersAdmin#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_PersAdmin/CS/PersAdmin.ascx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="personalizationStateInfoCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador estándar capaz de recorrer en iteración la colección. Este método no puede heredarse.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. El <xref:System.Collections.IEnumerator.Reset%2A> método también devuelve el enumerador a esta posición. En esta posición, el <xref:System.Collections.IEnumerator.Current%2A> propiedad no está definida. Por lo tanto, debe llamar a la <xref:System.Collections.IEnumerator.MoveNext%2A> método para hacer avanzar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>. Para obtener más información sobre los enumeradores, consulte <xref:System.Collections.IEnumerator>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 La instrucción `foreach` del lenguaje C# (`for each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración. Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la colección <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> está sincronizado (es seguro para la ejecución de subprocesos).</summary>
        <value><see langword="true" /> si el acceso a la colección está sincronizado; en caso contrario, <see langword="false" />. El valor siempre es <see langword="false" /> para los objetos <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> creados por el conjunto de controles de elementos Web.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 La propiedad <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> devuelve un objeto que puede usarse para sincronizar el acceso a <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un elemento de la colección a partir de los parámetros especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[int] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice ordinal del objeto que se va a recuperar.</param>
        <summary>Obtiene una instancia <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> ubicada en el índice ordinal especificado de la colección.</summary>
        <value>Instancia de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> ubicada en el índice ordinal especificado de la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se recupera la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> instancia se encuentra en el índice ordinal especificado en la colección.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es mayor que <see cref="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[string path, string username] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(path As String, username As String) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[System::String ^, System::String ^] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(System::String ^ path, System::String ^ username); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso de aplicación relativa del objeto de estado de personalización que se va a recuperar.</param>
        <param name="username">Nombre de usuario del objeto <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> que se va a recuperar.</param>
        <summary>Obtiene un elemento de la colección a partir de los parámetros especificados.</summary>
        <value>Elemento de la colección a partir de los parámetros especificados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es el indizador predeterminado de la colección. Si solo `path` se proporciona, la propiedad devuelve un <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> instancia. Si ambos `path` y `username` se proporcionan, la propiedad devuelve un <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> instancia para la combinación de `path` y `username`.  
  
 Si `path` (en el caso de que `username` está establecido en `null`) no existe, o si `username` y `path` no existen, `null` se devuelve.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string path, string username);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string path, string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (path As String, username As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ path, System::String ^ username);" />
      <MemberSignature Language="F#" Value="member this.Remove : string * string -&gt; unit" Usage="personalizationStateInfoCollection.Remove (path, username)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso de aplicación relativa del objeto de estado de personalización que se va a quitar.</param>
        <param name="username">Nombre de usuario del objeto derivado de <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> que se va a eliminar.</param>
        <summary>Quita un objeto derivado de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método quita un <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-instancia derivada de la colección. Todos los elementos después de la instancia quitado ascienden para ocupar la posición libre. Internamente, el recuento de la colección es reduce en uno. No se invalidan todos los enumeradores actualmente activos en la colección.  
  
 Si solo `path` se proporciona, el <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> para esa ruta de acceso se quita de la instancia. Si ambos `path` y `username` se proporcionan, la <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> instancia para la combinación de `path` y `username` se quita.  
  
> [!NOTE]
>  Puede intentar quitar un elemento no existente de la colección; Esta acción no producirá una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La colección está marcada como de sólo lectura.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es null.  
  
O bien 
ambos parámetros son null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetReadOnly">
      <MemberSignature Language="C#" Value="public void SetReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReadOnly();" />
      <MemberSignature Language="F#" Value="member this.SetReadOnly : unit -&gt; unit" Usage="personalizationStateInfoCollection.SetReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca la colección como de sólo lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos que intentan modificar una colección de solo lectura, como <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add%2A> y <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove%2A>, producir una <xref:System.NotSupportedException> excepción.  
  
> [!NOTE]
>  Puede llamar a la <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly%2A> método varias veces en la colección; Esto hará que se produzca una excepción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede utilizar para sincronizar el acceso a la instancia de <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />. El conjunto de controles de elementos Web devuelve una referencia al objeto de colección actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 Las clases derivadas pueden proporcionar sus propias versiones sincronizadas de la colección utilizando el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> propiedad. El código de sincronización debe realizar operaciones en el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> de la colección, no directamente en la propia colección. De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos. En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar al mismo tiempo la instancia de la colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">La matriz a la que se copiará una colección de objetos <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />.</param>
        <param name="index">El punto de <paramref name="array" /> en el que se empezará a copiar objetos <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />.</param>
        <summary>Implementa el método <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" /> base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método, como el <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> la clase <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo%2A> simplemente llama un método, el <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> y pasa el `array` y `index` parámetros.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>