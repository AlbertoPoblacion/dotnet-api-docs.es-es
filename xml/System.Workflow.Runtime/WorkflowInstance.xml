<Type Name="WorkflowInstance" FullName="System.Workflow.Runtime.WorkflowInstance">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3f6722f462218341de377b996c28536f8dae9901" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52222300" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInstance extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.WorkflowInstance" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInstance sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInstance = class" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una instancia de flujo de trabajo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 La clase <xref:System.Workflow.Runtime.WorkflowInstance> expone los métodos y propiedades que se pueden utilizar para controlar la ejecución de una instancia de flujo de trabajo; es esencialmente un proxy a la instancia de flujo de trabajo real utilizada por el motor en tiempo de ejecución de flujo de trabajo. Un host o un servicio puede indicar al motor en tiempo de ejecución de flujo de trabajo que realice las acciones en una instancia de flujo de trabajo llamando a los métodos adecuados contenidos en la clase <xref:System.Workflow.Runtime.WorkflowInstance>.  Si la acción solicitada no es válida, por ejemplo, si el host llama <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> en una instancia de flujo de trabajo que ya se ha completado, el motor en tiempo de ejecución de flujo de trabajo generará una excepción adecuada.  
  
> [!NOTE]
>  Si una instancia de flujo de trabajo no responde porque no se devuelve una llamada en la aplicación host, la única manera de recuperar la instancia es reiniciar el tiempo de ejecución. Sin embargo, si la instancia se ha descargado de forma forzada, o se ha interrumpido o suspendido, se puede continuar llamando al método <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo puede crear e iniciar <xref:System.Workflow.Runtime.WorkflowInstance> en un host del flujo de trabajo. El código crea una instancia de <xref:System.Workflow.Runtime.WorkflowRuntime>, agrega los servicios al tiempo de ejecución y, a continuación, muestra la manera recomendada de crear un objeto <xref:System.Workflow.Runtime.WorkflowInstance>. El código inicializa <xref:System.Workflow.Runtime.WorkflowInstance> llamando al método <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> y pasándole el tipo previamente creado. <xref:System.Workflow.Runtime.WorkflowInstance> se inicia con la llamada al método <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>.  
  
 Este ejemplo de código forma parte de la muestra de SDK Cancelar un Flujo de trabajo, del archivo Program.cs. Para obtener más información, consulte [cancelar un flujo de trabajo](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Cancelar un flujo de trabajo</related>
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="workflowInstance.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anula la instancia de flujo de trabajo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La instancia de flujo de trabajo se anula de forma sincrónica; es decir, el método vuelve después de que la instancia de flujo de trabajo haya sido anulada. El motor en tiempo de ejecución de flujo de trabajo invalida la instancia de flujo de trabajo en la memoria y borra <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. Si su instancia de flujo de trabajo utilizó un servicio de persistencia, no se tendrá en cuenta todo el trabajo realizado desde el último punto de persistencia. Después de anular la instancia de flujo de trabajo, el motor en tiempo de ejecución de flujo de trabajo genera el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowAborted>. Puede llamar <xref:System.Workflow.Runtime.WorkflowRuntime.GetWorkflow%2A> para recargar la instancia de flujo de trabajo e empezar desde su último punto de persistencia.  
  
 `Abort` es diferente de <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> en que `Abort` simplemente borra la instancia de flujo de trabajo en memoria y se puede reiniciar desde el último punto de persistencia, Finalizar borra la instancia de flujo de trabajo en memoria e informa al servicio de persistencia de que la instancia se ha borrado de la memoria. Para <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, esto significa que toda la información de estado para esa instancia de flujo de trabajo se elimina de la base de datos cuando se termina. No podrá recargar la instancia de flujo de trabajo de un punto de persistencia previamente almacenado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo se llama a Anular en una instancia de flujo de trabajo de tipo Workflow1.  
  
 [!code-csharp[WF_Samples#13](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#13)]
 [!code-vb[WF_Samples#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyWorkflowChanges">
      <MemberSignature Language="C#" Value="public void ApplyWorkflowChanges (System.Workflow.ComponentModel.WorkflowChanges workflowChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyWorkflowChanges(class System.Workflow.ComponentModel.WorkflowChanges workflowChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ApplyWorkflowChanges(System.Workflow.ComponentModel.WorkflowChanges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyWorkflowChanges(System::Workflow::ComponentModel::WorkflowChanges ^ workflowChanges);" />
      <MemberSignature Language="F#" Value="member this.ApplyWorkflowChanges : System.Workflow.ComponentModel.WorkflowChanges -&gt; unit" Usage="workflowInstance.ApplyWorkflowChanges workflowChanges" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflowChanges" Type="System.Workflow.ComponentModel.WorkflowChanges" />
      </Parameters>
      <Docs>
        <param name="workflowChanges">
          <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" /> que especifica las actualizaciones dinámicas para la instancia de flujo de trabajo.</param>
        <summary>Aplica los cambios a la instancia de flujo de trabajo especificada por el objeto <see cref="T:System.Workflow.ComponentModel.WorkflowChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aún no se ha suspendido la instancia de flujo de trabajo, el motor en tiempo de ejecución de flujo de trabajo suspende temporalmente la instancia antes de aplicar los cambios.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo se llama a ApplyWorkflowChanges a un objeto <xref:System.Workflow.Runtime.WorkflowInstance>.  Este ejemplo es de la muestra de SDK Máquina de estados de la Clasificación, del archivo Mainform.cs.  Para obtener más información, consulte el [ejemplo de equipo de estado de ordenación](https://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#89](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#89)]
 [!code-vb[WF_Samples#89](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItem">
      <MemberSignature Language="C#" Value="public void EnqueueItem (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItem(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItem(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItem (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItem(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItem : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItem (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Nombre del objeto <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Objeto que se va a poner en cola.</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" />que permite notificar el remitente cuando se entrega el elemento <paramref name="item" />.</param>
        <param name="workItem">Objeto que se pasará a los métodos <see cref="T:System.Workflow.Runtime.IPendingWork" />.</param>
        <summary>Envía un mensaje a la cola del flujo de trabajo especificada sincrónicamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Envía el `item` al <xref:System.Workflow.Runtime.WorkflowQueue> especificado. Si quiere recibir una notificación cuando se entregue el mensaje, puede implementar <xref:System.Workflow.Runtime.IPendingWork> en su servicio y pasar `workItem` y un objeto <xref:System.Workflow.Runtime.IPendingWork> a <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Si no quiere recibir una notificación, puede pasar una referencia nula (`Nothing` en Visual Basic) para `pendingWork` y `workItem`.  
  
 Al usar este método con un flujo de trabajo del equipo de estado, puede obtener una excepción con el mensaje "La cola '{0}' no está habilitada". Esto sucede cuando el estado actual del equipo de estado no sabe cómo administrar un evento concreto. Por ejemplo, cuando un estado distinto del estado actual contiene la <xref:System.Workflow.Activities.EventDrivenActivity> que contiene la <xref:System.Workflow.Activities.HandleExternalEventActivity> que está representada por la cola' {0}.'  
  
> [!NOTE]
>  No se garantiza que la instancia de flujo de trabajo envíe los mensajes en el orden en que se enviaron. Por ejemplo, si al recibir un mensaje en una cola existente (Cola A) un flujo de trabajo crea otra cola (Cola B) que, a continuación, escucha otros mensaje enviados después del primer mensaje, es posible que el segundo mensaje llegue primero, y que no se reciba debido a que todavía no se ha creado su cola. Para evitar este problema, no se debería enviar el segundo mensaje hasta que se compruebe la presencia de la segunda cola (utilizar <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>.)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Cuando se produce el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled>, se llama al método `OnWorkflowIdled` definido en este ejemplo. Determina qué flujo de trabajo está inactivo utilizando la propiedad <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> y, a continuación, obtiene una colección de elementos en cola para la instancia de flujo de trabajo llamando al método <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>. El código itera sobre la colección para determinar qué actividad está esperando para el evento que ralentizó el flujo de trabajo. Envía a continuación una excepción a la cola del flujo de trabajo utilizando el método <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> junto con el nombre del elemento de cola de evento.  
  
 Este ejemplo de código forma parte de la muestra de SDK Cancelar un Flujo de trabajo, del archivo Program.cs. Para obtener más información, consulte [cancelar un flujo de trabajo](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> es una referencia nula (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.  
  
O bien 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> especificado por <paramref name="queueName" /> no existe.  
  
O bien 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> especificado por <paramref name="queueName" />no está habilitado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Cancelar un flujo de trabajo</related>
      </Docs>
    </Member>
    <Member MemberName="EnqueueItemOnIdle">
      <MemberSignature Language="C#" Value="public void EnqueueItemOnIdle (IComparable queueName, object item, System.Workflow.Runtime.IPendingWork pendingWork, object workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnqueueItemOnIdle(class System.IComparable queueName, object item, class System.Workflow.Runtime.IPendingWork pendingWork, object workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnqueueItemOnIdle (queueName As IComparable, item As Object, pendingWork As IPendingWork, workItem As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnqueueItemOnIdle(IComparable ^ queueName, System::Object ^ item, System::Workflow::Runtime::IPendingWork ^ pendingWork, System::Object ^ workItem);" />
      <MemberSignature Language="F#" Value="member this.EnqueueItemOnIdle : IComparable * obj * System.Workflow.Runtime.IPendingWork * obj -&gt; unit" Usage="workflowInstance.EnqueueItemOnIdle (queueName, item, pendingWork, workItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queueName" Type="System.IComparable" />
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="pendingWork" Type="System.Workflow.Runtime.IPendingWork" />
        <Parameter Name="workItem" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="queueName">Nombre del objeto <see cref="T:System.Workflow.Runtime.WorkflowQueue" />.</param>
        <param name="item">Objeto que se va a poner en cola.</param>
        <param name="pendingWork">
          <see cref="T:System.Workflow.Runtime.IPendingWork" />que permite notificar el remitente cuando se entrega el elemento <paramref name="item" />.</param>
        <param name="workItem">Objeto que se pasará a los métodos <see cref="T:System.Workflow.Runtime.IPendingWork" />.</param>
        <summary>Envía un mensaje a la cola del flujo de trabajo especificada cuando el flujo de trabajo está inactivo. <see cref="M:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle(System.IComparable,System.Object,System.Workflow.Runtime.IPendingWork,System.Object)" /> espera hasta que el flujo de trabajo alcanza un punto inactivo y se pone a la cola después de comprobar que el programador del flujo de trabajo está inactivo (es decir, no se ejecuta ninguna operación activa).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espera a que la instancia de flujo de trabajo se vuelva inactiva y, a continuación, envía `item` al <xref:System.Workflow.Runtime.WorkflowQueue> especificado. Si usted llama <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItemOnIdle%2A> mientras se suspende la instancia de flujo de trabajo, el motor en tiempo de ejecución de flujo de trabajo iniciará <xref:System.InvalidOperationException>. Si quiere recibir una notificación cuando se entregue el mensaje, puede implementar <xref:System.Workflow.Runtime.IPendingWork> en su servicio y pasar `workItem` y un objeto <xref:System.Workflow.Runtime.IPendingWork> a <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A>. Si no quiere recibir una notificación, puede pasar una referencia nula (`Nothing` en Visual Basic) para `pendingWork` y `workItem`.  
  
 Cuando utilice este método con un flujo de trabajo de equipo de estado, podría obtener una excepción que contiene el mensaje "Cola del mensaje' {0}' no está habilitado." Esto sucede cuando el estado actual del equipo de estado no sabe cómo administrar un evento específico. Por ejemplo, cuando un estado distinto del estado actual contiene la <xref:System.Workflow.Activities.EventDrivenActivity> que contiene la <xref:System.Workflow.Activities.HandleExternalEventActivity> que está representada por la cola' {0}.'  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo enviar información a una instancia de flujo de trabajo mediante el método `EnqueueItemOnIdle`. Primero, un objeto WorkflowInstance se crea y se inicia; después, se creará un objeto que implementa la interfaz <xref:System.Workflow.Runtime.IPendingWork>. `EnqueueItemOnIdle` a continuación, se llama, pasando los valores de cadena para el nombre de cola, el elemento en cola y el elemento de trabajo que se pasarán a los métodos del objeto pendingWork.  
  
 [!code-csharp[WF_Samples#12](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#12)]
 [!code-vb[WF_Samples#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queueName" /> es una referencia nula (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.  
  
O bien 
Se suspende la instancia de flujo de trabajo.  
  
O bien 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> especificado por <paramref name="queueName" /> no existe.  
  
O bien 
<see cref="T:System.Workflow.Runtime.WorkflowQueue" /> especificado por <paramref name="queueName" />no está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="workflowInstance.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar.</param>
        <summary>Devuelve un valor que indica si el objeto especificado es igual a <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</summary>
        <returns>Es <see langword="true" /> si el objeto especificado es igual a <see cref="T:System.Workflow.Runtime.WorkflowInstance" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El objeto debe ser una instancia de la clase <xref:System.Workflow.Runtime.WorkflowInstance> y tener el mismo <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> que <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="workflowInstance.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia de flujo de trabajo.</summary>
        <returns>Código hash de esta <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetHashCode%2A> devuelve un código hash basado en el valor de <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowDefinition">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity GetWorkflowDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Workflow.ComponentModel.Activity GetWorkflowDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowDefinition () As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Workflow::ComponentModel::Activity ^ GetWorkflowDefinition();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowDefinition : unit -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowInstance.GetWorkflowDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la actividad raíz para esta instancia de flujo de trabajo.</summary>
        <returns>Un objeto <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar la actividad raíz para navegar la jerarquía de la actividad del flujo de trabajo.  
  
 Este método no es seguro para subprocesos por lo que el host debería sincronizar sus llamadas a este método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo recuperar la definición de flujo de trabajo de una instancia de flujo de trabajo.  Este ejemplo es de la muestra de SDK Máquina de estados de la Clasificación, del archivo Mainform.cs.  Para obtener más información, consulte el [ejemplo de equipo de estado de ordenación](https://msdn.microsoft.com/library/59272cf4-bc98-439c-bcfa-b66999ebce5c).  
  
 [!code-csharp[WF_Samples#86](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#86)]
 [!code-vb[WF_Samples#86](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#86)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowNextTimerExpiration">
      <MemberSignature Language="C#" Value="public DateTime GetWorkflowNextTimerExpiration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetWorkflowNextTimerExpiration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowNextTimerExpiration () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetWorkflowNextTimerExpiration();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowNextTimerExpiration : unit -&gt; DateTime" Usage="workflowInstance.GetWorkflowNextTimerExpiration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el punto siguiente en el momento en que se programa <see cref="T:System.Workflow.Runtime.WorkflowInstance" /> para recibir un mensaje del temporizador.</summary>
        <returns>Un valor DateTime que representa la hora <see cref="P:System.Workflow.Runtime.TimerEventSubscription.ExpiresAt" /> siguiente en que se entregará un mensaje del temporizador a <see cref="T:System.Workflow.Runtime.WorkflowInstance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar el método <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowNextTimerExpiration%2A> para determinar si se ponen en cola más mensajes del temporizador de flujo de trabajo. Este ejemplo es de la muestra de SDK de WorkflowThreading del archivo Program.cs. Para obtener más información, consulte [ejemplo de subprocesamiento de flujo de trabajo](https://msdn.microsoft.com/library/5b650be7-09fa-47db-a2f6-523dc8ea5ee9).  
  
 [!code-csharp[WF_Samples#284](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#284)]
 [!code-vb[WF_Samples#284](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#284)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Workflow.Runtime.TimerEventSubscription" />
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowQueueData">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Workflow.Runtime.WorkflowQueueInfo&gt; GetWorkflowQueueData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWorkflowQueueData () As ReadOnlyCollection(Of WorkflowQueueInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Workflow::Runtime::WorkflowQueueInfo ^&gt; ^ GetWorkflowQueueData();" />
      <MemberSignature Language="F#" Value="member this.GetWorkflowQueueData : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;" Usage="workflowInstance.GetWorkflowQueueData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Workflow.Runtime.WorkflowQueueInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una colección de los objetos <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /> que contiene los elementos pendientes y las actividades subscritas para las colas del flujo de trabajo asociadas a esta instancia de flujo de trabajo.</summary>
        <returns>Colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Workflow.Runtime.WorkflowQueueInfo" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> devuelve una colección de objetos <xref:System.Workflow.Runtime.WorkflowQueueInfo>, cada uno de los cuales contiene información sobre el estado de una de las colas de flujo de trabajo asociadas a esta instancia de flujo de trabajo. <xref:System.Workflow.Runtime.WorkflowQueueInfo.Items%2A?displayProperty=nameWithType> contiene los elementos pendientes de <xref:System.Workflow.Runtime.WorkflowQueue> y <xref:System.Workflow.Runtime.WorkflowQueueInfo.SubscribedActivityNames%2A?displayProperty=nameWithType> contiene una lista de las actividades que se suscriben para la entrega del elemento en <xref:System.Workflow.Runtime.WorkflowQueue>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo puede utilizar el método <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A> para obtener información sobre el estado de todas las colas de flujo de trabajo asociadas a un objeto <xref:System.Workflow.Runtime.WorkflowInstance>. Cuando se produce el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled>, se llama al método `OnWorkflowIdled` definido en este ejemplo. Determina qué flujo de trabajo está inactivo utilizando la propiedad <xref:System.Workflow.Runtime.WorkflowEventArgs.WorkflowInstance%2A> y, a continuación, obtiene una colección de elementos en cola para la instancia de flujo de trabajo llamando al método <xref:System.Workflow.Runtime.WorkflowInstance.GetWorkflowQueueData%2A>. El código itera sobre la colección para determinar qué actividad está esperando para el evento que ralentizó el flujo de trabajo. Envía a continuación una excepción a la cola del flujo de trabajo utilizando el método <xref:System.Workflow.Runtime.WorkflowInstance.EnqueueItem%2A> junto con el nombre del elemento de cola de evento.  
  
 Este ejemplo de código forma parte de la muestra de SDK Cancelar un Flujo de trabajo, del archivo Program.cs. Para obtener más información, consulte [cancelar un flujo de trabajo](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#261](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#261)]
 [!code-vb[WF_Samples#261](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#261)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Cancelar un flujo de trabajo</related>
      </Docs>
    </Member>
    <Member MemberName="InstanceId">
      <MemberSignature Language="C#" Value="public Guid InstanceId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid InstanceId" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid InstanceId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceId : Guid" Usage="System.Workflow.Runtime.WorkflowInstance.InstanceId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador único de la instancia de flujo de trabajo.</summary>
        <value>
          <see cref="T:System.Guid" /> de la instancia de flujo de trabajo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> para hacer referencia a la instancia de flujo de trabajo.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo puede utilizar la propiedad <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> para obtener información sobre un objeto <xref:System.Workflow.Runtime.WorkflowInstance>. El primer fragmento de código crea una variable <xref:System.Workflow.Runtime.WorkflowInstance> denominada `instanceId`.  
  
 [!code-csharp[WF_Samples#210](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#210)]
 [!code-vb[WF_Samples#210](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#210)]  
  
 El segundo fragmento de código utiliza la propiedad <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> como el primer objeto en una llamada de constructor `OrderEventArgs` cuando se llama al método `CallBackForApproval`.  
  
 Este ejemplo de código forma la parte de la muestra de SDK Escuche, del archivo OrderServiceImple.cs. Para obtener más información, consulte [ejemplo escuchar](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)).  
  
 [!code-csharp[WF_Samples#211](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets19.cs#211)]
 [!code-vb[WF_Samples#211](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets19.vb#211)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741698(v=vs.90)">Ejemplo de escucha</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Load" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load();" />
      <MemberSignature Language="F#" Value="member this.Load : unit -&gt; unit" Usage="workflowInstance.Load " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Carga una instancia de flujo de trabajo previamente descargada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> es sincrónico; si se puede cargar la instancia de flujo de trabajo, <xref:System.Workflow.Runtime.WorkflowInstance.Load%2A> devolverá cuando el motor en tiempo de ejecución de flujo de trabajo haya cargado en la memoria y haya programado la instancia de flujo de trabajo. El tiempo de ejecución genera el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowLoaded> después de que el servicio de persistencia haya restaurado la instancia de flujo de trabajo en memoria, pero antes de que el motor en tiempo de ejecución de flujo de trabajo programe la instancia.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo cargar un objeto <xref:System.Workflow.Runtime.WorkflowInstance> previamente descargado.  
  
 [!code-csharp[WF_Samples#10](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#10)]
 [!code-vb[WF_Samples#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReloadTrackingProfiles">
      <MemberSignature Language="C#" Value="public void ReloadTrackingProfiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReloadTrackingProfiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.ReloadTrackingProfiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReloadTrackingProfiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReloadTrackingProfiles();" />
      <MemberSignature Language="F#" Value="member this.ReloadTrackingProfiles : unit -&gt; unit" Usage="workflowInstance.ReloadTrackingProfiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recargue los perfiles de seguimiento para esta instancia de flujo de trabajo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La infraestructura del seguimiento en tiempo de ejecución recargará cada <xref:System.Workflow.Runtime.Tracking.TrackingProfile> para esta instancia de flujo de trabajo asociada a sus canales del seguimiento. Si aún no está en estado suspendido, la infraestructura del seguimiento en tiempo de ejecución suspende temporalmente el flujo de trabajo mientras se recargan los perfiles del seguimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="workflowInstance.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reanuda la ejecución de una instancia de flujo de trabajo previamente suspendida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El host puede llamar <xref:System.Workflow.Runtime.WorkflowInstance.Resume%2A> para reanudar la ejecución de una instancia de flujo de trabajo suspendida previamente. Si la instancia de flujo de trabajo no está en estado suspendido, no se realiza ninguna acción. El tiempo de ejecución genera el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowResumed> justo antes de que se reanude la ejecución de la instancia de flujo de trabajo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a Reanudar en una instancia de flujo de trabajo previamente suspendida.  Este ejemplo pertenece a Suspenda y Finalice el ejemplo de SDK.  Para obtener más información, consulte [Suspend y Terminate ejemplo](https://msdn.microsoft.com/library/f4dffa58-d01e-44fb-b5a1-3b283d2c4517).  
  
 [!code-csharp[WF_Samples#172](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#172)]
 [!code-vb[WF_Samples#172](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#172)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="workflowInstance.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia la ejecución de la instancia de flujo de trabajo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> llama <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ExecuteActivity%2A> en la actividad raíz de esta instancia de flujo de trabajo. Si <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> se encuentra con una excepción, finaliza la instancia de flujo de trabajo llamando <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> con la propiedad <xref:System.Exception.Message%2A> de la excepción pasada como la razón para la finalización.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo puede utilizar el método <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A> para iniciar <xref:System.Workflow.Runtime.WorkflowInstance> en un host del flujo de trabajo. El código crea una instancia de <xref:System.Workflow.Runtime.WorkflowRuntime>, agrega los servicios al tiempo de ejecución y, a continuación, muestra la manera recomendada de crear un objeto <xref:System.Workflow.Runtime.WorkflowInstance>. Crea un objeto <xref:System.Type> y lo convierte a uno de los objetos de flujo de trabajo a los cuales el host está asociado. Después, el código inicializa <xref:System.Workflow.Runtime.WorkflowInstance> llamando al método <xref:System.Workflow.Runtime.WorkflowRuntime.CreateWorkflow%2A> y pasándole el tipo previamente creado. <xref:System.Workflow.Runtime.WorkflowInstance> se inicia con la llamada al método <xref:System.Workflow.Runtime.WorkflowInstance.Start%2A>.  
  
 Este ejemplo de código forma parte de la muestra de SDK Cancelar un Flujo de trabajo, del archivo Program.cs. Para obtener más información, consulte [cancelar un flujo de trabajo](https://msdn.microsoft.com/library/d5077f56-a78b-48e7-825c-f6c77c8e54fb).  
  
 [!code-csharp[WF_Samples#260](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#260)]
 [!code-vb[WF_Samples#260](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#260)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.  
  
O bien 
Ya se ha iniciado la instancia de flujo de trabajo.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742169(v=vs.90)">Cancelar un flujo de trabajo</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Suspend(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Suspend : string -&gt; unit" Usage="workflowInstance.Suspend error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Una descripción de la razón para suspender la instancia de flujo de trabajo.</param>
        <summary>Suspende la instancia de flujo de trabajo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La instancia de flujo de trabajo se suspende de una manera sincrónica. Si se ya se ha suspendido la instancia de flujo de trabajo, no se realiza ninguna acción; de lo contrario, el motor en tiempo de ejecución de flujo de trabajo suspende la instancia de flujo de trabajo, genera el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowSuspended> y pasa `reason` en <xref:System.Workflow.Runtime.WorkflowSuspendedEventArgs>.  
  
> [!NOTE]
>  <xref:System.Workflow.Runtime.WorkflowInstance.Suspend%2A> no descarga la instancia de flujo de trabajo.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo se llama a Suspender en un objeto <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#9](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#9)]
 [!code-vb[WF_Samples#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.</exception>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ error);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowInstance.Terminate error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="error">Una descripción de la razón para finalizar la instancia de flujo de trabajo.</param>
        <summary>Finaliza la instancia de flujo de trabajo de una forma sincrónica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La instancia de flujo de trabajo se finaliza de una forma sincrónica. El host llama a <xref:System.Workflow.Runtime.WorkflowInstance.Terminate%2A> para finalizar la instancia de flujo de trabajo. El motor en tiempo de ejecución de flujo de trabajo borra la instancia de flujo de trabajo en memoria e informa al servicio de persistencia que se ha borrado la instancia de la memoria. Para <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService>, esto significa que toda la información de estado para esa instancia de flujo de trabajo se elimina de la base de datos cuando se termina. No podrá recargar la instancia de flujo de trabajo de un punto de persistencia previamente almacenado.  
  
 Una vez borrada la instancia de flujo de trabajo en memoria y se informa al servicio de persistencia de la finalización, el método `Terminate` genera el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> y pasa `reason` en la propiedad <xref:System.Exception.Message%2A> de <xref:System.Workflow.ComponentModel.WorkflowTerminatedException> contenida en <xref:System.Workflow.Runtime.WorkflowTerminatedEventArgs>.  
  
 `Terminate` es diferente de <xref:System.Workflow.Runtime.WorkflowInstance.Abort%2A> en que Finalizar borra la instancia de flujo de trabajo en memoria e informa al servicio de persistencia de la finalización, `Abort` simplemente borra la instancia de flujo de trabajo en memoria, que puede reiniciarse a continuación desde el último punto de persistencia.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo se llama a Terminar en un objeto <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#8](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#8)]
 [!code-vb[WF_Samples#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El motor en tiempo de ejecución de flujo de trabajo no está en ejecución.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryUnload">
      <MemberSignature Language="C#" Value="public bool TryUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.TryUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function TryUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryUnload();" />
      <MemberSignature Language="F#" Value="member this.TryUnload : unit -&gt; bool" Usage="workflowInstance.TryUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarga la instancia de flujo de trabajo de la memoria al almacén de persistencia cuando la instancia se suspende o está inactiva.</summary>
        <returns>
          <see langword="true" /> si se descargara la instancia de flujo de trabajo; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la instancia de flujo de trabajo está inactiva o suspendida, <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> utiliza el servicio de persistencia para quitar la instancia de flujo de trabajo de la memoria y conservarla en un almacén de datos. Si no hay ningún servicio de persistencia registrado con <xref:System.Workflow.Runtime.WorkflowRuntime>, <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> inicia <xref:System.InvalidOperationException>. Si la instancia de flujo de trabajo se conserva correctamente, el tiempo de ejecución genera el <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded> eventos y devoluciones `true`. <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> Devuelve `false` si ya se ha descargado la instancia de flujo de trabajo, ha finalizado, anulado o ya se ha completado.  
  
 El host puede utilizar <xref:System.Workflow.Runtime.WorkflowInstance.TryUnload%2A> para reclamar los recursos del sistema de un flujo de trabajo inactivo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar el método TryUnload para descargar un flujo de trabajo cuando se desencadena el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowIdled>. Este ejemplo pertenece a la muestra de SDK de Utilizar Servicios de Persistencia, del archivo Program.cs. Para obtener más información, consulte [utilizando el ejemplo de servicios de persistencia](https://msdn.microsoft.com/library/3176b7e7-ae49-4d5c-802b-85032d6ebde6).  
  
 [!code-csharp[WF_Samples#280](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#280)]
 [!code-vb[WF_Samples#280](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#280)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No hay ningún servicio de persistencia registrado con el motor en tiempo de ejecución de flujo de trabajo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.WorkflowInstance.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowInstance.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarga la instancia de flujo de trabajo desde la memoria al almacén de persistencia. Esta llamada se bloquea hasta que finalice el trabajo actualmente programado o hasta el final de un ámbito de transacción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> es sincrónica; es decir, se devuelve después de completar cualquier acción que realice. Si la instancia de flujo de trabajo no está inactiva, el motor en tiempo de ejecución espera hasta que se pueda interrumpir la instancia. Sólo se puede interrumpir una instancia una vez finalizado el elemento de trabajo actualmente programado. Generalmente, esto se produce cuando la Actividad actualmente en ejecución vuelve de su método <xref:System.Workflow.ComponentModel.Activity.Execute%2A>. Sin embargo, si la instancia está ejecutando una <xref:System.Workflow.ComponentModel.TransactionScopeActivity>, el ámbito de transacción debe completar la ejecución antes de que se pueda interrumpir la instancia. A continuación, la descarga utiliza el servicio de persistencia para quitar la instancia de flujo de trabajo de la memoria y lo conserva en un almacén de datos. Si no hay ningún servicio de persistencia registrado con <xref:System.Workflow.Runtime.WorkflowRuntime>, <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> inicia <xref:System.InvalidOperationException>. Si se conserva la instancia de flujo de trabajo correctamente, el tiempo de ejecución genera el evento <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowUnloaded>.  
  
 El host puede utilizar <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> para reclamar los recursos del sistema de un flujo de trabajo inactivo.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo llamar <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A> en un objeto <xref:System.Workflow.Runtime.WorkflowInstance>.  
  
 [!code-csharp[WF_Samples#11](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#11)]
 [!code-vb[WF_Samples#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No hay ningún servicio de persistencia registrado con el motor en tiempo de ejecución de flujo de trabajo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkflowRuntime">
      <MemberSignature Language="C#" Value="public System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.Runtime.WorkflowRuntime WorkflowRuntime" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkflowRuntime As WorkflowRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::Runtime::WorkflowRuntime ^ WorkflowRuntime { System::Workflow::Runtime::WorkflowRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkflowRuntime : System.Workflow.Runtime.WorkflowRuntime" Usage="System.Workflow.Runtime.WorkflowInstance.WorkflowRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el estado de <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> para esta instancia de flujo de trabajo.</summary>
        <value>
          <see cref="T:System.Workflow.Runtime.WorkflowRuntime" /> que representa el entorno de ejecución en el que esta instancia de flujo de trabajo se está ejecutando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo tener acceso a la ejecución <xref:System.Workflow.Runtime.WorkflowRuntime> de un <xref:System.Workflow.Runtime.WorkflowInstance> objeto.  
  
 [!code-csharp[WF_Samples#7](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#7)]
 [!code-vb[WF_Samples#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>