<Type Name="PeerName" FullName="System.Net.PeerToPeer.PeerName">
  <Metadata><Meta Name="ms.openlocfilehash" Value="259fb70c6ab49baa8fe528c72cff9e6a68e04c81" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53290877" /></Metadata><TypeSignature Language="C#" Value="public class PeerName : IEquatable&lt;System.Net.PeerToPeer.PeerName&gt;, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable PeerName extends System.Object implements class System.IEquatable`1&lt;class System.Net.PeerToPeer.PeerName&gt;, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.PeerToPeer.PeerName" />
  <TypeSignature Language="VB.NET" Value="Public Class PeerName&#xA;Implements IEquatable(Of PeerName), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class PeerName : IEquatable&lt;System::Net::PeerToPeer::PeerName ^&gt;, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type PeerName = class&#xA;    interface ISerializable&#xA;    interface IEquatable&lt;PeerName&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Net.PeerToPeer.PeerName&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Especifica los valores que definen un objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> punto a punto. Un nombre del mismo nivel suele ser una cadena que se usa para identificar un recurso del mismo nivel.</summary>
    <remarks>To be added.</remarks>
    <altmember cref="N:System.Net.PeerToPeer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PeerName (string remotePeerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string remotePeerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (remotePeerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PeerName(System::String ^ remotePeerName);" />
      <MemberSignature Language="F#" Value="new System.Net.PeerToPeer.PeerName : string -&gt; System.Net.PeerToPeer.PeerName" Usage="new System.Net.PeerToPeer.PeerName remotePeerName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="remotePeerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="remotePeerName">Contiene el nombre del mismo nivel para codificar como una instancia de <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <summary>Inicializa un nuevo objeto de tipo <see cref="T:System.Net.PeerToPeer.PeerName" /> con valor <see cref="T:System.String" /> del nombre del mismo nivel completo proporcionado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.String" /> proporcionado no es un <see cref="T:System.Net.PeerToPeer.PeerName" /> válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="remotePeerName" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PeerName (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PeerName(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Net.PeerToPeer.PeerName : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.PeerToPeer.PeerName" Usage="new System.Net.PeerToPeer.PeerName (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Referencia al objeto que contiene los datos necesarios para deserializar esta instancia.</param>
        <param name="context">Contexto que proporciona los medios para deserializar los datos. Se conoce también como el origen de los datos serializados.</param>
        <summary>Rellena un objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con los datos necesarios para serializar el <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor es necesario para la deserialización de este tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios parámetros son <see langword="null" />.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
        <altmember cref="N:System.Runtime.Serialization" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PeerName (string classifier, System.Net.PeerToPeer.PeerNameType peerNameType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string classifier, valuetype System.Net.PeerToPeer.PeerNameType peerNameType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.#ctor(System.String,System.Net.PeerToPeer.PeerNameType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PeerName(System::String ^ classifier, System::Net::PeerToPeer::PeerNameType peerNameType);" />
      <MemberSignature Language="F#" Value="new System.Net.PeerToPeer.PeerName : string * System.Net.PeerToPeer.PeerNameType -&gt; System.Net.PeerToPeer.PeerName" Usage="new System.Net.PeerToPeer.PeerName (classifier, peerNameType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classifier" Type="System.String" />
        <Parameter Name="peerNameType" Type="System.Net.PeerToPeer.PeerNameType" />
      </Parameters>
      <Docs>
        <param name="classifier"><see cref="T:System.String" /> que contiene el nombre del mismo nivel para codificar como <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <param name="peerNameType">Valor de enumeración <see cref="T:System.Net.PeerToPeer.PeerNameType" /> que especifica el tipo del nombre del mismo nivel que se va a crear.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor devuelve un objeto de tipo <xref:System.Net.PeerToPeer.PeerName> que contiene el nombre completo del mismo nivel. También especifica si el nombre del mismo nivel está protegido o no protegido.  
  
 Esta instancia usa la identidad del mismo nivel predeterminada para el usuario actual y el especificado <xref:System.Net.PeerToPeer.PeerName.Classifier%2A>, además del tipo de nombre del mismo nivel para crear con el clasificador y tipo especificados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Net.PeerToPeer.PeerName.Classifier" /> incluye uno o más caracteres no válidos.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios parámetros son <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException">-   No se puede recuperar la identidad predeterminada que se utiliza como base de <see cref="T:System.Net.PeerToPeer.PeerName" />.  
  
-   <see cref="T:System.Net.PeerToPeer.PeerName" /> no se puede crear.</exception>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Net.PeerToPeer.PeerName.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve una cadena que especifica la propiedad <see cref="P:System.Net.PeerToPeer.PeerName.Authority" /> utilizada por este objeto <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <value>La cadena que contiene la parte de autenticación del objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> especificado. Para los nombres del mismo nivel seguros, esta propiedad contiene la clave pública como una cadena hexadecimal de cuarenta caracteres. Para los nombres del mismo nivel no protegidos, esta propiedad se establece en cero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo el propietario o el host del mismo nivel, puede registrar un nombre seguro de mismo nivel. Un nombre de mismo nivel se considera seguro si está respaldado por un certificado autofirmado.  
  
 Nombres de mismo nivel distinguen mayúsculas de minúsculas y el formato de un nombre de mismo nivel es: *Authority.Classifier*. Por ejemplo, "0.MiNombreDelMismoNivel" es un nombre de mismo nivel tiene el formato correcto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Con un nombre seguro de mismo nivel no garantiza la seguridad general de la aplicación de red. La seguridad de la aplicación depende de la implementación.</para></block>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Classifier" />
        <altmember cref="T:System.Net.PeerToPeer.PeerNameType" />
      </Docs>
    </Member>
    <Member MemberName="Classifier">
      <MemberSignature Language="C#" Value="public string Classifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Classifier" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.Classifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Classifier As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Classifier { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Classifier : string" Usage="System.Net.PeerToPeer.PeerName.Classifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve una cadena que contiene el clasificador para un objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> punto a punto.</summary>
        <value>Cadena que contiene la parte del clasificador utilizada para identificar un nombre del mismo nivel para <see cref="T:System.Net.PeerToPeer.PeerNameRegistration" /> o una resolución de un objeto <see cref="T:System.Net.PeerToPeer.Cloud" /> de PNRP.  
  
A menos que especifique explícitamente, el valor predeterminado para todas las propiedades es <see langword="null" /> para tipos de referencia y cero (0) para las propiedades de tipo <see langword="int" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El formato de un nombre de mismo nivel es: *Authority.Classifier*. El nombre del mismo nivel *clasificador* componente se puede establecer en cualquier cadena que contenga 149 o menos caracteres Unicode, incluido el `null` terminador ("\0"). Las cadenas de nombre del mismo nivel distinguen mayúsculas de minúsculas.  
  
 Para los nombres del mismo nivel seguros, el clasificador y el punto que después de la entidad son opcionales. Para los nombres de mismo nivel no protegidos, el clasificador no es opcional.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Authority" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.IsSecured" />
        <altmember cref="T:System.Net.PeerToPeer.PeerNameType" />
      </Docs>
    </Member>
    <Member MemberName="CreateFromPeerHostName">
      <MemberSignature Language="C#" Value="public static System.Net.PeerToPeer.PeerName CreateFromPeerHostName (string peerHostName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.PeerToPeer.PeerName CreateFromPeerHostName(string peerHostName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromPeerHostName (peerHostName As String) As PeerName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::PeerToPeer::PeerName ^ CreateFromPeerHostName(System::String ^ peerHostName);" />
      <MemberSignature Language="F#" Value="static member CreateFromPeerHostName : string -&gt; System.Net.PeerToPeer.PeerName" Usage="System.Net.PeerToPeer.PeerName.CreateFromPeerHostName peerHostName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.PeerToPeer.PeerName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peerHostName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peerHostName">Cadena que contiene el nombre de host calificado con DNS.</param>
        <summary>Crea una nueva instancia del objeto <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> especificado con el nombre de host del mismo nivel especificado.</summary>
        <returns>Objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> que representa el nombre de host del mismo nivel especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El host de punto a punto es el nodo"inicialización" invitar a homólogos responsable de iniciar la sesión de red punto a punto, participar en aplicaciones para que este tipo de conectividad de red es más adecuado para las comunicaciones, como grupos de chat o juego sesiones.  
  
 Este método se puede usar para crear un <xref:System.Net.PeerToPeer.PeerName> objeto según el <xref:System.Net.PeerToPeer.PeerName.PeerHostName%2A> propiedad. Este nombre del mismo nivel no está asociado con la identidad del nodo que realiza la llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor <see cref="T:System.String" /> proporcionado no es una cadena de nombre de host del mismo nivel válida.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException"><see cref="T:System.Net.PeerToPeer.PeerName" /> no se pudo crear a partir del <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> proporcionado.</exception>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelativePeerName">
      <MemberSignature Language="C#" Value="public static System.Net.PeerToPeer.PeerName CreateRelativePeerName (System.Net.PeerToPeer.PeerName peerName, string classifier);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.PeerToPeer.PeerName CreateRelativePeerName(class System.Net.PeerToPeer.PeerName peerName, string classifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::PeerToPeer::PeerName ^ CreateRelativePeerName(System::Net::PeerToPeer::PeerName ^ peerName, System::String ^ classifier);" />
      <MemberSignature Language="F#" Value="static member CreateRelativePeerName : System.Net.PeerToPeer.PeerName * string -&gt; System.Net.PeerToPeer.PeerName" Usage="System.Net.PeerToPeer.PeerName.CreateRelativePeerName (peerName, classifier)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.PeerToPeer.PeerName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peerName" Type="System.Net.PeerToPeer.PeerName" />
        <Parameter Name="classifier" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="peerName">Objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> en el que se establece el nuevo valor de cadena del clasificador.</param>
        <param name="classifier">El <see cref="P:System.Net.PeerToPeer.PeerName.Classifier" /> que se ha de establecer en el <see cref="T:System.Net.PeerToPeer.PeerName" /> devuelto.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> y reemplaza el campo <see cref="P:System.Net.PeerToPeer.PeerName.Classifier" /> definido en el objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> proporcionado por el valor de cadena del clasificador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> que contiene el clasificador actualizado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.PeerToPeer.PeerName.Classifier%2A> se anexa a la existente <xref:System.Net.PeerToPeer.PeerName.Authority%2A> parte de la <xref:System.Net.PeerToPeer.PeerName>. Esta cadena es no más de 149 caracteres, incluido el `null` terminador. Especificar `null` para devolver el nombre del mismo nivel de la identidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor <see cref="T:System.String" /> proporcionado no es un clasificador del nombre del mismo nivel válido.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios parámetros son <see langword="null" />.</exception>
        <exception cref="T:System.Net.PeerToPeer.PeerToPeerException"><see cref="T:System.Net.PeerToPeer.PeerName" /> no se pudo crear a partir del <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> proporcionado.</exception>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateFromPeerHostName(System.String)" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si el contenido de este objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> es equivalente al contenido de otro objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación de Equals se define mediante IEquatable\<T >.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Authority" />
        <altmember cref="P:System.Net.PeerToPeer.PeerName.Classifier" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Net.PeerToPeer.PeerName other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Net.PeerToPeer.PeerName other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.Equals(System.Net.PeerToPeer.PeerName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As PeerName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Net::PeerToPeer::PeerName ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Net.PeerToPeer.PeerName -&gt; bool" Usage="peerName.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Net.PeerToPeer.PeerName" />
      </Parameters>
      <Docs>
        <param name="other">El nombre del mismo nivel que se compara con <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <summary>Realiza una comparación con distinción entre mayúsculas y minúsculas del objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> actual y el nombre del mismo nivel especificado.</summary>
        <returns>Devuelve <see langword="true" /> si el objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> especificado identifica el mismo recurso que el objeto de nombre del mismo nivel actual; de lo contrario, este método devuelve <see langword="false" />.  
  
Este método también devuelve <see langword="false" /> si <paramref name="other" /> se establece en <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos nombres de mismo nivel se consideran iguales si contienen caracteres idénticos en sus <xref:System.Net.PeerToPeer.PeerName.Authority%2A> y <xref:System.Net.PeerToPeer.PeerName.Classifier%2A> componentes.  
  
 En las cadenas antes de la comparación se realiza ninguna normalización.  Toda la normalización se debe haber completado, o bien antes de construir los objetos con nombre del mismo nivel.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="peerName.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto <see cref="T:System.Object" /> que se va a comparar con el objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> actual.</param>
        <summary>Determina si el contenido de <see cref="T:System.Net.PeerToPeer.PeerName" /> es igual al contenido de otro objeto.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Net.PeerToPeer.PeerName" /> y el objeto de comparación contienen la misma información; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método hereda la firma de manera predeterminada y el comportamiento de <xref:System.Object>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="peerName.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reemplaza el método <see cref="M:System.Object.GetHashCode" />.</summary>
        <returns>Código hash para la clase <see cref="T:System.Object" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos objetos se consideran iguales si este método devuelve el mismo código hash para ambos.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="peerName.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Contiene los datos serializados asociados al objeto <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <param name="context">Contiene el destino del flujo serializado asociado al objeto <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <summary>Rellena un objeto de información de serialización con los datos necesarios para serializar <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo derivado debe llamar al método <xref:System.Runtime.Serialization.ISerializable.GetObjectData%2A> de tipo base.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="IsSecured">
      <MemberSignature Language="C#" Value="public bool IsSecured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecured" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.IsSecured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecured : bool" Usage="System.Net.PeerToPeer.PeerName.IsSecured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor booleano que especifica si se trata de un nombre del mismo nivel seguro.</summary>
        <value>Si es <see langword="true" />, este nombre del mismo nivel está protegido con un par de clave privada y clave pública. Su nombre contiene el hash del Algoritmo hash seguro (SHA) de la clave pública del certificado de usuario de ese equipo del mismo nivel. De lo contrario, si es <see langword="false" />, el nombre del mismo nivel no tiene ninguna identidad asociada.  
  
A menos que especifique explícitamente, el valor predeterminado para todas las propiedades es <see langword="null" /> para tipos de referencia y cero (0) para las propiedades de tipo <see langword="int" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nombre de mismo nivel se considera seguro si está respaldado por un certificado autofirmado.  
  
 Solo el propietario puede registrar un nombre seguro de mismo nivel con PNRP.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Con un nombre seguro de mismo nivel no garantiza la seguridad general de la aplicación de red. La seguridad de la aplicación depende de la implementación.</para></block>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
        <altmember cref="N:System.Security.Permissions" />
      </Docs>
    </Member>
    <Member MemberName="PeerHostName">
      <MemberSignature Language="C#" Value="public string PeerHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PeerHostName" />
      <MemberSignature Language="DocId" Value="P:System.Net.PeerToPeer.PeerName.PeerHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeerHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PeerHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PeerHostName : string" Usage="System.Net.PeerToPeer.PeerName.PeerHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del host punto a punto. Ésta es una versión codificada por DNS de <see cref="T:System.Net.PeerToPeer.PeerName" /> que es equivalente a <see cref="P:System.Net.PeerToPeer.PeerName.PeerHostName" /> en cuanto que ambos son identificadores.  La diferencia entre los dos es la representación visual.</summary>
        <value>Valor <see cref="T:System.String" /> que es el nombre del host punto a punto. A menos que se especifique explícitamente, el valor predeterminado de todas las propiedades es <see langword="null" /> para los tipos de referencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El host de punto a punto es el nodo"inicialización" invitar a homólogos responsable de iniciar la sesión de red punto a punto, participar en aplicaciones para que este tipo de conectividad de red es más adecuado para las comunicaciones, como grupos de chat o juego sesiones.  
  
 El <xref:System.Net.PeerToPeer.PeerName.PeerHostName%2A> propiedad especifica el nombre del mismo nivel que creó la sesión de red punto a punto, y que se considera el host de la sesión.  El host de una sesión de red punto a punto puede recopilar los elementos del mismo nivel en más de una <xref:System.Net.PeerToPeer.Cloud>. Además, un elemento del mismo nivel puede hospedar simultáneamente más de un host del mismo nivel.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.PeerToPeer.PeerName.CreateRelativePeerName(System.Net.PeerToPeer.PeerName,System.String)" />
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Contiene los datos serializados asociados al objeto <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <param name="context">Contiene el destino del flujo serializado asociado al objeto <see cref="T:System.Net.PeerToPeer.PeerName" />.</param>
        <summary>Implementa la interfaz de <see cref="T:System.Runtime.Serialization.ISerializable" /> y devuelve los datos necesarios para serializar la instancia de <see cref="T:System.Net.PeerToPeer.PeerName" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PeerName.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="peerName.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una representación en forma de cadena del objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> actual.</summary>
        <returns>Cadena que representa el objeto <see cref="T:System.Net.PeerToPeer.PeerName" /> actual y se especifica en el formato siguiente: *Authority.Classifier*. Por ejemplo, "0.MiElementoDelMismoNivelDeInternet".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método hereda la firma de manera predeterminada y el comportamiento de <xref:System.Object>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.PeerToPeer.PeerName" />
      </Docs>
    </Member>
  </Members>
</Type>