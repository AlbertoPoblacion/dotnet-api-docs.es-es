<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="HashAlgorithm.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52b9b76797e6d798773a44e829bec18e894d93a53.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2b9b76797e6d798773a44e829bec18e894d93a53</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>Represents the base class from which all implementations of cryptographic hash algorithms must derive.</source>
          <target state="translated">Representa la clase base de la que deben derivarse todas las implementaciones de algoritmos hash criptográficos.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>Hash functions are fundamental to modern cryptography.</source>
          <target state="translated">Las funciones hash son fundamentales para criptografía modernos.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>These functions map binary strings of an arbitrary length to small binary strings of a fixed length, known as hash values.</source>
          <target state="translated">Estas funciones asignan cadenas binarias de longitud arbitraria a cadenas binarias pequeñas de una longitud fija, denominadas valores hash.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>A cryptographic hash function has the property that it is computationally infeasible to find two distinct inputs that hash to the same value.</source>
          <target state="translated">Una función hash criptográfica tiene la propiedad que es poco factible encontrar dos entradas distintas cuyo hash sea el mismo valor.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>Hash functions are commonly used with digital signatures and for data integrity.</source>
          <target state="translated">Las funciones hash se utilizan normalmente con firmas digitales y para la integridad de los datos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>The hash is used as a unique value of fixed size representing a large amount of data.</source>
          <target state="translated">El hash se utiliza como un valor único de tamaño fijo que representa una gran cantidad de datos.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>Hashes of two sets of data should match if the corresponding data also matches.</source>
          <target state="translated">Los valores hash de dos conjuntos de datos deben coincidir si los datos correspondientes también coinciden.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>Small changes to the data result in large unpredictable changes in the hash.</source>
          <target state="translated">Los pequeños cambios en el resultado de datos grandes cambios imprevisibles en el valor hash.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>The following code example computes the <ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1CryptoServiceProvider&gt;</ph> hash for an array.</source>
          <target state="translated">El siguiente código de ejemplo calcula el <ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1CryptoServiceProvider&gt;</ph> hash para una matriz.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>This example assumes that there is a predefined byte array <ph id="ph1">`dataArray[]`</ph>.</source>
          <target state="translated">En este ejemplo se supone que hay una matriz de bytes predefinida <ph id="ph1">`dataArray[]`</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1CryptoServiceProvider&gt;</ph> is a derived class of <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1CryptoServiceProvider&gt;</ph> es una clase derivada de <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> class, you must override the following members:  <ph id="ph2">&lt;see cref="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Security.Cryptography.HashAlgorithm.HashFinal" /&gt;</ph>.</source>
          <target state="translated">Al heredar de la <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> (clase), debe reemplazar los miembros siguientes: <ph id="ph2">&lt;see cref="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)" /&gt;</ph> y <ph id="ph3">&lt;see cref="M:System.Security.Cryptography.HashAlgorithm.HashFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.#ctor">
          <source>You cannot create an instance of an abstract class.</source>
          <target state="translated">No se puede crear una instancia de una clase abstracta.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.#ctor">
          <source>Application code creates a new instance of a derived class.</source>
          <target state="translated">Código de la aplicación crea una nueva instancia de una clase derivada.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.HashAlgorithm.CanReuseTransform">
          <source>Gets a value indicating whether the current transform can be reused.</source>
          <target state="translated">Obtiene un valor que indica si la transformación actual puede volver a usarse.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.CanReuseTransform">
          <source>Always <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Siempre es <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.HashAlgorithm.CanTransformMultipleBlocks">
          <source>When overridden in a derived class, gets a value indicating whether multiple blocks can be transformed.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene un valor que indica si se pueden transformar varios bloques.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.CanTransformMultipleBlocks">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if multiple blocks can be transformed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si se pueden transformar varios bloques; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Clear">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> class.</source>
          <target state="translated">Libera todos los recursos que utiliza la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Clear">
          <source>This method is a simple call to the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Este método es una simple llamada a la <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Clear">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> class to be reallocated for other purposes.</source>
          <target state="translated">Al llamar a <ph id="ph1">`Dispose`</ph> permite que los recursos utilizados por la <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> clase se reasignen para otros fines.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Clear">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de <ph id="ph1">`Dispose`</ph>, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>Computes the hash value for the input data.</source>
          <target state="translated">Calcula el valor hash de los datos de entrada.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])">
          <source>The input to compute the hash code for.</source>
          <target state="translated">La entrada para la cual se calcula el código hash.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])">
          <source>Computes the hash value for the specified byte array.</source>
          <target state="translated">Calcula el valor hash para la matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])">
          <source>The computed hash code.</source>
          <target state="translated">Código hash calculado.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])">
          <source>The following example computes the <ph id="ph1">&lt;xref:System.Security.Cryptography.MD5&gt;</ph> hash value of a string and returns the hash as a 32-character, hexadecimal-formatted string.</source>
          <target state="translated">El ejemplo siguiente se calcula el <ph id="ph1">&lt;xref:System.Security.Cryptography.MD5&gt;</ph> valor hash de una cadena y devuelve el hash como una cadena con formato hexadecimal de 32 caracteres.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])">
          <source>The hash string created by this code example is compatible with any MD5 hash function (on any platform) that creates a 32-character, hexadecimal-formatted hash string.</source>
          <target state="translated">La cadena de hash creada por este ejemplo de código es compatible con cualquier función de hash MD5 (en cualquier plataforma) que crea una cadena de hash de 32 caracteres, con formato hexadecimal.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])">
          <source>The object has already been disposed.</source>
          <target state="translated">El objeto ya se ha desechado.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)">
          <source>The input to compute the hash code for.</source>
          <target state="translated">La entrada para la cual se calcula el código hash.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)">
          <source>Computes the hash value for the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">Calcula el valor hash del objeto <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)">
          <source>The computed hash code.</source>
          <target state="translated">Código hash calculado.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)">
          <source>The following example calculates the <ph id="ph1">&lt;xref:System.Security.Cryptography.RIPEMD160&gt;</ph> hash for all files in a directory.</source>
          <target state="translated">En el ejemplo siguiente se calcula el <ph id="ph1">&lt;xref:System.Security.Cryptography.RIPEMD160&gt;</ph> hash para todos los archivos en un directorio.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)">
          <source>The object has already been disposed.</source>
          <target state="translated">El objeto ya se ha desechado.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source>The input to compute the hash code for.</source>
          <target state="translated">La entrada para la cual se calcula el código hash.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source>The offset into the byte array from which to begin using data.</source>
          <target state="translated">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes in the array to use as data.</source>
          <target state="translated">Número de bytes de la matriz que se van a usar como datos.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source>Computes the hash value for the specified region of the specified byte array.</source>
          <target state="translated">Calcula el valor hash para la región especificada de la matriz de bytes indicada.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source>The computed hash code.</source>
          <target state="translated">Código hash calculado.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es un valor no válido.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> length is invalid.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> no es válida.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> está fuera del intervalo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source>This parameter requires a non-negative number.</source>
          <target state="translated">Este parámetro requiere un número no negativo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)">
          <source>The object has already been disposed.</source>
          <target state="translated">El objeto ya se ha desechado.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>Creates an instance of an implementation of a hash algorithm.</source>
          <target state="translated">Crea una instancia de una implementación de un algoritmo hash.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create">
          <source>Creates an instance of the default implementation of a hash algorithm.</source>
          <target state="translated">Crea una instancia de la implementación predeterminada de un algoritmo hash .</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create">
          <source>A new <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph> instance, unless the default settings have been changed using the .</source>
          <target state="translated">Una nueva instancia de <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph>, a menos que la configuración predeterminada se haya cambiado usando .</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Create">
          <source>By default, this overload uses the <ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1CryptoServiceProvider&gt;</ph> implementation of a hash algorithm.</source>
          <target state="translated">De forma predeterminada, esta sobrecarga utiliza el <ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1CryptoServiceProvider&gt;</ph> implementación de un algoritmo hash.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Create">
          <source>If you want to specify a different implementation, use the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.Create%28System.String%29&gt;</ph> overload, which lets you specify an algorithm name, instead.</source>
          <target state="translated">Si desea especificar una implementación diferente, use el <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.Create%28System.String%29&gt;</ph> sobrecarga, que le permite especificar un nombre de algoritmo, en su lugar.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Create">
          <source>The cryptography configuration system defines the default implementation of <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph>.</source>
          <target state="translated">El sistema de configuración de criptografía define la implementación predeterminada de <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source>The hash algorithm implementation to use.</source>
          <target state="translated">La implementación de algoritmo hash a usar.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source>The following table shows the valid values for the <bpt id="p1">&lt;c&gt;</bpt>hashName<ept id="p1">&lt;/c&gt;</ept> parameter and the algorithms they map to.</source>
          <target state="translated">En esta tabla se muestran los valores válidos para el parámetro <bpt id="p1">&lt;c&gt;</bpt>hashName<ept id="p1">&lt;/c&gt;</ept> y los algoritmos a los que se asignan.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Parameter value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor de parámetro</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Implements</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Implementa</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> SHA</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> SHA</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA1</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA1</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.SHA1</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.SHA1</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.HashAlgorithm</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.HashAlgorithm</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> MD5</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA1CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> MD5</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.MD5</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.MD5</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA256</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.MD5CryptoServiceProvider" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA256</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA256Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA-256</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA256Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA-256</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA256Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.SHA256</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA256Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.SHA256</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA256Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA384</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA256Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA384</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA384Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA-384</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA384Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA-384</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA384Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.SHA384</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA384Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.SHA384</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA384Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA512</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA384Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA512</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA512Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA-512</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA512Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> SHA-512</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA512Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.SHA512</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="T:System.Security.Cryptography.SHA512Managed" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> System.Security.Cryptography.SHA512</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source>Creates an instance of the specified implementation of a hash algorithm.</source>
          <target state="translated">Crea una instancia de la implementación especificada de un algoritmo hash.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Create(System.String)">
          <source>A new instance of the specified hash algorithm, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="hashName" /&gt;</ph> is not a valid hash algorithm.</source>
          <target state="translated">Una nueva instancia del algoritmo hash especificado o <ph id="ph1">&lt;see langword="null" /&gt;</ph> si <ph id="ph2">&lt;paramref name="hashName" /&gt;</ph> no es un algoritmo hash válido.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.HashAlgorithm">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> class.</source>
          <target state="translated">Libera todos los recursos usados por la instancia actual de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> class.</source>
          <target state="translated">Libera todos los recursos usados por la instancia actual de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph>.</source>
          <target state="translated">Llame a <ph id="ph1">`Dispose`</ph> cuando haya terminado de usar <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> in an unusable state.</source>
          <target state="translated">El método <ph id="ph1">`Dispose`</ph> deja el <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> en un estado no utilizable.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> was occupying.</source>
          <target state="translated">Después de llamar a <ph id="ph1">`Dispose`</ph>, debe liberar todas las referencias a la <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> para que el recolector de elementos no utilizados pueda reclamar la memoria que el <ph id="ph3">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> estaba ocupando.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> y <bpt id="p2">[</bpt>implementa un método Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph>.</source>
          <target state="translated">Realice siempre una llamada a <ph id="ph1">`Dispose`</ph> antes de liberar la última referencia al objeto <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> del objeto <ph id="ph2">`Finalize`</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para liberar tanto recursos administrados como no administrados; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para liberar únicamente recursos no administrados.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> and optionally releases the managed resources.</source>
          <target state="translated">Libera los recursos no administrados que usa <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> y, de forma opcional, libera los recursos administrados.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Se llama a este método público <ph id="ph1">`Dispose()`</ph> método y <ph id="ph2">`Finalize`</ph> método.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> se invoca el protegido <ph id="ph2">`Dispose(Boolean)`</ph> método con el <ph id="ph3">`disposing`</ph> parámetro establecido en <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source><ph id="ph1">`Finalize`</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> invoca <ph id="ph2">`Dispose`</ph> con <ph id="ph3">`disposing`</ph> establecido en <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> references.</source>
          <target state="translated">Cuando el parámetro <ph id="ph1">`disposing`</ph> es <ph id="ph2">`true`</ph>, este método libera todos los recursos retenidos por los objetos administrados a los que el control <ph id="ph3">&lt;xref:System.Security.Cryptography.HashAlgorithm&gt;</ph> hace referencia.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">Este método invoca al método <ph id="ph1">`Dispose()`</ph> de cada uno de los objetos a los que se hace referencia.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> puede recibir varias llamadas de otros objetos.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated">Al reemplazar <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo implementar <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, consulte <bpt id="p1">[</bpt>implementa un método Dispose<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see langword="Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> y <ph id="ph2">&lt;see langword="Finalize" /&gt;</ph>, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.HashAlgorithm.Hash">
          <source>Gets the value of the computed hash code.</source>
          <target state="translated">Obtiene el valor del código hash calculado.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.Hash">
          <source>The current value of the computed hash code.</source>
          <target state="translated">Valor actual del código hash calculado.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.Hash">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> property is a byte array; the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A&gt;</ph> property is a value that represent bits.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> propiedad es una matriz de bytes; el <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A&gt;</ph> propiedad es un valor que representa los bits.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.Hash">
          <source>Therefore, the number of elements in <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> is one-eighth the size of <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A&gt;</ph>.</source>
          <target state="translated">Por lo tanto, el número de elementos de <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> es una octava parte el tamaño de <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.HashAlgorithm.Hash">
          <source><ph id="ph1">&lt;see cref="F:System.Security.Cryptography.HashAlgorithm.HashValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Security.Cryptography.HashAlgorithm.HashValue" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.HashAlgorithm.Hash">
          <source>The object has already been disposed.</source>
          <target state="translated">El objeto ya se ha desechado.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
          <source>The input to compute the hash code for.</source>
          <target state="translated">La entrada para la cual se calcula el código hash.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
          <source>The offset into the byte array from which to begin using data.</source>
          <target state="translated">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes in the byte array to use as data.</source>
          <target state="translated">Número de bytes de la matriz de bytes que se van a usar como datos.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
          <source>When overridden in a derived class, routes data written to the object into the hash algorithm for computing the hash.</source>
          <target state="translated">Cuando se invalida en una clase derivada, enruta los datos escritos en el objeto al algoritmo hash para el cálculo del valor hash.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
          <source>This method is not called by application code.</source>
          <target state="translated">Código de la aplicación no llama a este método.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
          <source>This abstract method performs the hash computation.</source>
          <target state="translated">Este método abstracto realiza el cálculo de hash.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
          <source>Every write to the cryptographic stream object passes the data through this method.</source>
          <target state="translated">Cada escritura en el objeto de secuencia criptográfico transmite los datos a través de este método.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.HashCore(System.Byte[],System.Int32,System.Int32)">
          <source>For each block of data, this method updates the state of the hash object so a correct hash value is returned at the end of the data stream.</source>
          <target state="translated">Para cada bloque de datos, este método actualiza el estado del objeto hash, por lo que se devuelve un valor de hash correcto al final del flujo de datos.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.HashFinal">
          <source>When overridden in a derived class, finalizes the hash computation after the last data is processed by the cryptographic stream object.</source>
          <target state="translated">Cuando se invalida en una clase derivada, finaliza el cálculo hash una vez que el objeto de secuencia criptográfico termina de procesar los últimos datos.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.HashFinal">
          <source>The computed hash code.</source>
          <target state="translated">Código hash calculado.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.HashFinal">
          <source>This method finalizes any partial computation and returns the correct hash value for the data stream.</source>
          <target state="translated">Este método finaliza cualquier cálculo parcial y devuelve el valor de hash correcto para el flujo de datos.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.HashAlgorithm.HashSize">
          <source>Gets the size, in bits, of the computed hash code.</source>
          <target state="translated">Obtiene el tamaño en bits del código hash calculado.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.HashSize">
          <source>The size, in bits, of the computed hash code.</source>
          <target state="translated">Obtiene el tamaño en bits del código hash calculado.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.HashAlgorithm.HashSizeValue">
          <source>Represents the size, in bits, of the computed hash code.</source>
          <target state="translated">Representa el tamaño en bits del código hash calculado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Security.Cryptography.HashAlgorithm.HashSizeValue">
          <source>The hash algorithm specifies the size of the hash code.</source>
          <target state="translated">El algoritmo hash especifica el tamaño del código hash.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Security.Cryptography.HashAlgorithm.HashSizeValue">
          <source>For example, <ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1&gt;</ph> uses a hash size of 160 bits.</source>
          <target state="translated">Por ejemplo, <ph id="ph1">&lt;xref:System.Security.Cryptography.SHA1&gt;</ph> utiliza un tamaño de hash de 160 bits.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Security.Cryptography.HashAlgorithm.HashSizeValue">
          <source>This field is accessed through the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A&gt;</ph> property.</source>
          <target state="translated">Este campo se tiene acceso a través de la <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.HashSize%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.HashAlgorithm.HashValue">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">Representa el valor del código hash calculado.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Security.Cryptography.HashAlgorithm.HashValue">
          <source>This field is accessed through the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> property.</source>
          <target state="translated">Este campo se tiene acceso a través de la <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.Initialize">
          <source>Initializes an implementation of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph> class.</source>
          <target state="translated">Inicializa la implementación de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HashAlgorithm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.HashAlgorithm.InputBlockSize">
          <source>When overridden in a derived class, gets the input block size.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene el tamaño del bloque de entrada.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.InputBlockSize">
          <source>The input block size.</source>
          <target state="translated">Tamaño del bloque de entrada.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.InputBlockSize">
          <source>Unless overridden, this property returns the value 1.</source>
          <target state="translated">A menos que se reemplaza, esta propiedad devuelve el valor 1.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.HashAlgorithm.OutputBlockSize">
          <source>When overridden in a derived class, gets the output block size.</source>
          <target state="translated">Cuando se invalida en una clase derivada, obtiene el tamaño del bloque de salida.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.OutputBlockSize">
          <source>The output block size.</source>
          <target state="translated">Tamaño del bloque de salida.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.HashAlgorithm.OutputBlockSize">
          <source>Unless overridden, this property returns the value 1.</source>
          <target state="translated">A menos que se reemplaza, esta propiedad devuelve el valor 1.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.HashAlgorithm.State">
          <source>Represents the state of the hash computation.</source>
          <target state="translated">Representa el estado del cálculo del valor hash.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Security.Cryptography.HashAlgorithm.State">
          <source>This field is used to prevent users from changing the key of a keyed hash algorithm during a hash operation.</source>
          <target state="translated">Este campo se usa para impedir que los usuarios cambien la clave de un algoritmo hash con clave durante una operación de hash.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Security.Cryptography.HashAlgorithm.State">
          <source>When a key change is legitimate, the value of this field is zero both before and after a hash operation.</source>
          <target state="translated">Cuando un cambio de clave es legítimo, el valor de este campo es cero antes y después de una operación de hash.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Security.Cryptography.HashAlgorithm.State">
          <source>When a key change is not legitimate, the value of this field is nonzero.</source>
          <target state="translated">Cuando un cambio de clave no es legítimo, el valor de este campo es distinto de cero.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The input to compute the hash code for.</source>
          <target state="translated">La entrada para la cual se calcula el código hash.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The offset into the input byte array from which to begin using data.</source>
          <target state="translated">Desplazamiento en la matriz de bytes de entrada a partir del cual se van a empezar a usar los datos.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of bytes in the input byte array to use as data.</source>
          <target state="translated">Número de bytes de la matriz de bytes de entrada que se van a usar como datos.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A copy of the part of the input array used to compute the hash code.</source>
          <target state="translated">Copia de la parte de la matriz de entrada usada para calcular el código hash.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The offset into the output byte array from which to begin writing data.</source>
          <target state="translated">Desplazamiento en la matriz de bytes de salida a partir del cual se van a empezar a escribir los datos.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Computes the hash value for the specified region of the input byte array and copies the specified region of the input byte array to the specified region of the output byte array.</source>
          <target state="translated">Calcula el valor hash para la región especificada de la matriz de bytes de entrada y copia la región especificada de la matriz de bytes de entrada resultante en la región indicada de la matriz de bytes de salida.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of bytes written.</source>
          <target state="translated">Número de bytes escritos.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> method before calling the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> method.</source>
          <target state="translated">Debe llamar a la <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> método antes de llamar a la <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>You must call both methods before you retrieve the final hash value.</source>
          <target state="translated">Debe llamar a ambos métodos antes de recuperar el último valor hash.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To retrieve the final hash value after calling the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> method, get the byte array contained within the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> property.</source>
          <target state="translated">Para recuperar el último valor hash después de llamar a la <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> método, se obtiene la matriz de bytes incluida en el <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> method with different input and output arrays results in an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph>.</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> método con diferentes de entrada y salida matrices da como resultado un <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following code examples use the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> method to hash a string.</source>
          <target state="translated">Uso de ejemplos de código siguiente el <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> método con el <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> método a una cadena de hash.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="inputCount" /&gt;</ph> uses an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputCount" /&gt;</ph> utiliza un valor no válido.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="inputBuffer" /&gt;</ph> has an invalid length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputBuffer" /&gt;</ph> tiene una longitud no válida.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="inputBuffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputBuffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="inputOffset" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputOffset" /&gt;</ph> está fuera del intervalo.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>This parameter requires a non-negative number.</source>
          <target state="translated">Este parámetro requiere un número no negativo.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The object has already been disposed.</source>
          <target state="translated">El objeto ya se ha desechado.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>The input to compute the hash code for.</source>
          <target state="translated">La entrada para la cual se calcula el código hash.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>The offset into the byte array from which to begin using data.</source>
          <target state="translated">Desplazamiento en la matriz de bytes a partir del cual se empezarán a usar los datos.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes in the byte array to use as data.</source>
          <target state="translated">Número de bytes de la matriz de bytes que se van a usar como datos.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>Computes the hash value for the specified region of the specified byte array.</source>
          <target state="translated">Calcula el valor hash para la región especificada de la matriz de bytes indicada.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>An array that is a copy of the part of the input that is hashed.</source>
          <target state="translated">Una matriz que es una copia de la parte de la entrada a la que se aplica el algoritmo hash.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> method after calling the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> method but before you retrieve the final hash value.</source>
          <target state="translated">Debe llamar a la <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> método después de llamar a la <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> método pero antes de recuperar el último valor hash.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>Note that the return value of this method is not the hash value, but only a copy of the hashed part of the input data.</source>
          <target state="translated">Tenga en cuenta que el valor devuelto de este método no es el valor de hash, pero solo una copia de la parte con hash de los datos de entrada.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>To retrieve the final hashed value after calling the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> method, get the byte array contained in the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> property.</source>
          <target state="translated">Para recuperar el último valor con hash después de llamar a la <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> método, obtenga la matriz de bytes contenida en el <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.Hash%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>The following code examples use the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> method to hash a string.</source>
          <target state="translated">Uso de ejemplos de código siguiente el <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock%2A&gt;</ph> método con el <ph id="ph2">&lt;xref:System.Security.Cryptography.HashAlgorithm.TransformBlock%2A&gt;</ph> método a una cadena de hash.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="inputCount" /&gt;</ph> uses an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputCount" /&gt;</ph> utiliza un valor no válido.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="inputBuffer" /&gt;</ph> has an invalid offset length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputBuffer" /&gt;</ph> tiene una longitud de desplazamiento no válida.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="inputBuffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputBuffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="inputOffset" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputOffset" /&gt;</ph> está fuera del intervalo.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>This parameter requires a non-negative number.</source>
          <target state="translated">Este parámetro requiere un número no negativo.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
          <source>The object has already been disposed.</source>
          <target state="translated">El objeto ya se ha desechado.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>