<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ECDiffieHellman.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5240947e743f897b08d004de6a9deb8c851fcc7e3.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">240947e743f897b08d004de6a9deb8c851fcc7e3</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.ECDiffieHellman">
          <source>Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from.</source>
          <target state="translated">Proporciona una clase base abstracta de la que pueden derivar las implementaciones de algoritmos Diffie-Hellman de curva elíptica (ECDH).</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.ECDiffieHellman">
          <source>This class provides the basic set of operations that all ECDH implementations must support.</source>
          <target state="translated">Esta clase proporciona el conjunto básico de operaciones que todas las implementaciones ECDH deben admitir.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.ECDiffieHellman">
          <source>This class serves as the abstract base class for ECDH implementations.</source>
          <target state="translated">Esta clase actúa como la clase base abstracta para implementaciones ECDH.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.#ctor">
          <source>This constructor is called by classes that derive from the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman&gt;</ph> class.</source>
          <target state="translated">Se llama a este constructor las clases que derivan de la <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellmanCng&gt;</ph> class is the only implementation that is currently included in the <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellmanCng&gt;</ph> clase es la única implementación que está incluida en el <ph id="ph2">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.#ctor">
          <source>For information about how to create a new implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm, see the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman.Create%2A&gt;</ph> method.</source>
          <target state="translated">Para obtener información sobre cómo crear una nueva implementación del algoritmo de Diffie-Hellman de curva elíptica (ECDH), consulte el <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman.Create%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.ECDiffieHellman">
          <source>Creates a new instance of an implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</source>
          <target state="translated">Crea una nueva instancia de una implementación del algoritmo Diffie-Hellman de curva elíptica (ECDH).</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create">
          <source>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</source>
          <target state="translated">Crea una nueva instancia de la implementación predeterminada del algoritmo Diffie-Hellman de curva elíptica (ECDH).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create">
          <source>A new instance of the default implementation of this class.</source>
          <target state="translated">Nueva instancia de la implementación predeterminada de esta clase.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
          <source>The curve to use to generate a new public/private key-pair.</source>
          <target state="translated">La curva que se usará para generar un nuevo par de claves pública-privada.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
          <source>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve.</source>
          <target state="translated">Crea una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH) con un nuevo par de claves pública-privada que se genera sobre la curva especificada.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
          <source>A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</source>
          <target state="translated">Una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
          <source>curve must validate (that is, it must return true when passed to the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">debe validar la curva (es decir, debe devolver true cuando se pasan a la <ph id="ph1">&lt;xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
          <source>Characteristic-2 curves are not supported on Windows.</source>
          <target state="translated">Curvas de característica-2 no se admiten en Windows.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)">
          <source><ph id="ph1">&lt;paramref name="curve" /&gt;</ph> does not validate.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="curve" /&gt;</ph> no se valida.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
          <source>The parameters  for the elliptic curve cryptography (ECC) algorithm.</source>
          <target state="translated">Parámetros del algoritmo de criptografía de curva elíptica (ECC).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
          <source>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECParameters" /&gt;</ph> object.</source>
          <target state="translated">Crea una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH) con la clave que describe el objeto <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECParameters" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
          <source>A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</source>
          <target state="translated">Una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
          <source><ph id="ph1">`parameters`</ph> must validate (that is, it must return <ph id="ph2">`true`</ph>) when passed to the <ph id="ph3">&lt;xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`parameters`</ph> debe validar (es decir, debe devolver <ph id="ph2">`true`</ph>) cuando se pasan a la <ph id="ph3">&lt;xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
          <source>Parameters over implicit curves are not supported.</source>
          <target state="translated">No se admiten parámetros en curvas implícita.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
          <source>Characteristic-2 curves are not supported on Windows.</source>
          <target state="translated">Curvas de característica-2 no se admiten en Windows.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)">
          <source><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> does not validate.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> no se valida.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>The name of an implementation of the ECDH algorithm.</source>
          <target state="translated">Nombre de una implementación del algoritmo ECDH.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</source>
          <target state="translated">Crea una nueva instancia de la implementación especificada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>A new instance of the specified implementation of this class.</source>
          <target state="translated">Nueva instancia de la implementación especificada de esta clase.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>If the specified algorithm name does not map to an ECDH implementation, this method returns <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si el nombre del algoritmo especificado no se asigna a una implementación ECDH, este método devuelve <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>If you develop your own implementation of an <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman&gt;</ph> object, you can use the <ph id="ph2">&lt;xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29&gt;</ph> method overload to create a custom <ph id="ph3">`algorithm`</ph> string that specifies your implementation.</source>
          <target state="translated">Si desarrolla su propia implementación de un <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman&gt;</ph> objeto, puede usar el <ph id="ph2">&lt;xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29&gt;</ph> sobrecarga del método para crear un personalizado <ph id="ph3">`algorithm`</ph> cadena que especifica la implementación.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>The <ph id="ph1">`algorithm`</ph> parameter specifies the name of an implementation of the ECDH algorithm.</source>
          <target state="translated">El <ph id="ph1">`algorithm`</ph> parámetro especifica el nombre de una implementación del algoritmo ECDH.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>The following strings all refer to the same implementation, which is the only implementation currently supported in the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>:</source>
          <target state="translated">Las cadenas siguientes hacen todas referencia a la misma implementación, que es la única implementación actualmente admitida en <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>"ECDH"</source>
          <target state="translated">"ECDH"</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>"ECDiffieHellman"</source>
          <target state="translated">"ECDiffieHellman"</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>"ECDiffieHellmanCng"</source>
          <target state="translated">"ECDiffieHellmanCng"</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>"System.Security.Cryptography.ECDiffieHellmanCng"</source>
          <target state="translated">"System.Security.Cryptography.ECDiffieHellmanCng"</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>You can also provide the name of a custom ECDH implementation for the <ph id="ph1">`algorithm`</ph> parameter.</source>
          <target state="translated">También puede proporcionar el nombre de una implementación ECDH personalizada para el <ph id="ph1">`algorithm`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>If you do that, the <ph id="ph1">&lt;xref:System.Security.Cryptography.CryptoConfig&gt;</ph> object will use it to determine whether an ECDH object can be created.</source>
          <target state="translated">Si lo hace, la <ph id="ph1">&lt;xref:System.Security.Cryptography.CryptoConfig&gt;</ph> objeto utiliza para determinar si se puede crear un objeto ECDH.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="algorithm" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="algorithm" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.ECDiffieHellman">
          <source>Derives bytes that can be used as a key using a hash function .</source>
          <target state="translated">Deriva bytes que se pueden usar como una clave mediante una función hash.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
          <source>The other party's public key.</source>
          <target state="translated">Clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
          <source>The hash algorithm  to use to derive the key material.</source>
          <target state="translated">Algoritmo hash que se va a usar para derivar el material de clave.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
          <source>Derives bytes that can be used as a key using a hash function, given another party's public key and hash algorithm's name.</source>
          <target state="translated">Deriva bytes que se pueden usar como una clave mediante una función hash, dada la clave pública de otra parte y el nombre del algoritmo hash.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
          <source>The key material from the key exchange with the other party’s public key.</source>
          <target state="translated">Material de clave del intercambio de claves con la clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)">
          <source>This overload calls the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A&gt;</ph> method passing <ph id="ph2">`null`</ph> as the prepend and append values.</source>
          <target state="translated">Esta sobrecarga llama a la <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A&gt;</ph> método pasando <ph id="ph2">`null`</ph> como el prepend y anexar valores.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
          <source>The other party's public key.</source>
          <target state="translated">Clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
          <source>The hash algorithm  to use to derive the key material.</source>
          <target state="translated">Algoritmo hash que se va a usar para derivar el material de clave.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
          <source>A value to prepend to the derived secret before hashing.</source>
          <target state="translated">Valor para anteponer al secreto derivado antes de la operación hash.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
          <source>A value to append to the derived secret before hashing.</source>
          <target state="translated">Valor para anexar al secreto derivado antes de la operación hash.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
          <source>When implemented in a derived class, derives bytes that can be used as a key using a hash function, given another party's public key, hash algorithm's name, a prepend value and an append value.</source>
          <target state="translated">Cuando se implementa en una clase derivada, deriva bytes que se pueden usar como una clave mediante una función hash, dada la clave pública de otra parte, el nombre del algoritmo hash, un valor Prepend y un valor Append.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
          <source>The key material from the key exchange with the other party’s public key.</source>
          <target state="translated">Material de clave del intercambio de claves con la clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])">
          <source>A derived class must override this method.</source>
          <target state="translated">Una clase derivada debe reemplazar este método.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.ECDiffieHellman">
          <source>Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</source>
          <target state="translated">Deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The other party's public key.</source>
          <target state="translated">Clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The hash algorithm to use to derive the key material.</source>
          <target state="translated">Algoritmo hash que se va a usar para derivar el material de clave.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The key for the HMAC.</source>
          <target state="translated">Clave para HMAC.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</source>
          <target state="translated">Deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The key material from the key exchange with the other party’s public key.</source>
          <target state="translated">Material de clave del intercambio de claves con la clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>This overload calls the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A&gt;</ph> method passing <ph id="ph2">`null`</ph> as the prepend and append values.</source>
          <target state="translated">Esta sobrecarga llama a la <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A&gt;</ph> método pasando <ph id="ph2">`null`</ph> como el prepend y anexar valores.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
          <source>The other party's public key.</source>
          <target state="translated">Clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
          <source>The hash algorithm to use to derive the key material.</source>
          <target state="translated">Algoritmo hash que se va a usar para derivar el material de clave.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
          <source>The key for the HMAC.</source>
          <target state="translated">Clave para HMAC.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
          <source>A value to prepend to the derived secret before hashing.</source>
          <target state="translated">Valor para anteponer al secreto derivado antes de la operación hash.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
          <source>A value to append to the derived secret before hashing.</source>
          <target state="translated">Valor para anexar al secreto derivado antes de la operación hash.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
          <source>When implemented in a derived class, derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</source>
          <target state="translated">Cuando se implementa en un clase derivada, deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
          <source>The key material from the key exchange with the other party’s public key.</source>
          <target state="translated">Material de clave del intercambio de claves con la clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])">
          <source>A derived class must override this method.</source>
          <target state="translated">Una clase derivada debe reemplazar este método.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)">
          <source>The other party's public key.</source>
          <target state="translated">Clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)">
          <source>Derives bytes that can be used as a key, given another party's public key.</source>
          <target state="translated">Deriva bytes que se pueden utilizar como clave, si hay una clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)">
          <source>The key material from the key exchange with the other party’s public key.</source>
          <target state="translated">Material de clave del intercambio de claves con la clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)">
          <source>For more information about public keys, see the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellmanPublicKey&gt;</ph> class.</source>
          <target state="translated">Para obtener más información acerca de las claves públicas, consulte el <ph id="ph1">&lt;xref:System.Security.Cryptography.ECDiffieHellmanPublicKey&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
          <source>The other party's public key.</source>
          <target state="translated">Clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
          <source>The ASCII-encoded PRF label.</source>
          <target state="translated">Etiqueta PRF con codificación ASCII.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
          <source>The 64-byte PRF seed.</source>
          <target state="translated">Valor de inicialización de PRF de 64 bytes.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
          <source>When implemented in a derived class, derives bytes that can be used as a key using a Transport Layer Security (TLS) Pseudo-Random Function (PRF) derivation algorithm.</source>
          <target state="translated">Cuando se implementa en una clase derivada, deriva bytes que se pueden usar como una clave mediante un algoritmo de derivación de la función pesudoaleatoria (PRF) de seguridad de capa de transporte (TLS).</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
          <source>The key material from the key exchange with the other party’s public key.</source>
          <target state="translated">Material de clave del intercambio de claves con la clave pública de la otra parte.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])">
          <source>A derived class must override this method.</source>
          <target state="translated">Una clase derivada debe reemplazar este método.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include private parameters; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se van a incluir parámetros privados; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)">
          <source>When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph> key to an <ph id="ph2">&lt;see cref="T:System.Security.Cryptography.ECParameters" /&gt;</ph> structure so that it can be passed to the <ph id="ph3">&lt;see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /&gt;</ph> method.</source>
          <target state="translated">Si se reemplaza en una clase derivada, exporta la información de clave pública o la información de clave pública y privada con el formulario de curva explícito desde una clave <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph> de trabajo a una estructura <ph id="ph2">&lt;see cref="T:System.Security.Cryptography.ECParameters" /&gt;</ph> de modo que pueda pasarse al método <ph id="ph3">&lt;see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)">
          <source>An object that represents the point on the curve for this key, using the explicit curve format.</source>
          <target state="translated">Un objeto que representa el punto de la curva para esta clave, con el formato de curva explícito.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)">
          <source>A derived class must override this method.</source>
          <target state="translated">Una clase derivada debe reemplazar este método.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to include private parameters; otehrwise,  <ph id="ph2">&lt;see langword="false" /&gt;</ph> to include public parameters only.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para incluir parámetros privados; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph> para incluir solo parámetros públicos.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
          <source>When overridden in a derived class, exports either the public or the public and private key information from a working <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph> key to an <ph id="ph2">&lt;see cref="T:System.Security.Cryptography.ECParameters" /&gt;</ph> structure so that it can be passed to the <ph id="ph3">&lt;see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /&gt;</ph> method.</source>
          <target state="translated">Si se reemplaza en una clase derivada, exporta la información de clave pública o la información de clave pública y privada desde una clave <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph> de trabajo a una estructura <ph id="ph2">&lt;see cref="T:System.Security.Cryptography.ECParameters" /&gt;</ph> de modo que pueda pasarse al método <ph id="ph3">&lt;see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
          <source>An object that represents the point on the curve for this key.</source>
          <target state="translated">Un objeto que representa el punto de la curva para esta clave.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
          <source>It can be passed to the <ph id="ph1">&lt;see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /&gt;</ph> method.</source>
          <target state="translated">Puede pasarse al método <ph id="ph1">&lt;see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
          <source>If the curve has a name, the <ph id="ph1">&lt;xref:System.Security.Cryptography.ECParameters.Curve&gt;</ph> property contains named curve parameters; otherwise, it will contain explicit parameters.</source>
          <target state="translated">Si la curva tiene un nombre, el <ph id="ph1">&lt;xref:System.Security.Cryptography.ECParameters.Curve&gt;</ph> propiedad contiene los parámetros con nombre curva; en caso contrario, contiene parámetros explícitos.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)">
          <source>A derived class must override this method.</source>
          <target state="translated">Una clase derivada debe reemplazar este método.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
          <source>The curve used to generate an ephemeral public/private key pair.</source>
          <target state="translated">La curva usada para generar un par de claves pública-privada efímeras.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
          <source>When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve.</source>
          <target state="translated">Si se reemplaza en una clase derivada, genera un nuevo par de claves pública-privada efímeras para la curva especificada.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
          <source><ph id="ph1">`curve`</ph> must validate (that is, it must return <ph id="ph2">`true`</ph>) when passed to the <ph id="ph3">&lt;xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType&gt;</ph> method) and must not be implicit.</source>
          <target state="translated"><ph id="ph1">`curve`</ph> debe validar (es decir, debe devolver <ph id="ph2">`true`</ph>) cuando se pasan a la <ph id="ph3">&lt;xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType&gt;</ph> método) y no debe ser implícita.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
          <source>Characteristic-2 curves are not supported on Windows.</source>
          <target state="translated">Curvas de característica-2 no se admiten en Windows.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
          <source><ph id="ph1">&lt;paramref name="curve" /&gt;</ph> does not validate.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="curve" /&gt;</ph> no se valida.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)">
          <source>A derived class must override this method.</source>
          <target state="translated">Una clase derivada debe reemplazar este método.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
          <source>The curve's parameters to import.</source>
          <target state="translated">Los parámetros de la curva que se importarán.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
          <source>When overridden in a derived class, imports the specified parameters for an <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECCurve" /&gt;</ph> as an ephemeral key into the current <ph id="ph2">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph> object.</source>
          <target state="translated">Si se reemplaza en una clase derivada, importa los parámetros especificados para un objeto <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECCurve" /&gt;</ph> como clave efímera en el objeto <ph id="ph2">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
          <source><ph id="ph1">`parameters`</ph> must validate (that is, it must return <ph id="ph2">`true`</ph>) when passed to the <ph id="ph3">&lt;xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`parameters`</ph> debe validar (es decir, debe devolver <ph id="ph2">`true`</ph>) cuando se pasan a la <ph id="ph3">&lt;xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
          <source>Parameters over implicit curves are not supported.</source>
          <target state="translated">No se admiten parámetros en curvas implícita.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
          <source>Characteristic-2 curves are not supported on Windows.</source>
          <target state="translated">Curvas de característica-2 no se admiten en Windows.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
          <source><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> does not validate.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> no se valida.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)">
          <source>A derived class must override this method.</source>
          <target state="translated">Una clase derivada debe reemplazar este método.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm">
          <source>Gets the name of the key exchange algorithm.</source>
          <target state="translated">Obtiene el nombre del algoritmo de intercambio de claves.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm">
          <source>The name of the key exchange algorithm.</source>
          <target state="translated">Nombre del algoritmo de intercambio de claves.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm">
          <source>The default (non-overridden) implementation of this property returns the string "ECDiffieHellman".</source>
          <target state="translated">La implementación de predeterminada (no invalidada) de esta propiedad devuelve la cadena "ECDiffieHellman".</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm">
          <source>This property is inherited from the <ph id="ph1">&lt;xref:System.Security.Cryptography.AsymmetricAlgorithm&gt;</ph> base class.</source>
          <target state="translated">Esta propiedad se hereda de la <ph id="ph1">&lt;xref:System.Security.Cryptography.AsymmetricAlgorithm&gt;</ph> clase base.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.ECDiffieHellman.PublicKey">
          <source>Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</source>
          <target state="translated">Obtiene la clave pública que utiliza la instancia Diffie-Hellman de curva elíptica (ECDH) actual.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.ECDiffieHellman.PublicKey">
          <source>The public part of the ECDH key pair that is being used by this <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph> instance.</source>
          <target state="translated">Parte pública del par de claves ECDH utilizada por esta instancia <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.ECDiffieHellman" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
          <source>Gets the name of the signature algorithm.</source>
          <target state="translated">Obtiene el nombre del algoritmo de firma.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Siempre es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
          <source>This property is inherited from the <ph id="ph1">&lt;xref:System.Security.Cryptography.AsymmetricAlgorithm&gt;</ph> base class.</source>
          <target state="translated">Esta propiedad se hereda de la <ph id="ph1">&lt;xref:System.Security.Cryptography.AsymmetricAlgorithm&gt;</ph> clase base.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
          <source>The Elliptic Curve Diffie-Hellman (ECDH) algorithm is used for key derivation, not digital signature generation.</source>
          <target state="translated">El algoritmo de Diffie-Hellman de curva elíptica (ECDH) se utiliza para la derivación de claves, la generación de firmas digitales no.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm">
          <source>Therefore, this property returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Por lo tanto, esta propiedad devuelve <ph id="ph1">`null`</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>