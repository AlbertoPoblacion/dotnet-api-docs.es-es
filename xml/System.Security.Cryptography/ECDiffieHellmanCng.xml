<Type Name="ECDiffieHellmanCng" FullName="System.Security.Cryptography.ECDiffieHellmanCng">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="286bf918255ea8d29ba319f459e569551d533740" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500959" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ECDiffieHellmanCng : System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ECDiffieHellmanCng extends System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellmanCng" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ECDiffieHellmanCng&#xA;Inherits ECDiffieHellman" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellmanCng sealed : System::Security::Cryptography::ECDiffieHellman" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.ECDiffieHellman</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una implementación CNG (Cryptography Next Generation) del algoritmo Diffie-Hellman de curva elíptica (ECDH). Esta clase se utiliza para realizar operaciones criptográficas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Security.Cryptography.ECDiffieHellmanCng> clase permite a dos partes intercambiar el material de clave privada aunque se comunican a través de un canal público.  Ambas partes pueden calcular el mismo valor de secreto, que se conoce como el *acuerdo confidencial* en las clases administradas de Diffie-Hellman. El acuerdo confidencial, a continuación, se utiliza para una variedad de fines, incluidos como una clave simétrica. Sin embargo, en lugar de exponer el acuerdo confidencial directamente, la <xref:System.Security.Cryptography.ECDiffieHellmanCng> clase realiza algún procesamiento posterior en el acuerdo antes de proporcionar el valor. Este procesamiento posterior se conoce como el *clave de la función de derivación (KDF)*; puede seleccionar qué KDF que desea usar y establecer sus parámetros a través de un conjunto de propiedades en la instancia del objeto de Diffie-Hellman.  
  
|Función de derivación de claves|Propiedades|  
|-----------------------------|----------------|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm%2A> -El algoritmo hash que se usa para procesar el acuerdo confidencial.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A> -Una matriz de bytes opcional para anteponer al acuerdo secreto antes de usar un valor hash.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> -Una matriz de bytes opcional que se anexará al acuerdo secreto antes de usar un valor hash.|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm%2A> -El algoritmo hash que se usa para procesar el acuerdo confidencial.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A>-Una matriz de bytes opcional para anteponer al acuerdo secreto antes de usar un valor hash.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> -Una matriz de bytes opcional que se anexará al acuerdo secreto antes de usar un valor hash.|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.Label%2A> -La etiqueta de derivación de claves.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.Seed%2A> -El valor de inicialización de derivación de claves.|  
  
 El resultado de pasar el acuerdo confidencial a través de la función de derivación de claves es una matriz de bytes que puede utilizarse como material de clave para la aplicación. El número de bytes del material de clave generado es dependiente de la función de derivación de claves; Por ejemplo, SHA-256 generará 256 bits de material de clave, mientras que SHA-512 generará 512 bits de material de clave. El flujo básico de un intercambio de claves de ECDH es como sigue:  
  
1.  Alice y Bob crean un par de claves que se utilizará para la operación de intercambio de claves Diffie-Hellman  
  
2.  Alice y Bob configura KDF utilizando parámetros la están de acuerdo en.  
  
3.  Alicia envía a Roberto su clave pública.  
  
4.  Roberto envía su clave pública de Alicia.  
  
5.  Alice y Bob utilice de todas las demás claves públicas para generar el acuerdo confidencial y aplique KDF para el acuerdo confidencial para generar material de clave.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar la <xref:System.Security.Cryptography.ECDiffieHellmanCng> clase para establecer un intercambio de claves y cómo usar dicha clave para cifrar un mensaje que puede ser enviado a través de un canal público que y descifrado por el receptor.  
  
 [!code-csharp[ECDiffieHellmanCng#1](~/samples/snippets/csharp/VS_Snippets_CLR/ecdiffiehellmancng/cs/program.cs#1)]
 [!code-vb[ECDiffieHellmanCng#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ecdiffiehellmancng/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> con un par de claves aleatorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El par de claves aleatorio tiene una longitud de clave pública predeterminada de 521 bits.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (int keySize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 keySize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keySize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(int keySize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keySize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keySize">Tamaño de la clave. Los tamaños de clave válidos son 256, 384 y 521 bits.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> con un par de claves aleatorio usando el tamaño de clave especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El par de claves aleatorio tendrá la longitud de clave pública definida por el `keySize` parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySize" /> especifica una longitud no válida.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Las clases de Cryptography Next Generation (CNG) no se admiten en este sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (System.Security.Cryptography.CngKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.CngKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As CngKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(System::Security::Cryptography::CngKey ^ key);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="key" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="key">La clave que se usará como entrada para las operaciones criptográficas llevadas a cabo por el objeto actual.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> mediante el objeto <see cref="T:System.Security.Cryptography.CngKey" /> especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> no especifica un grupo de algoritmos Diffie-Hellman de curva elíptica (ECDH).</exception>
        <exception cref="T:System.PlatformNotSupportedException">Las clases de Cryptography Next Generation (CNG) no se admiten en este sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(System::Security::Cryptography::ECCurve curve);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">La curva usada para generar el par de claves pública-privada.</param>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> cuyo par de claves pública-privada se genera sobre la curva especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `curve` debe validar (es decir, debe devolver `true`) cuando se pasan a la <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> método y debe ser un bloqueo explícito o con nombre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="curve" /> no se valida.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deriva bytes que se pueden usar como una clave mediante una función hash.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
        <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar el material de clave.</param>
        <param name="secretPrepend">Valor para anteponer al secreto derivado antes de la operación hash.</param>
        <param name="secretAppend">Valor para anexar al secreto derivado antes de la operación hash.</param>
        <summary>Deriva bytes que se pueden usar como una clave mediante una función hash, dada la clave pública de otra parte, el nombre del algoritmo hash, un valor Prepend y un valor Append.</summary>
        <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de `secretPrepend` o `secretAppend` es `null`, se tratan como matrices vacías.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> no es una clave ECDH o no tiene el tamaño correcto.  
  
 O bien  
  
 <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Todos los demás errores.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="hmacKey" Type="System.Byte[]" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
        <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar el material de clave.</param>
        <param name="hmacKey">Clave para HMAC.</param>
        <param name="secretPrepend">Valor para anteponer al secreto derivado antes de la operación hash.</param>
        <param name="secretAppend">Valor para anexar al secreto derivado antes de la operación hash.</param>
        <summary>Deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</summary>
        <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de `secretPrepend` o `secretAppend` es `null`, se tratan como matrices vacías. Si el valor de `hmacKey` es `null`, el resultado del algoritmo de Diffie-Hellman de curva elíptica (ECDH) que se utilizará como clave HMAC.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> no es una clave ECDH o no tiene el tamaño correcto.  
  
 O bien  
  
 <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Todos los demás errores.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyMaterial">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deriva el material de clave que se genera del acuerdo confidencial entre dos partes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El algoritmo de Diffie-Hellman de curva elíptica (ECDH) acepta la clave privada y clave pública de la otra parte como entrada y genera el acuerdo confidencial como salida. La función de derivación de claves (KDF), a continuación, toma el acuerdo confidencial y genera el material de clave como salida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyMaterial (System.Security.Cryptography.CngKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.CngKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyMaterial (otherPartyPublicKey As CngKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::CngKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Objeto que contiene la parte pública de la clave Diffie-Hellman de curva elíptica (ECDH) de la otra parte en el intercambio de claves.</param>
        <summary>Deriva el material de clave que se genera del acuerdo confidencial entre dos partes, según un objeto <see cref="T:System.Security.Cryptography.CngKey" /> que contiene la clave pública de la segunda parte.</summary>
        <returns>Matriz de bytes que contiene el material de clave. Esta información se genera a partir del acuerdo confidencial que se calcula de la clave privada del objeto actual y de la clave pública especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> no es válido. Su propiedad <see cref="P:System.Security.Cryptography.CngKey.AlgorithmGroup" /> no especifica <see cref="P:System.Security.Cryptography.CngAlgorithmGroup.ECDiffieHellman" /> o su tamaño de clave no coincide con el tamaño de clave de esta instancia.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction" /> de este objeto especifica la función de derivación de claves <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />, pero <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" /> o <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Todos los demás errores.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Clave pública de la otra parte en el intercambio de claves.</param>
        <summary>Deriva el material de clave que se genera del acuerdo confidencial entre dos partes, según un objeto <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> que contiene la clave pública de la segunda parte.</summary>
        <returns>Matriz de bytes que contiene el material de clave. Esta información se genera a partir del acuerdo confidencial que se calcula de la clave privada del objeto actual y de la clave pública especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> no es una clave <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="prfLabel" Type="System.Byte[]" />
        <Parameter Name="prfSeed" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Clave pública de la otra parte.</param>
        <param name="prfLabel">Etiqueta PRF con codificación ASCII.</param>
        <param name="prfSeed">Valor de inicialización de PRF de 64 bytes.</param>
        <summary>Deriva bytes que se pueden usar como una clave mediante un algoritmo de derivación de la función pesudoaleatoria (PRF) de seguridad de capa de transporte (TLS).</summary>
        <returns>Material de clave del intercambio de claves con la clave pública de la otra parte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="prfLabel" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="prfSeed" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> no es una clave ECDH o no tiene el tamaño correcto.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="prfSeed" /> no es exactamente 64 bytes de longitud.  
  
 O bien  
  
 Todos los demás errores criptográficos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveSecretAgreementHandle">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un identificador para el acuerdo confidencial generado entre dos partes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle%2A> sobrecargas del método son para usuarios avanzados que necesitan un identificador para el acuerdo confidencial original en lugar del material de clave. El identificador del acuerdo confidencial se puede utilizar en la plataforma llamadas de invocación a realizar cualquier trabajo que no se ajusta mediante la <xref:System.Security.Cryptography.ECDiffieHellmanCng> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveSecretAgreementHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle (System.Security.Cryptography.CngKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle(class System.Security.Cryptography.CngKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveSecretAgreementHandle (otherPartyPublicKey As CngKey) As SafeNCryptSecretHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::SafeHandles::SafeNCryptSecretHandle ^ DeriveSecretAgreementHandle(System::Security::Cryptography::CngKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Objeto que contiene la parte pública de la clave Diffie-Hellman de curva elíptica (ECDH) de la otra parte en el intercambio de claves.</param>
        <summary>Obtiene un identificador para el acuerdo confidencial generado entre dos partes, según un objeto <see cref="T:System.Security.Cryptography.CngKey" /> que contiene la clave pública de la segunda parte.</summary>
        <returns>Identificador del acuerdo confidencial. Esta información se calcula a partir de la clave privada del objeto actual y la clave pública especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> no es una clave ECDH o no tiene el tamaño correcto.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Todos los demás errores.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener permiso llamar a código no administrado. Valor de la petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeriveSecretAgreementHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveSecretAgreementHandle (otherPartyPublicKey As ECDiffieHellmanPublicKey) As SafeNCryptSecretHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::SafeHandles::SafeNCryptSecretHandle ^ DeriveSecretAgreementHandle(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Clave pública de la otra parte en el intercambio de claves.</param>
        <summary>Obtiene un identificador para el acuerdo confidencial generado entre dos partes, según un objeto <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> que contiene la clave pública de la segunda parte.</summary>
        <returns>Identificador del acuerdo confidencial. Esta información se calcula a partir de la clave privada del objeto actual y la clave pública especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> no es una clave <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
        <summary>Exporta la clave y parámetros de curva explícitos que usa el objeto <see cref="T:System.Security.Cryptography.ECCurve" /> en un objeto <see cref="T:System.Security.Cryptography.ECParameters" />.</summary>
        <returns>La clave y parámetros de curva explícitos que usa el objeto <see cref="T:System.Security.Cryptography.ECCurve" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El método no puede obtener valores de curva.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Esta plataforma no admite la exportación explícita. Se requiere Windows 10, o bien versiones posteriores.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
        <summary>Exporta la clave que usa el objeto <see cref="T:System.Security.Cryptography.ECCurve" /> en un objeto <see cref="T:System.Security.Cryptography.ECParameters" />.</summary>
        <returns>La clave y parámetros de curva con nombre que usa el objeto <see cref="T:System.Security.Cryptography.ECCurve" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave se creó como una curva con nombre, la <xref:System.Security.Cryptography.ECParameters.Curve?displayProperty=nameWithType> campo contiene parámetros con nombre curva;          en caso contrario, contiene parámetros explícitos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El método no puede obtener valores de curva.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromXmlString">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deserializa la información de clave de una cadena XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlString">Información de clave basada en XML que se va a deserializar.</param>
        <summary>Este método no se implementa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para deserializar una clave XML, utilice el <xref:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString%28System.String%2CSystem.Security.Cryptography.ECKeyXmlFormat%29> sobrecarga en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Este método no se ha invalidado para esta instancia.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public void FromXmlString (string xml, System.Security.Cryptography.ECKeyXmlFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FromXmlString(string xml, valuetype System.Security.Cryptography.ECKeyXmlFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString(System.String,System.Security.Cryptography.ECKeyXmlFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXmlString (xml As String, format As ECKeyXmlFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FromXmlString(System::String ^ xml, System::Security::Cryptography::ECKeyXmlFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
        <Parameter Name="format" Type="System.Security.Cryptography.ECKeyXmlFormat" />
      </Parameters>
      <Docs>
        <param name="xml">Información de clave basada en XML que se va a deserializar.</param>
        <param name="format">Uno de los valores de la enumeración que especifica el formato de la cadena XML. El único formato actualmente aceptado es <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
        <summary>Deserializa la información de clave de una cadena XML mediante el formato especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xml" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="xml" /> es incorrecto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="format" /> especifica un formato no válido. El único valor aceptado es <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Todos los demás errores.</exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public override void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">La curva usada para generar un par de claves pública-privada efímeras.</param>
        <summary>Genera un nuevo par de claves pública-privada efímeras para la curva especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `curve` debe validar (es decir, debe devolver true cuando se pasan a la <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> método) y no debe ser implícita.  
  
 Curvas de característica-2 no se admiten en Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="curve" /> no se valida.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CngAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CngAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As CngAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CngAlgorithm ^ HashAlgorithm { System::Security::Cryptography::CngAlgorithm ^ get(); void set(System::Security::Cryptography::CngAlgorithm ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el algoritmo hash que se utiliza al generar el material de clave.</summary>
        <value>Objeto que especifica el algoritmo hash.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad la usan solo si de objetos de Cryptography Next Generation (CNG) la <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash> o <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> valor se establece en el <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> propiedad.  
  
 Esta propiedad acepta los siguientes algoritmos: <xref:System.Security.Cryptography.CngAlgorithm.MD5%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha1%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha256%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha384%2A>, y <xref:System.Security.Cryptography.CngAlgorithm.Sha512%2A>.  
  
 También pueden utilizarse otros algoritmos hash personalizados.  
  
 El algoritmo predeterminado es <xref:System.Security.Cryptography.CngAlgorithm.Sha256%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor es <see langword="null." /></exception>
      </Docs>
    </Member>
    <Member MemberName="HmacKey">
      <MemberSignature Language="C#" Value="public byte[] HmacKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] HmacKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.HmacKey" />
      <MemberSignature Language="VB.NET" Value="Public Property HmacKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ HmacKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la clave del código de autenticación de mensajes basado en hash (HMAC) que se utiliza para derivar el material de clave.</summary>
        <value>La clave del código de autenticación de mensajes basado en hash (HMAC) que se utiliza para derivar el material de clave.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad solo aplica cuando la <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> valor se establece en el <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> propiedad y el <xref:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey%2A> propiedad es `false`. De forma predeterminada, el valor es `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public override void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Los parámetros de la curva que se importarán.</param>
        <summary>Importa los parámetros especificados para un objeto <see cref="T:System.Security.Cryptography.ECCurve" /> como una clave en la instancia actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.Cryptography.ECDiffieHellmanCng.ImportParameters%2A> método reemplaza la clave existente con la que este objeto funciona mediante la creación de un nuevo <xref:System.Security.Cryptography.CngKey> objeto. Si `parameters` contiene solo el <xref:System.Security.Cryptography.ECParameters.Q> campo, a continuación, se importa solo una clave pública.         Si `parameters` también contiene <xref:System.Security.Cryptography.ECParameters.D>, a continuación, un par de claves completo se importarán. El `parameter` <xref:System.Security.Cryptography.ECParameters.Curve> valor especifica el tipo de la curva para importar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="parameters" /> no se valida.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="parameters" /> hace referencia a una curva que no se puede importar.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <paramref name="parameters" /> hace referencia a una curva que esta plataforma no admite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Key">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CngKey Key { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CngKey Key" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Key" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Key As CngKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CngKey ^ Key { System::Security::Cryptography::CngKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica la <see cref="T:System.Security.Cryptography.CngKey" /> utilizada por el objeto actual para operaciones criptográficas.</summary>
        <value>Par de claves utilizado por este objeto para realizar operaciones criptográficas.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDerivationFunction">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyDerivationFunction As ECDiffieHellmanKeyDerivationFunction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction get(); void set(System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la función de derivación de claves para la clase <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />.</summary>
        <value>Uno de los valores de la enumeración <see cref="T:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction" />: <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />, <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" /> o <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />. El valor predeterminado es <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad especifica la función de derivación de claves que se utiliza para transformar el acuerdo confidencial en material de clave.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de la enumeración está fuera del intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public byte[] Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Label" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Label { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de la etiqueta que se utiliza para la derivación de claves.</summary>
        <value>Valor de la etiqueta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se utiliza para la derivación de claves si la <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls> valor se establece en el <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> propiedad. De forma predeterminada, es `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la clave pública que puede utilizar otro objeto <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> para generar un acuerdo confidencial compartido.</summary>
        <value>Clave pública que está asociada a esta instancia del objeto <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecretAppend">
      <MemberSignature Language="C#" Value="public byte[] SecretAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SecretAppend" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property SecretAppend As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SecretAppend { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que se anexará al acuerdo confidencial al generar el material de clave.</summary>
        <value>Valor que se anexa al acuerdo confidencial.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se utiliza para la derivación de claves si la <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash> o <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> se utiliza la función de derivación de claves (KDF). El valor se anexa al acuerdo confidencial y el valor combinado se pasa a KDF para generar el material de clave. De forma predeterminada, el valor es `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecretPrepend">
      <MemberSignature Language="C#" Value="public byte[] SecretPrepend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SecretPrepend" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend" />
      <MemberSignature Language="VB.NET" Value="Public Property SecretPrepend As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SecretPrepend { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que se agregará al principio del acuerdo confidencial cuando se deriva el material de clave.</summary>
        <value>Valor que se anexa al principio del acuerdo confidencial durante la derivación de claves.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se utiliza para la derivación de claves si la <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> propiedad se establece en uno de los siguientes valores:  
  
-   <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash>  
  
-   <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>  
  
 El valor se antepone al acuerdo confidencial y el valor combinado se pasa a la función de derivación de claves (KDF) para generar el material de clave. De forma predeterminada, el valor es `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seed">
      <MemberSignature Language="C#" Value="public byte[] Seed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Seed" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" />
      <MemberSignature Language="VB.NET" Value="Public Property Seed As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Seed { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de inicialización que se utilizará cuando se deriva el material de clave.</summary>
        <value>El valor de inicialización.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se utiliza para la derivación de claves si la <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> propiedad está establecida en <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls>. De forma predeterminada, el valor es `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToXmlString">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serializa la información de clave en una cadena XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</param>
        <summary>Este método no se implementa.</summary>
        <returns>No es aplicable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para convertir la clave actual en una representación XML, utilice el <xref:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString%28System.Security.Cryptography.ECKeyXmlFormat%29> sobrecarga en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Este método no se ha invalidado para esta instancia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public string ToXmlString (System.Security.Cryptography.ECKeyXmlFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToXmlString(valuetype System.Security.Cryptography.ECKeyXmlFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString(System.Security.Cryptography.ECKeyXmlFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXmlString (format As ECKeyXmlFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToXmlString(System::Security::Cryptography::ECKeyXmlFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Security.Cryptography.ECKeyXmlFormat" />
      </Parameters>
      <Docs>
        <param name="format">Uno de los valores de la enumeración que especifica el formato de la cadena XML. El único formato actualmente aceptado es <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
        <summary>Serializa la información de clave en una cadena XML mediante el formato especificado.</summary>
        <returns>Objeto de cadena que contiene la información de clave, serializada en una cadena XML, según el formato solicitado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="format" /> especifica un formato no válido. El único valor aceptado es <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSecretAgreementAsHmacKey">
      <MemberSignature Language="C#" Value="public bool UseSecretAgreementAsHmacKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSecretAgreementAsHmacKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UseSecretAgreementAsHmacKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSecretAgreementAsHmacKey { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acuerdo confidencial se utiliza como clave de código de autenticación de mensajes basado en hash (HMAC) para derivar el material de clave.</summary>
        <value>
          <see langword="true" /> si el acuerdo confidencial se utiliza como una clave HMAC para derivar el material de clave; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Este valor se utiliza para la derivación de claves si la <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> propiedad está establecida en <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>. De forma predeterminada, el valor es `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>