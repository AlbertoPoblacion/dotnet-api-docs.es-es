<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Rfc2898DeriveBytes.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5e285ca1271a28895045fb33d43ebf5e6709370cf.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e285ca1271a28895045fb33d43ebf5e6709370cf</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA1" /&gt;</ph>.</source>
          <target state="translated">Implementa PBKDF2 (función de derivación de claves basada en contraseña) mediante un generador de números pseudoaleatorios basado en <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> takes a password, a salt, and an iteration count, and then generates keys through calls to the <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> toma una contraseña, un valor "salt" y un número de iteraciones y, a continuación, genera las claves mediante llamadas a la <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">RFC 2898 incluye métodos para crear un vector de clave e inicialización (IV) de una contraseña y un valor "salt".</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Puede usar una función de derivación de claves basada en contraseña PBKDF2 para derivar claves mediante una función pseudoaleatoria que permite a las claves de longitud prácticamente ilimitada para generarse.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase puede usarse para generar una clave derivada de una clave base y otros parámetros.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponible en el <bpt id="p1">[</bpt>solicitar para el sitio Web de comentarios<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Vea la sección 5.2, "PBKDF2","para obtener información detallada.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Nunca codificar una contraseña en el código fuente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Codificado de forma rígida las contraseñas se pueden recuperar desde un ensamblado mediante la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class to create two identical keys for the <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> class.</source>
          <target state="translated">El siguiente ejemplo de código utiliza el <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase para crear dos idénticas claves para el <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>It then encrypts and decrypts some data using the keys.</source>
          <target state="translated">A continuación, cifra y descifra algunos datos utilizando las claves.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.Rfc2898DeriveBytes">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The password used to derive the key.</source>
          <target state="translated">Contraseña usada para derivar la clave.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The key salt used to derive the key.</source>
          <target state="translated">Valor de clave "salt" que se usa para derivar la clave.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using a password and salt to derive the key.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> con una contraseña y un valor "salt" para derivar la clave.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The salt size must be 8 bytes or larger.</source>
          <target state="translated">El tamaño del valor salt debe ser de 8 bytes o superior.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">RFC 2898 incluye métodos para crear un vector de clave e inicialización (IV) de una contraseña y un valor "salt".</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Puede usar una función de derivación de claves basada en contraseña PBKDF2 para derivar claves mediante una función pseudoaleatoria que permite a las claves de longitud prácticamente ilimitada para generarse.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase puede usarse para generar una clave derivada de una clave base y otros parámetros.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponible en el <bpt id="p1">[</bpt>solicitar para el sitio Web de comentarios<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Vea la sección 5.2, "PBKDF2","para obtener información detallada.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Nunca codificar una contraseña en el código fuente.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Codificado de forma rígida las contraseñas se pueden recuperar desde un ensamblado mediante la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class to create two identical keys for the <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> class.</source>
          <target state="translated">El siguiente ejemplo de código utiliza el <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase para crear dos idénticas claves para el <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>It then encrypts and decrypts some data using the keys.</source>
          <target state="translated">A continuación, cifra y descifra algunos datos utilizando las claves.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</source>
          <target state="translated">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La contraseña o el valor salt son <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The password used to derive the key.</source>
          <target state="translated">Contraseña usada para derivar la clave.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The size of the random salt that you want the class to generate.</source>
          <target state="translated">Tamaño del valor "salt" aleatorio que se desea que la clase genere.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using the password and salt size to derive the key.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> usando la contraseña y el tamaño del valor "salt" para derivar la clave.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The salt size must be 8 bytes or larger.</source>
          <target state="translated">El tamaño del valor salt debe ser de 8 bytes o superior.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">RFC 2898 incluye métodos para crear un vector de clave e inicialización (IV) de una contraseña y un valor "salt".</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Puede usar una función de derivación de claves basada en contraseña PBKDF2 para derivar claves mediante una función pseudoaleatoria que permite a las claves de longitud prácticamente ilimitada para generarse.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase puede usarse para generar una clave derivada de una clave base y otros parámetros.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponible en el <bpt id="p1">[</bpt>solicitar para el sitio Web de comentarios<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Vea la sección 5.2, "PBKDF2","para obtener información detallada.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Nunca codificar una contraseña en el código fuente.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Codificado de forma rígida las contraseñas se pueden recuperar desde un ensamblado mediante la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The specified salt size is smaller than 8 bytes.</source>
          <target state="translated">El tamaño del valor salt especificado es menor que 8 bytes.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La contraseña o el valor salt son <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The password used to derive the key.</source>
          <target state="translated">Contraseña usada para derivar la clave.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The key salt used to derive the key.</source>
          <target state="translated">Valor de clave "salt" que se usa para derivar la clave.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The number of iterations for the operation.</source>
          <target state="translated">Número de iteraciones de la operación.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using a password, a salt, and number of iterations to derive the key.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> usando una contraseña, un valor "salt" y un número de iteraciones para derivar la clave.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</source>
          <target state="translated">El tamaño del valor salt debe ser de 8 bytes o superior y el número de iteraciones debe ser mayor que cero.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The minimum recommended number of iterations is 1000.</source>
          <target state="translated">El número mínimo recomendado de iteraciones es 1000.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">RFC 2898 incluye métodos para crear un vector de clave e inicialización (IV) de una contraseña y un valor "salt".</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Puede usar una función de derivación de claves basada en contraseña PBKDF2 para derivar claves mediante una función pseudoaleatoria que permite a las claves de longitud prácticamente ilimitada para generarse.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase puede usarse para generar una clave derivada de una clave base y otros parámetros.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponible en el <bpt id="p1">[</bpt>solicitar para el sitio Web de comentarios<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Vea la sección 5.2, "PBKDF2","para obtener información detallada.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Nunca codificar una contraseña en el código fuente.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Codificado de forma rígida las contraseñas se pueden recuperar desde un ensamblado mediante la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</source>
          <target state="translated">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La contraseña o el valor salt son <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The password used to derive the key.</source>
          <target state="translated">Contraseña usada para derivar la clave.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The key salt used to derive the key.</source>
          <target state="translated">Valor de clave "salt" que se usa para derivar la clave.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The number of iterations for the operation.</source>
          <target state="translated">Número de iteraciones de la operación.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using a password, a salt, and number of iterations to derive the key.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> usando una contraseña, un valor "salt" y un número de iteraciones para derivar la clave.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</source>
          <target state="translated">El tamaño del valor salt debe ser de 8 bytes o superior y el número de iteraciones debe ser mayor que cero.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The minimum recommended number of iterations is 1000.</source>
          <target state="translated">El número mínimo recomendado de iteraciones es 1000.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">RFC 2898 incluye métodos para crear un vector de clave e inicialización (IV) de una contraseña y un valor "salt".</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Puede usar una función de derivación de claves basada en contraseña PBKDF2 para derivar claves mediante una función pseudoaleatoria que permite a las claves de longitud prácticamente ilimitada para generarse.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase puede usarse para generar una clave derivada de una clave base y otros parámetros.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponible en el <bpt id="p1">[</bpt>solicitar para el sitio Web de comentarios<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Vea la sección 5.2, "PBKDF2","para obtener información detallada.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Nunca codificar una contraseña en el código fuente.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Codificado de forma rígida las contraseñas se pueden recuperar desde un ensamblado mediante la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class to create two identical keys for the <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> class.</source>
          <target state="translated">El siguiente ejemplo de código utiliza el <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase para crear dos idénticas claves para el <ph id="ph2">&lt;xref:System.Security.Cryptography.TripleDES&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>It then encrypts and decrypts some data using the keys.</source>
          <target state="translated">A continuación, cifra y descifra algunos datos utilizando las claves.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</source>
          <target state="translated">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La contraseña o el valor salt son <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The password used to derive the key.</source>
          <target state="translated">Contraseña usada para derivar la clave.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The size of the random salt that you want the class to generate.</source>
          <target state="translated">Tamaño del valor "salt" aleatorio que se desea que la clase genere.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The number of iterations for the operation.</source>
          <target state="translated">Número de iteraciones de la operación.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class using a password, a salt size, and number of iterations to derive the key.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> usando una contraseña, un tamaño de valor "salt" y un número de iteraciones para derivar la clave.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</source>
          <target state="translated">El tamaño del valor salt debe ser de 8 bytes o superior y el número de iteraciones debe ser mayor que cero.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The minimum recommended number of iterations is 1000.</source>
          <target state="translated">El número mínimo recomendado de iteraciones es 1000.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</source>
          <target state="translated">RFC 2898 incluye métodos para crear un vector de clave e inicialización (IV) de una contraseña y un valor "salt".</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</source>
          <target state="translated">Puede usar una función de derivación de claves basada en contraseña PBKDF2 para derivar claves mediante una función pseudoaleatoria que permite a las claves de longitud prácticamente ilimitada para generarse.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class can be used to produce a derived key from a base key and other parameters.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase puede usarse para generar una clave derivada de una clave base y otros parámetros.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</source>
          <target state="translated">En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>For more information on PBKDF2, see RFC 2898,"PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the <bpt id="p1">[</bpt>Request for Comments Web site<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</source>
          <target state="translated">Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," disponible en el <bpt id="p1">[</bpt>solicitar para el sitio Web de comentarios<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=37119)</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>See section 5.2, "PBKDF2," for complete details.</source>
          <target state="translated">Vea la sección 5.2, "PBKDF2","para obtener información detallada.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>Never hard-code a password within your source code.</source>
          <target state="translated">Nunca codificar una contraseña en el código fuente.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>Hard-coded passwords can be retrieved from an assembly by using the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</source>
          <target state="translated">Codificado de forma rígida las contraseñas se pueden recuperar desde un ensamblado mediante la <bpt id="p1">[</bpt>Ildasm.exe (Desensamblador de IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>, con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</source>
          <target state="translated">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>The password or salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La contraseña o el valor salt son <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="iterations" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="iterations" /&gt;</ph> está fuera del intervalo.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)">
          <source>This parameter requires a non-negative number.</source>
          <target state="translated">Este parámetro requiere un número no negativo.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The algorithm name for which to derive the key.</source>
          <target state="translated">Nombre del algoritmo para el que se va a derivar la clave.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The hash algorithm name to use to derive the key.</source>
          <target state="translated">Nombre del algoritmo hash que se va a usar para derivar la clave.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The size of the key, in bits, to derive.</source>
          <target state="translated">Tamaño de la clave, en bits, que se va a derivar.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The initialization vector (IV) to use to derive the key.</source>
          <target state="translated">Vector de inicialización (IV) que se va a usar para derivar la clave.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>Derives a cryptographic key from the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> object.</source>
          <target state="translated">Deriva una clave criptográfica a partir del objeto <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The derived key.</source>
          <target state="translated">Clave derivada.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>This function is a wrapper for the Crypto API function CryptDeriveKey(), and is intended to offer interoperability with applications using the Crypto API.</source>
          <target state="translated">Esta función es un contenedor de la función CryptoAPI CryptDeriveKey() y está diseñada para ofrecer interoperabilidad con aplicaciones mediante la API de criptografía.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>If the <ph id="ph1">`keySize`</ph> parameter is set to 0 bits, the default key size for the specified algorithm is used.</source>
          <target state="translated">Si el <ph id="ph1">`keySize`</ph> parámetro se establece en 0 bits, se utiliza el tamaño de la clave predeterminada para el algoritmo especificado.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The <ph id="ph1">&lt;paramref name="keySize" /&gt;</ph> parameter is incorrect.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="keySize" /&gt;</ph> no es correcto.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The cryptographic service provider (CSP) cannot be acquired.</source>
          <target state="translated">No se puede adquirir el proveedor de servicios criptográficos (CSP).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The <ph id="ph1">&lt;paramref name="algname" /&gt;</ph> parameter is not a valid algorithm name.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="algname" /&gt;</ph> no es un nombre de algoritmo válido.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])">
          <source>The <ph id="ph1">&lt;paramref name="alghashname" /&gt;</ph> parameter is not a valid hash algorithm name.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="alghashname" /&gt;</ph> no es un nombre de algoritmo hash válido.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para liberar tanto recursos administrados como no administrados; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para liberar únicamente recursos no administrados.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> class and optionally releases the managed resources.</source>
          <target state="translated">Libera los recursos no administrados utilizados por la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /&gt;</ph> y, de forma opcional, libera los recursos administrados.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Se llama a este método público <ph id="ph1">`Dispose()`</ph> método y <ph id="ph2">`Finalize`</ph> método.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> se invoca el protegido <ph id="ph2">`Dispose(Boolean)`</ph> método con el <ph id="ph3">`disposing`</ph> parámetro establecido en <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source><ph id="ph1">`Finalize`</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> invoca <ph id="ph2">`Dispose`</ph> con <ph id="ph3">`disposing`</ph> establecido en <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> references.</source>
          <target state="translated">Cuando el parámetro <ph id="ph1">`disposing`</ph> es <ph id="ph2">`true`</ph>, este método libera todos los recursos retenidos por los objetos administrados a los que el control <ph id="ph3">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> hace referencia.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">Este método invoca al método <ph id="ph1">`Dispose()`</ph> de cada uno de los objetos a los que se hace referencia.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> puede recibir varias llamadas de otros objetos.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated">Al reemplazar <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo implementar <ph id="ph1">&lt;see langword="Dispose(Boolean)" /&gt;</ph>, consulte <bpt id="p1">[</bpt>implementa un método Dispose<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see langword="Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> y <ph id="ph2">&lt;see langword="Finalize" /&gt;</ph>, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>The number of pseudo-random key bytes to generate.</source>
          <target state="translated">Número de bytes de clave pseudoaleatorios que se van a generar.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>Returns the pseudo-random key for this object.</source>
          <target state="translated">Devuelve la clave pseudoaleatoria para este objeto.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>A byte array filled with pseudo-random key bytes.</source>
          <target state="translated">Matriz de bytes rellena de bytes de clave pseudoaleatorios.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class implements PBKDF2 functionality by using a pseudorandom number generator based on <ph id="ph2">&lt;xref:System.Security.Cryptography.HMACSHA1&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase implementa la función PBKDF2 utilizando un generador de números pseudoaleatorio basado en <ph id="ph2">&lt;xref:System.Security.Cryptography.HMACSHA1&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class takes a password, a salt, and an iteration count, and then generates keys through calls to the <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase toma una contraseña, un valor "salt" y un número de iteraciones y, a continuación, genera las claves mediante llamadas a la <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>Repeated calls to this method will not generate the same key; instead, appending two calls of the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method with a <ph id="ph2">`cb`</ph> parameter value of <ph id="ph3">`20`</ph> is the equivalent of calling the <ph id="ph4">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method once with a <ph id="ph5">`cb`</ph> parameter value of <ph id="ph6">`40`</ph>.</source>
          <target state="translated">Las llamadas repetidas a este método no generará la misma clave; en su lugar, anexar dos llamadas de la <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> método con un <ph id="ph2">`cb`</ph> valor del parámetro de <ph id="ph3">`20`</ph> es el equivalente de llamar al método el <ph id="ph4">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> método una vez con un <ph id="ph5">`cb`</ph> valor del parámetro de <ph id="ph6">`40`</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> method to get the key for an instance of <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A&gt;</ph> método para obtener la clave de una instancia de <ph id="ph2">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="cb" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cb" /&gt;</ph> está fuera del intervalo.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)">
          <source>This parameter requires a non-negative number.</source>
          <target state="translated">Este parámetro requiere un número no negativo.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>Gets or sets the number of iterations for the operation.</source>
          <target state="translated">Obtiene o establece el número de iteraciones de la operación.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>The number of iterations for the operation.</source>
          <target state="translated">Número de iteraciones de la operación.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>Iteration count is the number of times an operation is performed.</source>
          <target state="translated">Número de iteraciones es el número de veces que se realiza una operación.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>For this method, the count should be greater than zero.</source>
          <target state="translated">Para este método, el número debe ser mayor que cero.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>The minimum recommended number of iterations is 1000.</source>
          <target state="translated">El número mínimo recomendado de iteraciones es 1000.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A&gt;</ph> property to display the number of iterations used in the generation of the key.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A&gt;</ph> propiedad para mostrar el número de iteraciones usadas en la generación de la clave.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount">
          <source>The number of iterations is less than 1.</source>
          <target state="translated">El número de iteraciones es menor que 1.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
          <source>Resets the state of the operation.</source>
          <target state="translated">Restablece el estado de la operación.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
          <source>This method is automatically called if the salt or iteration count is modified.</source>
          <target state="translated">Este método se llama automáticamente si se modifica el número de iteración o el valor "salt".</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A&gt;</ph> method.</source>
          <target state="translated">En el siguiente ejemplo, se muestra cómo utilizar el método <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.Security.Cryptography.Rfc2898DeriveBytes&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>Gets or sets the key salt value for the operation.</source>
          <target state="translated">Obtiene o establece el valor de clave "salt" de la operación.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>The key salt value for the operation.</source>
          <target state="translated">Valor de clave "salt" de clave de la operación.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>Salt, a random set of bytes, is used to make unauthorized decrypting of a message more difficult.</source>
          <target state="translated">Valor "salt", un conjunto aleatorio de bytes, se utiliza para realizar el descifrado no autorizado de un mensaje más difícil.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>A dictionary attack is an attack in which the attacker attempts to decrypt an encrypted message by comparing the encrypted value with previously computed encrypted values for the most likely keys.</source>
          <target state="translated">Un ataque de diccionario es un ataque en el que el atacante intenta descifrar un mensaje cifrado comparando el valor cifrado con los valores cifrados calculados previamente para las claves más probables.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>This attack is made much more difficult by the introduction of salt, or random bytes, at the end of the password before the key derivation.</source>
          <target state="translated">Este ataque se hace mucho más difícil la introducción de salt, o bytes aleatorios, al final de la contraseña antes de la derivación de claves.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>The specified salt size is smaller than 8 bytes.</source>
          <target state="translated">El tamaño del valor salt especificado es menor que 8 bytes.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt">
          <source>The salt is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor salt es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>