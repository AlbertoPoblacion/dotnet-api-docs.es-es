<Type Name="Rfc2898DeriveBytes" FullName="System.Security.Cryptography.Rfc2898DeriveBytes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="33ee2fd66fc05f288789835988a052f4e50d1055" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51877143" /></Metadata><TypeSignature Language="C#" Value="public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Rfc2898DeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Rfc2898DeriveBytes" />
  <TypeSignature Language="VB.NET" Value="Public Class Rfc2898DeriveBytes&#xA;Inherits DeriveBytes" />
  <TypeSignature Language="C++ CLI" Value="public ref class Rfc2898DeriveBytes : System::Security::Cryptography::DeriveBytes" />
  <TypeSignature Language="F#" Value="type Rfc2898DeriveBytes = class&#xA;    inherit DeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa PBKDF2 (función de derivación de claves basada en contraseña) mediante un generador de números pseudoaleatorios basado en <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> toma un número de iteraciones, un valor "salt" y una contraseña y, a continuación, genera las claves mediante llamadas a la <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método.  
  
 RFC 2898 incluye métodos para crear un vector de clave y la inicialización (IV) de una contraseña y un valor "salt". PBKDF2, una función de derivación de claves basada en contraseña, puede usar para derivar claves mediante una función pseudoaleatoria que permite que las claves de longitud prácticamente ilimitada a generarse. La <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase puede usarse para generar una clave derivada de una clave base y otros parámetros. En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.  
  
 Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: especificación de criptografía basada en contraseña versión 2.0," disponible en el [sitio Web de comentarios de solicitud de](https://go.microsoft.com/fwlink/?LinkID=37119). Vea la sección 5.2, "PBKDF2", para obtener información detallada.  
  
> [!IMPORTANT]
>  Nunca codifique de forma rígida una contraseña en su código fuente.  Las contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado mediante la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase para crear dos idénticas claves para el <xref:System.Security.Cryptography.TripleDES> clase.  A continuación, cifra y descifra algunos datos utilizando las claves.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">Contraseña usada para derivar la clave.</param>
        <param name="salt">Valor de clave "salt" que se usa para derivar la clave.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> con una contraseña y un valor "salt" para derivar la clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del valor salt debe ser de 8 bytes o superior.  
  
 RFC 2898 incluye métodos para crear un vector de clave y la inicialización (IV) de una contraseña y un valor "salt". PBKDF2, una función de derivación de claves basada en contraseña, puede usar para derivar claves mediante una función pseudoaleatoria que permite que las claves de longitud prácticamente ilimitada a generarse. La <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase puede usarse para generar una clave derivada de una clave base y otros parámetros. En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.  
  
 Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: especificación de criptografía basada en contraseña versión 2.0," disponible en el [sitio Web de comentarios de solicitud de](https://go.microsoft.com/fwlink/?LinkID=37119). Vea la sección 5.2, "PBKDF2", para obtener información detallada.  
  
> [!IMPORTANT]
>  Nunca codifique de forma rígida una contraseña en su código fuente.  Las contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado mediante la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase para crear dos idénticas claves para el <xref:System.Security.Cryptography.TripleDES> clase.  A continuación, cifra y descifra algunos datos utilizando las claves.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</exception>
        <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Contraseña usada para derivar la clave.</param>
        <param name="saltSize">Tamaño del valor "salt" aleatorio que se desea que la clase genere.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando la contraseña y el tamaño del valor "salt" para derivar la clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del valor salt debe ser de 8 bytes o superior.  
  
 RFC 2898 incluye métodos para crear un vector de clave y la inicialización (IV) de una contraseña y un valor "salt". PBKDF2, una función de derivación de claves basada en contraseña, puede usar para derivar claves mediante una función pseudoaleatoria que permite que las claves de longitud prácticamente ilimitada a generarse. La <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase puede usarse para generar una clave derivada de una clave base y otros parámetros. En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.  
  
 Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: especificación de criptografía basada en contraseña versión 2.0," disponible en el [sitio Web de comentarios de solicitud de](https://go.microsoft.com/fwlink/?LinkID=37119). Vea la sección 5.2, "PBKDF2", para obtener información detallada.  
  
> [!IMPORTANT]
>  Nunca codifique de forma rígida una contraseña en su código fuente.  Las contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado mediante la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes.</exception>
        <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Contraseña usada para derivar la clave.</param>
        <param name="salt">Valor de clave "salt" que se usa para derivar la clave.</param>
        <param name="iterations">Número de iteraciones de la operación.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando una contraseña, un valor "salt" y un número de iteraciones para derivar la clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del valor salt debe ser de 8 bytes o superior y el número de iteraciones debe ser mayor que cero. El número mínimo recomendado de iteraciones es 1000.  
  
 RFC 2898 incluye métodos para crear un vector de clave y la inicialización (IV) de una contraseña y un valor "salt". PBKDF2, una función de derivación de claves basada en contraseña, puede usar para derivar claves mediante una función pseudoaleatoria que permite que las claves de longitud prácticamente ilimitada a generarse. La <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase puede usarse para generar una clave derivada de una clave base y otros parámetros. En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.  
  
 Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: especificación de criptografía basada en contraseña versión 2.0," disponible en el [sitio Web de comentarios de solicitud de](https://go.microsoft.com/fwlink/?LinkID=37119). Vea la sección 5.2, "PBKDF2", para obtener información detallada.  
  
> [!IMPORTANT]
>  Nunca codifique de forma rígida una contraseña en su código fuente.  Las contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado mediante la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</exception>
        <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Contraseña usada para derivar la clave.</param>
        <param name="salt">Valor de clave "salt" que se usa para derivar la clave.</param>
        <param name="iterations">Número de iteraciones de la operación.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando una contraseña, un valor "salt" y un número de iteraciones para derivar la clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del valor salt debe ser de 8 bytes o superior y el número de iteraciones debe ser mayor que cero. El número mínimo recomendado de iteraciones es 1000.  
  
 RFC 2898 incluye métodos para crear un vector de clave y la inicialización (IV) de una contraseña y un valor "salt". PBKDF2, una función de derivación de claves basada en contraseña, puede usar para derivar claves mediante una función pseudoaleatoria que permite que las claves de longitud prácticamente ilimitada a generarse. La <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase puede usarse para generar una clave derivada de una clave base y otros parámetros. En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.  
  
 Para obtener más información acerca de PBKDF2, vea RFC 2898, "PKCS #5: especificación de criptografía basada en contraseña versión 2.0," disponible en el [sitio Web de comentarios de solicitud de](https://go.microsoft.com/fwlink/?LinkID=37119). Vea la sección 5.2, "PBKDF2", para obtener información detallada.  
  
> [!IMPORTANT]
>  Nunca codifique de forma rígida una contraseña en su código fuente.  Las contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado mediante la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase para crear dos idénticas claves para el <xref:System.Security.Cryptography.TripleDES> clase.  A continuación, cifra y descifra algunos datos utilizando las claves.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</exception>
        <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Contraseña usada para derivar la clave.</param>
        <param name="saltSize">Tamaño del valor "salt" aleatorio que se desea que la clase genere.</param>
        <param name="iterations">Número de iteraciones de la operación.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando una contraseña, un tamaño de valor "salt" y un número de iteraciones para derivar la clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño del valor salt debe ser de 8 bytes o superior y el número de iteraciones debe ser mayor que cero. El número mínimo recomendado de iteraciones es 1000.  
  
 RFC 2898 incluye métodos para crear un vector de clave y la inicialización (IV) de una contraseña y un valor "salt". PBKDF2, una función de derivación de claves basada en contraseña, puede usar para derivar claves mediante una función pseudoaleatoria que permite que las claves de longitud prácticamente ilimitada a generarse. La <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase puede usarse para generar una clave derivada de una clave base y otros parámetros. En una función de derivación de claves basada en contraseña, la clave base es una contraseña y los demás parámetros son un valor "salt" y un número de iteraciones.  
  
 Para obtener más información sobre PBKDF2, vea RFC 2898, "PKCS nº 5: especificación de criptografía basada en contraseña versión 2.0," disponible en el [sitio Web de comentarios de solicitud de](https://go.microsoft.com/fwlink/?LinkID=37119). Vea la sección 5.2, "PBKDF2", para obtener información detallada.  
  
> [!IMPORTANT]
>  Nunca codifique de forma rígida una contraseña en su código fuente.  Las contraseñas codificadas de forma rígida se pueden recuperar desde un ensamblado mediante la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), con un editor hexadecimal o, sencillamente, abriendo el ensamblado en un editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes o el número de iteraciones es menor que 1.</exception>
        <exception cref="T:System.ArgumentNullException">La contraseña o el valor salt son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="iterations" /> está fuera del intervalo. Este parámetro requiere un número no negativo.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Contraseña que se va a usar para derivar la clave.</param>
        <param name="salt">Valor de clave "salt" que se va a usar para derivar la clave.</param>
        <param name="iterations">Número de iteraciones de la operación.</param>
        <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar la clave.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> mediante la contraseña, el valor "salt", el número de iteraciones y el nombre del algoritmo hash especificados para derivar la clave.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="saltSize" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El nombre del algoritmo hash no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Contraseña que se va a usar para derivar la clave.</param>
        <param name="salt">Valor de clave "salt" que se va a usar para derivar la clave.</param>
        <param name="iterations">Número de iteraciones de la operación.</param>
        <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar la clave.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> mediante la contraseña, el valor "salt", el número de iteraciones y el nombre del algoritmo hash especificados para derivar la clave.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El nombre del algoritmo hash no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">Contraseña que se va a usar para derivar la clave.</param>
        <param name="saltSize">Tamaño del valor "salt" aleatorio que se desea que la clase genere.</param>
        <param name="iterations">Número de iteraciones de la operación.</param>
        <param name="hashAlgorithm">Algoritmo hash que se va a usar para derivar la clave.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> mediante la contraseña, el tamaño del valor "salt", el número de iteraciones y el nombre del algoritmo hash especificados para derivar la clave.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="saltSize" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> de <paramref name="hashAlgorithm" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El nombre del algoritmo hash no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CryptDeriveKey (algname As String, alghashname As String, keySize As Integer, rgbIV As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ CryptDeriveKey(System::String ^ algname, System::String ^ alghashname, int keySize, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberSignature Language="F#" Value="member this.CryptDeriveKey : string * string * int * byte[] -&gt; byte[]" Usage="rfc2898DeriveBytes.CryptDeriveKey (algname, alghashname, keySize, rgbIV)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" />
        <Parameter Name="alghashname" Type="System.String" />
        <Parameter Name="keySize" Type="System.Int32" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="algname">Nombre del algoritmo para el que se va a derivar la clave.</param>
        <param name="alghashname">Nombre del algoritmo hash que se va a usar para derivar la clave.</param>
        <param name="keySize">Tamaño de la clave, en bits, que se va a derivar.</param>
        <param name="rgbIV">Vector de inicialización (IV) que se va a usar para derivar la clave.</param>
        <summary>Deriva una clave criptográfica a partir del objeto <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />.</summary>
        <returns>Clave derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta función es un contenedor para la función de la API Crypto CryptDeriveKey() y está diseñada para ofrecer interoperabilidad con las aplicaciones que usan la API de criptografía.  
  
 Si el `keySize` parámetro se establece en 0 bits, se utiliza el tamaño de clave predeterminado para el algoritmo especificado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">El parámetro <paramref name="keySize" /> no es correcto.  
  
O bien 
No se puede adquirir el proveedor de servicios criptográficos (CSP).  
  
O bien 
El parámetro <paramref name="algname" /> no es un nombre de algoritmo válido.  
  
O bien 
El parámetro <paramref name="alghashname" /> no es un nombre de algoritmo hash válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="rfc2898DeriveBytes.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados utilizados por la clase <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose()` método y el `Finalize` método. `Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. `Finalize` invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.Security.Cryptography.Rfc2898DeriveBytes> hace referencia. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Cuando se reemplaza <see langword="Dispose(Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see langword="Dispose" /> y <see langword="Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (cb As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(int cb);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int -&gt; byte[]" Usage="rfc2898DeriveBytes.GetBytes cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Número de bytes de clave pseudoaleatorios que se van a generar.</param>
        <summary>Devuelve la clave pseudoaleatoria para este objeto.</summary>
        <returns>Matriz de bytes rellena de bytes de clave pseudoaleatorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase implementa la función PBKDF2 utilizando un generador de números pseudoaleatorio basado en <xref:System.Security.Cryptography.HMACSHA1>. El <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase toma un número de iteraciones, un valor "salt" y una contraseña y, a continuación, genera las claves mediante llamadas a la <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método. Las llamadas repetidas a este método no generará la misma clave; en su lugar, anexar dos llamadas de la <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método con un `cb` valor del parámetro de `20` equivale a llamar a la <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método una vez con un `cb` valor del parámetro de `40`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método para obtener la clave de una instancia de <xref:System.Security.Cryptography.Rfc2898DeriveBytes>. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase.  
  
 [!code-cpp[rfc28981#2](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#2)]
 [!code-csharp[rfc28981#2](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#2)]
 [!code-vb[rfc28981#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="cb" /> está fuera del intervalo. Este parámetro requiere un número no negativo.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.HashAlgorithmName HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.HashAlgorithmName HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HashAlgorithm As HashAlgorithmName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::HashAlgorithmName HashAlgorithm { System::Security::Cryptography::HashAlgorithmName get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Cryptography.HashAlgorithmName" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithmName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property IterationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IterationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IterationCount : int with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de iteraciones de la operación.</summary>
        <value>Número de iteraciones de la operación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Número de iteraciones es el número de veces que se realiza una operación. Para este método, el número debe ser mayor que cero. El número mínimo recomendado de iteraciones es 1000.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A> propiedad para mostrar el número de iteraciones usadas en la generación de la clave. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase.  
  
 [!code-cpp[rfc28981#3](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#3)]
 [!code-csharp[rfc28981#3](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#3)]
 [!code-vb[rfc28981#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de iteraciones es menor que 1.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="override this.Reset : unit -&gt; unit" Usage="rfc2898DeriveBytes.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el estado de la operación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama automáticamente si se modifica el número de iteración o el valor "salt".  
  
   
  
## Examples  
 En el siguiente ejemplo, se muestra cómo utilizar el método <xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A>. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.Cryptography.Rfc2898DeriveBytes> clase.  
  
 [!code-cpp[rfc28981#5](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#5)]
 [!code-csharp[rfc28981#5](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#5)]
 [!code-vb[rfc28981#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberSignature Language="VB.NET" Value="Public Property Salt As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Salt { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Salt : byte[] with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de clave "salt" de la operación.</summary>
        <value>Valor de clave "salt" de clave de la operación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Valor "salt", un conjunto aleatorio de bytes, se utiliza para realizar el descifrado no autorizado de un mensaje más difícil. Un ataque de diccionario es un ataque en el que el atacante intenta descifrar un mensaje cifrado comparando el valor cifrado con los valores cifrados calculados previamente para las claves más probables. Este ataque se hace mucho más difícil la introducción de valor "salt", o bytes aleatorios, al final de la contraseña antes de la derivación de claves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño del valor salt especificado es menor que 8 bytes.</exception>
        <exception cref="T:System.ArgumentNullException">El valor salt es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">servicios criptográficos</related>
      </Docs>
    </Member>
  </Members>
</Type>