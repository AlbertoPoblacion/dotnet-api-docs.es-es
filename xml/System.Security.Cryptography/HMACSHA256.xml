<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="HMACSHA256.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c4a95573b647579bd27a466bebd983565c9aa6c8.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c4a95573b647579bd27a466bebd983565c9aa6c8</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>Computes a Hash-based Message Authentication Code (HMAC) by using the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.SHA256" /&gt;</ph> hash function.</source>
          <target state="translated">Calcula un código de autenticación de mensajes basado en hash (HMAC) mediante la función hash <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.SHA256" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> is a type of keyed hash algorithm that is constructed from the SHA-256 hash function and used as a Hash-based Message Authentication Code (HMAC).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> es un tipo de algoritmo hash con clave que se construyen a partir de la función de hash SHA-256 y se usa como un código de autenticación de mensajes basado en Hash (HMAC).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time.</source>
          <target state="translated">El proceso HMAC combina una clave secreta con los datos del mensaje, aplica un algoritmo hash el resultado con la función hash, combina de nuevo ese valor hash con la clave secreta y, a continuación, aplica la función hash por segunda vez.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>The output hash is 256 bits in length.</source>
          <target state="translated">El hash de salida es de 256 bits de longitud.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>An HMAC can be used to determine whether a message sent over an insecure channel has been tampered with, provided that the sender and receiver share a secret key.</source>
          <target state="translated">Un HMAC puede utilizarse para determinar si se ha manipulado un mensaje enviado a través de un canal no seguro, siempre que el remitente y el receptor compartan una clave secreta.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>The sender computes the hash value for the original data and sends both the original data and hash value as a single message.</source>
          <target state="translated">El remitente calcula el valor hash para los datos originales y envía el valor hash y los datos como un solo mensaje.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>The receiver recalculates the hash value on the received message and checks that the computed HMAC matches the transmitted HMAC.</source>
          <target state="translated">El receptor vuelve a calcular el valor hash en el mensaje recibido y comprueba que el HMAC calculado coincide con el transmitido.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>Any change to the data or the hash value results in a mismatch, because knowledge of the secret key is required to change the message and reproduce the correct hash value.</source>
          <target state="translated">Cualquier cambio en los datos o el valor hash se produce un error de coincidencia, porque se requieren conocimientos de la clave secreta para cambiar el mensaje y reproducir el valor hash correcto.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>Therefore, if the original and computed hash values match, the message is authenticated.</source>
          <target state="translated">Por lo tanto, si los valores de hash original y el calculado coinciden, se autentica el mensaje.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> accepts keys of any size, and produces a hash sequence 256 bits in length.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> acepta claves de cualquier tamaño y genera una secuencia de hash de 256 bits de longitud.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>The following example shows how to sign a file by using the <ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> object and then how to verify the file.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo firmar un archivo mediante la <ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> objeto y, a continuación, cómo comprobar el archivo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.HMACSHA256">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA256" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA256" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HMACSHA256.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA256" /&gt;</ph> class with a randomly generated key.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA256" /&gt;</ph> con una clave generada aleatoriamente.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HMACSHA256.#ctor">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> is a type of keyed hash algorithm that is constructed from the SHA-256 hash function and used as a Hash-based Message Authentication Code (HMAC).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> es un tipo de algoritmo hash con clave que se construyen a partir de la función de hash SHA-256 y se usa como un código de autenticación de mensajes basado en Hash (HMAC).</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HMACSHA256.#ctor">
          <source>The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time.</source>
          <target state="translated">El proceso HMAC combina una clave secreta con los datos del mensaje, aplica un algoritmo hash el resultado con la función hash, combina de nuevo ese valor hash con la clave secreta y, a continuación, aplica la función hash por segunda vez.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HMACSHA256.#ctor">
          <source>The output hash is 256 bits in length.</source>
          <target state="translated">El hash de salida es de 256 bits de longitud.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HMACSHA256.#ctor">
          <source>This constructor uses a 64-byte, randomly generated key.</source>
          <target state="translated">Este constructor utiliza una clave generada aleatoriamente de 64 bytes.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>The secret key for <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA256" /&gt;</ph> encryption.</source>
          <target state="translated">Clave secreta para el cifrado de <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA256" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>The key can be any length.</source>
          <target state="translated">La clave puede tener cualquier longitud.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>However, the recommended size is 64 bytes.</source>
          <target state="translated">Sin embargo, el tamaño recomendado es de 64 bytes.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>If the key is more than 64 bytes long, it is hashed (using SHA-256) to derive a 64-byte key.</source>
          <target state="translated">Si la clave tiene más de 64 bytes se usará un algoritmo hash (SHA-256) para derivar una clave de 64 bytes.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>If it is less than 64 bytes long, it is padded to 64 bytes.</source>
          <target state="translated">Si es menor de 64 bytes de longitud, se completa en 64 bytes.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA256" /&gt;</ph> class with the specified key data.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.HMACSHA256" /&gt;</ph> con los datos de clave especificados.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> is a type of keyed hash algorithm that is constructed from the SHA-256 hash function and used as a Hash-based Message Authentication Code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> es un tipo de algoritmo hash con clave que se construyen a partir de la función de hash SHA-256 y se usa como un código de autenticación de mensajes basado en Hash.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time.</source>
          <target state="translated">El proceso HMAC combina una clave secreta con los datos del mensaje, aplica un algoritmo hash el resultado con la función hash, combina de nuevo ese valor hash con la clave secreta y, a continuación, aplica la función hash por segunda vez.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>The output hash is 256 bits in length.</source>
          <target state="translated">El hash de salida es de 256 bits de longitud.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>For an example of how to use this constructor, see the <ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> class.</source>
          <target state="translated">Para obtener un ejemplo de cómo utilizar este constructor, vea el <ph id="ph1">&lt;xref:System.Security.Cryptography.HMACSHA256&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])">
          <source>The <ph id="ph1">&lt;paramref name="key" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="key" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>