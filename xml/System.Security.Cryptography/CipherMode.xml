<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CipherMode.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac57c70ff3bf1a311578eeb87faf3ca052f53d7933f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7c70ff3bf1a311578eeb87faf3ca052f53d7933f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.CipherMode">
          <source>Specifies the block cipher mode to use for encryption.</source>
          <target state="translated">Especifica el modo de cifrado de bloques que se utilizará para el cifrado.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Block cipher algorithms encrypt data in block units, rather than a single byte at a time.</source>
          <target state="translated">Algoritmos de cifrado de bloques cifran datos en unidades de bloque, en lugar de un solo byte a la vez.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>The most common block size is 8 bytes.</source>
          <target state="translated">El tamaño del bloque más común es de 8 bytes.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Because each block is heavily processed, block ciphers provide a higher level of security than stream ciphers.</source>
          <target state="translated">Dado que cada bloque se procesa intensivamente, cifrado de bloques proporciona un mayor nivel de seguridad que los cifrados de flujo de.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>However, block cipher algorithms tend to execute more slowly than stream ciphers.</source>
          <target state="translated">Sin embargo, los algoritmos de cifrado de bloques suelen ejecutarse con mayor lentitud que los cifrados de flujo de.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Block ciphers use the same encryption algorithm for each block.</source>
          <target state="translated">Los cifrados de bloques utilizan el mismo algoritmo de cifrado para cada bloque.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Because of this, a block of plain text will always return the same cipher text when encrypted with the same key and algorithm.</source>
          <target state="translated">Por este motivo, un bloque de texto sin formato siempre devolverá el mismo texto de cifrado al cifrado con la misma clave y el algoritmo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>Because this behavior can be used to crack a cipher, cipher modes are introduced that modify the encryption process based on feedback from earlier block encryptions.</source>
          <target state="translated">Dado que este comportamiento puede utilizarse para descifrar un cifrado, se introducen los modos de cifrado que modifican el proceso de cifrado basado en los comentarios de cifrados de bloques anteriores.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.Cryptography.CipherMode">
          <source>The resulting encryption provides a higher level of security than a simple block encryption.</source>
          <target state="translated">Cifrado resultante proporciona un mayor nivel de seguridad que un cifrado de bloques simple.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>The Cipher Block Chaining (<ph id="ph1">&lt;see langword="CBC" /&gt;</ph>) mode introduces feedback.</source>
          <target state="translated">El modo Cipher Block Chaining (<ph id="ph1">&lt;see langword="CBC" /&gt;</ph>) incluye información de cifrados anteriores.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>Before each plain text block is encrypted, it is combined with the cipher text of the previous block by a bitwise exclusive OR operation.</source>
          <target state="translated">Antes de cifrarse cada bloque de texto sin formato, cada uno de ellos se combina con el texto de cifrado del bloque anterior mediante una operación OR exclusiva bit a bit.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>This ensures that even if the plain text contains many identical blocks, they will each encrypt to a different cipher text block.</source>
          <target state="translated">Esto garantiza que, aunque el texto sin formato contenga muchos bloques idénticos, cada uno de ellos se cifrará en un bloque de texto de cifrado distinto.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>The initialization vector is combined with the first plain text block by a bitwise exclusive OR operation before the block is encrypted.</source>
          <target state="translated">El vector de inicialización se combina con el primer bloque de texto sin formato mediante una operación OR exclusiva bit a bit antes de cifrar el bloque.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>If a single bit of the cipher text block is mangled, the corresponding plain text block will also be mangled.</source>
          <target state="translated">Si se trastoca un único bit del bloque de texto de cifrado, se trastoca también el bloque de texto sin formato correspondiente.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CBC">
          <source>In addition, a bit in the subsequent block, in the same position as the original mangled bit, will be mangled.</source>
          <target state="translated">Asimismo, se trastocará el bit del bloque siguiente que se encuentra en la misma posición que el bit trastocado original.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>The Cipher Feedback (<ph id="ph1">&lt;see langword="CFB" /&gt;</ph>) mode processes small increments of plain text into cipher text, instead of processing an entire block at a time.</source>
          <target state="translated">El modo Cipher Feedback (<ph id="ph1">&lt;see langword="CFB" /&gt;</ph>) procesa pequeños incrementos del texto sin formato como texto de cifrado, en lugar de procesar un bloque completo cada vez.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>This mode uses a shift register that is one block in length and is divided into sections.</source>
          <target state="translated">Este modo utiliza un registro de desplazamiento con una longitud de un bloque y dividido en secciones.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>For example, if the block size is 8 bytes, with one byte processed at a time, the shift register is divided into eight sections.</source>
          <target state="translated">Por ejemplo, si el tamaño del bloque es de 8 bytes y se procesa un byte cada vez, el registro de desplazamiento se divide en ocho secciones.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>If a bit in the cipher text is mangled, one plain text bit is mangled and the shift register is corrupted.</source>
          <target state="translated">Si se trastoca un bit del texto de cifrado, se trastoca un bit del texto sin formato y el registro de desplazamiento queda dañado.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>This results in the next several plain text increments being mangled until the bad bit is shifted out of the shift register.</source>
          <target state="translated">Esto da lugar a que los siguientes incrementos del texto sin formato se trastoquen hasta que el bit erróneo se elimine del registro de desplazamiento.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>The default feedback size can vary by algorithm, but is typically either 8 bits or the number of bits of the block size.</source>
          <target state="translated">El tamaño del comentario predeterminado puede variar en función del algoritmo, pero suele ser de 8 bits o el número de bits del tamaño de bloque.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>You can alter the number of feedback bits by using the <ph id="ph1">&lt;see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /&gt;</ph> property.</source>
          <target state="translated">Puede modificar el número de bits del comentario mediante la propiedad <ph id="ph1">&lt;see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CFB">
          <source>Algorithms that support CFB use this property to set the feedback.</source>
          <target state="translated">Los algoritmos que admiten CFB usan esta propiedad para establecer los comentarios.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CTS">
          <source>The Cipher Text Stealing (<ph id="ph1">&lt;see langword="CTS" /&gt;</ph>) mode handles any length of plain text and produces cipher text whose length matches the plain text length.</source>
          <target state="translated">El modo Cipher Text Stealing (<ph id="ph1">&lt;see langword="CTS" /&gt;</ph>) controla el texto sin formato de cualquier tamaño y produce texto de cifrado cuya longitud coincide con la del texto sin formato.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.CTS">
          <source>This mode behaves like the <ph id="ph1">&lt;see langword="CBC" /&gt;</ph> mode for all but the last two blocks of the plain text.</source>
          <target state="translated">Este modo se comporta igual que el modo <ph id="ph1">&lt;see langword="CBC" /&gt;</ph> para todos los bloques excepto para los dos últimos del texto sin formato.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>The Electronic Codebook (<ph id="ph1">&lt;see langword="ECB" /&gt;</ph>) mode encrypts each block individually.</source>
          <target state="translated">El modo Electronic Codebook (<ph id="ph1">&lt;see langword="ECB" /&gt;</ph>) cifra cada bloque por separado.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>Any blocks of plain text that are identical and in the same message, or that are in a different message encrypted with the same key, will be transformed into identical cipher text blocks.</source>
          <target state="translated">Los bloques de texto sin formato que sean idénticos y estén en el mismo mensaje, o en uno diferente cifrado con la misma clave, se convertirán en bloques de texto de cifrado idénticos.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>:  This mode is not recommended because it opens the door for multiple security exploits.</source>
          <target state="translated"><bpt id="p1">**</bpt>Importante<ept id="p1">**</ept>: No se recomienda este modo porque representa un riesgo para la seguridad.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>If the plain text to be encrypted contains substantial repetition, it is feasible for the cipher text to be broken one block at a time.</source>
          <target state="translated">Si el texto sin formato que se va a cifrar contiene muchas repeticiones, es posible que el texto de cifrado se divida en un bloque cada vez.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>It is also possible to use block analysis to determine the encryption key.</source>
          <target state="translated">También es posible usar el análisis de bloques para determinar la clave de cifrado.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.ECB">
          <source>Also, an active adversary can substitute and exchange individual blocks without detection, which allows blocks to be saved and inserted into the stream at other points without detection.</source>
          <target state="translated">Un adversario activo también puede sustituir e intercambiar bloques individuales sin ser detectado, lo que permite guardar los bloques e insertarlos en la secuencia en otros puntos sin que se advierta.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.OFB">
          <source>The Output Feedback (<ph id="ph1">&lt;see langword="OFB" /&gt;</ph>) mode processes small increments of plain text into cipher text instead of processing an entire block at a time.</source>
          <target state="translated">El modo Output Feedback (<ph id="ph1">&lt;see langword="OFB" /&gt;</ph>) procesa pequeños incrementos del texto sin formato como texto de cifrado, en lugar de procesar un bloque completo cada vez.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.OFB">
          <source>This mode is similar to <ph id="ph1">&lt;see langword="CFB" /&gt;</ph>; the only difference between the two modes is the way that the shift register is filled.</source>
          <target state="translated">Este modo es similar a <ph id="ph1">&lt;see langword="CFB" /&gt;</ph>; la única diferencia entre los dos modos es la forma en que se rellena el registro de desplazamiento.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.OFB">
          <source>If a bit in the cipher text is mangled, the corresponding bit of plain text will be mangled.</source>
          <target state="translated">Si se trastoca un bit del texto de cifrado, se trastoca también el bit del texto sin formato correspondiente.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="F:System.Security.Cryptography.CipherMode.OFB">
          <source>However, if there are extra or missing bits from the cipher text, the plain text will be mangled from that point on.</source>
          <target state="translated">Sin embargo, si hay bits adicionales o falta alguno en el texto de cifrado, el texto sin formato sólo se trastoca a partir de ese punto.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>