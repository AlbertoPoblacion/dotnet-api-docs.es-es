<Type Name="SessionSecurityTokenHandler" FullName="System.IdentityModel.Tokens.SessionSecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c115a52489fd77750e537edfe5b3127ffc36e982" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30419959" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SessionSecurityTokenHandler : System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionSecurityTokenHandler extends System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionSecurityTokenHandler&#xA;Inherits SecurityTokenHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionSecurityTokenHandler : System::IdentityModel::Tokens::SecurityTokenHandler" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Tokens.SecurityTokenHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> que procesa los tokens de seguridad de tipo <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> clase serializa, deserializa y valida los tokens de la sesión. Los tokens de sesión son tokens de tipo <xref:System.IdentityModel.Tokens.SessionSecurityToken>. La <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> clase serializa los tokens a y desde el formato de la cookie. De forma predeterminada, la clase serializa tokens en WS-Secure Conversation Feb2005 o WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` elementos. Tokens de sesión son usados por la <xref:System.IdentityModel.Services.WSFederationAuthenticationModule> (WSFAM) y la <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) para almacenar información sobre una sesión, se trata principalmente la <xref:System.Security.Claims.ClaimsPrincipal> asociada al usuario autenticado y las horas de inicio y finalización de sesión.  
  
 En escenarios pasivos, el <xref:System.IdentityModel.Services.WSFederationAuthenticationModule> llama a la <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) de la canalización de autenticación para crear un token de sesión desde el <xref:System.Security.Claims.ClaimsPrincipal> que representa al usuario autenticado. El SAM usa su configurado <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> para crear el token y para serializar en una cookie (y para deserializar el token de una cookie de sesión en las solicitudes subsiguientes). El SAM usa una instancia de su configurado <xref:System.IdentityModel.Services.CookieHandler> clase volver a escribir la cookie en la respuesta HTTP. Esta cookie, a continuación, se devuelve al cliente y en las solicitudes subsiguientes puede presentar al cliente la cookie en lugar de realizar un de ida y vuelta hacia el proveedor de identidades para volver a obtener un token de seguridad. Para obtener más información sobre el funcionan de las sesiones con WIF, consulte [administración de sesiones de WIF](~/docs/framework/security/wif-session-management.md).  
  
> [!NOTE]
>  El \<securityTokenHandlers > elemento de configuración se puede usar para especificar un <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> que tiene la responsabilidad de proteger las sesiones de la aplicación. Los desarrolladores deben tener cuidado al cambiar esta opción de configuración, como un sistema mal configurado podría poner en peligro de aplicación. Por ejemplo, si se especifica un hipervínculo derivado "http://msdn.microsoft.com/library/hh193426%28v=vs.110%29.aspx" \t "_blank" <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> y pasar una colección vacía de transformaciones (CookieTransform) a la base, daría lugar a la identidad de los usuarios que se está serializando en una cookie que no se ha protegido. Esto podría permitir que un atacante modifique la identidad y, por tanto, cambie los privilegios de acceso.  
  
 Si el token de sesión está en modo de referencia, es decir, su <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propiedad es `true`, la sesión de controlador de token sólo serializa las propiedades del token de sesión que son necesarios para volver a generar su clave en el <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>. En el caso predeterminado, el <xref:System.IdentityModel.Tokens.SessionSecurityTokenCacheKey> clase se usa para representar las claves de caché y el controlador de token escribe el <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType> y <xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType> propiedades del token. Si el token de sesión no está en modo de referencia, es decir, el <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propiedad es `false`, a continuación, además de las propiedades que se ha mencionado anteriormente, se invoca el controlador de la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> método en una matriz de bytes serializado desde el símbolo (token) y almacena el valor resultante en la cookie así. Para obtener más información acerca de cómo se serializa el token, consulte el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> método.  
  
 El <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> propiedad obtiene la lista de transformaciones que se aplican a la sesión de símbolo (token) en el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> método. Todas las transformaciones que se derivan de la <xref:System.IdentityModel.CookieTransform> clase. En el caso predeterminado el <xref:System.IdentityModel.DeflateCookieTransform> y <xref:System.IdentityModel.ProtectedDataCookieTransform> se aplican. El <xref:System.IdentityModel.ProtectedDataCookieTransform> usa la API de protección de datos (DPAPI) para proteger el material de cookie. DPAPI utiliza una clave específica para el equipo en el que se está ejecutando en sus algoritmos de protección. Por este motivo, el controlador de token de sesión predeterminada no es utilizable en escenarios de granja de servidores Web porque, en estos escenarios, los tokens que se escriben en un equipo que necesite leerse en otro equipo. Puede usar muchas estrategias para evitar este problema. Por ejemplo, se puede:  
  
-   Reemplace el valor predeterminado <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> con el <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>. El <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler> le permite especificar las claves de firma y cifrado en ASP.NET `<machineKey>` elemento en el archivo de configuración.  
  
-   Proporciona un controlador para el <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType> eventos en el archivo global.asax.cs y reemplazar la sesión predeterminada del controlador con una instancia de token <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> que tiene una lista de transformaciones que incluye el <xref:System.IdentityModel.RsaSignatureCookieTransform> y <xref:System.IdentityModel.RsaEncryptionCookieTransform>. Puede crear la nueva instancia mediante la invocación de uno de los constructores que toma una lista de transformaciones.  
  
-   Derivar una transformación personalizada desde el <xref:System.IdentityModel.CookieTransform> clase base y utilizar el método anterior para incluirlo en la lista de transformaciones que se deben aplicar.  
  
-   Derivar un controlador de token personalizado de <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> e implementar su propio mecanismo.  
  
 Para obtener más información acerca del uso de sesiones en los escenarios de granja de servidores Web, consulte [WIF y granjas de servidores Web](~/docs/framework/security/wif-and-web-farms.md).  
  
 El <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> se incluye en la colección de controlador de token predeterminada; sin embargo, puede reemplazarlo con un controlador de token de sesión personalizada si especifica primero una [ &lt;quitar&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md) elemento bajo el [ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) elemento que se va a quitar el controlador predeterminado de la colección y, a continuación, agregar el controlador de token personalizado usando el [ &lt;agregar&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) elemento. De forma predeterminada, puede especificar la duración del token predeterminado mediante la inclusión de la [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) elemento bajo el `<add>` elemento. Puede diseñar un controlador de token personalizado tomar elementos de configuración personalizados en el `<add>` elemento invalidando el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A> método para proporcionar la lógica para procesarlos.  
  
   
  
## Examples  
 El siguiente XML muestra cómo reemplazar el controlador de token predeterminado sesión seguridad en una colección de controlador de token con una instancia de la <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler> clase en la configuración.  
  
```xml  
<securityTokenHandlers>  
  <remove type="System.IdentityModel.Tokens.SessionSecurityTokenHandler, System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  <add type="System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
</securityTokenHandlers>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityTokenCache" />
    <altmember cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />
    <altmember cref="T:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler" />
    <altmember cref="T:System.IdentityModel.CookieTransform" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> que usa las transformaciones de cookie predeterminadas y la duración del token.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> y <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> propiedades se inicializan en <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime> y <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformaciones que se van a aplicar al codificar o descodificar la cookie. Establece la propiedad <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> que usa las transformaciones de cookie especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> se inicializa en <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionSecurityTokenHandler (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; transforms, TimeSpan tokenLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; transforms, valuetype System.TimeSpan tokenLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.CookieTransform},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (transforms As ReadOnlyCollection(Of CookieTransform), tokenLifetime As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionSecurityTokenHandler(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms, TimeSpan tokenLifetime);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;" />
        <Parameter Name="tokenLifetime" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformaciones que se van a aplicar al codificar o descodificar la cookie. Establece la propiedad <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />.</param>
        <param name="tokenLifetime">Duración predeterminada para un token. Establece la propiedad <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> que usa las transformaciones de cookie especificadas y la duración del token.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transforms" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="tokenLifetime" /> es menor o igual que <see cref="F:System.TimeSpan.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyTransforms">
      <MemberSignature Language="C#" Value="protected virtual byte[] ApplyTransforms (byte[] cookie, bool outbound);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] ApplyTransforms(unsigned int8[] cookie, bool outbound) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ApplyTransforms (cookie As Byte(), outbound As Boolean) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ApplyTransforms(cli::array &lt;System::Byte&gt; ^ cookie, bool outbound);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Byte[]" />
        <Parameter Name="outbound" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cookie">Cookie que se transformará.</param>
        <param name="outbound">
          <see langword="true" /> si se debe codificar la cookie; <see langword="false" /> si se debe descodificar la cookie.</param>
        <summary>Aplique las transformaciones especificadas por la propiedad de <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> a la cookie especificada para codificarla o descodificarla.</summary>
        <returns>Cookie codificada o descodificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se transforma la codificación de una cookie se aplican en el orden en que aparecen en la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> propiedad. Al descodificar una cookie, estas se aplican en el orden inverso.  
  
 Llamar desde el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> y <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> métodos para codificar y descodificar el material de cookie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public override bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> sobre el <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> de entrada. El lector debe colocarse en un elemento <see langword="&lt;wsc:SecurityContextToken&gt;" />.</param>
        <summary>Devuelve un valor que indica si el lector está colocado en un elemento <see langword="&lt;wsc:SecurityContextToken&gt;" /> .</summary>
        <returns>
          <see langword="true" /> si el lector apunta a un elemento <see langword="&lt;wsc:SecurityContextToken&gt;" /> ; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public override bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este controlador admite la validación de tokens de tipo <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value>
          <see langword="true" /> si el controlador admite la validación de tokens de tipo <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />; en caso contrario, <see langword="false" />. Siempre es <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public override bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este controlador puede escribir tokens de tipo <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <value>
          <see langword="true" /> si el controlador puede escribir tokens de tipo <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />; en caso contrario, <see langword="false" />. Siempre es <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieElementName">
      <MemberSignature Language="C#" Value="public virtual string CookieElementName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieElementName" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieElementName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del elemento de la cookie.</summary>
        <value>Nombre para mostrar de la cookie. El nombre de elemento predeterminado es "Cookie".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se utiliza en el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> y <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> métodos para determinar el elemento en la que se debe escribir o leer el material codificado de símbolo (token).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CookieNamespace">
      <MemberSignature Language="C#" Value="public virtual string CookieNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CookieNamespace" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CookieNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CookieNamespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el espacio de nombres del elemento de la cookie.</summary>
        <value>Espacio de nombres del elemento de la cookie. El espacio de nombres predeterminado es "http://schemas.microsoft.com/ws/2006/05/security".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se utiliza en el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%2A> y <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%2A> métodos para determinar el espacio de nombres del elemento en la que se debe escribir o leer el material codificado de símbolo (token).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
        <altmember cref="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, string endpointId, valuetype System.DateTime validFrom, valuetype System.DateTime validTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.String,System.DateTime,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, endpointId As String, validFrom As DateTime, validTo As DateTime) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, System::String ^ endpointId, DateTime validFrom, DateTime validTo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="endpointId" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="principal">La entidad de seguridad de notificaciones.</param>
        <param name="context">Cadena de contexto definida por el autor de la llamada.</param>
        <param name="endpointId">Identificador del extremo que es el ámbito del token.</param>
        <param name="validFrom">Instante de tiempo en el que el token es válido.</param>
        <param name="validTo">Instante de tiempo después del cual el token ya no es válido.</param>
        <summary>Crea un objeto <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> basándose en la entidad de seguridad de notificaciones especificada y en el intervalo de tiempo durante el que el token es válido.</summary>
        <returns>El token de seguridad de sesión creado. Las propiedades del nuevo token de la sesión se establecen según los parámetros especificados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Descriptor de token a partir del que se va a crear el token.</param>
        <summary>Crea un token de seguridad basándose en el descriptor de token especificado.</summary>
        <returns>Token de seguridad que se creó. Será una instancia de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea y devuelve un token de seguridad de la sesión mediante el uso de las siguientes propiedades del descriptor del token: <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A?displayProperty=nameWithType>, y <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A?displayProperty=nameWithType>. Si el <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.SaveBootstrapContext%2A?displayProperty=nameWithType> se establece la propiedad `true` en la configuración del controlador de token especificada por el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propiedad, se crea el contexto de arranque desde el <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Token%2A?displayProperty=nameWithType> propiedad y se guarda en el token de sesión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tokenDescriptor" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultCookieTransforms">
      <MemberSignature Language="C#" Value="public static readonly System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; DefaultCookieTransforms" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultCookieTransforms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultCookieTransforms As ReadOnlyCollection(Of CookieTransform) " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ DefaultCookieTransforms;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Una colección de solo lectura que contiene la lista de transformaciones predeterminadas que se aplican a las cookies, a <see cref="T:System.IdentityModel.DeflateCookieTransform" /> y a <see cref="T:System.IdentityModel.ProtectedDataCookieTransform" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultLifetime">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan DefaultLifetime;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan DefaultLifetime" />
      <MemberSignature Language="DocId" Value="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultLifetime As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan DefaultLifetime;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Una constante que especifica la duración predeterminada para las cookies, diez horas.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultTokenLifetime">
      <MemberSignature Language="C#" Value="public static TimeSpan DefaultTokenLifetime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan DefaultTokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultTokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultTokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan DefaultTokenLifetime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la duración predeterminada del token.</summary>
        <value>Duración predeterminada del token. Siempre es <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public override string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el URI de tipo de token para los tipos de token que este controlador puede procesar.</summary>
        <returns>URI de tipo de token para los tipos de token que este controlador puede procesar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se admiten los URI de tipo siguiente: "http://schemas.microsoft.com/ws/2006/05/servicemodel/tokens/SecureConversation","http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct", y "http://schemas.xmlsoap.org/ws/2005/02/sc/sct".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public override void LoadCustomConfiguration (System.Xml.XmlNodeList customConfigElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList customConfigElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub LoadCustomConfiguration (customConfigElements As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void LoadCustomConfiguration(System::Xml::XmlNodeList ^ customConfigElements);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customConfigElements" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="customConfigElements">Elementos de configuración personalizados.</param>
        <summary>Carga la configuración personalizado de XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamado por la infraestructura de configuración para inicializar la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> instancia. Inicializa el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> propiedad desde el `lifetime` atributo de la [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) elemento en el archivo de configuración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customConfigElements" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La configuración especificada por la <paramref name="customConfigElements" /> no es válida. Por ejemplo, no contiene un elemento de <see langword="&lt;sessionTokenRequirement&gt;" />, contiene más de un elemento de <see langword="&lt;sessionTokenRequirement&gt;" />, un valor válido de <see cref="T:System.TimeSpan" /> no se puede leer en el atributo de <see langword="lifetime" /> o el atributo de <see langword="lifetime" /> especifica un valor inferior a <see cref="F:System.TimeSpan.Zero" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada deserializa el token de WS-Secure Conversation Feb2005 o de WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> sobre el <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> de entrada.</param>
        <summary>Lee <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> utilizando el lector de XML especificado.</summary>
        <returns>El token de seguridad de la sesión que se leyó, una instancia de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El lector debe estar situado en una conversación WS-Secure, Feb2005 o un WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` elemento.  
  
 La implementación predeterminada, se invoca el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType> método con una resolución de tokens de forma predeterminada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">El lector no está situado en un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> o <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> no se puede leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (byte[] token, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(unsigned int8[] token, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Byte[],System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (token As Byte(), tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(cli::array &lt;System::Byte&gt; ^ token, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.Byte[]" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="token">La secuencia de bytes que contiene el token.</param>
        <param name="tokenResolver">Solucionador del token que se usará.</param>
        <summary>Lee el <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> de una secuencia de bytes mediante el solucionador de token especificado.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> que se leyó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada crea un <xref:System.Xml.XmlDictionaryReader> sobre el token e invoca el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken%28System.Xml.XmlReader%2CSystem.IdentityModel.Selectors.SecurityTokenResolver%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public override System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> sobre el <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> de entrada.</param>
        <param name="tokenResolver">
          <see cref="T:System.IdentityModel.Selectors.SecurityTokenResolver" /> que puede usarse para resolver <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Lee <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> mediante el lector XML especificado y la resolución de token.</summary>
        <returns>El token de seguridad de la sesión que se leyó, una instancia de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El lector debe estar situado en una conversación WS-Secure, Feb2005 o un WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` elemento.  
  
 Si el material de símbolo (token) se almacena en caché, se lee desde la caché de tokens, que es una instancia de la <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache> clase. En caso contrario, el material de token se lee desde el elemento secundario de la `<wsc:SecurityContextToken>` elemento especificado por la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A> y <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A> propiedades y <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> método se invoca para descodificar la cookie.  
  
 Para obtener más información acerca de cómo se serializan los símbolos de sesión en un `<SecurityContextToken` elemento, vea la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="tokenResolver" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">El lector no está situado en un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> o <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> no se puede leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetTransforms">
      <MemberSignature Language="C#" Value="protected void SetTransforms (System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt; transforms);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTransforms(class System.Collections.Generic.IEnumerable`1&lt;class System.IdentityModel.CookieTransform&gt; transforms) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.SetTransforms(System.Collections.Generic.IEnumerable{System.IdentityModel.CookieTransform})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTransforms (transforms As IEnumerable(Of CookieTransform))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTransforms(System::Collections::Generic::IEnumerable&lt;System::IdentityModel::CookieTransform ^&gt; ^ transforms);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transforms" Type="System.Collections.Generic.IEnumerable&lt;System.IdentityModel.CookieTransform&gt;" />
      </Parameters>
      <Docs>
        <param name="transforms">Transformaciones que se van a usar.</param>
        <summary>Establece las transformaciones que se aplicarán a las cookies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establece la lista de transformaciones devuelto por la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms%2A> propiedad. Las transformaciones se aplicarán en el orden en que aparecen en la lista al codificar una cookie y en el orden inverso al descodificar una cookie.  
  
> [!WARNING]
>  Si el `transforms` parámetro es `null`, se producirá una excepción desde el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> método cuando se llama a codificar o descodificar la cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenLifetime">
      <MemberSignature Language="C#" Value="public virtual TimeSpan TokenLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TokenLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TokenLifetime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property TimeSpan TokenLifetime { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la duración de token.</summary>
        <value>Duración del token. El valor predeterminado es <see cref="F:System.IdentityModel.Tokens.SessionSecurityTokenHandler.DefaultLifetime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, si la [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) se especifica en el archivo de configuración, la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenLifetime%2A> propiedad se inicializa en el valor de la `lifetime` atributo por el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.LoadCustomConfiguration%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produce un intento de establecer un el intervalo de tiempo menor o igual que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public override Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ TokenType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de los tokens que este controlador procesa.</summary>
        <value>
          <see cref="T:System.Type" /> de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transforms">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt; Transforms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.CookieTransform&gt; Transforms" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.Transforms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transforms As ReadOnlyCollection(Of CookieTransform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ Transforms { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::CookieTransform ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.CookieTransform&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las transformaciones que se aplicarán a la cookie.</summary>
        <value>Lista de transformaciones que se aplicarán a la cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las transformaciones se aplican en el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSession">
      <MemberSignature Language="C#" Value="protected virtual void ValidateSession (System.IdentityModel.Tokens.SessionSecurityToken securityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateSession(class System.IdentityModel.Tokens.SessionSecurityToken securityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateSession (securityToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateSession(System::IdentityModel::Tokens::SessionSecurityToken ^ securityToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="securityToken">Token que se va a comprobar.</param>
        <summary>Determina si la sesión asociada al token especificado sigue siendo válida. La validez se determina comprobando las propiedades <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> y <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> del token especificado. Se produce una excepción si la sesión ya no es válida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El token no es válido si su <xref:System.IdentityModel.Tokens.SecurityToken.ValidFrom%2A> propiedad está establecida en un valor que se produce después de <xref:System.DateTime.UtcNow%2A>, o si su <xref:System.IdentityModel.Tokens.SecurityToken.ValidTo%2A> propiedad está establecida en un valor que se produce anteriores a <xref:System.DateTime.UtcNow%2A>.  
  
 Llamar desde el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A> métodos para validar la sesión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityToken" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenNotYetValidException">La propiedad <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidFrom" /> del token es posterior a <see cref="P:System.DateTime.UtcNow" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenExpiredException">La propiedad <see cref="P:System.IdentityModel.Tokens.SecurityToken.ValidTo" /> del token es anterior a <see cref="P:System.DateTime.UtcNow" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Valida un token y devuelve sus notificaciones.</summary>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public override System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token que se va a validar. Debe poder asignarse desde <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Valida el token especificado y devuelve sus notificaciones.</summary>
        <returns>Las identidades que se encuentran en el token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se invoca el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateSession%2A> método para validar el token.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" />
          <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> no es asignable desde <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SessionSecurityToken token, string endpointId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SessionSecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SessionSecurityToken, endpointId As String) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SessionSecurityToken ^ token, System::String ^ endpointId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="endpointId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Token que se va a validar. Debe poder asignarse desde <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <param name="endpointId">Identificador del extremo que es el ámbito del token.</param>
        <summary>Valida el token de sesión especificado y devuelve sus notificaciones.</summary>
        <returns>Las identidades que se encuentran en el token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Realiza una comprobación para asegurarse de que el token especificado tiene un ámbito para el identificador de punto de conexión especificada y, si es así, se invoca el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%28System.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> método; de lo contrario, produce una <xref:System.IdentityModel.Tokens.SecurityTokenException>.  
  
> [!IMPORTANT]
>  Símbolos de sesión que tienen un <xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A> propiedad `null` o vacíos se consideran para ser un ámbito global. Esto presenta riesgos de seguridad. Por este motivo debe asegurarse de que el <xref:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId%2A> propiedad se establece en sus tokens de sesión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="token" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="endpointId" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> no es asignable desde <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</exception>
        <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">La propiedad <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.EndpointId" /> del token especificado no es <see langword="null" /> o no está vacía y su valor es diferente al que especifica el parámetro <paramref name="endpointId" /> .</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanValidateToken" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serializa un token.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada, el token serializa en un WS-Secure Conversation Feb2005 o WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual byte[] WriteToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] WriteToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (sessionToken As SessionSecurityToken) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ WriteToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Token que se va a escribir.</param>
        <summary>Serializa el token especificado en una matriz de bytes.</summary>
        <returns>Una matriz de bytes codificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializa el token especificado mediante la creación y el sistema de escritura XML sobre un <xref:System.IO.MemoryStream> e invocando el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken%28System.Xml.XmlWriter%2CSystem.IdentityModel.Tokens.SecurityToken%29?displayProperty=nameWithType> método. Consulte esa sobrecarga para obtener más detalles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessiontoken" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public override void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SessionSecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Sistema de escritura de XML para serializar el token.</param>
        <param name="token">Token que se va a serializar. Instancia de <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</param>
        <summary>Serializa el token especificado mediante el sistema de escritura especificado XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada, el token especificado serializa como WS-Secure Conversation Feb2005 o WS-Secure Conversation 1.3 `<wsc:SecurityContextToken>` elemento, dependiendo del valor de la <xref:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion%2A?displayProperty=nameWithType> propiedad. El <xref:System.IdentityModel.Tokens.SessionSecurityToken.Id%2A?displayProperty=nameWithType> propiedad se serializa como el `Id` atributo. El <xref:System.IdentityModel.Tokens.SessionSecurityToken.ContextId%2A?displayProperty=nameWithType> propiedad se serializa como el `<Identifier>` elemento secundario. Si no `null` el <xref:System.IdentityModel.Tokens.SessionSecurityToken.KeyGeneration%2A?displayProperty=nameWithType> propiedad se serializa como un `<Instance>` elemento. Por último, si la <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propiedad es `false`, todo el token se serializa en una matriz binaria que se pasa a la <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ApplyTransforms%2A> método que se desea codificar. El token codificado, a continuación, se escribe como un valor codificado en base64 en el elemento y el espacio de nombres especificado por el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieElementName%2A> y <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CookieNamespace%2A> propiedades. Si el <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propiedad es `true`, no se serializa el token.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="token" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="token" /> no es asignable desde <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.  
  
 O bien  
  
 La propiedad <see cref="P:System.IdentityModel.Tokens.SessionSecurityToken.SecureConversationVersion" /> del token especifica una versión de WS- Secure Conversation que no admite el controlador.</exception>
        <altmember cref="P:System.IdentityModel.Tokens.SessionSecurityTokenHandler.CanWriteToken" />
      </Docs>
    </Member>
  </Members>
</Type>