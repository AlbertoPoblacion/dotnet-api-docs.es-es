<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0c79f213d3f161955116c54a6c327ec3259dc61c" />
    <Meta Name="ms.sourcegitcommit" Value="1afcc8f9041ff3093fd13fb0afda92ac188878a9" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="09/06/2018" />
    <Meta Name="ms.locfileid" Value="43850455" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>La clase base abstracta para los controladores de token de seguridad.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Tokens.SecurityTokenHandler> es la clase base desde la seguridad de todos los controladores de token derivan. Un controlador de token de seguridad es responsable de:  
  
-   Validación de tokens de seguridad (<xref:System.IdentityModel.Tokens.SecurityToken>) del tipo está diseñado para procesar y empaquetado de las notificaciones contenidas en el token en un <xref:System.Security.Claims.ClaimsIdentity> objeto.  
  
-   Serializar y deserializar los tokens de seguridad del tipo está diseñado para procesar.  
  
-   Serializar y deserializar las cláusulas de identificador de clave (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>) que hacen referencia a tokens del tipo está diseñado para procesar y viceversa `<wsse:SecurityTokenReference>` elementos.  
  
-   Creación de tokens de seguridad desde un <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> objeto pasado por implementaciones de la <xref:System.IdentityModel.SecurityTokenService> clase.  
  
-   Creación de cláusulas de identificador de clave de un token de seguridad para las implementaciones de la <xref:System.IdentityModel.SecurityTokenService> clase.  
  
 Windows Identity Foundation (WIF) incluye los siguientes controladores de token de seguridad de fábrica:  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 La mayoría de estas clases expone a miembros adicionales que implementan la funcionalidad que es específica para el procesamiento de los tokens para el que la clase está diseñada. En muchos casos, es posible que convenga derivar de una de estas clases en lugar de directamente desde el <xref:System.IdentityModel.Tokens.SecurityTokenHandler> clase.  
  
 Un controlador de token de seguridad se puede agregar o quitar de una colección de controladores de token especificando el [ &lt;agregar&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [ &lt;quitar&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md), o [ &lt;borrar&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md) elementos bajo la [ &lt;securityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) elemento en un archivo de configuración. El <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> puede acceder al objeto que contiene los valores de configuración de la colección de controladores a través de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propiedad y la colección de controladores que el controlador de token es un miembro de se pueden acceder desde el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> propiedad. Puede invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> método para procesar los elementos de configuración personalizada que toma el controlador.  
  
 La <xref:System.IdentityModel.Tokens.SecurityTokenHandler> clase expone varias otras propiedades y métodos. Dependiendo de la funcionalidad que desee implementar, puede invalidar algunos o todos estos miembros.  
  
 Se debe reemplazar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> propiedad y el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> método para proporcionar la infraestructura WIF con información sobre el tipo de token de seguridad que su clase está diseñada para procesar.  
  
 Validación, la serialización y deserialización funcionalidad se expone a través de las propiedades o métodos que indican si el controlador puede realizar una función específica que se combina con el método o métodos que implementan la funcionalidad. La siguiente lista de pares de las propiedades o métodos que indican la funcionalidad con los métodos que implementan dicha funcionalidad:  
  
-   El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> propiedad y el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método: valida un token y empaqueta las notificaciones contenidas en el token en un <xref:System.Security.Claims.ClaimsIdentity>.  
  
-   El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> propiedad y el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> métodos: serialización del Token.  
  
-   El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> métodos y <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> métodos: símbolo (token) de deserialización.  
  
-   El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A> método y el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> método: deserializar las cláusulas de identificador de clave.  
  
-   El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> método y el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> método: serializar las cláusulas de identificador de clave.  
  
 El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> y <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> se llama a métodos de la canalización en las implementaciones de la <xref:System.IdentityModel.SecurityTokenService> clase.  
  
 El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> se llama al método por la infraestructura WIF para determinar si se ha recibido el token especificado. De forma predeterminada, este método devuelve `false`, lo que indica que el token ya no se ha recibido. Puede invalidar el método y proporcionar lógica para detectar tokens reproducidos.  
  
   
  
## Examples  
 Los ejemplos de código en todos los <xref:System.IdentityModel.Tokens.SecurityTokenHandler> temas se toman de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md). El siguiente XML muestra cómo agregar el controlador de token SWT a la colección de controladores de token.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Se llama desde constructores de clases derivadas para inicializar la clase <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lector XML situado en el elemento de inicio. Este método no debe avanzar el lector.</param>
        <summary>Devuelve un valor que indica si el elemento XML al que hace referencia el lector XML especificado es una cláusula de identificador de clave que esta instancia puede deserializar.</summary>
        <returns>
          <see langword="true" /> si el método <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" /> puede leer el elemento; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve `false` para indicar que no se puede leer la cláusula de identificador de clave.  
  
 Una clase derivada, comprueba el elemento al que el lector se hace referencia con el fin de determinar si la instancia puede deserializar una cláusula de identificador de clave. Normalmente, esto se logra mediante una llamada a la <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType> método con las cadenas adecuadas de elemento y espacio de nombres especificado. Si invalida <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> método para proporcionar la lógica para deserializar la cláusula de identificador de clave.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si el token especificado se puede deserializar como token del tipo procesado por esta instancia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">La cadena de token para leer.</param>
        <summary>Devuelve un valor que indica si la cadena especificada se puede deserializar como token del tipo procesado por esta instancia.</summary>
        <returns>
          <see langword="true" /> si el método <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" /> puede leer el elemento; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada siempre devuelve `false`.  
  
 Si invalida este método, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> método para proporcionar la lógica para deserializar el token.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lector XML situado en un elemento de inicio. Este método no debe avanzar el lector.</param>
        <summary>Devuelve un valor que indica si el elemento XML al que el lector XML especificado hace referencia se puede leer como token del tipo procesado por esta instancia.</summary>
        <returns>
          <see langword="true" /> si el método <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" /> puede leer el elemento; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada siempre devuelve `false`.  
  
 Una clase derivada, comprueba el elemento al que el lector se hace referencia con el fin de determinar si la instancia puede deserializar un token de seguridad. Normalmente, esto se logra mediante una llamada a la <xref:System.Xml.XmlReader.IsStartElement%2A> método con las cadenas adecuadas de elemento y espacio de nombres especificado. Si invalida <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> método o la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> método para proporcionar la lógica para deserializar la cláusula de identificador de clave.  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> método para determinar si se puede leer un token mediante un controlador. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el identificador admite la validación de tokens de seguridad.</summary>
        <value>
          <see langword="true" /> si la clase es capaz de validar tokens de seguridad; si no, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para implementar la validación en una clase derivada, invalide esta propiedad para devolver `true` e invalidar la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método para implementar la lógica de validación.  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> propiedad para indicar que un controlador personalizado puede validar tokens. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">Cláusula de identificador de clave que se va a activar.</param>
        <summary>Devuelve un valor que indica si la instancia puede serializar la cláusula de identificador de clave especificada.</summary>
        <returns>
          <see langword="true" /> si se puede serializar la cláusula de identificador clave; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada siempre devuelve `false`.  
  
 Si invalida <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> método para proporcionar la lógica para serializar la cláusula de identificador de clave.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el identificador puede serializar tokens de seguridad.</summary>
        <value>Es <see langword="true" /> si la clase es capaz de realizar la serialización de tokens; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para implementar la serialización en una clase derivada, invalide esta propiedad para devolver `true` e invalidar la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> métodos para implementar la lógica de serialización.  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> propiedad para indicar que un controlador personalizado puede serializar tokens. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" /> que proporciona la configuración de la instancia actual.</summary>
        <value>El objeto de configuración de la instancia actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> normalmente se establece la propiedad por la infraestructura de configuración de la [ &lt;securityTokenHandlerConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) inician el elemento en el archivo de configuración durante la aplicación.  
  
 En las clases derivadas, use el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propiedad para acceder a la configuración; por ejemplo, el registro de nombre del emisor para usar en el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método se puede acceder desde el <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType> propiedad del objeto de configuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección controladores de token que contiene la instancia actual.</summary>
        <value>La colección de controladores de token que contiene la instancia actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se agrega el controlador de token a un <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection> instancia, esta propiedad se establece automáticamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">El token para el que se va a crear la referencia.</param>
        <param name="attached">
          <see langword="true" /> si se debe crear una referencia adjunta; <see langword="false" /> si se debe crear una referencia sin adjuntar.</param>
        <summary>Cuando se reemplaza en una clase derivada, crea la referencia del token de seguridad para tokens procesados por esa clase. Un servicio de token de seguridad (STS) llama normalmente a este método.</summary>
        <returns>Cláusula de identificador de clave que hace referencia al token especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 Las clases derivadas invalidar este método para devolver una cláusula de identificador de clave (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>) que puede utilizarse para crear un `<wsse:SecurityTokenReference>` (elemento) para el token especificado.  
  
 Se llama desde las implementaciones de la <xref:System.IdentityModel.SecurityTokenService> clase.  
  
 Normalmente, un <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> no necesita ser utilizado, excepto cuando se crea un servicio de token de seguridad personalizado. Cuando un servicio de token de seguridad devuelve un token de seguridad, el token de seguridad emitido contiene las referencias a los tokens de seguridad adjuntas y no adjuntas. Las referencias adjuntas hacen referencia a los tokens de seguridad que están contenidos dentro del encabezado de seguridad de un mensaje SOAP y las referencias no adjuntas hacen referencia a tokens de seguridad que no están incluidos dentro del encabezado de seguridad de un mensaje SOAP. Normalmente, estas referencias afirman la autenticidad del token de seguridad emitido.  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> método para crear una cláusula de identificador de clave del token especificado. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">El descriptor de token de seguridad del que se va a crear el token. Las propiedades del descriptor de token se establecen antes de llamar a este método.</param>
        <summary>Cuando se reemplaza en una clase derivada, crea un token de seguridad usando el descriptor del token especificado. Un servicio de token de seguridad (STS) llama a este método.</summary>
        <returns>Token de seguridad que coincide con las propiedades del descriptor de token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 Se llama desde las implementaciones de la <xref:System.IdentityModel.SecurityTokenService> clase.  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> método para crear y devolver un token de un descriptor de token. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">El token cuya reproducción se va a comprobar.</param>
        <summary>Cuando se reemplaza en una clase derivada, produce una excepción si el token especificado se detecta como que se está volviendo a reproducir.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada no hace nada.  
  
 Las clases derivadas se deben producir una <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> si ya se ha utilizado el token.  
  
 Windows Identity Foundation (WIF) proporciona la <xref:System.IdentityModel.Tokens.TokenReplayCache> clase desde qué reproducción se pueden derivar las memorias caché y la [ &lt;tokenReplayCache&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) elemento de configuración, que se puede usar para configurar el memoria caché de reproducción utilizada por los controladores de token en una aplicación; Sin embargo, la implementación exacta de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> método es hasta el Diseñador de la clase derivada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, devuelve el conjunto de identificadores URI que se usan en solicitudes para identificar un token del tipo procesado por la clase derivada.</summary>
        <returns>El conjunto de URI que identifican el tipo de token que este controlador admite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Type> del token procesado por la instancia actual se accede a través del <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> propiedad. El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> método devuelve el conjunto de identificadores aceptables que se puede usar en los mensajes para hacer referencia al tipo de token. Por ejemplo, el valor del URI utilizado en el `<wst:TokenType>` elemento bajo el `<wst:RequestSecurityToken>` elemento para solicitar un tipo específico de token (representado por la <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType> propiedad del modelo de objetos).  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> método para devolver los identificadores de tipo de token para un token personalizado. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">Elementos XML de configuración. Todos los nodos de la lista son de tipo <see cref="T:System.Xml.XmlElement" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, carga la configuración personalizada de XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> se llama al método mediante la infraestructura de configuración. Cuando se llama a este método, el `nodelist` contendrá los elementos secundarios de nivel superior de la del controlador de token [ &lt;agregar&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) elemento desde el archivo de configuración. A su vez, cada una de ellas puede, contener atributos o elementos secundarios según el esquema de configuración que define para la clase derivada.  
  
 La implementación predeterminada inicia un <xref:System.NotImplementedException>. Invalide este método en una clase derivada para habilitar la inicialización del controlador de token de seguridad desde un archivo de configuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Un lector XML colocado en el elemento inicial del XML que se va a deserializar en la cláusula del identificador de clave.</param>
        <summary>Cuando se reemplaza en una clase derivada, deserializa el código XML al que hace referencia el lector XML especificado en una cláusula de identificador de clave que hace referencia a un token procesado por la clase derivada.</summary>
        <returns>Cláusula de identificador de clave que se deserializó de XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 Invalide este método para proporcionar la lógica para deserializar una cláusula de identificador de clave desde XML. Si invalida este método, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, deserializa el XLM especificado a un token del tipo procesado por la clase derivada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Cadena que se va a deserializar.</param>
        <summary>Cuando se reemplaza en una clase derivada, deserializa la cadena especificada a un token del tipo procesado por la clase derivada.</summary>
        <returns>El token de seguridad que se ha deserializado desde la cadena especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 Invalide este método para proporcionar la funcionalidad que puede deserializar un token de seguridad de una cadena. Si se reemplaza, este método, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Lector XML situado en el elemento de inicio del token.</param>
        <summary>Cuando se reemplaza en una clase derivada, deserializa el código XML al que hace referencia el lector XML a un token del tipo procesado por la clase derivada.</summary>
        <returns>El token de seguridad que se ha deserializado desde XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 Invalide este método para proporcionar la lógica para deserializar un token de seguridad de XML. Si invalida este método, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> método. Normalmente, en las clases derivadas, si el método no puede deserializar el token del archivo XML que se hace referencia, genera un <xref:System.Xml.XmlException>.  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> método para leer un token personalizado desde el lector XML especificado. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Lector XML situado en el elemento de inicio del token.</param>
        <param name="tokenResolver">Una resolución de tokens que contiene los tokens fuera de banda y almacenados en memoria caché.</param>
        <summary>Cuando se reemplaza en una clase derivada, deserializa el código XML al que hace referencia el lector XML especificado en token del tipo procesado por la clase derivada mediante el solucionador de token especificado.</summary>
        <returns>El token de seguridad que se ha deserializado desde XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 La implementación predeterminada omite la `tokenResolver` parámetro y delega la llamada a la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> método.  
  
 Invalide este método para proporcionar la lógica para deserializar un token de seguridad de XML. Si invalida este método, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> método. Normalmente, en las clases derivadas, si el método no puede deserializar el token del archivo XML que se hace referencia, genera un <xref:System.Xml.XmlException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene el tipo del token de seguridad que procesa esta instancia.</summary>
        <value>El tipo de token de seguridad procesados por esta instancia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe invalidar esta propiedad en las clases derivadas y devolver el <xref:System.Type> del token de seguridad (<xref:System.IdentityModel.Tokens.SecurityToken>) que es procesado por la clase derivada.  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> propiedad para devolver el <xref:System.Type> de los tokens de seguridad que se procesan mediante un controlador personalizado. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">El token de seguridad que se está validando.</param>
        <param name="errorMessage">Mensaje que se va a escribir en el seguimiento.</param>
        <summary>Hace un seguimiento del evento de error durante la validación de tokens de seguridad cuando está habilitado el seguimiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe llamarse desde el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método cuando se produce un error de validación del token.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">El token que se validó.</param>
        <summary>Hace un seguimiento de la validación correcta del evento de tokens de seguridad cuando está habilitado el seguimiento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe llamarse desde el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método después de que se ha validado correctamente el token.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token que se va a validar.</param>
        <summary>Cuando se reemplaza en una clase derivada, valida el token de seguridad especificado. El token debe ser del tipo procesado por la clase derivada.</summary>
        <returns>Identidades contenidas en el token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 El <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> se llama al método por la infraestructura para validar y extraer las notificaciones del token de seguridad deserializado. Estas notificaciones se devuelven en la colección de <xref:System.Security.Claims.ClaimsIdentity> los objetos devueltos por el método. En el caso típico, esta colección contendrá una identidad única.  
  
 En las clases derivadas, validación normalmente incluye la validación de los destinatarios especificados en el símbolo (token) frente a la audiencia URI especificados en el <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType> propiedad del objeto de configuración de controlador de token especificado en el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propiedad. Normalmente se establecen en el archivo de configuración de estos URI el [ &lt;audienceUris&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) elemento. Si no se puede validar la audiencia, un <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> se produce la excepción.  
  
 Al procesar el token, el emisor normalmente se valida al pasar el token del emisor en uno de los <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> métodos en el <xref:System.IdentityModel.Tokens.IssuerNameRegistry> objeto que está configurado para el controlador a través de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> propiedad. El registro de nombre del emisor se configura normalmente a través de la [ &lt;issuerNameRegistry&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) elemento en el archivo de configuración. El <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> devuelve el nombre del emisor. Este nombre se debe utilizar para establecer el <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType> propiedad en las notificaciones contenidas en el token. Si el registro de nombre del emisor no contiene una entrada para el token del emisor, <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> devuelve `null`. En este caso un <xref:System.IdentityModel.Tokens.SecurityTokenException> normalmente se produce en las clases derivadas, pero este comportamiento es hasta el Diseñador de la clase.  
  
   
  
## Examples  
 El código siguiente muestra un reemplazo del <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método para un controlador de token de seguridad que procesa tokens web simples (SWT). El código se toma de la `CustomToken` ejemplo. Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 El siguiente código muestra `CreateClaims` método que se invoca desde la invalidación de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método en el ejemplo anterior. Este método devuelve un <xref:System.Security.Claims.ClaimsIdentity> objeto que se crea a partir de las notificaciones del token. El código se toma de la `CustomToken` ejemplo. Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 El siguiente código muestra `ValidateSignature` método que se invoca desde la invalidación de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método en el controlador de token web simple. Este método valida la firma del token mediante el uso de la configurada <xref:System.IdentityModel.Tokens.IssuerTokenResolver>. El código se toma de la `CustomToken` ejemplo. Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 El siguiente código muestra `ValidateAudience` método que se invoca desde la invalidación de la <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> método en el controlador de token web simple. Este método valida la audiencia contenida en el símbolo (token) frente a la audiencia de los identificadores URI que se han especificado en la configuración. El código se toma de la `CustomToken` ejemplo. Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">Sistema de escritura XML.</param>
        <param name="securityKeyIdentifierClause">Cláusula de identificador de clave que se va a serializar.</param>
        <summary>Cuando se invalida en una clase derivada, serializa la cláusula del identificador de clave especificada a XML. La cláusula de identificador de clave debe ser del tipo admitido por la clase derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 Invalide este método para proporcionar la lógica para serializar una cláusula de identificador de clave para XML. Si invalida este método, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, serializa el token de seguridad especificado. El token debe ser del tipo procesado por la clase derivada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Token que se va a serializar.</param>
        <summary>Cuando se reemplaza en una clase derivada, serializa el token de seguridad especificado en una cadena. El token debe ser del tipo procesado por la clase derivada.</summary>
        <returns>Token que se va a serializar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 Invalide este método para proporcionar la lógica para serializar un token de seguridad en XML. Si invalida este método, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Sistema de escritura XML.</param>
        <param name="token">Token que se va a serializar.</param>
        <summary>Cuando se reemplaza en una clase derivada, serializa el token de seguridad especificado en XML. El token debe ser del tipo procesado por la clase derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, este método produce una <xref:System.NotImplementedException> excepción.  
  
 Invalide este método para proporcionar la lógica para serializar un token de seguridad en XML. Si invalida este método, también debe invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> propiedad.  
  
   
  
## Examples  
 El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> método para serializar un token personalizado. El código se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT). Para obtener información acerca de este ejemplo y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>