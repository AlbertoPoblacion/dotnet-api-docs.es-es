<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileIO.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e86466a1b5ea6c2c263a964d27b2380119678142" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36299043" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileIO.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona propiedades y métodos para trabajar con unidades, archivos y directorios.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem` objeto.  
  
|En|Vea|  
|-|-|  
|Leer de un archivo de texto|[Leer de archivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Leer de un archivo de texto delimitado|[Leer archivos de texto delimitado por comas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Leer de un archivo de texto de ancho fijo|[Leer archivos de texto de ancho fijo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Leer de un archivo de texto con varios formatos|[Leer archivos de texto con varios formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Leer de un archivo binario|[Leer archivos binarios](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Leer de un archivo de texto con un <xref:System.IO.StreamReader>|[Leer texto de archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Escribir en un archivo de texto|[Escribir texto en archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar a un archivo de texto|[Anexar a archivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Escribir en un archivo binario|[Escribir en archivos binarios](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Escribir en archivos de texto en el **Mis documentos** directory|[Escribir texto en archivos del directorio Mis documentos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Escribir en un archivo de texto con un `StreamWriter`|[Escribir texto en archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Copiar archivos con un modelo concreto|[Copiar archivos con un modelo específico en un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Copiar un archivo en el mismo directorio|[Crear una copia de un archivo en el mismo directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente|[Crear una copia de un archivo en un directorio diferente](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Crear un archivo|[Crear un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Eliminar un archivo|[Eliminar un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Buscar archivos con un modelo concreto|[Buscar archivos con un modelo concreto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Mover un archivo|[Mover archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Cambiar el nombre de un archivo|[Cambiar el nombre de un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Copiar un directorio en otro directorio|[Copiar un directorio en otro directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Crear un directorio|[Crear un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Buscar subdirectorios con un modelo concreto|[Buscar subdirectorios con un modelo concreto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Obtener la colección de archivos de un directorio|[Obtener la colección de archivos de un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Leer desde la **Mis documentos** directory|[Recuperar el contenido del directorio Mis documentos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analizar una ruta de acceso de archivo|[Analizar rutas de acceso a archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Este ejemplo se comprueba para determinar si la carpeta `C:\backup\logs` existe y se comprueban sus propiedades.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystem ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [Objetos (Visual Basic)](http://msdn.microsoft.com/library/651c73e4-dca8-402b-9c6b-e3902b3a3f4b)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public static string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory">
          <see langword="String" />. Primera ruta de acceso que se va a combinar.</param>
        <param name="relativePath">
          <see langword="String" />. Segunda ruta de acceso que se va a combinar.</param>
        <summary>Combina dos rutas de acceso y devuelve una ruta de acceso con un formato correcto.</summary>
        <returns>Combinación de las rutas de acceso especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método quita caracteres de exceso de marca de barra diagonal para crear una ruta de acceso con el formato correcto.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.CombinePath` método.  
  
|En|Vea|  
|-|-|  
|Combinar un nombre de archivo y ruta de directorio|[Cómo: analizar rutas de acceso de archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Este ejemplo combina un nombre de archivo y ruta de directorio para crear una ruta de acceso con el formato correcto.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 Este ejemplo combina dos rutas de acceso para crear una ruta de acceso con el formato correcto.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Este ejemplo devuelve `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseDirectory" /> o <paramref name="relativePath" /> son rutas de acceso incorrectas.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia el contenido de un directorio en otro directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Directorio que se va a copiar.</param>
        <param name="destinationDirectoryName">Ubicación donde se va a copiar el contenido del directorio.</param>
        <summary>Copia el contenido de un directorio en otro directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia el contenido del directorio de origen en el directorio de destino. Si el directorio de destino no existe, se crea. Si existe un directorio con el mismo nombre en la ubicación de destino, se combina el contenido de los dos directorios. Puede especificar un nuevo nombre para el directorio durante la operación.  
  
 Cuando copie archivos contenidos en un directorio, se pueden producir excepciones se producen por un archivo concreto. Cuando se producen dichas excepciones, se consolidan en una excepción única cuya `Data` propiedad contiene entradas en forma de un <xref:System.Collections.IDictionary> en el que la ruta de acceso de archivo o directorio es la clave y el mensaje de excepción concreta se encuentra en el valor correspondiente. Use `For…Each` para enumerar las entradas.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.CopyDirectory` método.  
  
|En|Vea|  
|-|-|  
|Copiar un directorio|[Cómo: copiar un directorio en otro directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 El siguiente ejemplo copia el contenido del directorio `TestDirectory1` en `TestDirectory2`, sobrescribiendo los archivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Reemplace `C:\TestDirectory1` y `C:\TestDirectory2` con la ruta de acceso y el nombre del directorio que se va a copiar y la ubicación a la que desea copiarlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de origen no existe.</exception>
        <exception cref="T:System.IO.IOException">La ruta de acceso de origen y la ruta de acceso de destino son iguales.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de carpeta de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Existe un archivo de destino pero no se puede obtener acceso a él.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Directorio que se va a copiar.</param>
        <param name="destinationDirectoryName">Ubicación donde se va a copiar el contenido del directorio.</param>
        <param name="showUI">Indica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copia el contenido de un directorio en otro directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia el contenido del directorio de origen en el directorio de destino. Si el directorio de destino no existe, se crea. Si existe un directorio con el mismo nombre en la ubicación de destino, se combina el contenido de los dos directorios. Puede especificar un nuevo nombre para el directorio durante la operación.  
  
 Cuando copie archivos contenidos en un directorio, se pueden producir excepciones se producen por un archivo concreto. Cuando se producen dichas excepciones, se consolidan en una excepción única cuya `Data` propiedad contiene entradas en forma de un <xref:System.Collections.IDictionary> en el que la ruta de acceso de archivo o directorio es la clave y el mensaje de excepción concreta se encuentra en el valor correspondiente. Use `For…Each` para enumerar las entradas.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.CopyDirectory` método.  
  
|En|Vea|  
|-|-|  
|Copiar un directorio|[Cómo: copiar un directorio en otro directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 El siguiente ejemplo copia el contenido del directorio `TestDirectory1` en `TestDirectory2`, sobrescribiendo los archivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Reemplace `C:\TestDirectory1` y `C:\TestDirectory2` con la ruta de acceso y el nombre del directorio que se va a copiar y la ubicación a la que desea copiarlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de origen no existe.</exception>
        <exception cref="T:System.IO.IOException">La ruta de acceso de origen y la ruta de acceso de destino son iguales.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de carpeta de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Existe un archivo de destino pero no se puede obtener acceso a él.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> está establecido en <see langword="UIOption.AllDialogs" /> y el usuario cancela la operación o no se puede copiar uno o más archivos del directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Directorio que se va a copiar.</param>
        <param name="destinationDirectoryName">Ubicación donde se va a copiar el contenido del directorio.</param>
        <param name="overwrite">
          <see langword="True" /> para sobrescribir los archivos existentes; de lo contrario, <see langword="False" />. El valor predeterminado es <see langword="False" />.</param>
        <summary>Copia el contenido de un directorio en otro directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia el contenido del directorio de origen en el directorio de destino. Si el directorio de destino no existe, se crea. Si existe un directorio con el mismo nombre en la ubicación de destino, se combina el contenido de los dos directorios. Puede especificar un nuevo nombre para el directorio durante la operación.  
  
 Cuando copie archivos contenidos en un directorio, puede producir excepciones que se producen por un archivo concreto, como un archivo existente durante una mezcla mientras se `overwrite` está establecido en `False`. Cuando se producen dichas excepciones, se consolidan en una excepción única cuya `Data` propiedad contiene entradas en forma de un <xref:System.Collections.IDictionary> en el que la ruta de acceso de archivo o directorio es la clave y el mensaje de excepción concreta se encuentra en el valor correspondiente. Use `For…Each` para enumerar las entradas.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.CopyDirectory` método.  
  
|En|Vea|  
|-|-|  
|Copiar un directorio|[Cómo: copiar un directorio en otro directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 El siguiente ejemplo copia el contenido del directorio `TestDirectory1` en `TestDirectory2`, sobrescribiendo los archivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Reemplace `C:\TestDirectory1` y `C:\TestDirectory2` con la ruta de acceso y el nombre del directorio que se va a copiar y la ubicación a la que desea copiarlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de origen no existe.</exception>
        <exception cref="T:System.IO.IOException">La ruta de acceso de origen y la ruta de acceso de destino son iguales.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de carpeta de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Existe un archivo de destino pero no se puede obtener acceso a él.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public static void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Directorio que se va a copiar.</param>
        <param name="destinationDirectoryName">Ubicación donde se va a copiar el contenido del directorio.</param>
        <param name="showUI">Indica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica la acción que se va a realizar cuando el usuario haga clic en **Cancelar** durante la operación. El valor predeterminado es <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copia el contenido de un directorio en otro directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia el contenido del directorio de origen en el directorio de destino. Si el directorio de destino no existe, se crea. Si existe un directorio con el mismo nombre en la ubicación de destino, se combina el contenido de los dos directorios. Puede especificar un nuevo nombre para el directorio durante la operación.  
  
 Cuando copie archivos contenidos en un directorio, se pueden producir excepciones se producen por un archivo concreto. Cuando se producen dichas excepciones, se consolidan en una excepción única cuya `Data` propiedad contiene entradas en forma de un <xref:System.Collections.IDictionary> en el que la ruta de acceso de archivo o directorio es la clave y el mensaje de excepción concreta se encuentra en el valor correspondiente. Use `For…Each` para enumerar las entradas.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.CopyDirectory` método.  
  
|En|Vea|  
|-|-|  
|Copiar un directorio|[Cómo: copiar un directorio en otro directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 El siguiente ejemplo copia el contenido del directorio `TestDirectory1` en `TestDirectory2`, sobrescribiendo los archivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Reemplace `C:\TestDirectory1` y `C:\TestDirectory2` con la ruta de acceso y el nombre del directorio que se va a copiar y la ubicación a la que desea copiarlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de origen no existe.</exception>
        <exception cref="T:System.IO.IOException">La ruta de acceso de origen y la ruta de acceso de destino son iguales.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de carpeta de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Existe un archivo de destino pero no se puede obtener acceso a él.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="ShowUI" /> está establecido en <see langword="UIOption.AllDialogs" /> y el usuario cancela la operación o no se puede copiar uno o más archivos del directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un archivo en una nueva ubicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Archivo que se va a copiar.</param>
        <param name="destinationFileName">Ubicación en la que se va a copiar el archivo.</param>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` no se conserva la ACE (entradas de Control de acceso). El archivo recién creado hereda las entradas ACE predeterminadas desde el directorio en el que se crea.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyFile` método.  
  
|En|Vea|  
|-|-|  
|Copiar un archivo en el mismo directorio.|[Cómo: crear una copia de un archivo en el mismo directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente.|[Cómo: crear una copia de un archivo en un directorio diferente en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` sin sobrescribir archivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Reemplace las rutas de acceso de archivo con las rutas de acceso que desea utilizar en el código.  
  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` y cambie el nombre `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Reemplace las rutas de acceso de archivo con las rutas de acceso que desea utilizar en el código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de código de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">Hay un archivo en uso con el mismo nombre en el directorio de destino.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Archivo que se va a copiar.</param>
        <param name="destinationFileName">Ubicación en la que se va a copiar el archivo.</param>
        <param name="showUI">Indica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` no se conserva la ACE (entradas de Control de acceso). El archivo recién creado hereda las entradas ACE predeterminadas desde el directorio en el que se crea.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyFile` método.  
  
|En|Vea|  
|-|-|  
|Copiar un archivo en el mismo directorio.|[Cómo: crear una copia de un archivo en el mismo directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente.|[Cómo: crear una copia de un archivo en un directorio diferente en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` sin sobrescribir archivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Reemplace las rutas de acceso de archivo con las rutas de acceso que desea utilizar en el código.  
  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` y cambie el nombre `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Reemplace las rutas de acceso de archivo con las rutas de acceso que desea utilizar en el código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de código de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo de destino existe y <paramref name="overwrite" /> se establece en <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Archivo que se va a copiar.</param>
        <param name="destinationFileName">Ubicación en la que se va a copiar el archivo.</param>
        <param name="overwrite">
          <see langword="True" /> si deben sobrescribirse los archivos existentes; de lo contrario, <see langword="False" />. El valor predeterminado es <see langword="False" />.</param>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` no se conserva la ACE (entradas de Control de acceso). El archivo recién creado hereda las entradas ACE predeterminadas desde el directorio en el que se crea.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyFile` método.  
  
|En|Vea|  
|-|-|  
|Copiar un archivo en el mismo directorio.|[Cómo: crear una copia de un archivo en el mismo directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente.|[Cómo: crear una copia de un archivo en un directorio diferente en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` sin sobrescribir archivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Reemplace las rutas de acceso de archivo con las rutas de acceso que desea utilizar en el código.  
  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` y cambie el nombre `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Reemplace las rutas de acceso de archivo con las rutas de acceso que desea utilizar en el código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de código de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo de destino existe y <paramref name="overwrite" /> se establece en <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public static void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Archivo que se va a copiar.</param>
        <param name="destinationFileName">Ubicación en la que se va a copiar el archivo.</param>
        <param name="showUI">Indica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica la acción que se va a realizar cuando el usuario haga clic en **Cancelar** durante la operación. El valor predeterminado es <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` no se conserva la ACE (entradas de Control de acceso). El archivo recién creado hereda las entradas ACE predeterminadas desde el directorio en el que se crea.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyFile` método.  
  
|En|Vea|  
|-|-|  
|Copiar un archivo en el mismo directorio.|[Cómo: crear una copia de un archivo en el mismo directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente.|[Cómo: crear una copia de un archivo en un directorio diferente en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` sin sobrescribir archivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Reemplace las rutas de acceso de archivo con las rutas de acceso que desea utilizar en el código.  
  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` y cambie el nombre `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Reemplace las rutas de acceso de archivo con las rutas de acceso que desea utilizar en el código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de código de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo de destino existe y <paramref name="overwrite" /> se establece en <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="UICancelOption" /> está establecido en <see langword="ThrowException" /> y el usuario ha cancelado la operación o se ha producido un error de E/S no especificado.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDirectory(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nombre y ubicación del directorio.</param>
        <summary>Crea un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el directorio ya existe, no se produce ninguna excepción.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.CreateDirectory` método.  
  
|En|Vea|  
|-|-|  
|Crear un directorio|[Cómo: crear un directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 Este ejemplo crea el directorio `NewDirectory`, en `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre del directorio es incorrecto. Por ejemplo, contiene caracteres no válidos o está compuesto solo por espacios en blanco.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">El nombre del directorio es demasiado largo.</exception>
        <exception cref="T:System.NotSupportedException">El nombre de directorio consta sólo de dos puntos (:).</exception>
        <exception cref="T:System.IO.IOException">El directorio principal del directorio que se va a crear es de solo lectura.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene permiso para crear el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el directorio actual.</summary>
        <value>Directorio actual para las operaciones de E/S de archivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` es una variable de entorno de todo el sistema.  
  
   
  
## Examples  
 Este ejemplo devuelve el directorio actual y lo muestra en un cuadro de mensaje.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 Este ejemplo establece el directorio actual a `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso no es válida.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio que se va a eliminar.</param>
        <param name="onDirectoryNotEmpty">Especifica qué se hace cuando un directorio que se va a eliminar contiene archivos o directorios. El valor predeterminado es <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Elimina un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo se elimina el directorio `OldDirectory` sólo si está vacío.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido, pidiendo al usuario que confirme la eliminación, pero no envía el contenido a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido, enviarlos a la **Papelera de reciclaje**, pero no se muestra el progreso de la operación.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso es una cadena de longitud cero, es incorrecta, contiene solo espacios en blanco o contiene caracteres no válidos (incluidos los caracteres comodín). La ruta de acceso es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe o es un archivo.</exception>
        <exception cref="T:System.IO.IOException">Un archivo del directorio o subdirectorio está en uso.</exception>
        <exception cref="T:System.NotSupportedException">El nombre de directorio contiene dos puntos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios.</exception>
        <exception cref="T:System.OperationCanceledException">El usuario cancela la operación o no se puede eliminar el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio que se va a eliminar.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica si el archivo eliminado se va a enviar o no a la **Papelera de reciclaje**. El valor predeterminado es <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Elimina un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `showUI` y `recycle` parámetros no se admiten en aplicaciones que no son interactivas, como los servicios de Windows con el usuario.  
  
   
  
## Examples  
 En el ejemplo se elimina el directorio `OldDirectory` sólo si está vacío.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido, pidiendo al usuario que confirme la eliminación, pero no envía el contenido a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido, enviarlos a la **Papelera de reciclaje**, pero no se muestra el progreso de la operación.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso es una cadena de longitud cero, es incorrecta, contiene solo espacios en blanco o contiene caracteres no válidos (incluidos los caracteres comodín). La ruta de acceso es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe o es un archivo.</exception>
        <exception cref="T:System.IO.IOException">Un archivo del directorio o subdirectorio está en uso.</exception>
        <exception cref="T:System.NotSupportedException">El nombre de directorio contiene dos puntos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios.</exception>
        <exception cref="T:System.OperationCanceledException">El usuario cancela la operación o no se puede eliminar el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public static void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio que se va a eliminar.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica si el archivo eliminado se va a enviar o no a la **Papelera de reciclaje**. El valor predeterminado es <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Especifica si se va a producir una excepción cuando el usuario haga clic en **Cancelar**.</param>
        <summary>Elimina un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `showUI`, `recycle`, y `onUserCancel` parámetros no se admiten en aplicaciones que no son interactivas, como los servicios de Windows con el usuario.  
  
   
  
## Examples  
 En el ejemplo se elimina el directorio `OldDirectory` sólo si está vacío.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido, pidiendo al usuario que confirme la eliminación, pero no envía el contenido a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 Este ejemplo elimina el directorio `OldDirectory` y todo su contenido, enviarlos a la **Papelera de reciclaje**, pero no se muestra el progreso de la operación.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso es una cadena de longitud cero, es incorrecta, contiene solo espacios en blanco o contiene caracteres no válidos (incluidos los caracteres comodín). La ruta de acceso es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe o es un archivo.</exception>
        <exception cref="T:System.IO.IOException">Un archivo del directorio o subdirectorio está en uso.</exception>
        <exception cref="T:System.NotSupportedException">El nombre de directorio contiene dos puntos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios.</exception>
        <exception cref="T:System.OperationCanceledException">El usuario cancela la operación o no se puede eliminar el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso al archivo que se va a eliminar.</param>
        <summary>Elimina un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.DeleteFile` método.  
  
|En|Vea|  
|-|-|  
|Para eliminar un archivo|[Cómo: eliminar un archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo elimina el archivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este ejemplo elimina el archivo `Test.txt` y permite al usuario que confirme que el archivo debe eliminarse.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este ejemplo elimina el archivo `Test.txt` y lo envía a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; tiene una barra diagonal final a partir de la cual se debe especificar un archivo; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene permiso para eliminar el archivo o el archivo es de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso al archivo que se va a eliminar.</param>
        <param name="showUI">Indica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica si el archivo eliminado se va a enviar o no a la **Papelera de reciclaje**. El valor predeterminado es <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Elimina un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `showUI` y `recycle` parámetros no se admiten en aplicaciones que no son interactivas, como los servicios de Windows con el usuario.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.DeleteFile` método.  
  
|En|Vea|  
|-|-|  
|Para eliminar un archivo|[Cómo: eliminar un archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo elimina el archivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este ejemplo elimina el archivo `Test.txt` y permite al usuario que confirme que el archivo debe eliminarse.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este ejemplo elimina el archivo `Test.txt` y lo envía a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; tiene una barra diagonal final a partir de la cual se debe especificar un archivo; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene permiso para eliminar el archivo o el archivo es de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public static void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso al archivo que se va a eliminar.</param>
        <param name="showUI">Indica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica si el archivo eliminado se va a enviar o no a la **Papelera de reciclaje**. El valor predeterminado es <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Especifica si se va a producir una excepción cuando el usuario cancele la operación. El valor predeterminado es <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Elimina un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `showUI`, `recycle`, y `onUserCancel` parámetros no se admiten en aplicaciones que no son interactivas, como los servicios de Windows con el usuario.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.DeleteFile` método.  
  
|En|Vea|  
|-|-|  
|Para eliminar un archivo|[Cómo: eliminar un archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo elimina el archivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este ejemplo elimina el archivo `Test.txt` y permite al usuario que confirme que el archivo debe eliminarse.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este ejemplo elimina el archivo `Test.txt` y lo envía a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; tiene una barra diagonal final a partir de la cual se debe especificar un archivo; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene permiso para eliminar el archivo o el archivo es de solo lectura.</exception>
        <exception cref="T:System.OperationCanceledException">El usuario ha cancelado la operación y el parámetro <paramref name="onUserCancel" /> está establecido en <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public static bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DirectoryExists(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Ruta de acceso al directorio.</param>
        <summary>Devuelve <see langword="True" /> si el directorio especificado existe.</summary>
        <returns>Es <see langword="True" /> si existe el directorio; en caso contrario, es <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se determina si el directorio `C:\backup\logs` existe y se comprueban sus propiedades.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.FileIO.FileSystem.Drives" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve una colección de sólo lectura de todos los nombres de unidad disponibles.</summary>
        <value>Colección de solo lectura de todas las unidades disponibles, especificadas como objetos <see cref="T:System.IO.DriveInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve todas las unidades lógicas.  
  
   
  
## Examples  
 Este ejemplo muestra los nombres de unidad disponible en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None" />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public static bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FileExists(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso al archivo.</param>
        <summary>Devuelve <see langword="True" /> si el archivo especificado existe.</summary>
        <returns>Devuelve <see langword="True" /> si el archivo existe; de lo contrario, este método devuelve <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la aplicación no tiene permisos suficientes para leer el archivo especificado, el `FileExists` método `False`, sin tener en cuenta la existencia de la ruta de acceso; el método no produce una excepción.  
  
   
  
## Examples  
 Este ejemplo se comprueba para ver si el archivo `Check.txt` existe y proporciona la información en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre del archivo finaliza con una barra diagonal inversa (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección de cadenas de sólo lectura que representa los nombres de los archivos que contienen el texto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio en el que se va a buscar.</param>
        <param name="containsText">Texto de búsqueda.</param>
        <param name="ignoreCase">
          <see langword="True" /> si la búsqueda debe distinguir entre mayúsculas y minúsculas; de lo contrario, <see langword="False" />. El valor predeterminado es <see langword="True" />.</param>
        <param name="searchType">Indica si se van a incluir las subcarpetas. El valor predeterminado es <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Devuelve una colección de cadenas de sólo lectura que representa los nombres de los archivos que contienen el texto especificado.</summary>
        <returns>Colección de solo lectura de los nombres de los archivos que contienen el texto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentran archivos que coincidan con el patrón especificado, se devuelve una colección vacía.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.FindInFiles` método.  
  
|En|Vea|  
|-|-|  
|Buscar un directorio de archivos que contienen una cadena concreta|[Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md) (Tutorial: Manipular archivos y directorios en Visual Basic)|  
  
   
  
## Examples  
 Este ejemplo busca en el directorio `C:\TestDir` para los archivos que contiene la cadena `"sample string"` y muestra los resultados en `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Para que funcione, el proyecto debe contener una `ListBox` denominado `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero, solo contiene un espacio en blanco, contiene caracteres no válidos o es una ruta de acceso de dispositivo (empieza por <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio especificado apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">La ruta de acceso del directorio especificada contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Directorio en el que se va a buscar.</param>
        <param name="containsText">Texto de búsqueda.</param>
        <param name="ignoreCase">
          <see langword="True" /> si la búsqueda debe distinguir entre mayúsculas y minúsculas; de lo contrario, <see langword="False" />. El valor predeterminado es <see langword="True" />.</param>
        <param name="searchType">Indica si se van a incluir las subcarpetas. El valor predeterminado es <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Modelo con el que hay que coincidir.</param>
        <summary>Devuelve una colección de cadenas de sólo lectura que representa los nombres de los archivos que contienen el texto especificado.</summary>
        <returns>Colección de solo lectura de los nombres de los archivos que contienen el texto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentran archivos que coincidan con el patrón especificado, se devuelve una colección vacía.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.FindInFiles` método.  
  
|En|Vea|  
|-|-|  
|Buscar un directorio de archivos que contienen una cadena concreta|[Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md) (Tutorial: Manipular archivos y directorios en Visual Basic)|  
  
   
  
## Examples  
 Este ejemplo busca en el directorio `C:\TestDir` para los archivos que contiene la cadena `"sample string"` y muestra los resultados en `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Para que funcione, el proyecto debe contener una `ListBox` denominado `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero, solo contiene un espacio en blanco, contiene caracteres no válidos o es una ruta de acceso de dispositivo (empieza por <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio especificado apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">La ruta de acceso del directorio especificada contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección de cadenas que representan los nombres de las rutas de acceso a los subdirectorios de un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Nombre y ruta de acceso al directorio.</param>
        <summary>Devuelve una colección de cadenas que representan los nombres de las rutas de acceso a los subdirectorios de un directorio.</summary>
        <returns>Colección de solo lectura de los nombres de ruta de acceso a los subdirectorios dentro del directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.GetDirectories` método.  
  
|En|Vea|  
|-|-|  
|Mostrar los subdirectorios con un modelo concreto|[Cómo: buscar subdirectorios con un modelo específico en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 El ejemplo siguiente devuelve todos los directorios en la estructura de directorios que contienen la palabra `Logs` en sus nombres y los agrega a `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio especificado apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Nombre y ruta de acceso al directorio.</param>
        <param name="searchType">Indica si se van a incluir las subcarpetas. El valor predeterminado es <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Modelo para comparar los nombres.</param>
        <summary>Devuelve una colección de cadenas que representan los nombres de las rutas de acceso a los subdirectorios de un directorio.</summary>
        <returns>Colección de solo lectura de los nombres de ruta de acceso a los subdirectorios dentro del directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el parámetro `wildcards` para especificar un patrón concreto. Si quiere incluir el contenido de subdirectorios en la búsqueda, establezca el parámetro `searchType` en `SearchAllSubDirectories`.  
  
 Se devuelve una colección vacía si no se encuentra ningún directorio que coincida con el modelo especificado.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.GetDirectories` método.  
  
|En|Vea|  
|-|-|  
|Mostrar los subdirectorios con un modelo concreto|[Cómo: buscar subdirectorios con un modelo específico en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 El ejemplo siguiente devuelve todos los directorios en la estructura de directorios que contienen la palabra `Logs` en sus nombres y los agrega a `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Uno o más de los caracteres comodín especificados es <see langword="Nothing" />, una cadena vacía o contiene solo espacios.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio especificado apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">
          <see langword="String" />. Ruta de acceso al directorio.</param>
        <summary>Devuelve un objeto <see cref="T:System.IO.DirectoryInfo" /> de la ruta de acceso especificada.</summary>
        <returns>Objeto <see cref="T:System.IO.DirectoryInfo" /> para la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el directorio no existe, se produce una excepción no hasta la primera vez que una propiedad el <xref:System.IO.DirectoryInfo> tener acceso al objeto.  
  
   
  
## Examples  
 Este ejemplo se obtiene un <xref:System.IO.DirectoryInfo> objeto para el directorio `C:\Documents and Settings` y muestra el directorio hora de creación, última hora de acceso y última hora de escritura.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">La ruta de acceso del directorio contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public static System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Unidad que se va a examinar.</param>
        <summary>Devuelve un objeto <see cref="T:System.IO.DriveInfo" /> de la unidad especificada.</summary>
        <returns>Objeto <see cref="T:System.IO.DriveInfo" /> para la unidad especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.IO.DriveInfo> clase modela una unidad y proporciona métodos y propiedades para consultar información de la unidad. Utilice <xref:System.IO.DriveInfo> para determinar qué unidades están disponibles y qué tipo de unidades son. También puede consultar la propiedad para determinar la capacidad y el espacio libre disponible en la unidad.  
  
   
  
## Examples  
 Este ejemplo se obtiene un <xref:System.IO.DriveInfo> objeto para la unidad C y lo utiliza para mostrar información acerca de la unidad.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Para obtener información sobre los tipos de unidad diferente, consulte <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="drive" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public static System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso al archivo.</param>
        <summary>Devuelve un objeto <see cref="T:System.IO.FileInfo" /> del archivo especificado.</summary>
        <returns>Objeto <see cref="T:System.IO.FileInfo" /> para el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se produce una excepción si el archivo no existe; en su lugar, se producirá la primera vez que se tiene acceso a las propiedades del objeto.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.GetFileInfo` método.  
  
|En|Vea|  
|-|-|  
|Determinar el nombre y la ruta de acceso de un archivo|[Cómo: analizar rutas de acceso de archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Este ejemplo recupera una <xref:System.IO.FileInfo?displayProperty=nameWithType> objeto para el archivo `MyLogFile.log` y se utiliza para notificar el nombre completo del archivo, hora del último acceso y longitud.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de la ruta de acceso es incorrecto. Por ejemplo, contiene caracteres no válidos o está compuesto solo por espacios en blanco. El nombre de archivo tiene un símbolo de barra oblicua final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.NotSupportedException">La ruta de acceso contiene un signo de dos puntos en el medio de la cadena.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso es demasiado larga.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene acceso de ACL (lista de control de acceso) al archivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección de cadenas de sólo lectura que representan los nombres de los archivos de un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio en el que se va a buscar.</param>
        <summary>Devuelve una colección de cadenas de sólo lectura que representan los nombres de los archivos de un directorio.</summary>
        <returns>Colección de solo lectura de los nombres de archivo del directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentran archivos que coincidan con el patrón especificado, se devuelve una colección vacía.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.GetFiles` método.  
  
|En|Vea|  
|-|-|  
|Obtener la colección de archivos de un directorio|[Cómo: obtener la colección de archivos en un directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Buscar archivos con un modelo específico en un directorio|[Cómo: buscar archivos con un modelo específico en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 En el siguiente ejemplo se devuelven todos los archivos contenidos en el directorio y se agregan a `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 Este ejemplo devuelve todos los archivos en el directorio con la extensión `.txt` y los agrega a `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio que se desea buscar no existe.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> señala a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Directorio en el que se va a buscar.</param>
        <param name="searchType">Indica si se van a incluir las subcarpetas. El valor predeterminado es <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Modelo con el que hay que coincidir.</param>
        <summary>Devuelve una colección de cadenas de sólo lectura que representan los nombres de los archivos de un directorio.</summary>
        <returns>Colección de solo lectura de los nombres de archivo del directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentran archivos que coincidan con el patrón especificado, se devuelve una colección vacía.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.GetFiles` método.  
  
|En|Vea|  
|-|-|  
|Obtener la colección de archivos de un directorio|[Cómo: obtener la colección de archivos en un directorio en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Buscar archivos con un modelo específico en un directorio|[Cómo: buscar archivos con un modelo específico en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 En el siguiente ejemplo se devuelven todos los archivos contenidos en el directorio y se agregan a `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 Este ejemplo devuelve todos los archivos en el directorio con la extensión `.txt` y los agrega a `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio que se desea buscar no existe.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="directory" /> señala a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Obligatorio. Ruta de acceso que se va a analizar. <see langword="String" />.</param>
        <summary>Analiza el nombre de archivo de la ruta de acceso proporcionada.</summary>
        <returns>Nombre de archivo desde la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de una operación de cadena; el `FileSystem` no se examina.  
  
 El `GetName` método omite una marca de barra diagonal que se producen al final de la ruta de acceso.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.GetFileName` método.  
  
|En|Vea|  
|-|-|  
|Analizar una ruta de acceso de archivo|[Cómo: analizar rutas de acceso de archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 En el ejemplo siguiente se analiza una ruta de acceso de archivo y devuelve el nombre del archivo.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Reemplace la ruta de acceso `C:\Testdirectory\Testfile` con la ruta de acceso que se va a analizar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public static string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetParentPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso que se va a examinar.</param>
        <summary>Devuelve la ruta de acceso primaria de la ruta de acceso especificada.</summary>
        <returns>Ruta de acceso primaria de la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de una operación de cadena; no se examina el sistema de archivos.  
  
   
  
## Examples  
 Este ejemplo obtiene la ruta de acceso principal `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no tiene una ruta de acceso primaria porque es una ruta de acceso raíz.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un archivo temporal de cero bytes y nombre único en el disco y devuelve la ruta de acceso completa a ese archivo.</summary>
        <returns>Un valor de tipo <see langword="String" /> que contiene la ruta de acceso completa del archivo temporal.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para crear un archivo temporal.  
  
   
  
## Examples  
 En este ejemplo se crea un archivo temporal y se devuelve su ruta de acceso.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ruta de acceso al directorio que se va a mover.</param>
        <param name="destinationDirectoryName">Ruta de acceso al directorio al que se va a mover el directorio de origen.</param>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se realiza un intento para mover un directorio dentro de un directorio que no existe, se creará la estructura de destino.  
  
   
  
## Examples  
 Este ejemplo se mueve `Directory1` en `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este ejemplo se mueve `Directory1` en `Directory2`, sobrescribiendo el directorio si ya existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">El origen es un directorio raíz o la ruta de acceso de origen y la ruta de acceso de destino son las mismas.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ruta de acceso al directorio que se va a mover.</param>
        <param name="destinationDirectoryName">Ruta de acceso al directorio al que se va a mover el directorio de origen.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se realiza un intento para mover un directorio dentro de un directorio que no existe, se creará la estructura de destino.  
  
   
  
## Examples  
 Este ejemplo se mueve `Directory1` en `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este ejemplo se mueve `Directory1` en `Directory2`, sobrescribiendo el directorio si ya existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio de destino ya existe y <paramref name="overwrite" /> está establecido en <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ruta de acceso al directorio que se va a mover.</param>
        <param name="destinationDirectoryName">Ruta de acceso al directorio al que se va a mover el directorio de origen.</param>
        <param name="overwrite">
          <see langword="True" /> si deben sobrescribirse los directorios existentes; de lo contrario, <see langword="False" />. El valor predeterminado es <see langword="False" />.</param>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se realiza un intento para mover un directorio dentro de un directorio que no existe, se creará la estructura de destino.  
  
   
  
## Examples  
 Este ejemplo se mueve `Directory1` en `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este ejemplo se mueve `Directory1` en `Directory2`, sobrescribiendo el directorio si ya existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio de destino ya existe y <paramref name="overwrite" /> está establecido en <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public static void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ruta de acceso al directorio que se va a mover.</param>
        <param name="destinationDirectoryName">Ruta de acceso al directorio al que se va a mover el directorio de origen.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica si se va a producir una excepción cuando el usuario cancele la operación. El valor predeterminado es <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se realiza un intento para mover un directorio dentro de un directorio que no existe, se creará la estructura de destino.  
  
   
  
## Examples  
 Este ejemplo se mueve `Directory1` en `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este ejemplo se mueve `Directory1` en `Directory2`, sobrescribiendo el directorio si ya existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="onUserCancel" /> está establecido en <see langword="ThrowException" /> y un subdirectorio del archivo no se puede copiar.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> está establecida en <see langword="ThrowException" /> y el usuario cancela la operación o ésta no se puede finalizar.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.CopyDirectory" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ruta de acceso al archivo que se va a mover.</param>
        <param name="destinationFileName">Ruta de acceso al directorio al que se moverá el archivo.</param>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la estructura de destino no existe, se crea.  
  
 El `MoveFile` método conserva ACE (entradas de Control de acceso) solo cuando se mueve el archivo dentro del mismo volumen. Esto incluye ACE heredadas, que se convierten en ACE directas cuando se mueven (las ACE directas tienen prioridad sobre las ACE heredadas). Si un archivo se mueve entre volúmenes, no se copiarán las ACE.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.MoveFile` método.  
  
|En|Vea|  
|-|-|  
|Mover un archivo|[Cómo: mover un archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 En este ejemplo se mueve el archivo `Test.txt` de `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 En este ejemplo se mueve el archivo `Test.txt` de `TestDir1` a `TestDir2` y cambie el nombre `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de código de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ruta de acceso al archivo que se va a mover.</param>
        <param name="destinationFileName">Ruta de acceso al directorio al que se moverá el archivo.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la estructura de destino no existe, se crea.  
  
 El `MoveFile` método conserva ACE (entradas de Control de acceso) solo cuando se mueve el archivo dentro del mismo volumen. Esto incluye ACE heredadas, que se convierten en ACE directas cuando se mueven (las ACE directas tienen prioridad sobre las ACE heredadas). Si un archivo se mueve entre volúmenes, no se copiarán las ACE.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.MoveFile` método.  
  
|En|Vea|  
|-|-|  
|Mover un archivo|[Cómo: mover un archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 En este ejemplo se mueve el archivo `Test.txt` de `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 En este ejemplo se mueve el archivo `Test.txt` de `TestDir1` a `TestDir2` y cambie el nombre `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de código de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ruta de acceso al archivo que se va a mover.</param>
        <param name="destinationFileName">Ruta de acceso al directorio al que se moverá el archivo.</param>
        <param name="overwrite">
          <see langword="True" /> para sobrescribir los archivos existentes; de lo contrario, <see langword="False" />. El valor predeterminado es <see langword="False" />.</param>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la estructura de destino no existe, se crea.  
  
 El `MoveFile` método conserva ACE (entradas de Control de acceso) solo cuando se mueve el archivo dentro del mismo volumen. Esto incluye ACE heredadas, que se convierten en ACE directas cuando se mueven (las ACE directas tienen prioridad sobre las ACE heredadas). Si un archivo se mueve entre volúmenes, no se copiarán las ACE.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.MoveFile` método.  
  
|En|Vea|  
|-|-|  
|Mover un archivo|[Cómo: mover un archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 En este ejemplo se mueve el archivo `Test.txt` de `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 En este ejemplo se mueve el archivo `Test.txt` de `TestDir1` a `TestDir2` y cambie el nombre `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de código de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public static void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ruta de acceso al archivo que se va a mover.</param>
        <param name="destinationFileName">Ruta de acceso al directorio al que se moverá el archivo.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica si se va a producir una excepción cuando el usuario cancele la operación. El valor predeterminado es <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la estructura de destino no existe, se crea.  
  
 El `MoveFile` método conserva ACE (entradas de Control de acceso) solo cuando se mueve el archivo dentro del mismo volumen. Esto incluye ACE heredadas, que se convierten en ACE directas cuando se mueven (las ACE directas tienen prioridad sobre las ACE heredadas). Si un archivo se mueve entre volúmenes, no se copiarán las ACE.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.MoveFile` método.  
  
|En|Vea|  
|-|-|  
|Mover un archivo|[Cómo: mover un archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 En este ejemplo se mueve el archivo `Test.txt` de `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 En este ejemplo se mueve el archivo `Test.txt` de `TestDir1` a `TestDir2` y cambie el nombre `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de código de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="onUserCancel" /> está establecido en <see langword="ThrowException" /> y el usuario ha cancelado la operación o se ha producido un error de E/S no especificado.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>El método <see langword="OpenTextFieldParser" /> permite crear un objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, que proporciona una forma sencilla y eficaz de analizar los archivos de texto estructurados como, por ejemplo, los registros. El objeto <see langword="TextFieldParser" /> puede utilizarse para leer los archivos de ancho fijo y delimitado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se va a abrir con <see langword="TextFieldParser" />.</param>
        <summary>El método <see langword="OpenTextFieldParser" /> permite crear un objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, que proporciona una forma sencilla y eficaz de analizar los archivos de texto estructurados, por ejemplo, los registros. El objeto <see langword="TextFieldParser" /> puede utilizarse para leer los archivos de ancho fijo y delimitado.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para leer el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|En|Vea|  
|-|-|  
|Leer de un archivo de texto delimitado|[Cómo: leer archivos de texto delimitado por comas en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Leer de un archivo de texto de ancho fijo|[Cómo: leer archivos de texto de ancho fijo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Leer de un archivo de texto con varios formatos|[Cómo: leer archivos de texto con varios formatos en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 En este ejemplo se abre la `TextFieldParser.reader` y se utiliza para leer de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">No se puede analizar una fila con el formato especificado. El mensaje de excepción especifica la línea que inicia la excepción, mientras que a la propiedad <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> se le asigna el texto incluido en la línea.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Describe un conjunto de permisos de seguridad aplicados al código. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Archivo que se va a abrir con <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Ancho de los campos.</param>
        <summary>El método <see langword="OpenTextFieldParser" /> permite crear un objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, que proporciona una forma sencilla y eficaz de analizar los archivos de texto estructurados como, por ejemplo, los registros. El objeto <see langword="TextFieldParser" /> puede utilizarse para leer los archivos de ancho fijo y delimitado.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para leer el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|En|Vea|  
|-|-|  
|Leer de un archivo de texto delimitado|[Cómo: leer archivos de texto delimitado por comas en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Leer de un archivo de texto de ancho fijo|[Cómo: leer archivos de texto de ancho fijo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Leer de un archivo de texto con varios formatos|[Cómo: leer archivos de texto con varios formatos en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 En este ejemplo se abre la `TextFieldParser.reader` y se utiliza para leer de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">No se puede analizar una fila con el formato especificado. El mensaje de excepción especifica la línea que inicia la excepción, mientras que a la propiedad <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> se le asigna el texto incluido en la línea.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Describe un conjunto de permisos de seguridad aplicados al código. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Archivo que se va a abrir con <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Delimitadores de los campos.</param>
        <summary>El método <see langword="OpenTextFieldParser" /> permite crear un objeto <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />, que proporciona una forma sencilla y eficaz de analizar los archivos de texto estructurados como, por ejemplo, los registros. El objeto <see langword="TextFieldParser" /> puede utilizarse para leer los archivos de ancho fijo y delimitado.</summary>
        <returns>
          <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para leer el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|En|Vea|  
|-|-|  
|Leer de un archivo de texto delimitado|[Cómo: leer archivos de texto delimitado por comas en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Leer de un archivo de texto de ancho fijo|[Cómo: leer archivos de texto de ancho fijo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Leer de un archivo de texto con varios formatos|[Cómo: leer archivos de texto con varios formatos en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 En este ejemplo se abre la `TextFieldParser.reader` y se utiliza para leer de `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">No se puede analizar una fila con el formato especificado. El mensaje de excepción especifica la línea que inicia la excepción, mientras que a la propiedad <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> se le asigna el texto incluido en la línea.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Describe un conjunto de permisos de seguridad aplicados al código. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un objeto <see cref="T:System.IO.StreamReader" /> para leer desde un archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se va a leer.</param>
        <summary>Abre un objeto <see cref="T:System.IO.StreamReader" /> para leer desde un archivo.</summary>
        <returns>Objeto <see cref="T:System.IO.StreamReader" /> que se va a leer del archivo</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo los archivos de texto que se puedan leer con un <xref:System.IO.StreamReader>.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.OpenTextFileReader` método.  
  
|En|Vea|  
|-|-|  
|Abrir un archivo con una <xref:System.IO.StreamReader>|[Cómo: leer texto de archivos con StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 En este ejemplo se abre el archivo `Testfile.txt`, lee una línea del mismo y se muestra la línea en un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de archivo finaliza con una barra diagonal inversa (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo especificado.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver leer en el archivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se va a leer.</param>
        <param name="encoding">Codificación que se va a usar para el contenido del archivo. El valor predeterminado es ASCII.</param>
        <summary>Abre un objeto <see cref="T:System.IO.StreamReader" /> para leer desde un archivo.</summary>
        <returns>Objeto <see cref="T:System.IO.StreamReader" /> que se va a leer del archivo</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo los archivos de texto que se puedan leer con un <xref:System.IO.StreamReader>.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.OpenTextFileReader` método.  
  
|En|Vea|  
|-|-|  
|Abrir un archivo con una <xref:System.IO.StreamReader>|[Cómo: leer texto de archivos con StreamReader (Visual Basic)](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 En este ejemplo se abre el archivo `Testfile.txt`, lee una línea del mismo y se muestra la línea en un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de archivo finaliza con una barra diagonal inversa (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo especificado.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver leer en el archivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un objeto <see cref="T:System.IO.StreamWriter" /> para escribir en el archivo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Archivo en el que se va a escribir.</param>
        <param name="append">
          <see langword="True" /> para anexar el contenido del archivo; <see langword="False" /> para sobrescribir el contenido del archivo. El valor predeterminado es <see langword="False" />.</param>
        <summary>Abre un objeto <see cref="T:System.IO.StreamWriter" /> para escribir en el archivo especificado.</summary>
        <returns>Objeto <see cref="T:System.IO.StreamWriter" /> que se va a escribir en el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `OpenTextFileWriter` método abre e Inicializa una secuencia para un archivo y, a continuación, devuelve el <xref:System.IO.StreamWriter> objeto para esa secuencia. Puede escribir en la secuencia tantas veces como sea necesario y, a continuación, cerrar cuando haya terminado.  
  
> [!NOTE]
>  Debe llamar a la <xref:System.IO.StreamWriter.Close%2A> método en la <xref:System.IO.StreamWriter> objeto para asegurarse de que todos los datos se escriben correctamente en la secuencia subyacente.  
  
 Si escribe solamente algunas cadenas en un archivo, puede que sea más fácil de usar el <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> método.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.OpenTextFileWriter` método.  
  
|En|Vea|  
|-|-|  
|Escribir texto en un archivo con una `StreamWriter`|[Cómo: escribir texto en archivos con un objeto StreamWriter en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 En este ejemplo se abre un <xref:System.IO.StreamWriter> con el `My.Computer.FileSystem.OpenTextFileWriter` método y lo utiliza para escribir una cadena en un archivo de texto con el `WriteLine` método de la `StreamWriter` clase.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de archivo finaliza con una barra oblicua final.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Archivo en el que se va a escribir.</param>
        <param name="append">
          <see langword="True" /> para anexar el contenido en el archivo; <see langword="False" /> para sobrescribir el contenido del archivo. El valor predeterminado es <see langword="False" />.</param>
        <param name="encoding">Codificación que se va a usar al escribir en el archivo. El valor predeterminado es ASCII.</param>
        <summary>Abre un objeto <see cref="T:System.IO.StreamWriter" /> para escribir en el archivo especificado.</summary>
        <returns>Objeto <see cref="T:System.IO.StreamWriter" /> que se va a escribir en el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `OpenTextFileWriter` método abre e Inicializa una secuencia para un archivo y, a continuación, devuelve el <xref:System.IO.StreamWriter> objeto para esa secuencia. Puede escribir en la secuencia tantas veces como sea necesario y, a continuación, cerrar cuando haya terminado.  
  
> [!NOTE]
>  Debe llamar a la <xref:System.IO.StreamWriter.Close%2A> método en la <xref:System.IO.StreamWriter> objeto para asegurarse de que todos los datos se escriben correctamente en la secuencia subyacente.  
  
 Si escribe solamente algunas cadenas en un archivo, puede que sea más fácil de usar el <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> método.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.OpenTextFileWriter` método.  
  
|En|Vea|  
|-|-|  
|Escribir texto en un archivo con una `StreamWriter`|[Cómo: escribir texto en archivos con un objeto StreamWriter en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 En este ejemplo se abre un <xref:System.IO.StreamWriter> con el `My.Computer.FileSystem.OpenTextFileWriter` método y lo utiliza para escribir una cadena en un archivo de texto con el `WriteLine` método de la `StreamWriter` clase.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de archivo finaliza con una barra oblicua final.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se va a leer.</param>
        <summary>Devuelve el contenido de un archivo como una matriz de bytes.</summary>
        <returns>Una matriz de <see langword="Byte" /> que contiene el contenido del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ReadAllBytes` método de la `My.Computer.FileSystem` objeto le permite leer de un archivo binario. El contenido del archivo se devuelve como una matriz de bytes.  
  
 No tome ninguna decisión sobre el contenido del archivo basándose en su nombre. Por ejemplo, es posible que el archivo Form1.vb no sea un archivo de código fuente de Visual Basic. Compruebe todas las entradas antes de utilizar los datos en la aplicación.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.ReadAllBytes` método.  
  
|En|Vea|  
|-|-|  
|Leer de un archivo binario|[Cómo: leer archivos binarios en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 Este ejemplo se lee desde el archivo `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el contenido de un archivo de texto como un objeto <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso al archivo que se va a leer.</param>
        <summary>Devuelve el contenido de un archivo de texto como un objeto <see langword="String" />.</summary>
        <returns>Un valor de tipo <see langword="String" /> que contiene el contenido del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método `ReadAllText` del objeto `My.Computer.FileSystem` permite leer de un archivo de texto. El contenido del archivo se devuelve como una cadena.  
  
 La codificación del archivo puede ser especificado si el contenido del archivo está en una codificación como ASCII o UTF-8. Si está leyendo de un archivo con caracteres extendidos, debe especificar la codificación del archivo utilizando otra sobrecarga de la <xref:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText%2A> método.  
  
 No tome ninguna decisión sobre el contenido del archivo basándose en su nombre. Por ejemplo, es posible que el archivo Form1.vb no sea un archivo de código fuente de Visual Basic. Compruebe todas las entradas antes de utilizar los datos en la aplicación.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.ReadAllText` método.  
  
|En|Vea|  
|-|-|  
|Leer de un archivo de texto|[Cómo: leer archivos de texto en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Este ejemplo lee el contenido de `Test.txt` en una cadena y, a continuación, se muestra en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Este ejemplo lee el contenido del archivo ASCII `Test.txt` en una cadena y, a continuación, se muestra en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso al archivo que se va a leer.</param>
        <param name="encoding">Codificación de caracteres que se usará al leer el archivo. El valor predeterminado es UTF-8.</param>
        <summary>Devuelve el contenido de un archivo de texto como un objeto <see langword="String" />.</summary>
        <returns>Un valor de tipo <see langword="String" /> que contiene el contenido del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método `ReadAllText` del objeto `My.Computer.FileSystem` permite leer de un archivo de texto. El contenido del archivo se devuelve como una cadena.  
  
 La codificación del archivo puede ser especificado si el contenido del archivo está en una codificación como ASCII o UTF-8. Si está leyendo de un archivo con caracteres extendidos, debe especificar la codificación del archivo.  
  
 No tome ninguna decisión sobre el contenido del archivo basándose en su nombre. Por ejemplo, es posible que el archivo Form1.vb no sea un archivo de código fuente de Visual Basic. Compruebe todas las entradas antes de utilizar los datos en la aplicación.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.ReadAllText` método.  
  
|En|Vea|  
|-|-|  
|Leer de un archivo de texto|[Cómo: leer archivos de texto en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 Este ejemplo lee el contenido de `Test.txt` en una cadena y, a continuación, se muestra en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Este ejemplo lee el contenido del archivo ASCII `Test.txt` en una cadena y, a continuación, se muestra en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public static void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Ruta de acceso y nombre del directorio cuyo nombre se va a cambiar.</param>
        <param name="newName">Nuevo nombre para el directorio.</param>
        <summary>Cambia el nombre de un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no se puede usar para mover un directorio; Utilice la `MoveDirectory` método para mover y cambiar el nombre del directorio.  
  
   
  
## Examples  
 Este ejemplo se cambia el `Test` directorio `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directory" /> es <see langword="Nothing" />.  -o bien- <paramref name="newName" /> es <see langword="Nothing" /> o una cadena vacía ("").</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">Ya hay un archivo o directorio con el nombre especificado en <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.MoveDirectory" />
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public static void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Archivo cuyo nombre se va a cambiar.</param>
        <param name="newName">Nuevo nombre de archivo.</param>
        <summary>Cambia el nombre de un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede usar este método para mover un archivo. Use el método <xref:Microsoft.VisualBasic.FileIO.FileSystem.MoveFile%2A> para mover y cambiar el nombre del archivo.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.RenameFile` método.  
  
|En|Vea|  
|-|-|  
|Cambiar el nombre de un archivo|[Cómo: cambiar el nombre de un archivo en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo cambia el nombre del archivo `Test.txt` a `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Cambie "`C:\Test.txt`" a la ruta de acceso y el nombre del archivo que desea cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="newName" /> contiene información de la ruta de acceso o finaliza con una barra diagonal inversa (\\).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.  -o bien- <paramref name="newName" /> es <see langword="Nothing" /> o una cadena vacía ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">Ya hay un archivo o directorio con el nombre especificado en <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Ruta de acceso y nombre del archivo en el que se va a escribir.</param>
        <param name="data">Datos que se van a escribir en el archivo.</param>
        <param name="append">
          <see langword="True" /> para anexar el contenido del archivo; <see langword="False" /> para sobrescribir el contenido del archivo. El valor predeterminado es <see langword="False" />.</param>
        <summary>Escribe datos en un archivo binario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ruta de acceso especificada, sin incluir el nombre de archivo no es válido, un <xref:System.IO.DirectoryNotFoundException> excepción. Si la ruta de acceso es válida, pero el archivo no existe, se crea el archivo.  
  
> [!NOTE]
>  El `WriteAllBytes` método abre un archivo, escribe en él y, a continuación, lo cierra. Código que usa el `WriteAllBytes` método es más sencillo que el código que usa un <xref:System.IO.BinaryWriter> objeto. Sin embargo, si va a agregar datos a un archivo mediante un bucle, un <xref:System.IO.BinaryWriter> objeto puede proporcionar un mejor rendimiento porque sólo tiene que abrir y cerrar el archivo una vez.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica el `My.Computer.FileSystem.WriteAllBytes` método.  
  
|En|Vea|  
|-|-|  
|Escribir en un archivo binario|[Cómo: escribir en archivos binarios en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 Este ejemplo anexa la matriz de datos `CustomerData` en el archivo `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe texto en un archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Archivo en el que se va a escribir.</param>
        <param name="text">Texto que se va a escribir en el archivo.</param>
        <param name="append">
          <see langword="True" /> para anexar el contenido del archivo; <see langword="False" /> para sobrescribir el contenido del archivo.</param>
        <summary>Escribe texto en un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codificación UTF-8 se utiliza para escribir en el archivo. Para especificar una codificación diferente, utilice una sobrecarga diferente de la <xref:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText%2A> método.  
  
 Si el archivo especificado no existe, se crea.  
  
 Si la codificación especificada no coincide con la codificación existente del archivo, se omite la codificación especificada.  
  
> [!NOTE]
>  El `WriteAllText` método abre un archivo, escribe en él y, a continuación, lo cierra. Código que usa el `WriteAllText` método es más sencillo que el código que usa un <xref:System.IO.StreamWriter> objeto. Sin embargo, si va a agregar cadenas a un archivo mediante el uso de un bucle, un <xref:System.IO.StreamWriter> objeto puede proporcionar un mejor rendimiento porque sólo tiene que abrir y cerrar el archivo una vez. Para obtener más información, vea el método <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.WriteAllText` método.  
  
|En|Vea|  
|-|-|  
|Escribir texto en un archivo|[Cómo: escribir texto en archivos en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar texto a un archivo|[Cómo: anexar a archivos de texto en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Este ejemplo escribe la línea `"This is new text to be added."` en el archivo `Test.txt`, sobrescribiendo cualquier texto existente en el archivo.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Este ejemplo escribe los nombres de los archivos de la `Documents and Settings` carpeta `FileList.txt`, insertar un carro devolver entre sí para mejorar la legibilidad.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileIO.FileSystem.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Archivo en el que se va a escribir.</param>
        <param name="text">Texto que se va a escribir en el archivo.</param>
        <param name="append">
          <see langword="True" /> para anexar el contenido del archivo; <see langword="False" /> para sobrescribir el contenido del archivo.</param>
        <param name="encoding">Codificación que se usará al escribir en el archivo.</param>
        <summary>Escribe texto en un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el archivo especificado no existe, se crea.  
  
 Si la codificación especificada no coincide con la codificación existente del archivo, se omite la codificación especificada.  
  
> [!NOTE]
>  El `WriteAllText` método abre un archivo, escribe en él y, a continuación, lo cierra. Código que usa el `WriteAllText` método es más sencillo que el código que usa un <xref:System.IO.StreamWriter> objeto. Sin embargo, si va a agregar cadenas a un archivo mediante el uso de un bucle, un <xref:System.IO.StreamWriter> objeto puede proporcionar un mejor rendimiento porque sólo tiene que abrir y cerrar el archivo una vez. Para obtener más información, vea el método <xref:Microsoft.VisualBasic.FileIO.FileSystem.OpenTextFileWriter%2A>.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.WriteAllText` método.  
  
|En|Vea|  
|-|-|  
|Escribir texto en un archivo|[Cómo: escribir texto en archivos en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar texto a un archivo|[Cómo: anexar a archivos de texto en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 Este ejemplo escribe la línea `"This is new text to be added."` en el archivo `Test.txt`, sobrescribiendo cualquier texto existente en el archivo.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 Este ejemplo escribe los nombres de los archivos de la `Documents and Settings` carpeta `FileList.txt`, insertar un carro devolver entre sí para mejorar la legibilidad.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso, o hay un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio de la ruta de acceso contiene dos puntos (:) o está en un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
  </Members>
</Type>