<Type Name="Graphics" FullName="System.Drawing.Graphics">
  <Metadata><Meta Name="ms.openlocfilehash" Value="72bcd4d4319bb2e4203ee7c06648669b6aac7c09" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55387064" /></Metadata><TypeSignature Language="C#" Value="public sealed class Graphics : MarshalByRefObject, IDisposable, System.Drawing.IDeviceContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Graphics extends System.MarshalByRefObject implements class System.Drawing.IDeviceContext, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Graphics" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Graphics&#xA;Inherits MarshalByRefObject&#xA;Implements IDeviceContext, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Graphics sealed : MarshalByRefObject, IDisposable, System::Drawing::IDeviceContext" />
  <TypeSignature Language="F#" Value="type Graphics = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable&#xA;    interface IDeviceContext" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.1</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Drawing.IDeviceContext</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsula una superficie de dibujo de GDI+. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Drawing.Graphics> clase proporciona métodos para dibujar objetos en el dispositivo de pantalla. Un <xref:System.Drawing.Graphics> está asociado a un contexto de dispositivo específico.  
  
 Puede obtener un <xref:System.Drawing.Graphics> objeto mediante una llamada a la <xref:System.Windows.Forms.Control.CreateGraphics%2A?displayProperty=nameWithType> método en un objeto que hereda de <xref:System.Windows.Forms.Control?displayProperty=nameWithType>, o controlando un control <xref:System.Windows.Forms.Control.Paint?displayProperty=nameWithType> eventos y obtener acceso a la <xref:System.Windows.Forms.PaintEventArgs.Graphics%2A> propiedad de la <xref:System.Windows.Forms.PaintEventArgs?displayProperty=nameWithType> clase. También puede crear un <xref:System.Drawing.Graphics> objeto desde una imagen mediante el uso de la <xref:System.Drawing.Graphics.FromImage%2A> método. Para obtener más información acerca de cómo crear un <xref:System.Drawing.Graphics> de objetos, vea [Cómo: Crear objetos Graphics para dibujar](~/docs/framework/winforms/advanced/how-to-create-graphics-objects-for-drawing.md).  
  
 Puede dibujar muchas líneas y formas distintas mediante una <xref:System.Drawing.Graphics> objeto. Para obtener más información sobre cómo dibujar líneas y formas, vea el `Draw` *GraphicalElement* método para la línea o forma que va a dibujar. Estos métodos incluyen <xref:System.Drawing.Graphics.DrawLine%2A>, <xref:System.Drawing.Graphics.DrawArc%2A>, <xref:System.Drawing.Graphics.DrawClosedCurve%2A>, <xref:System.Drawing.Graphics.DrawPolygon%2A>, y <xref:System.Drawing.Graphics.DrawRectangle%2A>. Para obtener más información sobre cómo dibujar líneas y formas, vea [utilizar lápiz para dibujar líneas y formas](~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md) y [mediante un pincel para rellenar formas](~/docs/framework/winforms/advanced/using-a-brush-to-fill-shapes.md).  
  
 También puede dibujar imágenes e iconos utilizando el <xref:System.Drawing.Graphics.DrawImage%2A> y <xref:System.Drawing.Graphics.DrawIcon%2A> métodos, respectivamente. Para realizar una transferencia de bloque de bits de datos de color de la pantalla a la superficie de dibujo de la <xref:System.Drawing.Graphics> de objetos, consulte <xref:System.Drawing.Graphics.CopyFromScreen%2A>. Para obtener más información sobre cómo dibujar imágenes con un <xref:System.Drawing.Graphics> de objetos, consulte [trabajar con imágenes, mapas de bits, iconos y metarchivos](~/docs/framework/winforms/advanced/working-with-images-bitmaps-icons-and-metafiles.md).  
  
 Además, puede manipular el sistema de coordenadas utilizado por el <xref:System.Drawing.Graphics> objeto. Para obtener más información sobre el sistema de coordenadas y cómo manipularlos, consulte [sistemas de coordenadas y transformaciones](~/docs/framework/winforms/advanced/coordinate-systems-and-transformations.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere un <xref:System.Windows.Forms.PaintEventArgs> objeto. El <xref:System.Windows.Forms.PaintEventArgs> se denomina objeto `e` y es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPEG. El archivo se denomina SampImag.jpg y se encuentra en la carpeta del ejemplo.  
  
-   Crea un punto en el que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Dibuja la imagen sin ajustar a escala en la pantalla mediante el uso de un <xref:System.Drawing.Graphics> objeto.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">Cómo: Crear objetos Graphics para dibujar</related>
    <related type="Article" href="https://msdn.microsoft.com/library/eb0f6d6f-9e52-4167-9592-ff4b82fb5869">Introducción a la programación de gráficos</related>
    <related type="Article" href="https://msdn.microsoft.com/library/6207cad1-7a34-4bd6-bfc1-db823ca7a73e">Administrar el estado de un objeto Graphics</related>
  </Docs>
  <Members>
    <Member MemberName="AddMetafileComment">
      <MemberSignature Language="C#" Value="public void AddMetafileComment (byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMetafileComment(unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.AddMetafileComment(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddMetafileComment (data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddMetafileComment(cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.AddMetafileComment : byte[] -&gt; unit" Usage="graphics.AddMetafileComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="data">Matriz de bytes que contiene el comentario.</param>
        <summary>Agrega un comentario al <see cref="T:System.Drawing.Imaging.Metafile" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método sólo es válido si este <xref:System.Drawing.Graphics> está asociado con un <xref:System.Drawing.Imaging.Metafile>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos, así como `thisForm`, el <xref:System.Windows.Forms.Form> para el ejemplo. El código realiza las siguientes acciones:  
  
-   Crea un archivo temporal <xref:System.Drawing.Graphics> para crear el metarchivo y obtiene un `hdc`, un identificador de su contexto de dispositivo.  
  
-   Crea un nuevo metarchivo mediante el `hdc`.  
  
-   Crea un <xref:System.Drawing.Graphics> para la presentación del metarchivo en el <xref:System.Drawing.Imaging.Metafile>.  
  
-   Dibuja un rectángulo en el metarchivo.  
  
-   Agrega un comentario al metarchivo.  
  
-   Desecha el <xref:System.Drawing.Graphics> correspondiente al metarchivo, lo que cierra el metarchivo.  
  
-   Elimina el metarchivo.  
  
-   Libera temporal `hdc`.  
  
-   Desecha temporal <xref:System.Drawing.Graphics>.  
  
-   Crea un segundo metarchivo desde el archivo creado anteriormente.  
  
-   Dibuja el metarchivo en la pantalla.  
  
-   Elimina el metarchivo.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginContainer">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Guarda un contenedor de gráficos con el estado actual de este <see cref="T:System.Drawing.Graphics" /> y abre y usa un nuevo contenedor de gráficos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer () As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer();" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : unit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Guarda un contenedor de gráficos con el estado actual de este <see cref="T:System.Drawing.Graphics" /> y abre y usa un nuevo contenedor de gráficos.</summary>
        <returns>Este método devuelve un <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> que representa el estado de este <see cref="T:System.Drawing.Graphics" /> en el momento de la llamada al método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método con el <xref:System.Drawing.Graphics.EndContainer%2A> método para crear contenedores de gráficos anidados. Contenedores de gráficos conservan el estado de gráficos, como la transformación, región de recorte y las propiedades de representación.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.BeginContainer%2A> método de un <xref:System.Drawing.Graphics>, un bloque de información que contiene el estado de la <xref:System.Drawing.Graphics> se coloca en una pila. El <xref:System.Drawing.Graphics.BeginContainer%2A> método devuelve un <xref:System.Drawing.Drawing2D.GraphicsContainer> que identifica ese bloque de información. Al pasar el objeto identificador para el <xref:System.Drawing.Graphics.EndContainer%2A> el bloque de información de método, se quita de la pila y se usa para restaurar la <xref:System.Drawing.Graphics> al estado que tenía en el momento de la <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método.  
  
 Los contenedores se pueden anidar; es decir, puede llamar a la <xref:System.Drawing.Graphics.BeginContainer%2A> método varias veces antes de llamar a la <xref:System.Drawing.Graphics.EndContainer%2A> método. Cada vez que se llama el <xref:System.Drawing.Graphics.BeginContainer%2A> método, se coloca un bloque de información en la pila y recibe un <xref:System.Drawing.Drawing2D.GraphicsContainer> para el bloque de información. Cuando se pasa uno de esos objetos a la <xref:System.Drawing.Graphics.EndContainer%2A> método, el <xref:System.Drawing.Graphics> se devuelve al estado que tenía en el momento de la <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método que devolvió ese determinado <xref:System.Drawing.Drawing2D.GraphicsContainer>. El bloque de información colocado en la pila mediante <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método se quita de la pila y todos los bloques colocan en la pila después de que <xref:System.Drawing.Graphics.BeginContainer%2A> también se quitan la llamada al método.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.Save%2A> bloques de información de contexto de método en la misma pila de llamadas a la <xref:System.Drawing.Graphics.BeginContainer%2A> método. Al igual que un <xref:System.Drawing.Graphics.EndContainer%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método, un <xref:System.Drawing.Graphics.Restore%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.Save%2A> llamada al método.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.EndContainer%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.BeginContainer%2A> método se quitan de la pila. Del mismo modo, cuando se llama a la <xref:System.Drawing.Graphics.Restore%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.Save%2A> método se quitan de la pila.  
  
 Establece el estado de los gráficos mediante la <xref:System.Drawing.Graphics.BeginContainer%2A> método incluye las cualidades de procesamiento del estado de gráficos predeterminado; cualquier cambio de estado de la calidad de representación existente cuando se llama al método se restablece a los valores predeterminados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Abre un nuevo contenedor de gráficos y guarda el contenedor anterior.  
  
-   Convierte las coordenadas universales en el contenedor.  
  
-   Rellena un rectángulo rojo en el (traducir las coordenadas de la) nuevo contenedor.  
  
-   Cierra el nuevo contenedor y restaura el contenedor guardado.  
  
-   Rellena un rectángulo verde (a las coordenadas sin traducir) del contenedor guardado.  
  
 El resultado es un rectángulo verde que se superpone a un rectángulo rojo del mismo tamaño.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.Rectangle dstrect, System.Drawing.Rectangle srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.Rectangle dstrect, valuetype System.Drawing.Rectangle srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As Rectangle, srcrect As Rectangle, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::Rectangle dstrect, System::Drawing::Rectangle srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcrect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect">Estructura <see cref="T:System.Drawing.Rectangle" /> que, junto con el parámetro <paramref name="srcrect" />, especifica una transformación de escala para el contenedor.</param>
        <param name="srcrect">Estructura <see cref="T:System.Drawing.Rectangle" /> que, junto con el parámetro <paramref name="dstrect" />, especifica una transformación de escala para el contenedor.</param>
        <param name="unit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida para el contenedor.</param>
        <summary>Guarda un contenedor de gráficos con el estado actual de este <see cref="T:System.Drawing.Graphics" /> y abre y usa un nuevo contenedor de gráficos con la transformación de escala especificada.</summary>
        <returns>Este método devuelve un <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> que representa el estado de este <see cref="T:System.Drawing.Graphics" /> en el momento de la llamada al método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método con el <xref:System.Drawing.Graphics.EndContainer%2A> método para crear contenedores de gráficos anidados. Contenedores de gráficos conservan el estado de gráficos, como la transformación, región de recorte y las propiedades de representación.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.BeginContainer%2A> método de un <xref:System.Drawing.Graphics>, un bloque de información que contiene el estado de la <xref:System.Drawing.Graphics> se coloca en una pila. El <xref:System.Drawing.Graphics.BeginContainer%2A> método devuelve un <xref:System.Drawing.Drawing2D.GraphicsContainer> que identifica ese bloque de información. Al pasar el objeto identificador para el <xref:System.Drawing.Graphics.EndContainer%2A> el bloque de información de método, se quita de la pila y se usa para restaurar la <xref:System.Drawing.Graphics> al estado que tenía en el momento de la <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método.  
  
 Los contenedores se pueden anidar; es decir, puede llamar a la <xref:System.Drawing.Graphics.BeginContainer%2A> método varias veces antes de llamar a la <xref:System.Drawing.Graphics.EndContainer%2A> método. Cada vez que se llama el <xref:System.Drawing.Graphics.BeginContainer%2A> método, se coloca un bloque de información en la pila y recibe un <xref:System.Drawing.Drawing2D.GraphicsContainer> para el bloque de información. Cuando se pasa uno de esos objetos a la <xref:System.Drawing.Graphics.EndContainer%2A> método, el <xref:System.Drawing.Graphics> se devuelve al estado que tenía en el momento de la <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método que devolvió ese determinado <xref:System.Drawing.Drawing2D.GraphicsContainer>. El bloque de información colocado en la pila mediante <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método se quita de la pila y todos los bloques colocan en la pila después de que <xref:System.Drawing.Graphics.BeginContainer%2A> también se quitan la llamada al método.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.Save%2A> bloques de información de contexto de método en la misma pila de llamadas a la <xref:System.Drawing.Graphics.BeginContainer%2A> método. Al igual que un <xref:System.Drawing.Graphics.EndContainer%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método, un <xref:System.Drawing.Graphics.Restore%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.Save%2A> llamada al método.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.EndContainer%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.BeginContainer%2A> método se quitan de la pila. Del mismo modo, cuando se llama a la <xref:System.Drawing.Graphics.Restore%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.Save%2A> método se quitan de la pila.  
  
 Este método especifica una transformación de escala para el nuevo contenedor de gráficos con el `dstrect` y `srcrect` parámetros. La escala es igual a la transformación que, cuando se aplica a `srcrect`, da como resultado `dstrect`.  
  
 Establece el estado de los gráficos mediante la <xref:System.Drawing.Graphics.BeginContainer%2A> método incluye las cualidades de procesamiento del estado de gráficos predeterminado; cualquier cambio de estado de la calidad de representación existente cuando se llama al método se restablece a los valores predeterminados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea dos rectángulos para especificar una transformación de escala para el nuevo contenedor.  
  
-   Se abre el nuevo contenedor de gráficos y guarda el contenedor anterior.  
  
-   Rellena un rectángulo rojo en el (escalar las coordenadas de la) nuevo contenedor.  
  
-   Cierra el nuevo contenedor y restaura el contenedor guardado.  
  
-   Rellena un rectángulo verde (a las coordenadas sin escala) del contenedor guardado.  
  
 El resultado es un rectángulo verde que se superpone a un rectángulo rojo más pequeño.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginContainer">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsContainer BeginContainer (System.Drawing.RectangleF dstrect, System.Drawing.RectangleF srcrect, System.Drawing.GraphicsUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsContainer BeginContainer(valuetype System.Drawing.RectangleF dstrect, valuetype System.Drawing.RectangleF srcrect, valuetype System.Drawing.GraphicsUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.BeginContainer(System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginContainer (dstrect As RectangleF, srcrect As RectangleF, unit As GraphicsUnit) As GraphicsContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsContainer ^ BeginContainer(System::Drawing::RectangleF dstrect, System::Drawing::RectangleF srcrect, System::Drawing::GraphicsUnit unit);" />
      <MemberSignature Language="F#" Value="member this.BeginContainer : System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; System.Drawing.Drawing2D.GraphicsContainer" Usage="graphics.BeginContainer (dstrect, srcrect, unit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dstrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcrect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="dstrect">Estructura <see cref="T:System.Drawing.RectangleF" /> que, junto con el parámetro <paramref name="srcrect" />, especifica una transformación de escala para el nuevo contenedor de gráficos.</param>
        <param name="srcrect">Estructura <see cref="T:System.Drawing.RectangleF" /> que, junto con el parámetro <paramref name="dstrect" />, especifica una transformación de escala para el nuevo contenedor de gráficos.</param>
        <param name="unit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida para el contenedor.</param>
        <summary>Guarda un contenedor de gráficos con el estado actual de este <see cref="T:System.Drawing.Graphics" /> y abre y usa un nuevo contenedor de gráficos con la transformación de escala especificada.</summary>
        <returns>Este método devuelve un <see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> que representa el estado de este <see cref="T:System.Drawing.Graphics" /> en el momento de la llamada al método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método con el <xref:System.Drawing.Graphics.EndContainer%2A> método para crear contenedores de gráficos anidados. Contenedores de gráficos conservan el estado de gráficos, como la transformación, región de recorte y las propiedades de representación.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.BeginContainer%2A> método de un <xref:System.Drawing.Graphics>, un bloque de información que contiene el estado de la <xref:System.Drawing.Graphics> se coloca en una pila. El <xref:System.Drawing.Graphics.BeginContainer%2A> método devuelve un <xref:System.Drawing.Drawing2D.GraphicsContainer> que identifica ese bloque de información. Al pasar el objeto identificador para el <xref:System.Drawing.Graphics.EndContainer%2A> el bloque de información de método, se quita de la pila y se usa para restaurar la <xref:System.Drawing.Graphics> al estado que tenía en el momento de la <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método.  
  
 Los contenedores se pueden anidar; es decir, puede llamar a la <xref:System.Drawing.Graphics.BeginContainer%2A> método varias veces antes de llamar a la <xref:System.Drawing.Graphics.EndContainer%2A> método. Cada vez que se llama el <xref:System.Drawing.Graphics.BeginContainer%2A> método, se coloca un bloque de información en la pila y recibe un <xref:System.Drawing.Drawing2D.GraphicsContainer> para el bloque de información. Cuando se pasa uno de esos objetos a la <xref:System.Drawing.Graphics.EndContainer%2A> método, el <xref:System.Drawing.Graphics> se devuelve al estado que tenía en el momento de la <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método que devolvió ese determinado <xref:System.Drawing.Drawing2D.GraphicsContainer>. El bloque de información colocado en la pila mediante <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método se quita de la pila y todos los bloques colocan en la pila después de que <xref:System.Drawing.Graphics.BeginContainer%2A> también se quitan la llamada al método.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.Save%2A> bloques de información de contexto de método en la misma pila de llamadas a la <xref:System.Drawing.Graphics.BeginContainer%2A> método. Al igual que un <xref:System.Drawing.Graphics.EndContainer%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método, un <xref:System.Drawing.Graphics.Restore%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.Save%2A> llamada al método.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.EndContainer%2A> método, todos los bloques de información colocados en la pila (por el `Save` método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.BeginContainer%2A> método se quitan de la pila. Del mismo modo, cuando se llama a la <xref:System.Drawing.Graphics.Restore%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.Save%2A> método se quitan de la pila.  
  
 Este método especifica una transformación de escala para el nuevo contenedor de gráficos con el `dstrect` y `srcrect` parámetros. La escala es igual a la transformación que, cuando se aplica a `srcrect`, da como resultado `dstrect`.  
  
 Establece el estado de los gráficos mediante la <xref:System.Drawing.Graphics.BeginContainer%2A> método incluye las cualidades de procesamiento del estado de gráficos predeterminado; cualquier cambio de estado de la calidad de representación existente cuando se llama al método se restablece a los valores predeterminados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea dos rectángulos para especificar una transformación de escala para el nuevo contenedor.  
  
-   Se abre el nuevo contenedor de gráficos y guarda el contenedor anterior.  
  
-   Rellena un rectángulo rojo en el (escalar las coordenadas de la) nuevo contenedor.  
  
-   Cierra el nuevo contenedor y restaura el contenedor guardado.  
  
-   Rellena un rectángulo verde (a las coordenadas sin escala) del contenedor guardado.  
  
 El resultado es un rectángulo verde que se superpone a un rectángulo rojo más pequeño.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Clear(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.Clear : System.Drawing.Color -&gt; unit" Usage="graphics.Clear color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color">Estructura <see cref="T:System.Drawing.Color" /> que representa el color de fondo de la superficie de dibujo.</param>
        <summary>Borra toda la superficie de dibujo y la rellena con el color de fondo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.Clear%2A> método borra el estado del objeto graphics y no se debe llamar cuando el objeto graphics no se puede actualizar. Por ejemplo, si la <xref:System.Drawing.Graphics.Clear%2A> se llama al método en un escritorio seguro en una sesión de terminal server, un <xref:System.Runtime.InteropServices.ExternalException> pueden producirse, dejando la <xref:System.Drawing.Graphics> objeto en un estado incoherente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código borra la superficie de dibujo de la <xref:System.Drawing.Graphics> y establece el color de fondo para el color verde azulado definido por el sistema.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Clip" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Clip { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Region with get, set" Usage="System.Drawing.Graphics.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un <see cref="T:System.Drawing.Region" /> que limita la región de dibujo de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value><see cref="T:System.Drawing.Region" /> que limita la parte de este <see cref="T:System.Drawing.Graphics" /> que se encuentra disponible actualmente para dibujar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modificar el <xref:System.Drawing.Region> objeto devuelto por la <xref:System.Drawing.Graphics.Clip%2A> propiedad no afecta a los dibujos posteriores con el <xref:System.Drawing.Graphics> objeto. Para cambiar la región de recorte, reemplace el <xref:System.Drawing.Graphics.Clip%2A> con un nuevo valor de la propiedad <xref:System.Drawing.Region> objeto. Para determinar si la región de recorte es infinita, recuperar el <xref:System.Drawing.Graphics.Clip%2A> propiedad y llame a su <xref:System.Drawing.Region.IsInfinite%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Drawing.Graphics.Clip%2A> propiedad. En este ejemplo está diseñado para usarse con Windows Forms. Pegue el código en un formulario y llame a la `SetAndFillClip` método cuando el control del formulario <xref:System.Windows.Forms.Control.Paint> evento pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.GraphicsProperties#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#4)]
 [!code-vb[System.Drawing.GraphicsProperties#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF ClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF ClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.ClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF ClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.ClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.ClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una estructura <see cref="T:System.Drawing.RectangleF" /> que delimita la región de recorte de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Estructura <see cref="T:System.Drawing.RectangleF" /> que representa un rectángulo delimitador para la región de recorte de este <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La unidad para el rectángulo resultante se designa mediante el <xref:System.Drawing.Graphics.PageUnit%2A> propiedad. La unidad predeterminada es píxeles. Un <xref:System.Drawing.Graphics> suele asociarse con un control y el origen del rectángulo será relativo al área de cliente de ese control.  
  
 Si la región de recorte es infinita, el <xref:System.Drawing.Graphics.ClipBounds%2A> propiedad devuelve un rectángulo grande sin sentido. Para determinar si la región de recorte es infinita, recuperar el <xref:System.Drawing.Graphics.Clip%2A> propiedad y llame a su <xref:System.Drawing.Region.IsInfinite%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingMode CompositingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingMode CompositingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingMode As CompositingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingMode CompositingMode { System::Drawing::Drawing2D::CompositingMode get(); void set(System::Drawing::Drawing2D::CompositingMode value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingMode : System.Drawing.Drawing2D.CompositingMode with get, set" Usage="System.Drawing.Graphics.CompositingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que especifica cómo se dibujan las imágenes compuestas en este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Esta propiedad especifica un miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CompositingMode" />. De manera predeterminada, es <see cref="F:System.Drawing.Drawing2D.CompositingMode.SourceOver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de composición determina si los píxeles de una imagen de origen sobrescriben o se combinan con los píxeles en segundo plano.  
  
> [!NOTE]
>  No se debe usar un <xref:System.Drawing.Graphics.CompositingMode%2A> el valor de propiedad <xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy> cuando el <xref:System.Drawing.Graphics.TextRenderingHint%2A> propiedad está establecida en <xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>. Podría producirse una excepción o la imagen no se presenten correctamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositingQuality">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.CompositingQuality CompositingQuality { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.CompositingQuality CompositingQuality" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.CompositingQuality" />
      <MemberSignature Language="VB.NET" Value="Public Property CompositingQuality As CompositingQuality" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::CompositingQuality CompositingQuality { System::Drawing::Drawing2D::CompositingQuality get(); void set(System::Drawing::Drawing2D::CompositingQuality value); };" />
      <MemberSignature Language="F#" Value="member this.CompositingQuality : System.Drawing.Drawing2D.CompositingQuality with get, set" Usage="System.Drawing.Graphics.CompositingQuality" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.CompositingQuality</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la calidad de representación de las imágenes compuestas que se dibujan en este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Esta propiedad especifica un miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CompositingQuality" />. De manera predeterminada, es <see cref="F:System.Drawing.Drawing2D.CompositingQuality.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La calidad de composición determina el nivel de calidad de representación de las imágenes compuestas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFromScreen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza una transferencia de bloque de bits de los datos de color desde la pantalla a la superficie de dibujo de <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (upperLeftSource As Point, upperLeftDestination As Point, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">Punto en la esquina superior izquierda del rectángulo de origen.</param>
        <param name="upperLeftDestination">Punto en la esquina superior izquierda del rectángulo de destino.</param>
        <param name="blockRegionSize">Tamaño del área que se va a transferir.</param>
        <summary>Realiza una transferencia de bloque de bits de los datos de color, correspondientes a un rectángulo de píxeles, desde la pantalla a la superficie de dibujo de <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos son útiles para una imagen de distribución en capas encima de otro. Para especificar cómo se mezclan los colores de origen y destino, use uno de los <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos que toma un <xref:System.Drawing.CopyPixelOperation> parámetro.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método <xref:System.Drawing.Graphics.CopyFromScreen%2A>. Para ejecutar este ejemplo, péguelo en un formulario de Windows. Controlar el formato <xref:System.Windows.Forms.Control.Paint> evento y llamar a la `CopyPixels1` método desde el <xref:System.Windows.Forms.Control.Paint> método de control de eventos, pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#4)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Error en la operación.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener acceso a todas las ventanas. Enumeración relacionada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Cómo: Imprimir Windows Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Filtrar Copiar píxeles para reducir el parpadeo en formularios de Windows</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (System.Drawing.Point upperLeftSource, System.Drawing.Point upperLeftDestination, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(valuetype System.Drawing.Point upperLeftSource, valuetype System.Drawing.Point upperLeftDestination, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Drawing.Point,System.Drawing.Point,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(System::Drawing::Point upperLeftSource, System::Drawing::Point upperLeftDestination, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : System.Drawing.Point * System.Drawing.Point * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (upperLeftSource, upperLeftDestination, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="upperLeftSource" Type="System.Drawing.Point" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="upperLeftDestination" Type="System.Drawing.Point" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="upperLeftSource">Punto en la esquina superior izquierda del rectángulo de origen.</param>
        <param name="upperLeftDestination">Punto en la esquina superior izquierda del rectángulo de destino.</param>
        <param name="blockRegionSize">Tamaño del área que se va a transferir.</param>
        <param name="copyPixelOperation">Uno de los valores de <see cref="T:System.Drawing.CopyPixelOperation" />.</param>
        <summary>Realiza una transferencia de bloque de bits de los datos de color, correspondientes a un rectángulo de píxeles, desde la pantalla a la superficie de dibujo de <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos son útiles para una imagen de distribución en capas encima de otro. El `copyPixelOperation` parámetro permite especificar si y cómo deben se mezclan los colores de origen con los colores en el área de destino.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método <xref:System.Drawing.Graphics.CopyFromScreen%2A>. Para ejecutar este ejemplo, péguelo en un formulario de Windows. Controlar el formato <xref:System.Windows.Forms.Control.Paint> evento y llamar a la `CopyPixels2` método desde el <xref:System.Windows.Forms.Control.Paint> método de control de eventos, pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#5)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="copyPixelOperation" /> no es un miembro de <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Error en la operación.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener acceso a todas las ventanas. Enumeración relacionada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Cómo: Imprimir Windows Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Filtrar Copiar píxeles para reducir el parpadeo en formularios de Windows</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFromScreen (sourceX As Integer, sourceY As Integer, destinationX As Integer, destinationY As Integer, blockRegionSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sourceY" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationX" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationY" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" Index="4" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceX">Coordenada x del punto en la esquina superior izquierda del rectángulo de origen.</param>
        <param name="sourceY">Coordenada y del punto en la esquina superior izquierda del rectángulo de origen.</param>
        <param name="destinationX">Coordenada x del punto en la esquina superior izquierda del rectángulo de destino.</param>
        <param name="destinationY">Coordenada y del punto en la esquina superior izquierda del rectángulo de destino.</param>
        <param name="blockRegionSize">Tamaño del área que se va a transferir.</param>
        <summary>Realiza una transferencia de bloque de bits de los datos de color, correspondientes a un rectángulo de píxeles, desde la pantalla a la superficie de dibujo de <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos son útiles para una imagen de distribución en capas encima de otro. Para especificar cómo se mezclan los colores de origen y destino, use uno de los <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos que toma un <xref:System.Drawing.CopyPixelOperation> parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Drawing.Graphics.CopyFromScreen%2A> para imprimir una copia del formulario actual.  
  
 [!code-csharp[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.CopyFromScreen#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.CopyFromScreen/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Error en la operación.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener acceso a todas las ventanas. Enumeración relacionada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Cómo: Imprimir Windows Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Filtrar Copiar píxeles para reducir el parpadeo en formularios de Windows</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFromScreen">
      <MemberSignature Language="C#" Value="public void CopyFromScreen (int sourceX, int sourceY, int destinationX, int destinationY, System.Drawing.Size blockRegionSize, System.Drawing.CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFromScreen(int32 sourceX, int32 sourceY, int32 destinationX, int32 destinationY, valuetype System.Drawing.Size blockRegionSize, valuetype System.Drawing.CopyPixelOperation copyPixelOperation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.CopyFromScreen(System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.Size,System.Drawing.CopyPixelOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, System::Drawing::Size blockRegionSize, System::Drawing::CopyPixelOperation copyPixelOperation);" />
      <MemberSignature Language="F#" Value="member this.CopyFromScreen : int * int * int * int * System.Drawing.Size * System.Drawing.CopyPixelOperation -&gt; unit" Usage="graphics.CopyFromScreen (sourceX, sourceY, destinationX, destinationY, blockRegionSize, copyPixelOperation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceX" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sourceY" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationX" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationY" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="blockRegionSize" Type="System.Drawing.Size" Index="4" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="copyPixelOperation" Type="System.Drawing.CopyPixelOperation" Index="5" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceX">Coordenada x del punto en la esquina superior izquierda del rectángulo de origen.</param>
        <param name="sourceY">Coordenada y del punto en la esquina superior izquierda del rectángulo de origen.</param>
        <param name="destinationX">Coordenada x del punto en la esquina superior izquierda del rectángulo de destino.</param>
        <param name="destinationY">Coordenada y del punto en la esquina superior izquierda del rectángulo de destino.</param>
        <param name="blockRegionSize">Tamaño del área que se va a transferir.</param>
        <param name="copyPixelOperation">Uno de los valores de <see cref="T:System.Drawing.CopyPixelOperation" />.</param>
        <summary>Realiza una transferencia de bloque de bits de los datos de color, correspondientes a un rectángulo de píxeles, desde la pantalla a la superficie de dibujo de <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.CopyFromScreen%2A> métodos son útiles para una imagen de distribución en capas encima de otro. El `copyPixelOperation` parámetro permite especificar si y cómo deben se mezclan los colores de origen con los colores en el área de destino.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método <xref:System.Drawing.Graphics.CopyFromScreen%2A>. Para ejecutar este ejemplo, péguelo en un formulario de Windows. Controlar el formato <xref:System.Windows.Forms.Control.Paint> evento y llamar a la `CopyPixels4` método desde el <xref:System.Windows.Forms.Control.Paint> método de control de eventos, pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#7)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="copyPixelOperation" /> no es un miembro de <see cref="T:System.Drawing.CopyPixelOperation" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Error en la operación.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener acceso a todas las ventanas. Enumeración relacionada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/c8dff5f8-f56a-4c07-ae31-64643b31f8fc">Cómo: Imprimir Windows Forms</related>
        <related type="Article" href="https://msdn.microsoft.com/library/33b76910-13a3-4521-be98-5c097341ae3b">Filtrar Copiar píxeles para reducir el parpadeo en formularios de Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="graphics.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por este <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Drawing.Graphics.Dispose%2A> permite que los recursos utilizados por este <xref:System.Drawing.Graphics> que reasignarse para otros fines.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un <xref:System.Drawing.Image> desde un objeto graphics SampImag.jpg de archivos en el directorio de ejemplo.  
  
-   Crea un <xref:System.Drawing.Graphics> desde el <xref:System.Drawing.Image>.  
  
-   Modifica la imagen rellenando un rectángulo dentro de él.  
  
-   Dibuja el <xref:System.Drawing.Image> a la pantalla.  
  
-   Libera el creado <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiX">
      <MemberSignature Language="C#" Value="public float DpiX { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiX" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiX" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiX As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiX { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiX : single" Usage="System.Drawing.Graphics.DpiX" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la resolución horizontal de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>El valor, en puntos por pulgada, de la resolución horizontal que admite este <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de cómo crear aplicaciones de alta resolución, vea  
  
 [Valores altos de PPP](https://go.microsoft.com/fwlink/?LinkId=159804).  
  
   
  
## Examples  
 El método siguiente muestra el uso de la <xref:System.Drawing.Graphics.DpiX%2A> y <xref:System.Drawing.Graphics.DpiY%2A> propiedades. En este ejemplo está diseñado para su uso con un formulario de Windows. Para ejecutar este ejemplo, péguelo en un formulario que contenga un <xref:System.Windows.Forms.ListBox> denominado listBox1 y llame a este método desde el constructor del formulario.  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">Valores altos de PPP</related>
      </Docs>
    </Member>
    <Member MemberName="DpiY">
      <MemberSignature Language="C#" Value="public float DpiY { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 DpiY" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.DpiY" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DpiY As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float DpiY { float get(); };" />
      <MemberSignature Language="F#" Value="member this.DpiY : single" Usage="System.Drawing.Graphics.DpiY" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la resolución vertical de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>El valor, en puntos por pulgada, de la resolución vertical que admite este <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de cómo crear aplicaciones de alta resolución, vea  
  
 [Valores altos de PPP](https://go.microsoft.com/fwlink/?LinkId=159804).  
  
   
  
## Examples  
 El método siguiente muestra el uso de la <xref:System.Drawing.Graphics.DpiX%2A> y <xref:System.Drawing.Graphics.DpiY%2A> propiedades. En este ejemplo está diseñado para su uso con un formulario de Windows. Para ejecutar este ejemplo, péguelo en un formulario que contenga un <xref:System.Windows.Forms.ListBox> denominado listBox1 y llame a este método desde el constructor del formulario.  
  
 [!code-cpp[System.Drawing.MiscExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.MiscExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.MiscExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=159804">Valores altos de PPP</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja un archivo que representa una parte de una elipse especificada por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del arco.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que define los límites de la elipse.</param>
        <param name="startAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el eje X hasta el punto inicial del arco.</param>
        <param name="sweepAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el punto final del arco.</param>
        <summary>Dibuja un arco que representa una parte de la elipse especificada por una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja un arco que es una parte del perímetro de una elipse. La elipse está definida por los límites de un rectángulo. El arco es la parte del perímetro de la elipse entre el `startAngle` parámetro y el `startAngle`  +  `sweepAngle` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea un rectángulo que delimita una elipse.  
  
-   Define el inicio (45 grados) y el ángulo de barrido (270 grados).  
  
-   Dibuja el arco elíptico a la pantalla.  
  
 El resultado es una elipse parcial falta un segmento entre + y - 45 grados alrededor del eje x.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawArc (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del arco.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que define los límites de la elipse.</param>
        <param name="startAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el eje X hasta el punto inicial del arco.</param>
        <param name="sweepAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el punto final del arco.</param>
        <summary>Dibuja un arco que representa una parte de la elipse especificada por una estructura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja un arco que es una parte del perímetro de una elipse. La elipse está definida por los límites de un rectángulo. El arco es la parte del perímetro de la elipse entre el `startAngle` parámetro y el `startAngle`  +  `sweepAngle` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea un rectángulo que delimita una elipse.  
  
-   Define el inicio (45 grados) y el ángulo de barrido (270 grados).  
  
-   Dibuja el arco elíptico a la pantalla.  
  
 El resultado es una elipse parcial falta un segmento entre + y - 45 grados alrededor del eje x.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del arco.</param>
        <param name="x">Coordenada X de la esquina superior izquierda del rectángulo que define la elipse.</param>
        <param name="y">Coordenada Y de la esquina superior izquierda del rectángulo que define la elipse.</param>
        <param name="width">Ancho del rectángulo que define la elipse.</param>
        <param name="height">Alto del rectángulo que define la elipse.</param>
        <param name="startAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el eje X hasta el punto inicial del arco.</param>
        <param name="sweepAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el punto final del arco.</param>
        <summary>Dibuja un archivo que representa una parte de una elipse especificada por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja un arco que es una parte del perímetro de una elipse. La elipse está definida por los límites de un rectángulo. El arco es la parte del perímetro de la elipse entre el `startAngle` parámetro y el `startAngle`  +  `sweepAngle` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea la posición y tamaño de un rectángulo para delimitar una elipse.  
  
-   Define el inicio (45 grados) y el ángulo de barrido (270 grados).  
  
-   Dibuja el arco elíptico a la pantalla.  
  
 El resultado es una elipse parcial falta un segmento entre + y - 45 grados alrededor del eje x.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawArc">
      <MemberSignature Language="C#" Value="public void DrawArc (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawArc(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawArc(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawArc(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawArc : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawArc (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del arco.</param>
        <param name="x">Coordenada X de la esquina superior izquierda del rectángulo que define la elipse.</param>
        <param name="y">Coordenada Y de la esquina superior izquierda del rectángulo que define la elipse.</param>
        <param name="width">Ancho del rectángulo que define la elipse.</param>
        <param name="height">Alto del rectángulo que define la elipse.</param>
        <param name="startAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el eje X hasta el punto inicial del arco.</param>
        <param name="sweepAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el punto final del arco.</param>
        <summary>Dibuja un archivo que representa una parte de una elipse especificada por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja un arco que es una parte del perímetro de una elipse. La elipse está definida por los límites de un rectángulo. El arco es la parte del perímetro de la elipse entre el `startAngle` parámetro y el `startAngle`  +  `sweepAngle` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea la posición y tamaño de un rectángulo para delimitar una elipse.  
  
-   Define el inicio (45 grados) y el ángulo de barrido (270 grados).  
  
-   Dibuja el arco elíptico a la pantalla.  
  
 El resultado es una elipse parcial falta un segmento entre + y - 45 grados alrededor del eje x.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja un elemento B-spline definido por cuatro estructuras <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen">Estructura <see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="pt1">Estructura <see cref="T:System.Drawing.Point" /> que representa el punto inicial de la curva.</param>
        <param name="pt2">Estructura <see cref="T:System.Drawing.Point" /> que representa el primer punto de control para la curva.</param>
        <param name="pt3">Estructura <see cref="T:System.Drawing.Point" /> que representa el segundo punto de control para la curva.</param>
        <param name="pt4">Estructura <see cref="T:System.Drawing.Point" /> que representa el extremo de la curva.</param>
        <summary>Dibuja un elemento B-spline definido por cuatro estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La curva de Bézier se dibuja desde el primer punto hasta el cuarto punto. El segundo y tercer puntos son puntos de control que determinan la forma de la curva.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea el inicio, end y dos puntos de control para la curva.  
  
-   Dibuja la curva de Bézier en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawBezier (pen, pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="pt1">Estructura <see cref="T:System.Drawing.PointF" /> que representa el punto inicial de la curva.</param>
        <param name="pt2">Estructura <see cref="T:System.Drawing.PointF" /> que representa el primer punto de control para la curva.</param>
        <param name="pt3">Estructura <see cref="T:System.Drawing.PointF" /> que representa el segundo punto de control para la curva.</param>
        <param name="pt4">Estructura <see cref="T:System.Drawing.PointF" /> que representa el extremo de la curva.</param>
        <summary>Dibuja un elemento B-spline definido por cuatro estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La curva spline de Bézier se dibuja desde el primer punto hasta el cuarto punto. El segundo y tercer puntos son puntos de control que determinan la forma de la curva.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea el inicio, end y dos puntos de control para la curva.  
  
-   Dibuja la curva de Bézier en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBezier">
      <MemberSignature Language="C#" Value="public void DrawBezier (System.Drawing.Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBezier(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBezier(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBezier(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="F#" Value="member this.DrawBezier : System.Drawing.Pen * single * single * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawBezier (pen, x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="x1">Coordenada x del punto inicial de la curva.</param>
        <param name="y1">Coordenada y del punto inicial de la curva.</param>
        <param name="x2">Coordenada x del primer punto de control de la curva.</param>
        <param name="y2">Coordenada y del primer punto de control de la curva.</param>
        <param name="x3">Coordenada x del segundo punto de control de la curva.</param>
        <param name="y3">Coordenada y del segundo punto de control de la curva.</param>
        <param name="x4">Coordenada x del punto final de la curva.</param>
        <param name="y4">Coordenada y del punto final de la curva.</param>
        <summary>Dibuja una curva spline de Bézier definida por cuatro pares ordenados de coordenadas que representan puntos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La curva spline de Bézier se dibuja desde el primer punto hasta el cuarto punto. El segundo y tercer puntos son puntos de control que determinan la forma de la curva.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea las coordenadas de inicio, end y dos puntos de control para la curva.  
  
-   Dibuja la curva de Bézier en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja una serie de elementos B-spline a partir de una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representan los puntos que definen la curva. El número de puntos en la matriz debe ser un múltiplo de 3 más 1, como 4, 7 o 10.</param>
        <summary>Dibuja una serie de elementos B-spline a partir de una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de puntos de la matriz debe ser un múltiplo de 3 más 1 porque el primer spline requiere 4 puntos y los demás spline requieren 3 puntos. La primera curva spline de Bézier se dibuja desde el primer punto hasta el cuarto punto en la matriz de puntos. El segundo y tercer puntos son puntos de control que determinan la forma de la curva. Cada curva sucesiva necesita exactamente tres puntos más: más de dos puntos de control y un punto final. El punto final de la curva anterior se usa como punto de partida para cada curva adicional.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea el inicio, end y dos puntos de control para una primera curva y punto de conexión y dos puntos de control para la segunda curva.  
  
-   Dibuja las curvas de Bézier sucesivas en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawBeziers">
      <MemberSignature Language="C#" Value="public void DrawBeziers (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawBeziers(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawBeziers(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawBeziers(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawBeziers : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawBeziers (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representan los puntos que definen la curva. El número de puntos en la matriz debe ser un múltiplo de 3 más 1, como 4, 7 o 10.</param>
        <summary>Dibuja una serie de elementos B-spline a partir de una matriz de estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de puntos de la matriz debe ser un múltiplo de 3 más 1 porque el primer spline requiere 4 puntos y los demás spline requieren 3 puntos. La primera curva de Bézier se dibuja desde el primer punto hasta el cuarto punto en la matriz de puntos. El segundo y tercer puntos son puntos de control que determinan la forma de la curva. Cada curva sucesiva necesita exactamente tres puntos más: más de dos puntos de control y un punto final. El punto final de la curva anterior se usa como punto de partida para cada curva adicional.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea el inicio, end y dos puntos de control para una primera curva y punto de conexión y dos puntos de control para la segunda curva.  
  
-   Dibuja las curvas de Bézier sucesivas en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y alto de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que definen la curva spline.</param>
        <summary>Dibuja una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto de cerrar la figura.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.Point> estructuras.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos para definir una curva.  
  
-   Dibuja siete líneas rectas rojo entre los siete puntos para formar un polígono cerrado.  
  
-   Dibuja una curva cerrada verde a través de los siete puntos.  
  
 El método utiliza una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y alto de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen la curva spline.</param>
        <summary>Dibuja una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.PointF> estructuras.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos para definir una curva.  
  
-   Dibuja siete líneas rectas rojo entre los siete puntos para formar un polígono cerrado.  
  
-   Dibuja una curva cerrada verde a través de los siete puntos.  
  
 El método utiliza una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.Point[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y alto de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que definen la curva spline.</param>
        <param name="tension">Valor mayor o igual que 0,0 F que especifica la tensión de la curva.</param>
        <param name="fillmode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina cómo se rellena la curva. Este parámetro es obligatorio, si bien se pasa por alto.</param>
        <summary>Dibuja una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.Point" />, usando la tensión especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.Point> estructuras.  
  
 El `tension` parámetro determina la forma de la curva polinomial. Si el valor de la `tension` parámetro es 0, 0F, este método dibuja segmentos de línea recta para conectar los puntos. Normalmente, el `tension` parámetro es menor o igual que 1, 0f. Los valores en 1, 0F producen resultados inesperados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos que definen la curva.  
  
-   Dibuja siete líneas rectas rojo entre los siete puntos para formar un polígono.  
  
-   Crea la configuración del modo de tensión y relleno.  
  
-   Dibuja una curva cerrada verde a través de los siete puntos.  
  
 El método usa una tensión de 1,0 y establece el modo de relleno en `FillMode.Alternate`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawClosedCurve">
      <MemberSignature Language="C#" Value="public void DrawClosedCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawClosedCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawClosedCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single,System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawClosedCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.DrawClosedCurve : System.Drawing.Pen * System.Drawing.PointF[] * single * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.DrawClosedCurve (pen, points, tension, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y alto de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen la curva spline.</param>
        <param name="tension">Valor mayor o igual que 0,0 F que especifica la tensión de la curva.</param>
        <param name="fillmode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina cómo se rellena la curva. Este parámetro es obligatorio, si bien se pasa por alto.</param>
        <summary>Dibuja una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.PointF" />, usando la tensión especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.PointF> estructuras.  
  
 El `tension` parámetro determina la forma de la curva polinomial. Si el valor de la `tension` parámetro es 0, 0F, este método dibuja segmentos de línea recta para conectar los puntos. Normalmente, el `tension` parámetro es menor o igual que 1, 0f. Los valores en 1, 0F producen resultados inesperados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos que definen la curva.  
  
-   Dibuja siete líneas rectas rojo entre los siete puntos para formar un polígono.  
  
-   Crea la configuración del modo de tensión y relleno.  
  
-   Dibuja una curva cerrada verde a través de los siete puntos.  
  
 El método usa una tensión de 1,0 y establece el modo de relleno en `FillMode.Alternate`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja una curva spline cardinal a través de una matriz especificada de estructuras <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y alto de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que definen la curva spline.</param>
        <summary>Dibuja una curva spline cardinal a través de una matriz especificada de estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal que pasa por cada punto de la matriz.  
  
 La matriz de puntos debe contener al menos tres <xref:System.Drawing.Point> estructuras para que se dibuja una curva.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos para definir una curva.  
  
-   Dibuja seis líneas rectas rojo entre los siete puntos para formar un polígono incompleto.  
  
-   Dibuja una curva de color verde abierta a través de los siete puntos.  
  
 El método utiliza una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawCurve (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen la curva spline.</param>
        <summary>Dibuja una curva spline cardinal a través de una matriz especificada de estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal que pasa por cada punto de la matriz.  
  
 La matriz de puntos debe contener al menos tres <xref:System.Drawing.PointF> estructuras para que se dibuja una curva.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos para definir una curva.  
  
-   Dibuja seis líneas rectas rojo entre los siete puntos para formar un polígono incompleto.  
  
-   Dibuja una curva de color verde abierta a través de los siete puntos.  
  
 El método utiliza una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que definen la curva spline.</param>
        <param name="tension">Valor mayor o igual que 0,0 F que especifica la tensión de la curva.</param>
        <summary>Dibuja una curva spline cardinal a través de una matriz especificada de estructuras <see cref="T:System.Drawing.Point" /> con la tensión especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal que pasa por cada punto de la matriz.  
  
 La matriz de puntos debe contener al menos tres <xref:System.Drawing.Point> estructuras para que se dibuja una curva.  
  
 El `tension` parámetro determina la forma de la curva polinomial. Si el valor de la `tension` parámetro es 0, 0F, este método dibuja segmentos de línea recta para conectar los puntos. Normalmente, el `tension` parámetro es menor o igual que 1, 0f. Los valores en 1, 0F producen resultados inesperados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos que definen la curva.  
  
-   Dibuja seis líneas rectas rojo entre los siete puntos para formar un polígono incompleto.  
  
-   Crea una configuración de tensión.  
  
-   Dibuja una curva cerrada verde abierta a través de los siete puntos.  
  
 El método usa una tensión de 1,0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representan los puntos que definen la curva.</param>
        <param name="tension">Valor mayor o igual que 0,0 F que especifica la tensión de la curva.</param>
        <summary>Dibuja una curva spline cardinal a través de una matriz especificada de estructuras <see cref="T:System.Drawing.PointF" /> con la tensión especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal que pasa por cada punto de la matriz.  
  
 La matriz de puntos debe contener al menos tres <xref:System.Drawing.PointF> estructuras para que se dibuja una curva.  
  
 El `tension` parámetro determina la forma de la curva polinomial. Si el valor de la `tension` parámetro es 0, 0F, este método dibuja segmentos de línea recta para conectar los puntos. Normalmente, el `tension` parámetro es menor o igual que 1, 0f. Los valores en 1, 0F producen resultados inesperados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos que definen la curva.  
  
-   Dibuja seis líneas rectas rojo entre los siete puntos para formar un polígono incompleto.  
  
-   Crea una configuración de tensión.  
  
-   Dibuja una curva cerrada verde abierta a través de los siete puntos.  
  
 El método usa una tensión de 1,0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen la curva spline.</param>
        <param name="offset">Desplazamiento entre el primer elemento de la matriz del parámetro <paramref name="points" /> y el punto inicial de la curva.</param>
        <param name="numberOfSegments">Número de segmentos posteriores al punto inicial que se incluirán en la curva.</param>
        <summary>Dibuja una curva spline cardinal a través de una matriz especificada de estructuras <see cref="T:System.Drawing.PointF" />. El dibujo comienza su desplazamiento a partir del comienzo de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal que pasa por cada punto de la matriz.  
  
 La matriz de puntos debe contener al menos tres <xref:System.Drawing.PointF> estructuras para que se dibuja una curva.  
  
 El valor de la `offset` parámetro especifica el número de elementos que se omiten en la matriz. El primer elemento después de los elementos omitidos representa el punto inicial de la curva.  
  
 El valor de la `numberOfSegments` parámetro especifica el número de segmentos, después del punto de partida, se va a dibujar en la curva. El valor de la `numberOfSegments` parámetro debe ser al menos 1. El valor de la `offset` parámetro más el valor de la `numberOfSegments` parámetro debe ser menor que el número de elementos de la matriz de los `points` parámetro.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos para definir una curva.  
  
-   Dibuja seis líneas rectas rojo entre los siete puntos para formar un polígono incompleto.  
  
-   Define el desplazamiento del punto inicial y el número de segmentos.  
  
-   Dibuja una curva de verde abierta (comenzando por el tercer punto) a través de los últimos cinco puntos.  
  
 El método utiliza una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.Point[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que definen la curva spline.</param>
        <param name="offset">Desplazamiento entre el primer elemento de la matriz del parámetro <paramref name="points" /> y el punto inicial de la curva.</param>
        <param name="numberOfSegments">Número de segmentos posteriores al punto inicial que se incluirán en la curva.</param>
        <param name="tension">Valor mayor o igual que 0,0 F que especifica la tensión de la curva.</param>
        <summary>Dibuja una curva spline cardinal a través de una matriz especificada de estructuras <see cref="T:System.Drawing.Point" /> con la tensión especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal que pasa por cada punto de la matriz.  
  
 La matriz de puntos debe contener al menos tres <xref:System.Drawing.Point> estructuras para que se dibuja una curva.  
  
 El valor de la `offset` parámetro especifica el número de elementos que se omiten en la matriz. El primer elemento después de los elementos omitidos representa el punto inicial de la curva.  
  
 El valor de la `numberOfSegments` parámetro especifica el número de segmentos, después del punto de partida, se va a dibujar en la curva. El valor de la `numberOfSegments` parámetro debe ser al menos 1. El valor de la `offset` parámetro más el valor de la `numberOfSegments` parámetro debe ser menor que el número de elementos de la matriz de los `points` parámetro.  
  
 El `tension` parámetro determina la forma de la curva polinomial. Si el valor de la `tension` parámetro es 0, 0F, este método dibuja segmentos de línea recta para conectar los puntos. Normalmente, el `tension` parámetro es menor o igual que 1, 0f. Los valores en 1, 0F producen resultados inesperados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos para definir una curva.  
  
-   Dibuja seis líneas rectas rojo entre los siete puntos para formar un polígono incompleto.  
  
-   Define el desplazamiento del punto inicial y el número de segmentos.  
  
-   Define la tensión.  
  
-   Dibuja una curva de verde abierta (comenzando por el tercer punto) a través de los últimos cinco puntos.  
  
 El método establece la tensión a 1.0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawCurve">
      <MemberSignature Language="C#" Value="public void DrawCurve (System.Drawing.Pen pen, System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawCurve(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawCurve(System.Drawing.Pen,System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawCurve(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.DrawCurve : System.Drawing.Pen * System.Drawing.PointF[] * int * int * single -&gt; unit" Usage="graphics.DrawCurve (pen, points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la curva.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen la curva spline.</param>
        <param name="offset">Desplazamiento entre el primer elemento de la matriz del parámetro <paramref name="points" /> y el punto inicial de la curva.</param>
        <param name="numberOfSegments">Número de segmentos posteriores al punto inicial que se incluirán en la curva.</param>
        <param name="tension">Valor mayor o igual que 0,0 F que especifica la tensión de la curva.</param>
        <summary>Dibuja una curva spline cardinal a través de una matriz especificada de estructuras <see cref="T:System.Drawing.PointF" /> con la tensión especificada. El dibujo comienza su desplazamiento a partir del comienzo de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una curva spline cardinal que pasa por cada punto de la matriz.  
  
 La matriz de puntos debe contener al menos tres <xref:System.Drawing.PointF> estructuras para la curva que se va a dibujar.  
  
 El valor de la `offset` parámetro especifica el número de elementos que se omiten en la matriz. El primer elemento después de los elementos omitidos representa el punto inicial de la curva.  
  
 El valor de la `numberOfSegments` parámetro especifica el número de segmentos, después del punto de partida, se va a dibujar en la curva. El valor de la `numberOfSegments` parámetro debe ser al menos 1. El valor de la `offset` parámetro más el valor de la `numberOfSegments` parámetro debe ser menor que el número de elementos de la matriz de los `points` parámetro.  
  
 El `tension` parámetro determina la forma de la curva polinomial. Si el valor de la `tension` parámetro es 0, 0F, este método dibuja segmentos de línea recta para conectar los puntos. Normalmente, el `tension` parámetro es menor o igual que 1, 0f. Los valores en 1, 0F producen resultados inesperados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea los lápices de rojos y verdes.  
  
-   Crea siete puntos para definir una curva.  
  
-   Dibuja seis líneas rectas rojo entre los siete puntos para formar un polígono incompleto.  
  
-   Define el desplazamiento del punto inicial y el número de segmentos.  
  
-   Define la tensión.  
  
-   Dibuja una curva de verde abierta (comenzando por el tercer punto) a través de los últimos cinco puntos.  
  
 El método establece la tensión a 1.0.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja una elipse definida por un rectángulo delimitador especificado por un par de coordenadas, un valor de alto y un valor de ancho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la elipse.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que define los límites de la elipse.</param>
        <summary>Dibuja una elipse especificada por una estructura <see cref="T:System.Drawing.Rectangle" /> de delimitación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una elipse definida por el rectángulo delimitador especificado por el `rect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea un rectángulo que delimita una elipse.  
  
-   Dibuja la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawEllipse (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la elipse.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que define los límites de la elipse.</param>
        <summary>Dibuja una elipse definida por una estructura <see cref="T:System.Drawing.RectangleF" /> de delimitación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una elipse definida por el rectángulo delimitador especificado por el `rect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea un rectángulo que delimita una elipse.  
  
-   Dibuja la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la elipse.</param>
        <param name="x">Coordenada X de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="y">Coordenada Y de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse.</param>
        <summary>Dibuja una elipse definida por un rectángulo delimitador que se especifica mediante las coordenadas de la esquina superior izquierda, un valor de alto y un valor de ancho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una elipse definida por el rectángulo delimitador que describen el `x`, `y`, `width`, y `height` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea la posición y tamaño de un rectángulo para delimitar una elipse.  
  
-   Dibuja la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public void DrawEllipse (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawEllipse(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawEllipse(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawEllipse(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawEllipse : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawEllipse (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la elipse.</param>
        <param name="x">Coordenada X de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="y">Coordenada Y de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse.</param>
        <summary>Dibuja una elipse definida por un rectángulo delimitador especificado por un par de coordenadas, un valor de alto y un valor de ancho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una elipse definida por el rectángulo delimitador que describen el `x`, `y`, `width`, y `height` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea la posición y tamaño de un rectángulo para delimitar una elipse.  
  
-   Dibuja la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawIcon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja la imagen representada por el <see cref="T:System.Drawing.Icon" /> especificado en las coordenadas señaladas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIcon (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon"><see cref="T:System.Drawing.Icon" /> que se va a dibujar.</param>
        <param name="targetRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen resultante en la superficie de pantalla. La imagen contenida en el parámetro <paramref name="icon" /> se amplía o reduce según las dimensiones de esta área rectangular.</param>
        <summary>Dibuja la imagen representada por el <see cref="T:System.Drawing.Icon" /> especificado dentro del área que indica una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un icono desde un archivo de icono de Windows estándar, SampIcon.ico, en la carpeta de ejemplo.  
  
-   Crea un rectángulo en el que se va a dibujar el icono.  
  
-   Dibuja el icono en la pantalla.  
  
 La posición del rectángulo localiza el icono en la pantalla y el tamaño del rectángulo determina el escalado del icono dibujado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#31)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#31)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#31](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIcon">
      <MemberSignature Language="C#" Value="public void DrawIcon (System.Drawing.Icon icon, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIcon(class System.Drawing.Icon icon, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIcon(System.Drawing.Icon,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIcon(System::Drawing::Icon ^ icon, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawIcon : System.Drawing.Icon * int * int -&gt; unit" Usage="graphics.DrawIcon (icon, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="icon"><see cref="T:System.Drawing.Icon" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <summary>Dibuja la imagen representada por el <see cref="T:System.Drawing.Icon" /> especificado en las coordenadas señaladas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un icono desde un archivo de icono de Windows estándar, SampIcon.ico, en la carpeta de ejemplo.  
  
-   Crea las coordenadas de la esquina superior izquierda en el que se va a dibujar el icono.  
  
-   Dibuja el icono en la pantalla.  
  
 Icono dibujado es sin escala.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#32)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#32)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#32](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawIconUnstretched">
      <MemberSignature Language="C#" Value="public void DrawIconUnstretched (System.Drawing.Icon icon, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawIconUnstretched(class System.Drawing.Icon icon, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawIconUnstretched(System.Drawing.Icon,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawIconUnstretched(System::Drawing::Icon ^ icon, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawIconUnstretched : System.Drawing.Icon * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawIconUnstretched (icon, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="icon" Type="System.Drawing.Icon" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="icon"><see cref="T:System.Drawing.Icon" /> que se va a dibujar.</param>
        <param name="targetRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen resultante. No se modifica la escala de la imagen para que encaje en el rectángulo, sino que conserva su tamaño original. Si la imagen es mayor que el rectángulo, se recorta para que quepa en él.</param>
        <summary>Dibuja la imagen representada por el <see cref="T:System.Drawing.Icon" /> especificado sin transformar a escala la imagen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un icono desde un archivo de icono de Windows estándar, SampIcon.ico, en la carpeta de ejemplo.  
  
-   Crea un rectángulo en el que se va a dibujar el icono.  
  
-   Dibuja el icono en la pantalla.  
  
 La posición del rectángulo localiza el icono en la pantalla y el icono dibujado se escala y correspondiente.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#33)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#33)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#33](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="icon" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada en la ubicación que se indique y con el tamaño original.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="point">Estructura <see cref="T:System.Drawing.Point" /> que representa la ubicación de la esquina superior izquierda de la imagen dibujada.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada con su tamaño físico original y en la ubicación que se indique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 3 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 Este método dibuja una imagen con su tamaño físico, de modo que la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a este método para dibujar esa imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la imagen representada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un punto en el que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Dibuja la imagen sin ajustar a escala en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#34)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#34)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#34](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada en la ubicación que se indique, con la forma y el tamaño señalados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.Point> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 La imagen representada por el `image` parámetro se escalan y se recorta para ajustarse a la forma del paralelogramo especificado por el `destPoints` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del paralelogramo localiza la imagen en la pantalla y el tamaño de la imagen original y el tamaño y forma del paralelogramo determinan la escala y el sesgo de la imagen dibujada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#35)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#35)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#35](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawImage (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="point">Estructura <see cref="T:System.Drawing.PointF" /> que representa la esquina superior izquierda de la imagen dibujada.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada con su tamaño físico original y en la ubicación que se indique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 3 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 Este método dibuja una imagen con su tamaño físico, de modo que la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a este método para dibujar esa imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la imagen representada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un punto en el que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Dibuja la imagen sin ajustar a escala en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#40)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#40)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawImage (image, destPoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada en la ubicación que se indique, con la forma y el tamaño señalados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 La imagen representada por el `image` objeto se escalan y se recorta para ajustarse a la forma del paralelogramo especificado por el `destPoints` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del paralelogramo localiza la imagen en la pantalla y el tamaño de la imagen original y el tamaño y forma del paralelogramo determinan la escala y el sesgo de la imagen dibujada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#41)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#41)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada en la ubicación que se indique y con el tamaño señalado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La imagen representada por el `image` objeto está a escala con las dimensiones de la `rect` rectángulo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un rectángulo en el que se va a dibujar la imagen.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del rectángulo localiza la imagen en la pantalla y el tamaño de la imagen original y el tamaño del rectángulo determinan el escalado de la imagen dibujada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#46)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#46)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#46](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawImage (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación y el tamaño de la imagen dibujada.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada en la ubicación que se indique y con el tamaño señalado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La imagen representada por el `image` objeto está a escala con las dimensiones de la `rect` rectángulo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un rectángulo en el que se va a dibujar la imagen.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del rectángulo localiza la imagen en la pantalla y el tamaño de la imagen original y el tamaño del rectángulo determinan el escalado de la imagen dibujada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#56)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#56)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#56](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <summary>Dibuja la imagen especificada con su tamaño físico original y en la ubicación especificada por un par de coordenadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 3 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 El <xref:System.Drawing.Graphics.DrawImage%2A> método dibuja una imagen con su tamaño físico, de modo que la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a <xref:System.Drawing.Graphics.DrawImage%2A> para dibujar esa imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la imagen representada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo SampImag.jpg situado en la carpeta del ejemplo.  
  
-   Crea las coordenadas de un punto en el que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Dibuja la imagen sin escala.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#58)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#58)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#58](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada con su tamaño físico original y en la ubicación que se indique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 3 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 Este método dibuja una imagen con su tamaño físico, de modo que la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a este método para dibujar esa imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la imagen representada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea las coordenadas de un punto en el que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Dibuja la imagen sin ajustar a escala en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#61)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#61)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#61](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.Point> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala y recorta para que encaje dentro del paralelogramo especificado por el `destPoints` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen.  
  
-   Crea un rectángulo para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del paralelogramo localiza la imagen en la pantalla y el tamaño del rectángulo y el tamaño y forma del paralelogramo determinan la escala y el sesgo de la imagen dibujada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#36)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#36)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#36](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala y recorta para que encaje dentro del paralelogramo especificado por el `destPoints` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen de destino.  
  
-   Crea un rectángulo de origen desde el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del paralelogramo destino localiza la imagen en la pantalla, el tamaño del rectángulo de origen y el tamaño y forma del paralelogramo destino determinan la escala y el sesgo de la imagen dibujada y determina el tamaño del rectángulo qué parte de la imagen original se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#42)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#42)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#42](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea un rectángulo de origen desde el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del rectángulo de destino localiza la imagen en la pantalla, el tamaño de los rectángulos de origen y destino determina el escalado de la imagen dibujada y el tamaño del rectángulo de origen determina qué parte de la imagen original se dibuja en el pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#47)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#47)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea un rectángulo de origen desde el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del rectángulo de destino localiza la imagen en la pantalla, el tamaño de los rectángulos de origen y destino determina el escalado de la imagen dibujada y el tamaño del rectángulo de origen determina qué parte de la imagen original se dibuja en el pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#57)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#57)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#57](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> que se indique en la ubicación señalada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.Point> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 El `srcRect` parámetro especifica una parte rectangular de la`image` objeto que se va a dibujar. Esta parte se escala y recorta para que encaje dentro del paralelogramo especificado por el `destPoints` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen.  
  
-   Crea un rectángulo para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un paralelogramo adicional en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 Para el paralelogramo original sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo y el tamaño y forma del paralelogramo determinan la escala y el sesgo de la imagen dibujada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#37)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#37)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#37)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala y recorta para que encaje dentro del paralelogramo especificado por el `destPoints` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen de destino.  
  
-   Crea un rectángulo de origen desde el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un paralelogramo adicional en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 El paralelogramo destino original y sin ajustar la posición localiza la imagen en la pantalla, el tamaño del rectángulo de origen y el tamaño y forma del paralelogramo destino determina el ajuste de escala y recorte de la imagen dibujada y el tamaño de la rectángulo determina qué parte de la imagen original se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#43)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#43)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#43](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Drawing.Rectangle,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * System.Drawing.Rectangle * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <summary>Dibuja una parte de una imagen en una ubicación especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 360 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 5 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 Este método dibuja una parte de una imagen con su tamaño físico, de modo que la parte de la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una parte de la imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a este método para dibujar esa parte de la imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la parte de la imagen representada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea las coordenadas en las que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Crea un rectángulo de origen desde el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen en la pantalla.  
  
 El tamaño del rectángulo de origen determina qué parte de la imagen original sin escala se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#59)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#59)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#59](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="width">Ancho de la imagen dibujada.</param>
        <param name="height">Alto de la imagen dibujada.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada en la ubicación que se indique y con el tamaño señalado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El rectángulo definido por el `x`, `y`, `width`, y `height` parámetros determina la posición y tamaño de la imagen dibujada.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea la posición y tamaño de un rectángulo en el que se va a dibujar la imagen.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del rectángulo localiza la imagen en la pantalla y el tamaño de la imagen original y el tamaño del rectángulo determinan el escalado de la imagen dibujada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#60)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#60)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#60](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Drawing.RectangleF,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * System.Drawing.RectangleF * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, x, y, srcRect, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte de <see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <summary>Dibuja una parte de una imagen en una ubicación especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 360 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 5 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 Este método dibuja una parte de una imagen con su tamaño físico, de modo que la parte de la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una parte de la imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a este método para dibujar esa parte de la imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la parte de la imagen representada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea las coordenadas en las que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Crea un rectángulo de origen desde el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen en la pantalla.  
  
 El tamaño del rectángulo de origen determina qué parte de la imagen original sin escala se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#62)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#62)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#62](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * single * single * single * single -&gt; unit" Usage="graphics.DrawImage (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="width">Ancho de la imagen dibujada.</param>
        <param name="height">Alto de la imagen dibujada.</param>
        <summary>Dibuja la <see cref="T:System.Drawing.Image" /> especificada en la ubicación que se indique y con el tamaño señalado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El rectángulo definido por el `x`, `y`, `width`, y `height` parámetros determina la posición y tamaño de la imagen dibujada.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea la posición y tamaño de un rectángulo en el que se va a dibujar la imagen.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del rectángulo localiza la imagen en la pantalla y el tamaño de la imagen original y el tamaño del rectángulo determinan el escalado de la imagen dibujada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#63)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#63)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#63](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica un método al que llamar durante el dibujado de la imagen. Se llama con frecuencia a este método para comprobar si se debe detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> según los criterios establecidos por la aplicación.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala y recorta para que encaje dentro del paralelogramo especificado por el `destPoints` parámetro.  
  
 Esta sobrecarga con el `callback` parámetro proporciona los medios para detener el dibujo de una imagen una vez que se inicia según los criterios especificados por la aplicación. Por ejemplo, una aplicación podría empezar a dibujar una imagen grande y el usuario puede desplazarse por la imagen fuera de la pantalla, en el que caso la aplicación podría dejar el dibujo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En primer lugar, el código define un método de devolución de llamada para el <xref:System.Drawing.Graphics.DrawImageAbort> delegar; la definición es sencilla y únicamente comprueba si el <xref:System.Drawing.Graphics.DrawImage%2A> método lo llama con un valor null `callBackData` parámetro. El cuerpo principal del ejemplo realiza las siguientes acciones:  
  
-   Crea una instancia de la <xref:System.Drawing.Graphics.DrawImageAbort> el método de devolución de llamada:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen.  
  
-   Crea un rectángulo para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un paralelogramo adicional en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 Para el paralelogramo original sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo y el tamaño y forma del paralelogramo determinan la escala y el sesgo de la imagen dibujada.  
  
 Dado que este ejemplo utiliza una sobrecarga que no pasa un `callBackData` parámetro, el <xref:System.Drawing.Graphics.DrawImageAbort> devolución de llamada devuelve `true`, lo que hace que el <xref:System.Drawing.Graphics.DrawImage%2A> método final y el código de control de excepciones incluido en el ejemplo imprime el texto de la excepción en lugar de dibujar la imagen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#38)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#38)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica un método al que llamar durante el dibujado de la imagen. Se llama con frecuencia a este método para comprobar si se debe detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> según los criterios establecidos por la aplicación.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala y recorta para que encaje dentro del paralelogramo especificado por el `destPoints` parámetro.  
  
 Esta sobrecarga con el `callback` parámetro proporciona los medios para detener el dibujo de una imagen una vez que se inicia según los criterios especificados por la aplicación. Por ejemplo, una aplicación podría empezar a dibujar una imagen grande y el usuario puede desplazarse por la imagen fuera de la pantalla, en el que caso la aplicación podría dejar el dibujo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En primer lugar, el código define un método de devolución de llamada para el <xref:System.Drawing.Graphics.DrawImageAbort> delegar; la definición es sencilla y únicamente comprueba si el <xref:System.Drawing.Graphics.DrawImage%2A> método lo llama con un valor null `callBackData` parámetro. El cuerpo principal del ejemplo realiza las siguientes acciones:  
  
-   Crea una instancia de la <xref:System.Drawing.Graphics.DrawImageAbort> el método de devolución de llamada.  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen.  
  
-   Crea un rectángulo para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un paralelogramo adicional en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 Para el paralelogramo original sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo y el tamaño y forma del paralelogramo determinan la escala y el sesgo de la imagen dibujada.  
  
 Dado que este ejemplo utiliza una sobrecarga que no pasa un `callBackData` parámetro, el <xref:System.Drawing.Graphics.DrawImageAbort> devolución de llamada devuelve `true`, lo que hace que el <xref:System.Drawing.Graphics.DrawImage%2A> método final y el código de control de excepciones incluido en el ejemplo imprime el texto de la excepción en lugar de dibujar la imagen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#44)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#44)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#44](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica un método al que llamar durante el dibujado de la imagen. Se llama con frecuencia a este método para comprobar si se debe detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> según los criterios establecidos por la aplicación.</param>
        <param name="callbackData">Valor que especifica datos adicionales para el delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> con el fin de usarlo al comprobar si se desea detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala y recorta para que encaje dentro del paralelogramo especificado por el `destPoints` parámetro.  
  
 Esta sobrecarga con el `callback` y `callbackData` parámetros proporciona los medios para detener el dibujo de una imagen una vez que se inicia según los criterios y los datos especificados por la aplicación. Por ejemplo, una aplicación podría empezar a dibujar una imagen grande y el usuario puede desplazarse por la imagen fuera de la pantalla, en el que caso la aplicación podría dejar el dibujo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En primer lugar, el código define un método de devolución de llamada para el <xref:System.Drawing.Graphics.DrawImageAbort> delegar; la definición es sencilla y únicamente comprueba si el <xref:System.Drawing.Graphics.DrawImage%2A> método lo llama con un valor null `callBackData` parámetro. El cuerpo principal del ejemplo realiza las siguientes acciones:  
  
-   Crea una instancia de la <xref:System.Drawing.Graphics.DrawImageAbort> el método de devolución de llamada.  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen.  
  
-   Crea un rectángulo para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un paralelogramo adicional en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 Para el paralelogramo original sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo y el tamaño y forma del paralelogramo determinan la escala y el sesgo de la imagen dibujada.  
  
 Dado que este ejemplo utiliza una sobrecarga que pasa un `callBackData` parámetro, el <xref:System.Drawing.Graphics.DrawImageAbort> devolución de llamada devuelve `false`, lo que hace que el <xref:System.Drawing.Graphics.DrawImage%2A> método para continuar y en el ejemplo se dibuja la imagen ajustada a la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#39)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#39)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#39](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#39)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback, int callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback, int32 callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback, int callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * int -&gt; unit" Usage="graphics.DrawImage (image, destPoints, srcRect, srcUnit, imageAttr, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del objeto <paramref name="image" /> que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que usará el parámetro <paramref name="srcRect" />.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica un método al que llamar durante el dibujado de la imagen. Se llama con frecuencia a este método para comprobar si se debe detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" /> según los criterios establecidos por la aplicación.</param>
        <param name="callbackData">Valor que especifica datos adicionales para el delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> con el fin de usarlo al comprobar si se desea detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.Int32)" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo.  
  
 El `srcRect` parámetro especifica una parte rectangular de la `image` objeto que se va a dibujar. Esta parte se escala y recorta para que encaje dentro del paralelogramo especificado por el `destPoints` parámetro.  
  
 Esta sobrecarga con el `callback` y `callbackData` parámetros proporciona los medios para detener el dibujo de una imagen una vez que se inicia según los criterios y los datos especificados por la aplicación. Por ejemplo, una aplicación podría empezar a dibujar una imagen grande y el usuario puede desplazarse por la imagen fuera de la pantalla, en el que caso la aplicación podría dejar el dibujo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la `Pa` <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En primer lugar, el código define un método de devolución de llamada para el <xref:System.Drawing.Graphics.DrawImageAbort> delegar; la definición es sencilla y únicamente comprueba si el <xref:System.Drawing.Graphics.DrawImage%2A> método lo llama con un valor null `callBackData` parámetro. El cuerpo principal del ejemplo realiza las siguientes acciones:  
  
-   Crea una instancia de la <xref:System.Drawing.Graphics.DrawImageAbort> el método de devolución de llamada.  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un paralelogramo en que se va a dibujar la imagen.  
  
-   Crea un rectángulo para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un paralelogramo adicional en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 Para el paralelogramo original sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo y el tamaño y forma del paralelogramo determinan la escala y el sesgo de la imagen dibujada.  
  
 Dado que este ejemplo utiliza una sobrecarga que pasa un `callBackData` parámetro, el <xref:System.Drawing.Graphics.DrawImageAbort> devolución de llamada devuelve `false`, lo que hace que el <xref:System.Drawing.Graphics.DrawImage%2A> método para continuar y en el ejemplo se dibuja la imagen ajustada a la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#45)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#45)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#45](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcX">Coordenada x de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcY">Coordenada y de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcWidth">Ancho de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcHeight">Alto de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que se usarán para determinar el rectángulo de origen.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcX`, `srcY`, `srcWidth`, y `srcHeight` los parámetros especifican una parte rectangular de la `image` objeto que se va a dibujar. El rectángulo es relativo a la esquina superior izquierda de la imagen de origen. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea las coordenadas de un rectángulo de origen en el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del rectángulo de destino localiza la imagen en la pantalla y el tamaño de los rectángulos de origen y destino determina el escalado de la imagen dibujada y el tamaño del rectángulo de origen determina qué parte de la imagen original se dibuja en el pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#48)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#48)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#48](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcX">Coordenada x de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcY">Coordenada y de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcWidth">Ancho de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcHeight">Alto de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que se usarán para determinar el rectángulo de origen.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcX`, `srcY`, `srcWidth`, y `srcHeight` los parámetros especifican una parte rectangular de la `image` objeto que se va a dibujar. El rectángulo es relativo a la esquina superior izquierda de la imagen de origen. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea las coordenadas de un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea un rectángulo de origen desde el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen en la pantalla.  
  
 La posición del rectángulo de destino localiza la imagen en la pantalla, el tamaño de los rectángulos de origen y destino determina el escalado de la imagen dibujada y el tamaño del rectángulo de origen determina qué parte de la imagen original se dibuja en el pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#52)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#52)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#52](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcX">Coordenada x de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcY">Coordenada y de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcWidth">Ancho de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcHeight">Alto de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que se usarán para determinar el rectángulo de origen.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcX`, `srcY`, `srcWidth`, y `srcHeight` los parámetros especifican una parte rectangular de la `image` objeto que se va a dibujar. El rectángulo es relativo a la esquina superior izquierda de la imagen de origen. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea las coordenadas de un rectángulo de origen en el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un rectángulo adicional en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 El rectángulo de destino original y sin ajustar la posición localiza la imagen en la pantalla y el tamaño de los rectángulos de origen y destino determina el escalado de la imagen dibujada y el tamaño del rectángulo de origen determina qué parte de la se dibuja la imagen original a la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#49)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#49)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#49](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#49)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcX">Coordenada x de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcY">Coordenada y de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcWidth">Ancho de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcHeight">Alto de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que se usarán para determinar el rectángulo de origen.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcX`, `srcY`, `srcWidth`, y `srcHeight` los parámetros especifican una parte rectangular de la `image` objeto que se va a dibujar. El rectángulo es relativo a la esquina superior izquierda de la imagen de origen. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea las coordenadas de un rectángulo de origen en el que se va a extraer una parte de la imagen.  
  
-   Establece la unidad de medida del rectángulo de origen en píxeles.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un rectángulo adicional en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 El rectángulo de destino original y sin ajustar la posición localiza la imagen en la pantalla y el tamaño de los rectángulos de origen y destino determina el escalado de la imagen dibujada y el tamaño del rectángulo de origen determina qué parte de la se dibuja la imagen original a la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#53)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#53)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#53](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#53)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttr, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttr, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttr, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttr, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcX">Coordenada x de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcY">Coordenada y de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcWidth">Ancho de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcHeight">Alto de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que se usarán para determinar el rectángulo de origen.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica un método al que llamar durante el dibujado de la imagen. Se llama con frecuencia a este método para comprobar si se debe detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> según los criterios establecidos por la aplicación.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcX`, `srcY`, `srcWidth`, y `srcHeight` los parámetros especifican una parte rectangular de la `image` objeto que se va a dibujar. El rectángulo es relativo a la esquina superior izquierda de la imagen de origen. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` objeto.  
  
 Esta sobrecarga con el `callback` parámetro proporciona los medios para detener el dibujo de una imagen una vez que se inicia según los criterios especificados por la aplicación. Por ejemplo, una aplicación podría empezar a dibujar una imagen grande y el usuario puede desplazarse por la imagen fuera de la pantalla, en el que caso la aplicación podría dejar el dibujo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En primer lugar, el código define un método de devolución de llamada para el <xref:System.Drawing.Graphics.DrawImageAbort> delegar; la definición es sencilla y únicamente comprueba si el <xref:System.Drawing.Graphics.DrawImage%2A> método lo llama con un valor null `callBackData` parámetro. El cuerpo principal del ejemplo realiza las siguientes acciones:  
  
-   Crea una instancia de la <xref:System.Drawing.Graphics.DrawImageAbort> el método de devolución de llamada.  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea un rectángulo de origen para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un rectángulo de destino adicionales en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 El rectángulo de destino original y sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo de origen y el tamaño y la forma de rectángulo de destino determinan el escalado de la imagen dibujada.  
  
 Dado que este ejemplo utiliza una sobrecarga que no pasa un `callBackData` parámetro, el <xref:System.Drawing.Graphics.DrawImageAbort> devolución de llamada devuelve `true`, lo que hace que el <xref:System.Drawing.Graphics.DrawImage%2A> método final y el código de control de excepciones incluido en el ejemplo imprime el texto de la excepción en lugar de dibujar la imagen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#50)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#50)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#50](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcX">Coordenada x de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcY">Coordenada y de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcWidth">Ancho de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcHeight">Alto de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que se usarán para determinar el rectángulo de origen.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica un método al que llamar durante el dibujado de la imagen. Se llama con frecuencia a este método para comprobar si se debe detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort)" /> según los criterios establecidos por la aplicación.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcX`, `srcY`, `srcWidth`, y `srcHeight` los parámetros especifican una parte rectangular de la `image` objeto que se va a dibujar. El rectángulo es relativo a la esquina superior izquierda de la imagen de origen. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
 Esta sobrecarga con el `callback` parámetro proporciona los medios para detener el dibujo de una imagen una vez que se inicia según los criterios especificados por la aplicación. Por ejemplo, una aplicación podría empezar a dibujar una imagen grande y el usuario puede desplazarse por la imagen fuera de la pantalla, en el que caso la aplicación podría dejar el dibujo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En primer lugar, el código define un método de devolución de llamada para el <xref:System.Drawing.Graphics.DrawImageAbort> delegar; la definición es sencilla y únicamente comprueba si el <xref:System.Drawing.Graphics.DrawImage%2A> método lo llama con un valor null `callBackData` parámetro. El cuerpo principal del ejemplo realiza las siguientes acciones:  
  
-   Crea una instancia de la <xref:System.Drawing.Graphics.DrawImageAbort> el método de devolución de llamada.  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea un rectángulo de origen para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un rectángulo de destino adicionales en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 El rectángulo de destino original y sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo de origen y el tamaño y la forma de rectángulo de destino determinan el escalado de la imagen dibujada.  
  
 Dado que este ejemplo utiliza una sobrecarga que no pasa un `callBackData` parámetro, el <xref:System.Drawing.Graphics.DrawImageAbort> devolución de llamada devuelve `true`, lo que hace que el <xref:System.Drawing.Graphics.DrawImage%2A> método final y el código de control de excepciones incluido en el ejemplo imprime el texto de la excepción en lugar de dibujar la imagen.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#54)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#54)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, int32 srcX, int32 srcY, int32 srcWidth, int32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * int * int * int * int * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Int32" />
        <Parameter Name="srcY" Type="System.Int32" />
        <Parameter Name="srcWidth" Type="System.Int32" />
        <Parameter Name="srcHeight" Type="System.Int32" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcX">Coordenada x de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcY">Coordenada y de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcWidth">Ancho de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcHeight">Alto de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que se usarán para determinar el rectángulo de origen.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica un método al que llamar durante el dibujado de la imagen. Se llama con frecuencia a este método para comprobar si se debe detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> según los criterios establecidos por la aplicación.</param>
        <param name="callbackData">Valor que especifica datos adicionales para el delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> con el fin de usarlo al comprobar si se desea detener la ejecución del método <see langword="DrawImage" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcX`, `srcY`, `srcWidth`, y `srcHeight` los parámetros especifican una parte rectangular de la `image` objeto que se va a dibujar. El rectángulo es relativo a la esquina superior izquierda de la imagen de origen. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
 Esta sobrecarga con el `callback` y `callbackData` parámetros proporciona los medios para detener el dibujo de una imagen una vez que se inicia según los criterios y los datos especificados por la aplicación. Por ejemplo, una aplicación podría empezar a dibujar una imagen grande y el usuario puede desplazarse por la imagen fuera de la pantalla, en el que caso la aplicación podría dejar el dibujo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En primer lugar, el código define un método de devolución de llamada para el <xref:System.Drawing.Graphics.DrawImageAbort> delegar; la definición es sencilla y únicamente comprueba si el <xref:System.Drawing.Graphics.DrawImage%2A> método lo llama con un valor null `callBackData` parámetro. El cuerpo principal del ejemplo realiza las siguientes acciones:  
  
-   Crea una instancia de la <xref:System.Drawing.Graphics.DrawImageAbort> el método de devolución de llamada.  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea un rectángulo de origen para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un rectángulo de destino adicionales en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 El rectángulo de destino original y sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo de origen y el tamaño y la forma de rectángulo de destino determinan el escalado de la imagen dibujada.  
  
 Dado que este ejemplo utiliza una sobrecarga que pasa un `callBackData` parámetro, el <xref:System.Drawing.Graphics.DrawImageAbort> devolución de llamada devuelve `false`, lo que hace que el <xref:System.Drawing.Graphics.DrawImage%2A> método para continuar y en el ejemplo se dibuja la imagen ajustada a la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CPP/form1.cpp#51)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/CS/form1.cs#51)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples#51](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples/VB/form1.vb#51)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public void DrawImage (System.Drawing.Image image, System.Drawing.Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Imaging.ImageAttributes imageAttrs, System.Drawing.Graphics.DrawImageAbort callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImage(class System.Drawing.Image image, valuetype System.Drawing.Rectangle destRect, float32 srcX, float32 srcY, float32 srcWidth, float32 srcHeight, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Imaging.ImageAttributes imageAttrs, class System.Drawing.Graphics/DrawImageAbort callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImage(System::Drawing::Image ^ image, System::Drawing::Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Imaging::ImageAttributes ^ imageAttrs, System::Drawing::Graphics::DrawImageAbort ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.DrawImage : System.Drawing.Image * System.Drawing.Rectangle * single * single * single * single * System.Drawing.GraphicsUnit * System.Drawing.Imaging.ImageAttributes * System.Drawing.Graphics.DrawImageAbort * nativeint -&gt; unit" Usage="graphics.DrawImage (image, destRect, srcX, srcY, srcWidth, srcHeight, srcUnit, imageAttrs, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcX" Type="System.Single" />
        <Parameter Name="srcY" Type="System.Single" />
        <Parameter Name="srcWidth" Type="System.Single" />
        <Parameter Name="srcHeight" Type="System.Single" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="imageAttrs" Type="System.Drawing.Imaging.ImageAttributes" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+DrawImageAbort" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño de la imagen dibujada. La imagen se reduce de escala para que encaje en el rectángulo.</param>
        <param name="srcX">Coordenada x de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcY">Coordenada y de la esquina superior izquierda de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcWidth">Ancho de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcHeight">Alto de la parte de la imagen de origen que se va a dibujar.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica las unidades de medida que se usarán para determinar el rectángulo de origen.</param>
        <param name="imageAttrs"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica la información de cambio de color y de gamma para <paramref name="image" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> que especifica un método al que llamar durante el dibujado de la imagen. Se llama con frecuencia a este método para comprobar si se debe detener la ejecución del método <see cref="M:System.Drawing.Graphics.DrawImage(System.Drawing.Image,System.Drawing.Rectangle,System.Single,System.Single,System.Single,System.Single,System.Drawing.GraphicsUnit,System.Drawing.Imaging.ImageAttributes,System.Drawing.Graphics.DrawImageAbort,System.IntPtr)" /> según los criterios establecidos por la aplicación.</param>
        <param name="callbackData">Valor que especifica datos adicionales para el delegado <see cref="T:System.Drawing.Graphics.DrawImageAbort" /> con el fin de usarlo al comprobar si se desea detener la ejecución del método <see langword="DrawImage" />.</param>
        <summary>Dibuja la parte especificada de la <see cref="T:System.Drawing.Image" /> indicada en la ubicación que se señale y con el tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `srcX`, `srcY`, `srcWidth`, y `srcHeight` los parámetros especifican una parte rectangular de la `image` objeto que se va a dibujar. El rectángulo es relativo a la esquina superior izquierda de la imagen de origen. Esta parte se escala para que quepa en el rectángulo especificado por el `destRect` parámetro.  
  
 Esta sobrecarga con el `callback` y `callbackData` parámetros proporciona los medios para detener el dibujo de una imagen una vez que se inicia según los criterios y los datos especificados por la aplicación. Por ejemplo, una aplicación podría empezar a dibujar una imagen grande y el usuario puede desplazarse por la imagen fuera de la pantalla, en el que caso la aplicación podría dejar el dibujo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En primer lugar, el código define un método de devolución de llamada para el <xref:System.Drawing.Graphics.DrawImageAbort> delegar; la definición es sencilla y únicamente comprueba si el <xref:System.Drawing.Graphics.DrawImage%2A> método lo llama con un valor null `callBackData` parámetro. El cuerpo principal del ejemplo realiza las siguientes acciones:  
  
-   Crea una instancia de la <xref:System.Drawing.Graphics.DrawImageAbort> el método de devolución de llamada.  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea puntos que definen un rectángulo de destino en el que se va a dibujar la imagen.  
  
-   Crea un rectángulo de origen para seleccionar la parte de la imagen para dibujar.  
  
-   Establece la unidad de dibujo en píxeles de gráficos.  
  
-   Dibuja la imagen original en la pantalla.  
  
-   Crea un rectángulo de destino adicionales en el que se va a dibujar una imagen ajustada.  
  
-   Crea y establece los atributos de la imagen ajustada tenga un valor gamma mayor de lo habitual.  
  
-   Dibuja la imagen ajustada a la pantalla.  
  
 El rectángulo de destino original y sin ajustar la posición localiza la imagen en la pantalla y el tamaño del rectángulo de origen y el tamaño y la forma de rectángulo de destino determinan el escalado de la imagen dibujada.  
  
 Dado que este ejemplo utiliza una sobrecarga que pasa un `callBackData` parámetro, el <xref:System.Drawing.Graphics.DrawImageAbort> devolución de llamada devuelve `false`, lo que hace que el <xref:System.Drawing.Graphics.DrawImage%2A> método para continuar y en el ejemplo se dibuja la imagen ajustada a la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#55)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#55)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImageUnscaled">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja la imagen especificada con su tamaño físico original y en la ubicación especificada por un par de coordenadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Point -&gt; unit" Usage="graphics.DrawImageUnscaled (image, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="point">Estructura <see cref="T:System.Drawing.Point" /> que especifica la esquina superior izquierda de la imagen dibujada.</param>
        <summary>Dibuja la imagen especificada con su tamaño físico original y en la ubicación especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 3 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 El <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> método dibuja una imagen con su tamaño físico, de modo que la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> para dibujar esa imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la imagen representada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPGEG en la carpeta del ejemplo.  
  
-   Crea un punto en el que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Dibuja la imagen completa con su tamaño físico.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#64)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#64)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#64](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaled (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" /> que especifica la esquina superior izquierda de la imagen dibujada. Las propiedades X e Y del rectángulo especifican la esquina superior izquierda. Se omiten las propiedades Width y Height.</param>
        <summary>Dibuja la imagen especificada con su tamaño físico original y en la ubicación especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 3 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 El <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> método dibuja una imagen con su tamaño físico, de modo que la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> para dibujar esa imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la imagen representada será (216/72) * 96 = 288.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <summary>Dibuja la imagen especificada con su tamaño físico original y en la ubicación especificada por un par de coordenadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 3 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 El <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> método dibuja una imagen con su tamaño físico, de modo que la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> para dibujar esa imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la imagen representada será (216/72) * 96 = 288.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una imagen desde un archivo JPEG, SampImag.jpg, en la carpeta del ejemplo.  
  
-   Crea un punto en el que se va a dibujar la esquina superior izquierda de la imagen.  
  
-   Dibuja la imagen completa con su tamaño físico.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#65)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#65)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#65](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#65)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaled">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaled (System.Drawing.Image image, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaled(class System.Drawing.Image image, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaled(System.Drawing.Image,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaled(System::Drawing::Image ^ image, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaled : System.Drawing.Image * int * int * int * int -&gt; unit" Usage="graphics.DrawImageUnscaled (image, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="x">Coordenada x de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="y">Coordenada y de la esquina superior izquierda de la imagen dibujada.</param>
        <param name="width">No se utiliza.</param>
        <param name="height">No se utiliza.</param>
        <summary>Dibuja la imagen especificada con su tamaño físico original y en la ubicación especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Image> almacena un valor para el ancho en píxeles y un valor para la resolución horizontal (puntos por pulgada). El ancho físico, medido en pulgadas, de una imagen es el ancho de píxel dividido entre la resolución horizontal. Por ejemplo, una imagen con un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada tiene un ancho físico de 3 pulgadas. Comentarios similares se aplican a alto en píxeles y el alto físico.  
  
 El <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> método dibuja una imagen con su tamaño físico, de modo que la imagen tendrá su tamaño correcto en pulgadas, independientemente de la resolución (puntos por pulgada) de la pantalla. Por ejemplo, suponga que una imagen tiene un ancho de píxel de 216 y una resolución horizontal de 72 puntos por pulgada. Si se llama a <xref:System.Drawing.Graphics.DrawImageUnscaled%2A> para dibujar esa imagen en un dispositivo que tenga una resolución de 96 puntos por pulgada, el ancho de píxel de la imagen representada será (216/72) * 96 = 288.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawImageUnscaledAndClipped">
      <MemberSignature Language="C#" Value="public void DrawImageUnscaledAndClipped (System.Drawing.Image image, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawImageUnscaledAndClipped(class System.Drawing.Image image, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawImageUnscaledAndClipped(System.Drawing.Image,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawImageUnscaledAndClipped(System::Drawing::Image ^ image, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawImageUnscaledAndClipped : System.Drawing.Image * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawImageUnscaledAndClipped (image, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> que se va a dibujar.</param>
        <param name="rect"><see cref="T:System.Drawing.Rectangle" /> en el que se va a dibujar la imagen.</param>
        <summary>Dibuja la imagen especificada sin ajustar la escala y la recorta, si es necesario, para que quepa en el rectángulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método <xref:System.Drawing.Graphics.DrawImageUnscaledAndClipped%2A>. Para ejecutar este ejemplo, péguelo en un formulario de Windows. Controlar el formato <xref:System.Windows.Forms.Control.Paint> evento y llamar a la `DrawImageUnscaled` método desde el <xref:System.Windows.Forms.Control.Paint> método de control de eventos, pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-csharp[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/CS/Form1.cs#8)]
 [!code-vb[System.Drawing.MiscWhidbeySnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.MiscWhidbeySnippets/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja una línea que conecta los dos puntos especificados por los pares de coordenadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la línea.</param>
        <param name="pt1">Estructura <see cref="T:System.Drawing.Point" /> que representa el primer punto que se va a conectar.</param>
        <param name="pt2">Estructura <see cref="T:System.Drawing.Point" /> que representa el segundo punto que se va a conectar.</param>
        <summary>Dibuja una línea que conecta dos estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea puntos para los puntos de conexión de la línea.  
  
-   Dibuja la línea en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#66)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#66)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#66](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#66)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Utilizar lápiz para dibujar líneas y formas</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawLine (pen, pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la línea.</param>
        <param name="pt1">Estructura <see cref="T:System.Drawing.PointF" /> que representa el primer punto que se va a conectar.</param>
        <param name="pt2">Estructura <see cref="T:System.Drawing.PointF" /> que representa el segundo punto que se va a conectar.</param>
        <summary>Dibuja una línea que conecta dos estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una línea que conecta los dos puntos especificados por el `pt1` y p`2` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea puntos para los puntos de conexión de la línea.  
  
-   Dibuja la línea en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#67)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#67)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Utilizar lápiz para dibujar líneas y formas</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la línea.</param>
        <param name="x1">Coordenada x del primer punto.</param>
        <param name="y1">Coordenada y del primer punto.</param>
        <param name="x2">Coordenada x del segundo punto.</param>
        <param name="y2">Coordenada y del segundo punto.</param>
        <summary>Dibuja una línea que conecta los dos puntos especificados por los pares de coordenadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una línea que conecta los dos puntos especificados por el `x1`, `y1`, `x2`, y `y2` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea las coordenadas de los puntos de conexión de la línea.  
  
-   Dibuja la línea en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#68)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#68)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Utilizar lápiz para dibujar líneas y formas</related>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public void DrawLine (System.Drawing.Pen pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLine(class System.Drawing.Pen pen, float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLine(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLine(System::Drawing::Pen ^ pen, float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="F#" Value="member this.DrawLine : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawLine (pen, x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la línea.</param>
        <param name="x1">Coordenada x del primer punto.</param>
        <param name="y1">Coordenada y del primer punto.</param>
        <param name="x2">Coordenada x del segundo punto.</param>
        <param name="y2">Coordenada y del segundo punto.</param>
        <summary>Dibuja una línea que conecta los dos puntos especificados por los pares de coordenadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una línea que conecta los dos puntos especificados por el `x1`, `y1`, `x2`, y `y2` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea las coordenadas de los puntos de conexión de la línea.  
  
-   Dibuja la línea en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#69)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#69)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/winforms/advanced/using-a-pen-to-draw-lines-and-shapes.md">Utilizar lápiz para dibujar líneas y formas</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja una serie de segmentos de línea que conectan una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de los segmentos de línea.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que se van a conectar.</param>
        <summary>Dibuja una serie de segmentos de línea que conectan una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una serie de líneas que conectan una matriz de puntos finales. Los dos primeros puntos de la matriz especifican la primera línea. Cada punto adicional especifica el final de un segmento de línea cuyo punto de partida es el punto final del segmento de línea anterior.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea una matriz de puntos de segmentos de la línea.  
  
-   Dibuja los segmentos de línea conectados a la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#70)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#70)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#70](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawLines">
      <MemberSignature Language="C#" Value="public void DrawLines (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawLines(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawLines(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawLines(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawLines : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawLines (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de los segmentos de línea.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que se van a conectar.</param>
        <summary>Dibuja una serie de segmentos de línea que conectan una matriz de estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una serie de líneas que conectan una matriz de puntos finales. Los dos primeros puntos de la matriz especifican la primera línea. Cada punto adicional especifica el final de un segmento de línea cuyo punto de partida es el punto final del segmento de línea anterior.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Código crea una pluma de color negro.  
  
-   Crea una matriz de puntos de segmentos de la línea.  
  
-   Dibuja los segmentos de línea conectados a la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#71)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#71)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#71](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPath">
      <MemberSignature Language="C#" Value="public void DrawPath (System.Drawing.Pen pen, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPath(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPath(System.Drawing.Pen,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPath(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.DrawPath : System.Drawing.Pen * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.DrawPath (pen, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del trazado.</param>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que se va a dibujar.</param>
        <summary>Dibuja un <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La transformación actual en el contexto gráfico se aplica a la <xref:System.Drawing.Drawing2D.GraphicsPath> antes de dibujarlo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un objeto de trazado del gráfico y agrega una elipse.  
  
-   Crea una pluma de color negro.  
  
-   Dibuja el trazado de gráficos en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#72)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#72)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#72](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="path" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja una forma circular definida por una elipse determinada por un par de coordenadas, unos valores de ancho y alto y dos líneas radiales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la forma de gráfico circular.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo delimitador que define la elipse, de la cual procede la forma circular.</param>
        <param name="startAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el eje X hasta el primer lado de la forma de gráfico circular.</param>
        <param name="sweepAngle">Ángulo medido en grados en sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el segundo lado de la forma de gráfico circular.</param>
        <summary>Dibuja una forma circular definida por una elipse, determinada por una estructura <see cref="T:System.Drawing.Rectangle" /> y dos líneas radiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una forma circular definida por el arco de una elipse y dos líneas radiales que forman una intersección con los puntos de conexión del arco. La elipse está definida por el rectángulo delimitador. La forma de gráfico circular se compone de las dos líneas radiales definidas por el `startAngle` y `sweepAngle` parámetros y el arco entre las intersecciones de dichas líneas radiales con la elipse.  
  
 Si el `sweepAngle` parámetro es mayor que 360 grados o menor que-360 grados, se trata como si fuese 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea un rectángulo que delimita una elipse completa.  
  
-   Define los ángulos en los que se va a comenzar a dibujar (en relación con el eje x) y, a través del cual se va a dibujar (ambos en una dirección de las agujas del reloj).  
  
-   El segmento del gráfico circular se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#73)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#73)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#73](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphics.DrawPie (pen, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la forma de gráfico circular.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo delimitador que define la elipse, de la cual procede la forma circular.</param>
        <param name="startAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el eje X hasta el primer lado de la forma de gráfico circular.</param>
        <param name="sweepAngle">Ángulo medido en grados en sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el segundo lado de la forma de gráfico circular.</param>
        <summary>Dibuja una forma circular definida por una elipse, determinada por una estructura <see cref="T:System.Drawing.RectangleF" /> y dos líneas radiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una forma circular definida por el arco de una elipse y dos líneas radiales que forman una intersección con los puntos de conexión del arco. La elipse está definida por el rectángulo delimitador. La forma de gráfico circular se compone de las dos líneas radiales definidas por el `startAngle` y `sweepAngle` parámetros y el arco entre las intersecciones de dichas líneas radiales con la elipse.  
  
 Si el `sweepAngle` parámetro es mayor que 360 grados o menor que-360 grados, se trata como si fuese 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea un rectángulo que delimita una elipse completa.  
  
-   Define los ángulos en los que se va a comenzar a dibujar (en relación con el eje x) y, a través del cual se va a dibujar (ambos en una dirección de las agujas del reloj).  
  
-   El segmento del gráfico circular se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#74)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#74)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#74](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * int * int * int * int * int * int -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la forma de gráfico circular.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo delimitador que define la elipse de la que procede la forma de gráfico circular.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo delimitador que define la elipse de la que procede la forma de gráfico circular.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse de la que procede la forma de gráfico circular.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse de la que procede la forma de gráfico circular.</param>
        <param name="startAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el eje X hasta el primer lado de la forma de gráfico circular.</param>
        <param name="sweepAngle">Ángulo medido en grados en sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el segundo lado de la forma de gráfico circular.</param>
        <summary>Dibuja una forma circular definida por una elipse determinada por un par de coordenadas, unos valores de ancho y alto y dos líneas radiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una forma circular definida por el arco de una elipse y dos líneas radiales que forman una intersección con los puntos de conexión del arco. La elipse está definida por el rectángulo delimitador que describen el `x`, `y`, `width`, y `height` parámetros. La forma de gráfico circular se compone de las dos líneas radiales definidas por el `startAngle` y `sweepAngle` parámetros y el arco entre las intersecciones de dichas líneas radiales con la elipse.  
  
 Si el `sweepAngle` parámetro es mayor que 360 grados o menor que-360 grados, se trata como si fuese 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea la posición y tamaño de un rectángulo que delimita una elipse completa.  
  
-   Define los ángulos en los que se va a comenzar a dibujar (en relación con el eje x) y, a través del cual se va a dibujar (ambos en una dirección de las agujas del reloj).  
  
-   Dibuja la forma circular en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#75)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#75)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#75](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPie">
      <MemberSignature Language="C#" Value="public void DrawPie (System.Drawing.Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPie(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPie(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPie(System::Drawing::Pen ^ pen, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.DrawPie : System.Drawing.Pen * single * single * single * single * single * single -&gt; unit" Usage="graphics.DrawPie (pen, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de la forma de gráfico circular.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo delimitador que define la elipse de la que procede la forma de gráfico circular.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo delimitador que define la elipse de la que procede la forma de gráfico circular.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse de la que procede la forma de gráfico circular.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse de la que procede la forma de gráfico circular.</param>
        <param name="startAngle">Ángulo en grados medido en el sentido de las agujas del reloj desde el eje X hasta el primer lado de la forma de gráfico circular.</param>
        <param name="sweepAngle">Ángulo medido en grados en sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el segundo lado de la forma de gráfico circular.</param>
        <summary>Dibuja una forma circular definida por una elipse determinada por un par de coordenadas, unos valores de ancho y alto y dos líneas radiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método dibuja una forma circular definida por el arco de una elipse y dos líneas radiales que forman una intersección con los puntos de conexión del arco. La elipse está definida por el rectángulo delimitador que describen el `x`, `y`, `width`, y `height` parámetros. La forma de gráfico circular se compone de las dos líneas radiales definidas por el `startAngle` y `sweepAngle` parámetros y el arco entre las intersecciones de dichas líneas radiales con la elipse.  
  
 Si el `sweepAngle` parámetro es mayor que 360 grados o menor que-360 grados, se trata como si fuese 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea la posición y tamaño de un rectángulo que delimita una elipse completa.  
  
-   Define los ángulos en los que se va a comenzar a dibujar (en relación con el eje x) y, a través del cual se va a dibujar (ambos en una dirección de las agujas del reloj).  
  
-   El segmento del gráfico circular se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#76)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#76)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#76](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja un polígono definido por una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.Point[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del polígono.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los vértices del polígono.</param>
        <summary>Dibuja un polígono definido por una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada par de dos puntos consecutivos de la matriz especifica que un lado del polígono. Además, si el último punto y el primer punto de la matriz no coinciden, especifique la última parte del polígono.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea una matriz de siete puntos para los vértices del polígono.  
  
-   Dibuja el polígono en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#78)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#78)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#78](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawPolygon">
      <MemberSignature Language="C#" Value="public void DrawPolygon (System.Drawing.Pen pen, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawPolygon(class System.Drawing.Pen pen, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawPolygon(System.Drawing.Pen,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawPolygon(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.DrawPolygon : System.Drawing.Pen * System.Drawing.PointF[] -&gt; unit" Usage="graphics.DrawPolygon (pen, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del polígono.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los vértices del polígono.</param>
        <summary>Dibuja un polígono definido por una matriz de estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada par de dos puntos consecutivos de la matriz especifica que un lado del polígono. Además, si el último punto y el primer punto de la matriz no coinciden, especifique la última parte del polígono.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea una matriz de siete puntos para los vértices del polígono.  
  
-   Dibuja el polígono en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#77)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#77)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#77](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja un rectángulo especificado por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * System.Drawing.Rectangle -&gt; unit" Usage="graphics.DrawRectangle (pen, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del rectángulo.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo que se va a dibujar.</param>
        <summary>Dibuja un rectángulo especificado por una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información sobre cómo dibujar un <xref:System.Drawing.RectangleF>, consulte <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea un rectángulo.  
  
-   Dibuja el rectángulo en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#79)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#79)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#79](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * int * int * int * int -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del rectángulo.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo que se va a dibujar.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo que se va a dibujar.</param>
        <param name="width">Ancho del rectángulo que se va a dibujar.</param>
        <param name="height">Alto del rectángulo que se va a dibujar.</param>
        <summary>Dibuja un rectángulo especificado por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información sobre cómo dibujar un <xref:System.Drawing.RectangleF>, consulte <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea la posición y tamaño de un rectángulo.  
  
-   Dibuja el rectángulo en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#80)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#80)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#80](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public void DrawRectangle (System.Drawing.Pen pen, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangle(class System.Drawing.Pen pen, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangle(System.Drawing.Pen,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangle(System::Drawing::Pen ^ pen, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangle : System.Drawing.Pen * single * single * single * single -&gt; unit" Usage="graphics.DrawRectangle (pen, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo del rectángulo.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo que se va a dibujar.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo que se va a dibujar.</param>
        <param name="width">Ancho del rectángulo que se va a dibujar.</param>
        <param name="height">Alto del rectángulo que se va a dibujar.</param>
        <summary>Dibuja un rectángulo especificado por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información sobre cómo dibujar un <xref:System.Drawing.RectangleF>, consulte <xref:System.Drawing.Graphics.DrawRectangles%28System.Drawing.Pen%2CSystem.Drawing.RectangleF%5B%5D%29>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea la posición y tamaño de un rectángulo.  
  
-   Dibuja el rectángulo en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#81)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#81)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#81](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja una serie de rectángulos especificados por las estructuras <see cref="T:System.Drawing.Rectangle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de los contornos de los rectángulos.</param>
        <param name="rects">Matriz de estructuras <see cref="T:System.Drawing.Rectangle" /> que representan los rectángulos que se van a dibujar.</param>
        <summary>Dibuja una serie de rectángulos especificados por las estructuras <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea una matriz de tres rectángulos.  
  
-   Los rectángulos se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#82)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#82)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#82](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="rects" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> es una matriz de longitud cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangles">
      <MemberSignature Language="C#" Value="public void DrawRectangles (System.Drawing.Pen pen, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawRectangles(class System.Drawing.Pen pen, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawRectangles(System.Drawing.Pen,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawRectangles(System::Drawing::Pen ^ pen, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.DrawRectangles : System.Drawing.Pen * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.DrawRectangles (pen, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="pen"><see cref="T:System.Drawing.Pen" /> que determina el color, ancho y estilo de los contornos de los rectángulos.</param>
        <param name="rects">Matriz de estructuras <see cref="T:System.Drawing.RectangleF" /> que representan los rectángulos que se van a dibujar.</param>
        <summary>Dibuja una serie de rectángulos especificados por las estructuras <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una pluma de color negro.  
  
-   Crea una matriz de tres rectángulos.  
  
-   Los rectángulos se dibuja en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#83)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#83)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#83](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#83)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="pen" /> es <see langword="null" />.  
  
O bien 
 <paramref name="rects" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> es una matriz de longitud cero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dibuja la cadena de texto especificada en la ubicación especificada y con los objetos <see cref="T:System.Drawing.Brush" /> y <see cref="T:System.Drawing.Font" /> especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF -&gt; unit" Usage="graphics.DrawString (s, font, brush, point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que se va a dibujar.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina el color y la textura del texto dibujado.</param>
        <param name="point">Estructura <see cref="T:System.Drawing.PointF" /> que especifica la esquina superior izquierda del texto dibujado.</param>
        <summary>Dibuja la cadena de texto especificada en la ubicación especificada y con los objetos <see cref="T:System.Drawing.Brush" /> y <see cref="T:System.Drawing.Font" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena de texto que se va a dibujar.  
  
-   Define la fuente Arial (16pt).  
  
-   Crea un pincel sólido, negro para dibujar con.  
  
-   Crea un punto de la esquina superior izquierda en el que se va a dibujar el texto.  
  
-   Dibuja la cadena en la pantalla con la fuente, el pincel y el punto de destino.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#84)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#84)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#84](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#84)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="s" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que se va a dibujar.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina el color y la textura del texto dibujado.</param>
        <param name="layoutRectangle">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación del texto dibujado.</param>
        <summary>Dibuja la cadena de texto especificada en el rectángulo especificado y con los objetos <see cref="T:System.Drawing.Brush" /> y <see cref="T:System.Drawing.Font" /> igualmente especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El texto representado por la `s` parámetro se dibuja dentro del rectángulo representado por el `layoutRectangle` parámetro. Si el texto no encaje dentro del rectángulo, se trunca en la palabra más cercana. Para manipular con más detalle cómo se dibuja la cadena dentro del rectángulo, utilice el <xref:System.Drawing.Graphics.DrawString%2A> sobrecarga que toma un <xref:System.Drawing.StringFormat>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena de texto que se va a dibujar.  
  
-   Define la fuente Arial (16pt).  
  
-   Crea un pincel sólido, negro para dibujar con.  
  
-   Crea un rectángulo en el que se va a dibujar el texto.  
  
-   Dibuja el rectángulo en la pantalla.  
  
-   Dibuja la cadena en la pantalla con la fuente, el pincel y el rectángulo de destino.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#86)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#86)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#86](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="s" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.PointF point, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.PointF point, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::PointF point, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.PointF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, point, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que se va a dibujar.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina el color y la textura del texto dibujado.</param>
        <param name="point">Estructura <see cref="T:System.Drawing.PointF" /> que especifica la esquina superior izquierda del texto dibujado.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" /> que especifica los atributos de formato, como el espaciado de líneas y la alineación, que se aplican al texto dibujado.</param>
        <summary>Dibuja la cadena de texto especificada en la ubicación que se indique, con los objetos <see cref="T:System.Drawing.Brush" /> y <see cref="T:System.Drawing.Font" /> dados y usando los atributos de formato del <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena de texto que se va a dibujar.  
  
-   Define la fuente Arial (16pt).  
  
-   Crea un pincel sólido, negro para dibujar con.  
  
-   Crea un punto de la esquina superior izquierda en el que se va a dibujar el texto.  
  
-   Establece el formato de la cadena se va a dibujar verticalmente.  
  
-   Dibuja la cadena en la pantalla con la fuente, pincel, punto de destino y formato.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#85)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#85)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#85](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="s" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, System.Drawing.RectangleF layoutRectangle, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF layoutRectangle, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, System::Drawing::RectangleF layoutRectangle, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, layoutRectangle, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="layoutRectangle" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que se va a dibujar.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina el color y la textura del texto dibujado.</param>
        <param name="layoutRectangle">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación del texto dibujado.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" /> que especifica los atributos de formato, como el espaciado de líneas y la alineación, que se aplican al texto dibujado.</param>
        <summary>Dibuja la cadena de texto especificada en el rectángulo que se indique, con los objetos <see cref="T:System.Drawing.Brush" /> y <see cref="T:System.Drawing.Font" /> dados y usando los atributos de formato del <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El texto representado por la `s` parámetro se dibuja dentro del rectángulo representado por el `layoutRectangle` parámetro. Si el texto no encaje dentro del rectángulo, se trunca en la palabra más cercana, a menos que se especifique lo contrario con la `format` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena de texto que se va a dibujar.  
  
-   Define la fuente Arial (16pt).  
  
-   Crea un pincel sólido, negro para dibujar con.  
  
-   Crea un rectángulo en el que se va a dibujar el texto.  
  
-   Dibuja el rectángulo en la pantalla.  
  
-   Establece el formato de la cadena para centrarlo dentro del rectángulo.  
  
-   Dibuja la cadena en la pantalla con la fuente, el pincel y el rectángulo de destino.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#87)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#87)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#87](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="s" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que se va a dibujar.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina el color y la textura del texto dibujado.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del texto dibujado.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del texto dibujado.</param>
        <summary>Dibuja la cadena de texto especificada en la ubicación especificada y con los objetos <see cref="T:System.Drawing.Brush" /> y <see cref="T:System.Drawing.Font" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena de texto que se va a dibujar.  
  
-   Define la fuente Arial (16pt).  
  
-   Crea un pincel de color negro sólido para dibujar con.  
  
-   Crea un punto de la esquina superior izquierda en el que se va a dibujar el texto.  
  
-   Dibuja la cadena en la pantalla con la fuente, el pincel y el punto de destino.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#88)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#88)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#88](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="s" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="DrawString">
      <MemberSignature Language="C#" Value="public void DrawString (string s, System.Drawing.Font font, System.Drawing.Brush brush, float x, float y, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawString(string s, class System.Drawing.Font font, class System.Drawing.Brush brush, float32 x, float32 y, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.DrawString(System.String,System.Drawing.Font,System.Drawing.Brush,System.Single,System.Single,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawString(System::String ^ s, System::Drawing::Font ^ font, System::Drawing::Brush ^ brush, float x, float y, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.DrawString : string * System.Drawing.Font * System.Drawing.Brush * single * single * System.Drawing.StringFormat -&gt; unit" Usage="graphics.DrawString (s, font, brush, x, y, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que se va a dibujar.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina el color y la textura del texto dibujado.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del texto dibujado.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del texto dibujado.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" /> que especifica los atributos de formato, como el espaciado de líneas y la alineación, que se aplican al texto dibujado.</param>
        <summary>Dibuja la cadena de texto especificada en la ubicación que se indique, con los objetos <see cref="T:System.Drawing.Brush" /> y <see cref="T:System.Drawing.Font" /> dados y usando los atributos de formato del <see cref="T:System.Drawing.StringFormat" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena de texto que se va a dibujar.  
  
-   Define la fuente Arial (16pt).  
  
-   Crea un pincel sólido, negro para dibujar con.  
  
-   Crea las coordenadas de un punto de la esquina superior izquierda en el que se va a dibujar el texto.  
  
-   Establece el formato de la cadena se va a dibujar verticalmente  
  
-   Dibuja la cadena en la pantalla con la fuente, pincel, punto de destino y formato.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#89)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#89)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#89](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="s" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.DrawText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Point,System.Drawing.Color)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="EndContainer">
      <MemberSignature Language="C#" Value="public void EndContainer (System.Drawing.Drawing2D.GraphicsContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndContainer(class System.Drawing.Drawing2D.GraphicsContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndContainer (container As GraphicsContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndContainer(System::Drawing::Drawing2D::GraphicsContainer ^ container);" />
      <MemberSignature Language="F#" Value="member this.EndContainer : System.Drawing.Drawing2D.GraphicsContainer -&gt; unit" Usage="graphics.EndContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Drawing.Drawing2D.GraphicsContainer" />
      </Parameters>
      <Docs>
        <param name="container"><see cref="T:System.Drawing.Drawing2D.GraphicsContainer" /> que representa el contenedor restaurado por este método.</param>
        <summary>Cierra el contenedor de gráficos actual y restaura el estado que tenía este <see cref="T:System.Drawing.Graphics" /> al estado guardado mediante una llamada al método <see cref="M:System.Drawing.Graphics.BeginContainer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método con el <xref:System.Drawing.Graphics.BeginContainer%2A> método para crear contenedores de gráficos anidados. Contenedores de gráficos conservan el estado de gráficos, como la transformación, región de recorte y las propiedades de representación.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.BeginContainer%2A> método de un <xref:System.Drawing.Graphics>, un bloque de información que contiene el estado de la <xref:System.Drawing.Graphics> se coloca en una pila. El <xref:System.Drawing.Graphics.BeginContainer%2A> método devuelve un <xref:System.Drawing.Drawing2D.GraphicsContainer> que identifica ese bloque de información. Al pasar el objeto identificador para el <xref:System.Drawing.Graphics.EndContainer%2A> el bloque de información de método, se quita de la pila y se usa para restaurar la <xref:System.Drawing.Graphics> al estado que tenía en el momento de la <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método.  
  
 Los contenedores se pueden anidar; es decir, puede llamar a la <xref:System.Drawing.Graphics.BeginContainer%2A> método varias veces antes de llamar a la <xref:System.Drawing.Graphics.EndContainer%2A> método. Cada vez que se llama el <xref:System.Drawing.Graphics.BeginContainer%2A> método, se coloca un bloque de información en la pila y recibe un <xref:System.Drawing.Drawing2D.GraphicsContainer> para el bloque de información. Cuando se pasa uno de esos objetos a la <xref:System.Drawing.Graphics.EndContainer%2A> método, el <xref:System.Drawing.Graphics> se devuelve al estado que tenía en el momento de la <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método que devolvió ese determinado <xref:System.Drawing.Drawing2D.GraphicsContainer>. El bloque de información colocado en la pila mediante <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método se quita de la pila y todos los bloques colocan en la pila después de que <xref:System.Drawing.Graphics.BeginContainer%2A> también se quitan la llamada al método.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.Save%2A> bloques de información de contexto de método en la misma pila de llamadas a la <xref:System.Drawing.Graphics.BeginContainer%2A> método. Al igual que un <xref:System.Drawing.Graphics.EndContainer%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método, un <xref:System.Drawing.Graphics.Restore%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.Save%2A> llamada al método.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.EndContainer%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.BeginContainer%2A> método se quitan de la pila. Del mismo modo, cuando se llama a la <xref:System.Drawing.Graphics.Restore%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.Save%2A> método se quitan de la pila.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Abre un nuevo contenedor de gráficos y guarda el contenedor anterior.  
  
-   Convierte las coordenadas universales en el contenedor.  
  
-   Rellena un rectángulo rojo en el (traducir las coordenadas de la) nuevo contenedor.  
  
-   Cierra el nuevo contenedor y restaura el contenedor guardado.  
  
-   Rellena un rectángulo verde (a las coordenadas sin traducir) del contenedor guardado.  
  
 El resultado es un rectángulo verde que se superpone a un rectángulo rojo del mismo tamaño.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#90)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#90)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#90](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#90)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateMetafile">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.Point" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un formulario que tiene un <xref:System.Drawing.Imaging.Metafile> como uno de sus miembros privados. El <xref:System.Windows.Forms.Control.OnPaint%2A> llamadas al método <xref:System.Drawing.Graphics.EnumerateMetafile%2A>, que llama a la forma `MetafileCallback` método para cada registro de metarchivo. El método `MetafileCallback` llama al método <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>. Tenga en cuenta que el `MetafileCallback` método recibe los datos del registro como un <xref:System.IntPtr>, pero la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método espera los datos del registro sea una matriz de bytes. La llamada a <xref:System.Runtime.InteropServices.Marshal.Copy%2A> copia los datos del registro en una matriz de bytes para que se puede pasar a <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>.  
  
 [!code-csharp[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/CS/Form1.cs#1)]
 [!code-vb[System.Drawing.Graphics.EnumerateMetafile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Graphics.EnumerateMetafile/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.PointF" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.Point" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.PointF" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.Point" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.Point" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros de un rectángulo seleccionado de un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.Point> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.Point> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.PointF" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo llamando al método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.PointF" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros de un rectángulo seleccionado de un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="srcRect">Estructuras <see cref="T:System.Drawing.RectangleF" /> que especifican la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.Point> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros del <see cref="T:System.Drawing.Imaging.Metafile" /> especificado, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.Point" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros de un rectángulo seleccionado de un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.Point> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.PointF" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros de un rectángulo seleccionado de un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit srcUnit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit srcUnit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit srcUnit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, srcUnit, callback, callbackData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcUnit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="srcUnit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el`callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point destPoint, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point destPoint, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Point destPoint, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.Point" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.Point" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="unit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado usando los atributos de imagen especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Point[] destPoints, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Point[] destPoints, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Point[],System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::Point&gt; ^ destPoints, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Point[] * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.Point[]" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.Point" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="unit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.Point> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF destPoint, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF destPoint, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::PointF destPoint, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoint, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoint" Type="System.Drawing.PointF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoint">Estructura <see cref="T:System.Drawing.PointF" /> que especifica la ubicación de la esquina superior izquierda del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="unit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un punto determinado usando los atributos de imagen especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destPoints, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destPoints">Matriz de tres estructuras <see cref="T:System.Drawing.PointF" /> que definen un paralelogramo, el cual determina el tamaño y la ubicación del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="unit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un paralelogramo determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 El `destPoints` parámetro especifica tres puntos de un paralelogramo. Los tres <xref:System.Drawing.PointF> estructuras representan las esquinas superior izquierda, superior derecha e inferior izquierda del paralelogramo. El cuarto punto se extrapola a partir de los tres primeros para formar un paralelogramo. Metarchivo dibujado se escala y recorta para que quepa en el paralelogramo.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.Rectangle destRect, System.Drawing.Rectangle srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.Rectangle destRect, valuetype System.Drawing.Rectangle srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.Rectangle,System.Drawing.Rectangle,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::Rectangle destRect, System::Drawing::Rectangle srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.Rectangle * System.Drawing.Rectangle * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="srcRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="unit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <Member MemberName="EnumerateMetafile">
      <MemberSignature Language="C#" Value="public void EnumerateMetafile (System.Drawing.Imaging.Metafile metafile, System.Drawing.RectangleF destRect, System.Drawing.RectangleF srcRect, System.Drawing.GraphicsUnit unit, System.Drawing.Graphics.EnumerateMetafileProc callback, IntPtr callbackData, System.Drawing.Imaging.ImageAttributes imageAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnumerateMetafile(class System.Drawing.Imaging.Metafile metafile, valuetype System.Drawing.RectangleF destRect, valuetype System.Drawing.RectangleF srcRect, valuetype System.Drawing.GraphicsUnit unit, class System.Drawing.Graphics/EnumerateMetafileProc callback, native int callbackData, class System.Drawing.Imaging.ImageAttributes imageAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.EnumerateMetafile(System.Drawing.Imaging.Metafile,System.Drawing.RectangleF,System.Drawing.RectangleF,System.Drawing.GraphicsUnit,System.Drawing.Graphics.EnumerateMetafileProc,System.IntPtr,System.Drawing.Imaging.ImageAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnumerateMetafile(System::Drawing::Imaging::Metafile ^ metafile, System::Drawing::RectangleF destRect, System::Drawing::RectangleF srcRect, System::Drawing::GraphicsUnit unit, System::Drawing::Graphics::EnumerateMetafileProc ^ callback, IntPtr callbackData, System::Drawing::Imaging::ImageAttributes ^ imageAttr);" />
      <MemberSignature Language="F#" Value="member this.EnumerateMetafile : System.Drawing.Imaging.Metafile * System.Drawing.RectangleF * System.Drawing.RectangleF * System.Drawing.GraphicsUnit * System.Drawing.Graphics.EnumerateMetafileProc * nativeint * System.Drawing.Imaging.ImageAttributes -&gt; unit" Usage="graphics.EnumerateMetafile (metafile, destRect, srcRect, unit, callback, callbackData, imageAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metafile" Type="System.Drawing.Imaging.Metafile" />
        <Parameter Name="destRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="unit" Type="System.Drawing.GraphicsUnit" />
        <Parameter Name="callback" Type="System.Drawing.Graphics+EnumerateMetafileProc" />
        <Parameter Name="callbackData" Type="System.IntPtr" />
        <Parameter Name="imageAttr" Type="System.Drawing.Imaging.ImageAttributes" />
      </Parameters>
      <Docs>
        <param name="metafile"><see cref="T:System.Drawing.Imaging.Metafile" /> que se va a enumerar.</param>
        <param name="destRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la ubicación y el tamaño del metarchivo dibujado.</param>
        <param name="srcRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica la parte del metarchivo que se va a dibujar, relativa a su esquina superior izquierda.</param>
        <param name="unit">Miembro de la enumeración <see cref="T:System.Drawing.GraphicsUnit" /> que especifica la unidad de medida empleada para determinar qué parte del metarchivo contiene el rectángulo especificado por el parámetro <paramref name="srcRect" />.</param>
        <param name="callback">Delegado <see cref="T:System.Drawing.Graphics.EnumerateMetafileProc" /> que especifica el método al cual se envían los registros de metarchivo.</param>
        <param name="callbackData">Puntero interno requerido pero que se pasa por alto. De manera opcional, se puede pasar <see cref="F:System.IntPtr.Zero" /> para este parámetro.</param>
        <param name="imageAttr"><see cref="T:System.Drawing.Imaging.ImageAttributes" /> que especifica información de atributos de imagen para la imagen dibujada.</param>
        <summary>Envía los registros de un rectángulo seleccionado en un <see cref="T:System.Drawing.Imaging.Metafile" />, de uno en uno, a un método de devolución de llamada para su presentación en un rectángulo determinado usando los atributos de imagen dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enumera los registros contenidos en el metarchivo especificado. Cada registro se envía por separado a un método de devolución de llamada especificado por el `callback` parámetro. Normalmente, las llamadas de método de devolución de llamada la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método para "reproducir" o dibujar el registro.  
  
 Si el método de devolución de llamada llama <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A>, debe hacerlo mediante una llamada a la <xref:System.Drawing.Imaging.Metafile.PlayRecord%2A> método específicas de <xref:System.Drawing.Imaging.Metafile> que se está enumerando.  
  
 Cualquier acción de dibujo que tenga lugar fuera del rectángulo especificado por el `srcRect` se omite el parámetro.  
  
 Los atributos de imagen especificados por el `imageAttr` reemplazo de parámetro aquellas especificadas cuando se escribió el metarchivo.  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea <xref:System.Drawing.Graphics.EnumerateMetafile%28System.Drawing.Imaging.Metafile%2CSystem.Drawing.Point%2CSystem.Drawing.Graphics.EnumerateMetafileProc%29>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7152b45b-a55c-49bc-8c78-ae002a844f71">Imágenes, mapas de bits y metarchivos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExcludeClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualiza la región de recorte de este <see cref="T:System.Drawing.Graphics" /> con el fin de excluir el área especificada por una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExcludeClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.ExcludeClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que especifica el rectángulo que se debe excluir de la región de recorte.</param>
        <summary>Actualiza la región de recorte de este <see cref="T:System.Drawing.Graphics" /> con el fin de excluir el área especificada por una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método excluye el área especificada por el `rect` parámetro desde la región de recorte actual y asigna el área resultante a la <xref:System.Drawing.Graphics.Clip%2A> propiedad de este <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un píxel 100 al rectángulo de 100 píxeles cuya esquina superior izquierda se encuentra en la coordenada (100, 100).  
  
-   Crea una región definida por el rectángulo.  
  
-   Establece la región de recorte para excluir de la región rectangular.  
  
-   Rellena un píxel 300 por 300 rectángulo de píxeles cuya esquina superior izquierda se encuentra en la coordenada (0, 0) con un pincel azul sólido.  
  
 El resultado es un rectángulo azul con una región cuadrada en su esquina inferior derecha que faltan.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#92)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#92)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#92](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#92)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExcludeClip">
      <MemberSignature Language="C#" Value="public void ExcludeClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExcludeClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ExcludeClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExcludeClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.ExcludeClip : System.Drawing.Region -&gt; unit" Usage="graphics.ExcludeClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" /> que especifica la región que se debe excluir de la región de recorte.</param>
        <summary>Actualiza la región de recorte de este <see cref="T:System.Drawing.Graphics" /> con el fin de excluir el área especificada por una <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método excluye el área especificada por el `region` parámetro desde la región de recorte actual y asigna el área resultante a la <xref:System.Drawing.Graphics.Clip%2A> propiedad de este <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un píxel 100 al rectángulo de 100 píxeles cuya esquina superior izquierda se encuentra en la coordenada (100, 100).  
  
-   Establece la región de recorte para excluir el rectángulo.  
  
-   Rellena un píxel 300 por 300 rectángulo de píxeles cuya esquina superior izquierda se encuentra en la coordenada (0, 0) con un pincel azul sólido.  
  
 El resultado es un rectángulo azul con una región cuadrada en su esquina inferior derecha que faltan.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#91)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#91)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#91](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#91)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rellena el interior de una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que definen la curva spline.</param>
        <summary>Rellena el interior de una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.Point> estructuras.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea una matriz de cuatro puntos para definir una curva spline.  
  
-   Rellena la curva en la pantalla.  
  
 La curva tiene una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#93)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#93)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#93](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#93)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillClosedCurve (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen la curva spline.</param>
        <summary>Rellena el interior de una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.PointF> estructuras.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea una matriz de cuatro puntos para definir una curva spline.  
  
-   Rellena la curva en la pantalla.  
  
 La curva tiene una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#96)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#96)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#96](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#96)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que definen la curva spline.</param>
        <param name="fillmode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina cómo se rellena la curva.</param>
        <summary>Rellena el interior de una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.Point" />, usando el modo de relleno especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.Point> estructuras.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea una matriz de cuatro puntos para definir una curva spline.  
  
-   Establece el modo de relleno en <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Rellena la curva en la pantalla.  
  
 La curva tiene una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#94)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#94)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#94](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#94)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen la curva spline.</param>
        <param name="fillmode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina cómo se rellena la curva.</param>
        <summary>Rellena el interior de una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.PointF" />, usando el modo de relleno especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.Point> estructuras.  
  
 Este método utiliza una tensión predeterminada de 0,5.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea una matriz de cuatro puntos para definir una curva spline.  
  
-   Establece el modo de relleno en <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Rellena la curva en la pantalla.  
  
 La curva tiene una tensión predeterminada de 0,5.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#97)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#97)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#97](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#97)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que definen la curva spline.</param>
        <param name="fillmode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina cómo se rellena la curva.</param>
        <param name="tension">Valor mayor o igual que 0,0 F que especifica la tensión de la curva.</param>
        <summary>Rellena el interior de una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.Point" />, usando la tensión y el modo de relleno especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.Point> estructuras.  
  
 El `tension` parámetro determina la forma de la curva polinomial. Si el valor de la `tension` parámetro es 0, 0F, este método dibuja segmentos de línea recta para conectar los puntos. Normalmente, el `tension` parámetro es menor o igual que 1, 0f. Los valores en 1, 0F producen resultados inesperados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea una matriz de cuatro puntos para definir una curva spline.  
  
-   Establece el modo de relleno en <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Establece la tensión a 1.0.  
  
-   Rellena la curva en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#95)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#95)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#95](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#95)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillClosedCurve">
      <MemberSignature Language="C#" Value="public void FillClosedCurve (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillmode, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillClosedCurve(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillmode, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillClosedCurve(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillClosedCurve(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillmode, float tension);" />
      <MemberSignature Language="F#" Value="member this.FillClosedCurve : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode * single -&gt; unit" Usage="graphics.FillClosedCurve (brush, points, fillmode, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillmode" Type="System.Drawing.Drawing2D.FillMode" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que definen la curva spline.</param>
        <param name="fillmode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina cómo se rellena la curva.</param>
        <param name="tension">Valor mayor o igual que 0,0 F que especifica la tensión de la curva.</param>
        <summary>Rellena el interior de una curva spline cardinal cerrada, definida por una matriz de estructuras <see cref="T:System.Drawing.PointF" />, usando la tensión y el modo de relleno especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una curva spline cardinal cerrada que pasa por cada punto de la matriz. Si el último punto no coincide con el primer punto, se agrega un segmento de curva adicional desde el último punto hasta el primer punto para cerrarlo.  
  
 La matriz de puntos debe contener al menos cuatro <xref:System.Drawing.Point> estructuras.  
  
 El `tension` parámetro determina la forma de la curva polinomial. Si el valor de la `tension` parámetro es 0, 0F, este método dibuja segmentos de línea recta para conectar los puntos. Normalmente, el `tension` parámetro es menor o igual que 1, 0f. Los valores en 1, 0F producen resultados inesperados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea una matriz de cuatro puntos para definir una curva spline.  
  
-   Establece el modo de relleno en <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Establece la tensión a 1.0.  
  
-   Rellena la curva en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#98)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#98)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#98](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rellena el interior de una elipse definida por un rectángulo delimitador especificado por un par de coordenadas, un valor de alto y un valor de ancho.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo delimitador que define la elipse.</param>
        <summary>Rellena el interior de una elipse definida por un rectángulo delimitador especificado a su vez por una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una elipse con un <xref:System.Drawing.Brush>. La elipse está definida por el rectángulo delimitador representado por la `rect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea un rectángulo que delimita una elipse.  
  
-   Rellena la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#99)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#99)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#99](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillEllipse (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo delimitador que define la elipse.</param>
        <summary>Rellena el interior de una elipse definida por un rectángulo delimitador especificado a su vez por una estructura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una elipse con un <xref:System.Drawing.Brush>. La elipse está definida por el rectángulo delimitador representado por la `rect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea un rectángulo que delimita una elipse.  
  
-   Rellena la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#100)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#100)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#100](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="x">Coordenada X de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="y">Coordenada Y de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse.</param>
        <summary>Rellena el interior de una elipse definida por un rectángulo delimitador especificado por un par de coordenadas, un valor de alto y un valor de ancho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una elipse con un <xref:System.Drawing.Brush>. La elipse está definida por el rectángulo delimitador representado por la `x`, `y`, `width`, y `height` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea la ubicación y tamaño de un rectángulo que delimita una elipse.  
  
-   Rellena la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#101)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#101)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#101](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillEllipse">
      <MemberSignature Language="C#" Value="public void FillEllipse (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillEllipse(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillEllipse(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillEllipse(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillEllipse : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillEllipse (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="x">Coordenada X de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="y">Coordenada Y de la esquina superior izquierda del rectángulo delimitador que define la elipse.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse.</param>
        <summary>Rellena el interior de una elipse definida por un rectángulo delimitador especificado por un par de coordenadas, un valor de alto y un valor de ancho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una elipse con un <xref:System.Drawing.Brush>. La elipse está definida por el rectángulo delimitador representado por la `x`, `y`, `width`, y `height` parámetros.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea la ubicación y tamaño de un rectángulo que delimita una elipse.  
  
-   Rellena la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#102)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#102)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#102](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPath">
      <MemberSignature Language="C#" Value="public void FillPath (System.Drawing.Brush brush, System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPath(class System.Drawing.Brush brush, class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPath(System.Drawing.Brush,System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPath(System::Drawing::Brush ^ brush, System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.FillPath : System.Drawing.Brush * System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.FillPath (brush, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que representa el trazado que se desea rellenar.</param>
        <summary>Rellena el interior de un <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Drawing2D.GraphicsPath> consta de una serie de segmentos de línea y la curva. Si la ruta de acceso representada por el `path` parámetro no está cerrado, se agrega un segmento adicional desde el último punto hasta el primer punto para cerrar la ruta de acceso.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea un objeto de trazado del gráfico.  
  
-   Agrega una elipse al trazado de gráficos.  
  
-   Rellena la ruta de acceso en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#103)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#103)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#103](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="path" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rellena el interior de una sección de gráfico circular definida por una elipse, determinada por un par de coordenadas, unos valores de ancho y alto y dos líneas radiales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphics.FillPie (brush, rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo delimitador que define la elipse, de la cual procede la sección de gráfico circular.</param>
        <param name="startAngle">Ángulo medido en grados en el sentido de las agujas del reloj desde el eje X hasta el primer lado de la sección de gráfico circular.</param>
        <param name="sweepAngle">Ángulo medido en grados en sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el segundo lado de la sección de gráfico circular.</param>
        <summary>Dibuja el interior de una sección circular definida por una elipse, determinada por una estructura <see cref="T:System.Drawing.RectangleF" /> y dos líneas radiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una sección circular definida por el arco de una elipse y dos líneas radiales que forman una intersección con los puntos de conexión del arco. La elipse está definida por el rectángulo delimitador. La sección de gráfico circular se compone de las dos líneas radiales definidas por el `startAngle` y `sweepAngle` parámetros y el arco entre las intersecciones de dichas líneas radiales con la elipse.  
  
 Si el `sweepAngle` parámetro es mayor que 360 grados o menor que-360 grados, se trata como si fuese 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea un rectángulo que delimita una elipse.  
  
-   Define el ángulo inicial (en relación con el eje x) y el ángulo de barrido (ambos en una dirección de las agujas del reloj).  
  
-   Rellena el área de gráfico en forma de la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#104)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#104)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#104](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height, int32 startAngle, int32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, int x, int y, int width, int height, int startAngle, int sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * int * int * int * int * int * int -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Int32" />
        <Parameter Name="sweepAngle" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo delimitador que define la elipse de la que procede la sección de gráfico circular.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo delimitador que define la elipse de la que procede la sección de gráfico circular.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse, de la cual procede la sección de gráfico circular.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse, de la cual procede la sección de gráfico circular.</param>
        <param name="startAngle">Ángulo medido en grados en el sentido de las agujas del reloj desde el eje X hasta el primer lado de la sección de gráfico circular.</param>
        <param name="sweepAngle">Ángulo medido en grados en sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el segundo lado de la sección de gráfico circular.</param>
        <summary>Rellena el interior de una sección de gráfico circular definida por una elipse, determinada por un par de coordenadas, unos valores de ancho y alto y dos líneas radiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una sección circular definida por el arco de una elipse y dos líneas radiales que forman una intersección con los puntos de conexión del arco. La elipse está definida por el rectángulo delimitador. La sección de gráfico circular se compone de las dos líneas radiales definidas por el `startAngle` y `sweepAngle` parámetros y el arco entre las intersecciones de dichas líneas radiales con la elipse.  
  
 Si el `sweepAngle` parámetro es mayor que 360 grados o menor que-360 grados, se trata como si fuese 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea la ubicación y tamaño de un rectángulo que delimita una elipse.  
  
-   Define el ángulo inicial (en relación con el eje x) y el ángulo de barrido (ambos en una dirección de las agujas del reloj).  
  
-   Rellena el área de gráfico en forma de la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#105)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#105)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#105](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPie">
      <MemberSignature Language="C#" Value="public void FillPie (System.Drawing.Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPie(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPie(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPie(System::Drawing::Brush ^ brush, float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.FillPie : System.Drawing.Brush * single * single * single * single * single * single -&gt; unit" Usage="graphics.FillPie (brush, x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo delimitador que define la elipse de la que procede la sección de gráfico circular.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo delimitador que define la elipse de la que procede la sección de gráfico circular.</param>
        <param name="width">Ancho del rectángulo delimitador que define la elipse, de la cual procede la sección de gráfico circular.</param>
        <param name="height">Alto del rectángulo delimitador que define la elipse, de la cual procede la sección de gráfico circular.</param>
        <param name="startAngle">Ángulo medido en grados en el sentido de las agujas del reloj desde el eje X hasta el primer lado de la sección de gráfico circular.</param>
        <param name="sweepAngle">Ángulo medido en grados en sentido de las agujas del reloj desde el parámetro <paramref name="startAngle" /> hasta el segundo lado de la sección de gráfico circular.</param>
        <summary>Rellena el interior de una sección de gráfico circular definida por una elipse, determinada por un par de coordenadas, unos valores de ancho y alto y dos líneas radiales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior de una sección circular definida por el arco de una elipse y dos líneas radiales que forman una intersección con los puntos de conexión del arco. La elipse está definida por el rectángulo delimitador. La sección de gráfico circular se compone de las dos líneas radiales definidas por el `startAngle` y `sweepAngle` parámetros y el arco entre las intersecciones de dichas líneas radiales con la elipse.  
  
 Si el `sweepAngle` parámetro es mayor que 360 grados o menor que-360 grados, se trata como si fuese 360 o -360 grados, respectivamente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel de color rojo sólido.  
  
-   Crea la ubicación y tamaño de un rectángulo que delimita una elipse.  
  
-   Define el ángulo inicial (en relación con el eje x) y el ángulo de barrido (ambos en una dirección de las agujas del reloj).  
  
-   Rellena el área de gráfico en forma de la elipse en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#106)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#106)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#106](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rellena el interior de un polígono definido por una matriz de puntos, especificados por estructuras <see cref="T:System.Drawing.Point" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representan los vértices del polígono que se van a rellenar.</param>
        <summary>Rellena el interior de un polígono definido por una matriz de puntos, especificados por estructuras <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada dos puntos consecutivos de la matriz especifican una cara del polígono. Además, si el último punto y el primer punto no coinciden, especifique el lado de cierre del polígono.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel azul sólido.  
  
-   Crea una matriz de siete puntos para definir un polígono.  
  
-   Rellena el área poligonal en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#107)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#107)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#107](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] -&gt; unit" Usage="graphics.FillPolygon (brush, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representan los vértices del polígono que se van a rellenar.</param>
        <summary>Rellena el interior de un polígono definido por una matriz de puntos, especificados por estructuras <see cref="T:System.Drawing.PointF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada dos puntos consecutivos de la matriz especifican una cara del polígono. Además, si el último punto y el primer punto no coinciden, especifique el lado de cierre del polígono.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel azul sólido.  
  
-   Crea una matriz de siete puntos para definir un polígono.  
  
-   Rellena el área poligonal en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#109)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#109)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#109](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.Point[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.Point[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.Point[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Point&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.Point[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representan los vértices del polígono que se van a rellenar.</param>
        <param name="fillMode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina el estilo del relleno.</param>
        <summary>Rellena el interior de un polígono definido por una matriz de puntos especificados por estructuras <see cref="T:System.Drawing.Point" />, usando el modo de relleno especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada dos puntos consecutivos de la matriz especifican una cara del polígono. Además, si el último punto y el primer punto no coinciden, especifique el lado de cierre del polígono.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pincel azul sólido.  
  
-   Crea una matriz de siete puntos para definir un polígono.  
  
-   Establece el modo de relleno en <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Rellena el área poligonal en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#108)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#108)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#108](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#108)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillPolygon">
      <MemberSignature Language="C#" Value="public void FillPolygon (System.Drawing.Brush brush, System.Drawing.PointF[] points, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillPolygon(class System.Drawing.Brush brush, valuetype System.Drawing.PointF[] points, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillPolygon(System.Drawing.Brush,System.Drawing.PointF[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillPolygon(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::PointF&gt; ^ points, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="member this.FillPolygon : System.Drawing.Brush * System.Drawing.PointF[] * System.Drawing.Drawing2D.FillMode -&gt; unit" Usage="graphics.FillPolygon (brush, points, fillMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="points">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representan los vértices del polígono que se van a rellenar.</param>
        <param name="fillMode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FillMode" /> que determina el estilo del relleno.</param>
        <summary>Rellena el interior de un polígono definido por una matriz de puntos especificados por estructuras <see cref="T:System.Drawing.PointF" />, usando el modo de relleno especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada dos puntos consecutivos de la matriz especifican una cara del polígono. Además, si el último punto y el primer punto no coinciden, especifique el lado de cierre del polígono.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un pincel azul sólido.  
  
-   Crea una matriz de siete puntos para definir un polígono.  
  
-   Establece el modo de relleno en <xref:System.Drawing.Drawing2D.FillMode.Winding>.  
  
-   Rellena el área poligonal en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CPP/form1.cpp#110)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/CS/form1.cs#110)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples2#110](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples2/VB/form1.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="points" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rellena el interior de un rectángulo especificado por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.Rectangle -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que representa el rectángulo que se va a rellenar.</param>
        <summary>Rellena el interior de un rectángulo especificado por una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior del rectángulo definido por el `rect` parámetro, incluidos la superior izquierda especificada de esquina y hasta la calculada reducir y bordes inferiores.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un pincel azul sólido.  
  
-   Crea un rectángulo.  
  
-   Rellena el área rectangular en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#111)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#111)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#111](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Drawing.RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * System.Drawing.RectangleF -&gt; unit" Usage="graphics.FillRectangle (brush, rect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que representa el rectángulo que se va a rellenar.</param>
        <summary>Rellena el interior de un rectángulo especificado por una estructura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior del rectángulo definido por el `rect` parámetro, incluidos la superior izquierda especificada de esquina y hasta la calculada reducir y bordes inferiores.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un pincel azul sólido.  
  
-   Crea un rectángulo.  
  
-   Rellena el área rectangular en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#112)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#112)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#112](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * int * int * int * int -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo que se va a rellenar.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo que se va a rellenar.</param>
        <param name="width">Ancho del rectángulo que se va a rellenar.</param>
        <param name="height">Alto del rectángulo que se va a rellenar.</param>
        <summary>Rellena el interior de un rectángulo especificado por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior del rectángulo definido por el`x`, `y`, `width`, y `height` parámetros, incluido el especificado superior izquierda esquina y hasta la calculada reducir y bordes inferiores.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un pincel azul sólido.  
  
-   Crea la ubicación y tamaño de un rectángulo.  
  
-   Rellena el área rectangular en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#113)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#113)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#113](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#113)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangle">
      <MemberSignature Language="C#" Value="public void FillRectangle (System.Drawing.Brush brush, float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangle(class System.Drawing.Brush brush, float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangle(System.Drawing.Brush,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangle(System::Drawing::Brush ^ brush, float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.FillRectangle : System.Drawing.Brush * single * single * single * single -&gt; unit" Usage="graphics.FillRectangle (brush, x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo que se va a rellenar.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo que se va a rellenar.</param>
        <param name="width">Ancho del rectángulo que se va a rellenar.</param>
        <param name="height">Alto del rectángulo que se va a rellenar.</param>
        <summary>Rellena el interior de un rectángulo especificado por un par de coordenadas, un valor de ancho y un valor de alto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método rellena el interior del rectángulo definido por el `x`, `y`, `width`, y `height` parámetros, incluido el especificado superior izquierda esquina y hasta la calculada reducir y bordes inferiores.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un pincel azul sólido.  
  
-   Crea la ubicación y tamaño de un rectángulo.  
  
-   Rellena el área rectangular en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#114)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#114)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#114](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#114)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FillRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rellena el interior de una serie de rectángulos especificados por estructuras <see cref="T:System.Drawing.Rectangle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.Rectangle[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.Rectangle[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="rects">Matriz de estructuras <see cref="T:System.Drawing.Rectangle" /> que representan los rectángulos que se van a rellenar.</param>
        <summary>Rellena el interior de una serie de rectángulos especificados por estructuras <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un pincel azul sólido.  
  
-   Crea una matriz de tres rectángulos.  
  
-   Rellena las tres áreas rectangulares en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#115)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#115)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#115](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#115)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="rects" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="rects" /> es una matriz de longitud cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRectangles">
      <MemberSignature Language="C#" Value="public void FillRectangles (System.Drawing.Brush brush, System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRectangles(class System.Drawing.Brush brush, valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRectangles(System.Drawing.Brush,System.Drawing.RectangleF[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRectangles(System::Drawing::Brush ^ brush, cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.FillRectangles : System.Drawing.Brush * System.Drawing.RectangleF[] -&gt; unit" Usage="graphics.FillRectangles (brush, rects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="rects">Matriz de estructuras <see cref="T:System.Drawing.RectangleF" /> que representan los rectángulos que se van a rellenar.</param>
        <summary>Rellena el interior de una serie de rectángulos especificados por estructuras <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un pincel azul sólido.  
  
-   Crea una matriz de tres rectángulos.  
  
-   Rellena las tres áreas rectangulares en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#116)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#116)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#116](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#116)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="rects" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="Rects" /> es una matriz de longitud cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="FillRegion">
      <MemberSignature Language="C#" Value="public void FillRegion (System.Drawing.Brush brush, System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FillRegion(class System.Drawing.Brush brush, class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FillRegion(System.Drawing.Brush,System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FillRegion(System::Drawing::Brush ^ brush, System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.FillRegion : System.Drawing.Brush * System.Drawing.Region -&gt; unit" Usage="graphics.FillRegion (brush, region)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Drawing.Brush" />
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="brush"><see cref="T:System.Drawing.Brush" /> que determina las características del relleno.</param>
        <param name="region"><see cref="T:System.Drawing.Region" /> que representa el área que se desea rellenar.</param>
        <summary>Rellena el interior de un <see cref="T:System.Drawing.Region" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Drawing.Region> se compone de rectángulos y rutas de acceso. Si la región no está cerrada, se agrega un segmento adicional desde el último punto hasta el primer punto para cerrarlo.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un pincel azul sólido.  
  
-   Crea un rectángulo.  
  
-   Crea una región rectangular.  
  
-   Rellena la región rectangular en la pantalla.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#117)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#117)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#117](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#117)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="brush" /> es <see langword="null" />.  
  
O bien 
 <paramref name="region" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Graphics ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Graphics ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="graphics.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que un objeto intente liberar recursos y realizar otras operaciones de limpieza antes de que sea reclamado por la recolección de elementos no utilizados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fuerza la ejecución de todas las operaciones de gráficos pendientes y devuelve inmediatamente el control sin esperar a que finalicen las operaciones.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="graphics.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fuerza la ejecución de todas las operaciones de gráficos pendientes y devuelve inmediatamente el control sin esperar a que finalicen las operaciones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método inicia una operación de vaciado y devuelve inmediatamente sin esperar a que finalice cualquier operación gráficos actualmente en ejecución.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush (System.Drawing.Drawing2D.FlushIntention intention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush(valuetype System.Drawing.Drawing2D.FlushIntention intention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Flush(System.Drawing.Drawing2D.FlushIntention)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush (intention As FlushIntention)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush(System::Drawing::Drawing2D::FlushIntention intention);" />
      <MemberSignature Language="F#" Value="member this.Flush : System.Drawing.Drawing2D.FlushIntention -&gt; unit" Usage="graphics.Flush intention" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intention" Type="System.Drawing.Drawing2D.FlushIntention" />
      </Parameters>
      <Docs>
        <param name="intention">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.FlushIntention" /> que especifica si el método devuelve un valor inmediatamente o espera a que finalicen las operaciones existentes.</param>
        <summary>Fuerza la ejecución de todas las operaciones de gráficos pendientes, esperando o no el método, según se especifique, a devolver un valor antes de que finalicen las operaciones.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de <xref:System.Drawing.Drawing2D.FlushIntention.Flush> para el `intention` parámetro especifica que el método devuelve inmediatamente después de iniciar el vaciado, mientras que un valor de <xref:System.Drawing.Drawing2D.FlushIntention.Sync> especifica que el método debe esperar antes de devolver hasta que finalicen las operaciones existentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo <see cref="T:System.Drawing.Graphics" /> a partir del identificador especificado en un contexto de dispositivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador de un contexto de dispositivo.</param>
        <summary>Crea un nuevo <see cref="T:System.Drawing.Graphics" /> a partir del identificador especificado en un contexto de dispositivo.</summary>
        <returns>Este método devuelve un nuevo <see cref="T:System.Drawing.Graphics" /> para el contexto de dispositivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siempre debe llamar a la <xref:System.Drawing.Graphics.Dispose%2A> método para liberar el <xref:System.Drawing.Graphics> y relacionados con los recursos creados por el <xref:System.Drawing.Graphics.FromHdc%2A> método.  
  
 Incluso si el dispositivo de pantalla tiene un perfil de color ICM asociado, [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] no utilizará dicho perfil de forma predeterminada. Para habilitar ICM para un <xref:System.Drawing.Graphics>, construir la <xref:System.Drawing.Graphics> de HDC después de pasar HDC (e ICM_ON) a la `SetICMMode` función. A continuación, todos los dibujos realizados el <xref:System.Drawing.Graphics> se ajustarán según el perfil ICM asociado con el dispositivo de pantalla. Si se habilita ICM dará como resultado un rendimiento más lento.  
  
 El estado del contexto de dispositivo (modo de asignación, unidad lógica y similares) en el momento de llamar a <xref:System.Drawing.Graphics.FromHdc%2A> pueden afectar a la representación que realiza el <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea una variable de tipo puntero interno `hdc` y lo establece en el identificador del contexto de dispositivo del objeto graphics del formulario.  
  
-   Crea un nuevo objeto de gráficos mediante `hdc`.  
  
-   Dibuja un rectángulo con el nuevo objeto de gráficos (en la pantalla).  
  
-   Libera el nuevo objeto de gráficos mediante `hdc`.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#118)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#118)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#118](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#118)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHdc">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdc (IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdc(native int hdc, native int hdevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdc(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdc (hdc As IntPtr, hdevice As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdc(IntPtr hdc, IntPtr hdevice);" />
      <MemberSignature Language="F#" Value="static member FromHdc : nativeint * nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdc (hdc, hdevice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
        <Parameter Name="hdevice" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador de un contexto de dispositivo.</param>
        <param name="hdevice">Identificador de un dispositivo.</param>
        <summary>Crea un nuevo <see cref="T:System.Drawing.Graphics" /> a partir del identificador especificado de un contexto de dispositivo y del identificador de un dispositivo.</summary>
        <returns>Este método devuelve un nuevo <see cref="T:System.Drawing.Graphics" /> para el contexto de dispositivo y el dispositivo especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siempre debe llamar a la <xref:System.Drawing.Graphics.Dispose%2A> método para liberar el <xref:System.Drawing.Graphics> y relacionados con los recursos creados por el <xref:System.Drawing.Graphics.FromHdc%2A> método.  
  
 Incluso si el dispositivo de pantalla tiene un perfil de color ICM asociado, [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] no utilizará dicho perfil de forma predeterminada. Para habilitar ICM para un <xref:System.Drawing.Graphics>, construir la <xref:System.Drawing.Graphics> de HDC después de pasar HDC (e ICM_ON) a la `SetICMMode` función. A continuación, todos los dibujos realizados el <xref:System.Drawing.Graphics> se ajustarán según el perfil ICM asociado con el dispositivo de pantalla. Si se habilita ICM dará como resultado un rendimiento más lento.  
  
 El estado del contexto de dispositivo (modo de asignación, unidad lógica y similares) en el momento de llamar a <xref:System.Drawing.Graphics.FromHdc%2A> pueden afectar a la representación que realiza el <xref:System.Drawing.Graphics>.  
  
 El identificador de dispositivo se utiliza normalmente para las capacidades de consulta específicas de la impresora.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración relacionada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHdcInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHdcInternal (hdc As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="static member FromHdcInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador de un contexto de dispositivo.</param>
        <summary>Devuelve un <see cref="T:System.Drawing.Graphics" /> correspondiente al contexto de dispositivo especificado.</summary>
        <returns><see cref="T:System.Drawing.Graphics" /> correspondiente al contexto de dispositivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no debe usarse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHwnd">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwnd (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwnd(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwnd(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwnd (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwnd(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwnd : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwnd hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Identificador de una ventana.</param>
        <summary>Crea un nuevo <see cref="T:System.Drawing.Graphics" /> a partir del identificador especificado de una ventana.</summary>
        <returns>Este método devuelve un nuevo <see cref="T:System.Drawing.Graphics" /> para el identificador de ventana especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siempre debe llamar a la <xref:System.Drawing.Graphics.Dispose%2A> método para liberar el <xref:System.Drawing.Graphics> y relacionados con los recursos creados por el <xref:System.Drawing.Graphics.FromHwnd%2A> método.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos, así como `thisForm`, el <xref:System.Windows.Forms.Form> para el ejemplo. El código realiza las siguientes acciones:  
  
-   Crea una nueva variable de puntero interno `hwnd` y lo establece en el identificador del formulario del ejemplo.  
  
-   Crea un nuevo <xref:System.Drawing.Graphics> partir del identificador.  
  
-   Dibuja un rectángulo a la nueva <xref:System.Drawing.Graphics> utilizando una pluma de color rojo.  
  
-   Desecha el nuevo <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#119)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#119)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#119](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#119)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración relacionada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromHwndInternal">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromHwndInternal (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromHwndInternal(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromHwndInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwndInternal (hwnd As IntPtr) As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromHwndInternal(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwndInternal : nativeint -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromHwndInternal hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">Identificador de una ventana.</param>
        <summary>Crea un nuevo <see cref="T:System.Drawing.Graphics" /> para el identificador de ventana especificado.</summary>
        <returns><see cref="T:System.Drawing.Graphics" /> para el identificador de ventana especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no debe usarse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromImage">
      <MemberSignature Language="C#" Value="public static System.Drawing.Graphics FromImage (System.Drawing.Image image);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Drawing.Graphics FromImage(class System.Drawing.Image image) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.FromImage(System.Drawing.Image)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::Graphics ^ FromImage(System::Drawing::Image ^ image);" />
      <MemberSignature Language="F#" Value="static member FromImage : System.Drawing.Image -&gt; System.Drawing.Graphics" Usage="System.Drawing.Graphics.FromImage image" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="image" Type="System.Drawing.Image" />
      </Parameters>
      <Docs>
        <param name="image"><see cref="T:System.Drawing.Image" /> a partir de la cual se va a crear el nuevo <see cref="T:System.Drawing.Graphics" />.</param>
        <summary>Crea un nuevo <see cref="T:System.Drawing.Graphics" /> con la <see cref="T:System.Drawing.Image" /> especificada.</summary>
        <returns>Este método devuelve un nuevo objeto <see cref="T:System.Drawing.Graphics" /> para la <see cref="T:System.Drawing.Image" /> especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la imagen tiene un formato de píxeles indizado, este método produce una excepción con el mensaje, "no puede crearse un objeto Graphics desde una imagen que tiene un formato de píxeles indizado." En la lista siguiente, se muestran los formatos de píxel indizado.  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format1bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format4bppIndexed>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format8bppIndexed>  
  
 Puede guardar la imagen indizada como otro formato mediante el <xref:System.Drawing.Image.Save%28System.String%2CSystem.Drawing.Imaging.ImageFormat%29> método y, a continuación, recupere un <xref:System.Drawing.Graphics> objeto para la nueva imagen.  
  
 Este método también produce una excepción si la imagen tiene cualquiera de los siguientes formatos de píxel.  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Undefined>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.DontCare>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppArgb1555>  
  
-   <xref:System.Drawing.Imaging.PixelFormat.Format16bppGrayScale>  
  
 Siempre debe llamar a la <xref:System.Drawing.Graphics.Dispose%2A> método para liberar el <xref:System.Drawing.Graphics> y relacionados con los recursos creados por el <xref:System.Drawing.Graphics.FromImage%2A> método.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza la acción siguiente:  
  
-   Crea un <xref:System.Drawing.Image> de un gráfico de archivos SampImag.jpg en la carpeta de ejemplo.  
  
-   Crea un <xref:System.Drawing.Graphics> desde el <xref:System.Drawing.Image>.  
  
-   Modifica la imagen rellenando un rectángulo dentro de él.  
  
-   Dibuja el <xref:System.Drawing.Image> a la pantalla.  
  
-   Libera el creado <xref:System.Drawing.Graphics>.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#120)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#120)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#120](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="image" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Exception"><paramref name="image" /> tiene un formato de píxel indizado o su formato no está definido.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/737bae30-e599-4e1d-bf30-bab8280b32be">Cómo: Crear un mapa de bits en tiempo de ejecución</related>
        <related type="Article" href="https://msdn.microsoft.com/library/a626d701-bd99-4fd8-b92f-7b8f794e042b">Trabajar con imágenes, mapas de bits, iconos y metarchivos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/162861f9-f050-445e-8abb-b2c43a918b8b">Cómo: Crear objetos Graphics para dibujar</related>
      </Docs>
    </Member>
    <Member MemberName="GetContextInfo">
      <MemberSignature Language="C#" Value="public object GetContextInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetContextInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetContextInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextInfo () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetContextInfo();" />
      <MemberSignature Language="F#" Value="member this.GetContextInfo : unit -&gt; obj" Usage="graphics.GetContextInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el contexto de los gráficos acumulativos.</summary>
        <returns><see cref="T:System.Object" /> que representa el contexto de los gráficos acumulativos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es una matriz de objetos donde el primer elemento contiene la región de recorte acumulativa y el segundo elemento contiene la matriz de traducir o transformar acumulativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHalftonePalette">
      <MemberSignature Language="C#" Value="public static IntPtr GetHalftonePalette ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHalftonePalette() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHalftonePalette" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHalftonePalette () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr GetHalftonePalette();" />
      <MemberSignature Language="F#" Value="static member GetHalftonePalette : unit -&gt; nativeint" Usage="System.Drawing.Graphics.GetHalftonePalette " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un identificador de la paleta actual de medios tonos de Windows.</summary>
        <returns>Puntero interno que especifica el identificador de la paleta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El propósito de la <xref:System.Drawing.Graphics.GetHalftonePalette%2A> método consiste en habilitar [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] para generar medios tonos de mayor calidad cuando usa de la presentación de 8 bits por píxel. Para mostrar una imagen mediante la paleta de semitonos, utilice el procedimiento siguiente.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Define la interoperabilidad <xref:System.Runtime.InteropServices.DllImportAttribute> atributos para el archivo gdi32.dll de Windows, que contiene el necesario [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] funciones.  
  
-   Define el `SelectPalette` y `RealizePalette` las funciones de dicha DLL como externa.  
  
-   Crea una imagen desde un archivo de imagen existente SampImag.jpg (que debe estar en la misma carpeta que el archivo de código de ejemplo) y dibuja la imagen en la pantalla.  
  
-   Crea variables de tipo de puntero interno y establece sus valores en el identificador para el objeto de gráficos y la paleta de medios tonos de Windows actual, respectivamente.  
  
-   Selecciona y genera la paleta de semitonos.  
  
-   Crea un nuevo objeto de gráficos mediante la `hdc` parámetro.  
  
-   Dibuja la imagen de nuevo.  
  
-   Libera el identificador del contexto de dispositivo.  
  
 El resultado es dos representaciones de la imagen de ejemplo: uno con la paleta de 16 bits y otra con la paleta de 8 bits.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#121)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#121)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#121](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#121)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHdc">
      <MemberSignature Language="C#" Value="public IntPtr GetHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance native int GetHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetHdc" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHdc () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IntPtr GetHdc();" />
      <MemberSignature Language="F#" Value="abstract member GetHdc : unit -&gt; nativeint&#xA;override this.GetHdc : unit -&gt; nativeint" Usage="graphics.GetHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.GetHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el identificador del contexto de dispositivo asociado a este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns>Identificador del contexto de dispositivo asociado a este <see cref="T:System.Drawing.Graphics" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El contexto de dispositivo es una estructura de Windows basada en [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] que define un conjunto de objetos gráficos y sus atributos asociados, así como los modos gráficos que afectan al resultado. Este método devuelve ese contexto de dispositivo con la excepción de una fuente. Porque no está seleccionada una fuente, las llamadas a la <xref:System.Drawing.Font.FromHdc%2A> método mediante un identificador devuelto por la <xref:System.Drawing.Graphics.GetHdc%2A> método generará un error.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.GetHdc%2A> y <xref:System.Drawing.Graphics.ReleaseHdc%2A> métodos deben aparecer en parejas. Durante el ámbito de un <xref:System.Drawing.Graphics.GetHdc%2A> y <xref:System.Drawing.Graphics.ReleaseHdc%2A> par de métodos, normalmente sólo realiza llamadas a [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] funciones. Llamadas de ese ámbito realizadas a [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] métodos de la <xref:System.Drawing.Graphics> que generó el `hdc` producirá un error en el parámetro con un `ObjectBusy` error. Además, [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] pasa por alto los cambios de estado realizados en el <xref:System.Drawing.Graphics> de la `hdc` parámetro en operaciones posteriores.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En el ejemplo se muestra una llamada a un Windows [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] función para realizar la misma tarea que un [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics> método. El código realiza las siguientes acciones:  
  
-   Define la interoperabilidad <xref:System.Runtime.InteropServices.DllImportAttribute> atributo para el archivo DLL de Windows gdi32.dll. Este archivo DLL contiene deseado [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] función.  
  
-   Define el <xref:System.Drawing.Rectangle> función en ese archivo DLL como externa.  
  
-   Crea una pluma de color rojo.  
  
-   Con el lápiz, dibuja un rectángulo en la pantalla mediante el [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics.DrawRectangle%2A> método.  
  
-   Define una variable de tipo puntero interno `hdc` y establece su valor en el identificador del contexto de dispositivo del formulario.  
  
-   Dibuja un rectángulo en la pantalla mediante el [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Rectangle> función.  
  
-   Libera el contexto de dispositivo representado por la `hdc` parámetro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#122)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#122)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#122](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#122)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración relacionada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNearestColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color GetNearestColor (System.Drawing.Color color);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Color GetNearestColor(valuetype System.Drawing.Color color) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.GetNearestColor(System.Drawing.Color)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Color GetNearestColor(System::Drawing::Color color);" />
      <MemberSignature Language="F#" Value="member this.GetNearestColor : System.Drawing.Color -&gt; System.Drawing.Color" Usage="graphics.GetNearestColor color" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="color" Type="System.Drawing.Color" />
      </Parameters>
      <Docs>
        <param name="color">Estructura <see cref="T:System.Drawing.Color" /> para la que se va a buscar una coincidencia.</param>
        <summary>Obtiene el color más próximo a la estructura <see cref="T:System.Drawing.Color" /> especificada.</summary>
        <returns>Estructura <see cref="T:System.Drawing.Color" /> que representa el color más próximo al especificado con el parámetro <paramref name="color" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un color arbitrario con coordenadas ARGB (255, 165, 63, 136).  
  
-   Crea un pincel sólido y establece su color en el color especificado.  
  
-   Rellena una elipse con el color arbitrario.  
  
-   Crea un segundo color y establece su valor en el color ARGB del sistema más cercano.  
  
-   Rellena una segunda elipse con este color.  
  
 El resultado es de dos elipses: la primera que se dibuja con el color especificado arbitrario y la segunda dibujada con el color del sistema más próximo al especificado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#123)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#123)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#123](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#123)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InterpolationMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.InterpolationMode InterpolationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.InterpolationMode InterpolationMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.InterpolationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InterpolationMode As InterpolationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::InterpolationMode InterpolationMode { System::Drawing::Drawing2D::InterpolationMode get(); void set(System::Drawing::Drawing2D::InterpolationMode value); };" />
      <MemberSignature Language="F#" Value="member this.InterpolationMode : System.Drawing.Drawing2D.InterpolationMode with get, set" Usage="System.Drawing.Graphics.InterpolationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.InterpolationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo de interpolación asociado a este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Drawing.Drawing2D.InterpolationMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de interpolación determina cómo los valores intermedios entre dos puntos de conexión se calculan.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IntersectClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualiza la región de recorte de este <see cref="T:System.Drawing.Graphics" /> a la intersección de la actual región de recorte y la estructura <see cref="T:System.Drawing.Rectangle" /> especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que va a formar una intersección con la actual región de recorte.</param>
        <summary>Actualiza la región de recorte de este <see cref="T:System.Drawing.Graphics" /> a la intersección de la actual región de recorte y la estructura <see cref="T:System.Drawing.Rectangle" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método asigna a la <xref:System.Drawing.Graphics.Clip%2A> propiedad de este <xref:System.Drawing.Graphics> el área representada por la intersección de la región de recorte actual y el rectángulo especificado por el `rect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un rectángulo con la esquina superior izquierda en (0, 0) y establece la región de recorte en este rectángulo.  
  
-   Crea un segundo rectángulo con la esquina superior izquierda en (100, 100) y establece la región de recorte en la intersección de este rectángulo y la región de recorte actual (el primer rectángulo).  
  
-   Rellena un rectángulo grande que incluye dos rectángulos anteriores con un pincel azul sólido.  
  
-   Restablece la región de recorte en infinito.  
  
-   Dibuja rectángulos en torno a las dos regiones de recorte. Utiliza una pluma de color negro para el primer rectángulo de recorte y un color rojo para la segunda región de recorte.  
  
 El resultado es que sólo la intersección de los dos rectángulos se rellena con el azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#124)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#124)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#124](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#124)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.IntersectClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que va a formar una intersección con la actual región de recorte.</param>
        <summary>Actualiza la región de recorte de este <see cref="T:System.Drawing.Graphics" /> a la intersección de la actual región de recorte y la estructura <see cref="T:System.Drawing.RectangleF" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método asigna a la <xref:System.Drawing.Graphics.Clip%2A> propiedad de este <xref:System.Drawing.Graphics> el área representada por la intersección de la región de recorte actual y el rectángulo especificado por el `rect` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un rectángulo con la esquina superior izquierda en (0, 0) y establece la región de recorte en este rectángulo.  
  
-   Crea un segundo rectángulo con la esquina superior izquierda en (100, 100) y establece la región de recorte en la intersección de este rectángulo y la región de recorte actual (el primer rectángulo).  
  
-   Rellena un rectángulo grande que incluye dos rectángulos anteriores con un pincel azul sólido.  
  
-   Restablece la región de recorte en infinito.  
  
-   Dibuja rectángulos en torno a las dos regiones de recorte. Utiliza una pluma de color negro para el primer rectángulo de recorte y un color rojo para la segunda región de recorte.  
  
 El resultado es que sólo la intersección de los dos rectángulos se rellena con el azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#125)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#125)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#125](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntersectClip">
      <MemberSignature Language="C#" Value="public void IntersectClip (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void IntersectClip(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IntersectClip(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void IntersectClip(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.IntersectClip : System.Drawing.Region -&gt; unit" Usage="graphics.IntersectClip region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" /> que va a formar una intersección con la región actual.</param>
        <summary>Actualiza la región de recorte de este <see cref="T:System.Drawing.Graphics" /> a la intersección de la actual región de recorte y la <see cref="T:System.Drawing.Region" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método asigna a la <xref:System.Drawing.Graphics.Clip%2A> propiedad de este <xref:System.Drawing.Graphics> el área representada por la intersección de la región de recorte actual y la región especificada por el `region` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un rectángulo con la esquina superior izquierda en (0, 0).  
  
-   Crea una región y lo establece en el rectángulo y establece la región de recorte en esta región.  
  
-   Crea un segundo rectángulo con la esquina superior izquierda en (100, 100).  
  
-   Crea una región y lo establece en el segundo rectángulo y establece la región de recorte en la intersección de esta región y la región de recorte actual (el primer rectángulo) mediante el modo de combinación <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Rellena un rectángulo grande que incluya ambas regiones anteriores con un pincel azul sólido.  
  
-   Restablece la región de recorte en infinito.  
  
-   Dibuja rectángulos en torno a las dos regiones de recorte. Utiliza una pluma de color negro para la primera región de recorte y un color rojo para la segunda región de recorte.  
  
 El resultado es que sólo la intersección de las dos regiones se rellena con el azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#126)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#126)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#126](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#126)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClipEmpty : bool" Usage="System.Drawing.Graphics.IsClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la región de recorte de este <see cref="T:System.Drawing.Graphics" /> está vacía.</summary>
        <value><see langword="true" /> si la región de recorte de este <see cref="T:System.Drawing.Graphics" /> está vacía; de lo contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si el punto especificado por un par de coordenadas se halla contenido en la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Estructura <see cref="T:System.Drawing.Point" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si la estructura <see cref="T:System.Drawing.Point" /> especificada está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> si el punto especificado por el parámetro <paramref name="point" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una región de recorte rectangular y lo establece como región de recorte para el objeto graphics del formulario mediante <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Crea dos puntos, uno dentro de la región de recorte y otro fuera.  
  
-   Comprueba cada uno de los puntos de visibilidad y dibuja únicamente el que es visible.  
  
 El resultado es un pequeño círculo rojo, que está dentro de la región de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#127)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#127)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#127](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#127)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="graphics.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">Estructura <see cref="T:System.Drawing.PointF" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si la estructura <see cref="T:System.Drawing.PointF" /> especificada está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> si el punto especificado por el parámetro <paramref name="point" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una región de recorte rectangular y lo establece como la región de recorte para los gráficos del formulario mediante <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Crea dos puntos, uno dentro de la región de recorte y otro fuera.  
  
-   Comprueba cada uno de los puntos de visibilidad y dibuja únicamente el que es visible.  
  
 El resultado es un pequeño círculo rojo, que está dentro de la región de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#128)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#128)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#128](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#128)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As Rectangle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Rectangle -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el rectángulo especificado por una estructura <see cref="T:System.Drawing.Rectangle" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> si el rectángulo especificado por el parámetro <paramref name="rect" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una región de recorte rectangular y lo establece como región de recorte para el objeto graphics del formulario mediante <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Crea la ubicación y tamaño de dos rectángulos, uno dentro de la región de recorte y otro fuera.  
  
-   Comprueba cada uno de los rectángulos de visibilidad y dibuja únicamente el que es visible.  
  
 El resultado es un pequeño rectángulo rojo, que está dentro de la región de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#129)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#129)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#129](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#129)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (rect As RectangleF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.RectangleF -&gt; bool" Usage="graphics.IsVisible rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el rectángulo especificado por una estructura <see cref="T:System.Drawing.RectangleF" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> si el rectángulo especificado por el parámetro <paramref name="rect" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una región de recorte rectangular y lo establece como región de recorte para el objeto graphics del formulario mediante <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Crea dos rectángulos, uno dentro de la región de recorte y otro fuera.  
  
-   Comprueba cada uno de los rectángulos de visibilidad y dibuja únicamente el que es visible.  
  
 El resultado es un pequeño rectángulo rojo, que está dentro de la región de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#130)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#130)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#130](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#130)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada x del punto cuya visibilidad se va a comprobar.</param>
        <param name="y">Coordenada y del punto cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado por un par de coordenadas se halla contenido en la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> si el punto definido por los parámetros <paramref name="x" /> e <paramref name="y" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una región de recorte rectangular y lo establece como región de recorte para el objeto graphics del formulario mediante <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Crea dos puntos, uno dentro de la región de recorte y otro fuera.  
  
-   Comprueba cada uno de los puntos de visibilidad y dibuja únicamente el que es visible.  
  
 El resultado es un pequeño círculo rojo, que está dentro de la región de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#131)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#131)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#131](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#131)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="graphics.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada x del punto cuya visibilidad se va a comprobar.</param>
        <param name="y">Coordenada y del punto cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el punto especificado por un par de coordenadas se halla contenido en la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> si el punto definido por los parámetros <paramref name="x" /> e <paramref name="y" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una región de recorte rectangular y lo establece como región de recorte para el objeto graphics del formulario mediante <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Crea dos puntos, uno dentro de la región de recorte y otro fuera.  
  
-   Comprueba cada uno de los puntos de visibilidad y dibuja únicamente el que es visible.  
  
 El resultado es un pequeño círculo rojo, que está dentro de la región de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#133)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#133)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#133](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#133)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer, width As Integer, height As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * int * int -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo cuya visibilidad se va a comprobar.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo cuya visibilidad se va a comprobar.</param>
        <param name="width">Ancho del rectángulo cuya visibilidad se va a comprobar.</param>
        <param name="height">Alto del rectángulo cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el rectángulo especificado por un par de coordenadas, un valor de ancho y un valor de alto se halla contenido en la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> si el rectángulo definido por los parámetros <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> y <paramref name="height" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una región de recorte rectangular y lo establece como región de recorte para el objeto graphics del formulario mediante <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Crea la ubicación y tamaño de dos rectángulos, uno dentro de la región de recorte y otro fuera.  
  
-   Comprueba cada uno de los rectángulos de visibilidad y dibuja únicamente el que es visible.  
  
 El resultado es un pequeño rectángulo rojo, que está dentro de la región de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#132)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#132)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#132](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#132)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.IsVisible(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single, width As Single, height As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * single * single -&gt; bool" Usage="graphics.IsVisible (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Coordenada x de la esquina superior izquierda del rectángulo cuya visibilidad se va a comprobar.</param>
        <param name="y">Coordenada y de la esquina superior izquierda del rectángulo cuya visibilidad se va a comprobar.</param>
        <param name="width">Ancho del rectángulo cuya visibilidad se va a comprobar.</param>
        <param name="height">Alto del rectángulo cuya visibilidad se va a comprobar.</param>
        <summary>Indica si el rectángulo especificado por un par de coordenadas, un valor de ancho y un valor de alto se halla contenido en la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <returns><see langword="true" /> si el rectángulo definido por los parámetros <paramref name="x" />, <paramref name="y" />, <paramref name="width" /> y <paramref name="height" /> está dentro de la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una región de recorte rectangular y lo establece como región de recorte para el objeto graphics del formulario mediante <xref:System.Drawing.Drawing2D.CombineMode.Replace>.  
  
-   Crea la ubicación y tamaño de dos rectángulos, uno dentro de la región de recorte y otro fuera.  
  
-   Comprueba cada uno de los rectángulos de visibilidad y dibuja únicamente el que es visible.  
  
 El resultado es un pequeño rectángulo rojo, que está dentro de la región de recorte.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#134)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#134)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#134](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#134)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleClipEmpty">
      <MemberSignature Language="C#" Value="public bool IsVisibleClipEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisibleClipEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisibleClipEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisibleClipEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisibleClipEmpty : bool" Usage="System.Drawing.Graphics.IsVisibleClipEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la región de recorte visible de este <see cref="T:System.Drawing.Graphics" /> está vacía.</summary>
        <value><see langword="true" /> si la parte visible de la región de recorte de este <see cref="T:System.Drawing.Graphics" /> está vacía; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La región de recorte visible es la intersección de la región de recorte de este `Graphics` y la región de recorte de la ventana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCharacterRanges">
      <MemberSignature Language="C#" Value="public System.Drawing.Region[] MeasureCharacterRanges (string text, System.Drawing.Font font, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Region[] MeasureCharacterRanges(string text, class System.Drawing.Font font, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Drawing::Region ^&gt; ^ MeasureCharacterRanges(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureCharacterRanges : string * System.Drawing.Font * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; System.Drawing.Region[]" Usage="graphics.MeasureCharacterRanges (text, font, layoutRect, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Region[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a medir.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="layoutRect">Estructura <see cref="T:System.Drawing.RectangleF" /> que especifica el rectángulo correspondiente a la cadena.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" /> que representa la información de formato, como el espaciado interlineal.</param>
        <summary>Obtiene una matriz de objetos <see cref="T:System.Drawing.Region" />, cada uno de los cuales delimita un intervalo de posiciones de caracteres dentro de la cadena especificada.</summary>
        <returns>Este método devuelve una matriz de objetos <see cref="T:System.Drawing.Region" />, cada uno de los cuales delimita un intervalo de posiciones de caracteres dentro de la cadena especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las regiones que devuelve este método son dependen de la resolución, por lo que podría haber una ligera pérdida de precisión si las cadenas se registran en un metarchivo con una resolución y se reproducen más adelante en otra resolución.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Establece una cadena "primera y segunda intervalos" y una fuente para mostrar de la cadena ("Times New Roman", 16 puntos).  
  
-   Conjuntos de dos intervalos de caracteres dentro de la cadena (que se corresponden con las palabras "First" y "Second").  
  
-   Crea un rectángulo en el que se va a mostrar la cadena.  
  
-   Establece el formato de la cadena ¾, incluidos los intervalos de dos caracteres.  
  
-   Dibuja la cadena en la pantalla.  
  
-   Mide los intervalos de caracteres, determina los rectángulos que limitan los dos intervalos especificados.  
  
-   Dibuja los dos rectángulos en la pantalla.  
  
 El resultado es la cadena mostrada con el primer intervalo ("First") delimitado por un rectángulo rojo y el segundo intervalo ("Second") delimitado por un rectángulo azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#135)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#135)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#135](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#135)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MeasureString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mide la cadena especificada al dibujarla con la <see cref="T:System.Drawing.Font" /> especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a medir.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <summary>Mide la cadena especificada al dibujarla con la <see cref="T:System.Drawing.Font" /> especificada.</summary>
        <returns>Este método devuelve una estructura <see cref="T:System.Drawing.SizeF" /> que representa el tamaño, en las unidades especificadas por la propiedad <see cref="P:System.Drawing.Graphics.PageUnit" />, de la cadena especificada por el parámetro <paramref name="text" /> que se dibuja con el parámetro <paramref name="font" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.MeasureString%2A> método está diseñado para usarlo con la persona cadenas e incluye una pequeña cantidad de espacio adicional antes y después de la cadena para permitir glifos sobresalientes. Además, el <xref:System.Drawing.Graphics.DrawString%2A> método ajusta los puntos de glifo para optimizar la calidad de presentación y puede mostrar una cadena más estrecha que notificados por <xref:System.Drawing.Graphics.MeasureString%2A>. Para obtener las medidas apropiadas para las cadenas adyacentes en el diseño (por ejemplo, al implementar texto con formato), utilice el <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método o a uno de los <xref:System.Drawing.Graphics.MeasureString%2A> métodos que toma un <xref:System.Drawing.StringFormat>y pasar <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Además, asegúrese del <xref:System.Drawing.Graphics.TextRenderingHint%2A> para el <xref:System.Drawing.Graphics> es <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena para medir.  
  
-   Crea un objeto de fuente y lo establece en Arial (16 puntos).  
  
-   Crea un objeto de tamaño y éste y el objeto de fuente se utiliza para medir el tamaño de la cadena.  
  
-   Dibuja un rectángulo rojo utilizando el tamaño medido de la cadena.  
  
-   Dibuja la cadena dentro del rectángulo dibujado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#136)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#136)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#136](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#136)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a medir.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="layoutArea">Estructura <see cref="T:System.Drawing.SizeF" /> que especifica el área máxima de presentación del texto.</param>
        <summary>Mide la cadena especificada al dibujarla con la <see cref="T:System.Drawing.Font" /> especificada dentro del área de presentación indicada.</summary>
        <returns>Este método devuelve una estructura <see cref="T:System.Drawing.SizeF" /> que representa el tamaño, en las unidades especificadas por la propiedad <see cref="P:System.Drawing.Graphics.PageUnit" />, de la cadena especificada por el parámetro <paramref name="text" /> que se dibuja con el parámetro <paramref name="font" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.MeasureString%2A> método está diseñado para usarlo con la persona cadenas e incluye una pequeña cantidad de espacio adicional antes y después de la cadena para permitir glifos sobresalientes. Además, el <xref:System.Drawing.Graphics.DrawString%2A> método ajusta los puntos de glifo para optimizar la calidad de presentación y puede mostrar una cadena más estrecha que notificados por <xref:System.Drawing.Graphics.MeasureString%2A>. Para obtener las medidas apropiadas para las cadenas adyacentes en el diseño (por ejemplo, al implementar texto con formato), utilice el <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método o a uno de los <xref:System.Drawing.Graphics.MeasureString%2A> métodos que toma un <xref:System.Drawing.StringFormat>y pasar <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Además, asegúrese del <xref:System.Drawing.Graphics.TextRenderingHint%2A> para el <xref:System.Drawing.Graphics> es <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena para medir y un objeto de fuente establecido en Arial (16 puntos).  
  
-   Establece el tamaño máximo de presentación de la cadena.  
  
-   Crea un objeto de tamaño y se utiliza para medir el tamaño de la cadena, el objeto de fuente y el tamaño máximo de presentación.  
  
-   Dibuja un rectángulo rojo utilizando el tamaño medido de la cadena.  
  
-   Dibuja la cadena dentro del rectángulo dibujado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#138)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#138)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#138](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#138)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a medir.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de la cadena.</param>
        <param name="width">Ancho máximo de la cadena en píxeles.</param>
        <summary>Mide la cadena especificada al dibujarla con la <see cref="T:System.Drawing.Font" /> especificada.</summary>
        <returns>Este método devuelve una estructura <see cref="T:System.Drawing.SizeF" /> que representa el tamaño, en las unidades especificadas por la propiedad <see cref="P:System.Drawing.Graphics.PageUnit" />, de la cadena especificada por el parámetro <paramref name="text" /> que se dibuja con el parámetro <paramref name="font" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `width` parámetro especifica el valor máximo del componente de ancho de devuelto <xref:System.Drawing.SizeF> estructura (<xref:System.Drawing.SizeF.Width%2A>). Si el `width` parámetro es menor que el ancho real de la cadena, el valor devuelto <xref:System.Drawing.SizeF.Width%2A> componente se trunca a un valor que representa el número máximo de caracteres que se ajusten el ancho especificado. Para dar cabida a toda la cadena, el valor devuelto <xref:System.Drawing.SizeF.Height%2A> componente se ajusta a un valor que permite mostrar la cadena con el ajuste de carácter.  
  
 El <xref:System.Drawing.Graphics.MeasureString%2A> método está diseñado para usarlo con la persona cadenas e incluye una pequeña cantidad de espacio adicional antes y después de la cadena para permitir glifos sobresalientes. Además, el <xref:System.Drawing.Graphics.DrawString%2A> método ajusta los puntos de glifo para optimizar la calidad de presentación y puede mostrar una cadena más estrecha que notificados por <xref:System.Drawing.Graphics.MeasureString%2A>. Para obtener las medidas apropiadas para las cadenas adyacentes en el diseño (por ejemplo, al implementar texto con formato), utilice el <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método o a uno de los <xref:System.Drawing.Graphics.MeasureString%2A> métodos que toma un <xref:System.Drawing.StringFormat>y pasar <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Además, asegúrese del <xref:System.Drawing.Graphics.TextRenderingHint%2A> para el <xref:System.Drawing.Graphics> es <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena para medir y un objeto de fuente establecido en Arial (16 puntos).  
  
-   Establece el ancho máximo de la cadena.  
  
-   Crea un objeto de tamaño y se utiliza para medir el tamaño de la cadena, el objeto de fuente y el ancho máximo de la cadena.  
  
-   Dibuja un rectángulo rojo utilizando el tamaño medido de la cadena.  
  
-   Dibuja la cadena dentro del rectángulo dibujado.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#141)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#141)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#141](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#141)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.PointF origin, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::PointF origin, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.PointF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, origin, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a medir.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="origin">Estructura <see cref="T:System.Drawing.PointF" /> que representa la esquina superior izquierda de la cadena.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" /> que representa la información de formato, como el espaciado interlineal.</param>
        <summary>Mide la cadena especificada al dibujarla con la <see cref="T:System.Drawing.Font" /> que se indique y darle formato con el <see cref="T:System.Drawing.StringFormat" /> señalado.</summary>
        <returns>Este método devuelve una estructura <see cref="T:System.Drawing.SizeF" /> que representa el tamaño, en las unidades especificadas por la propiedad <see cref="P:System.Drawing.Graphics.PageUnit" />, de la cadena especificada por el parámetro <paramref name="text" /> que se dibuja con los parámetros <paramref name="font" /> y <paramref name="stringFormat" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.MeasureString%2A> método está diseñado para usarlo con la persona cadenas e incluye una pequeña cantidad de espacio adicional antes y después de la cadena para permitir glifos sobresalientes. Además, el <xref:System.Drawing.Graphics.DrawString%2A> método ajusta los puntos de glifo para optimizar la calidad de presentación y puede mostrar una cadena más estrecha que notificados por <xref:System.Drawing.Graphics.MeasureString%2A>. Para obtener las medidas apropiadas para las cadenas adyacentes en el diseño (por ejemplo, al implementar texto con formato), utilice el <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método o a uno de los <xref:System.Drawing.Graphics.MeasureString%2A> métodos que toma un <xref:System.Drawing.StringFormat>y pasar <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Además, asegúrese del <xref:System.Drawing.Graphics.TextRenderingHint%2A> para el <xref:System.Drawing.Graphics> es <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena para medir y un objeto de fuente establecido en Arial (16 puntos)  
  
-   Crea un punto para localizar la esquina superior izquierda de la cadena.  
  
-   Crea un objeto de formato de cadena y establece sus marcas de formato en <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Crea un objeto de tamaño para medir la cadena.  
  
-   Mide el tamaño de la cadena, utilizando la cadena, el objeto de fuente, el punto de situación y el formato de cadena.  
  
-   Dibuja un rectángulo rojo utilizando el punto de localización y el tamaño de la cadena medido.  
  
-   Dibuja la cadena dentro del rectángulo dibujado.  
  
 El resultado es un rectángulo vertical que contiene una cadena vertical.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#137)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#137)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#137](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#137)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a medir.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="layoutArea">Estructura <see cref="T:System.Drawing.SizeF" /> que especifica el área máxima de presentación del texto.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" /> que representa la información de formato, como el espaciado interlineal.</param>
        <summary>Mide la cadena especificada al dibujarla con la <see cref="T:System.Drawing.Font" /> que se indique y darle formato con el <see cref="T:System.Drawing.StringFormat" /> señalado.</summary>
        <returns>Este método devuelve una estructura <see cref="T:System.Drawing.SizeF" /> que representa el tamaño, en las unidades especificadas por la propiedad <see cref="P:System.Drawing.Graphics.PageUnit" />, de la cadena especificada por el parámetro <paramref name="text" /> que se dibuja con los parámetros <paramref name="font" /> y <paramref name="stringFormat" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.MeasureString%2A> método está diseñado para usarlo con la persona cadenas e incluye una pequeña cantidad de espacio adicional antes y después de la cadena para permitir glifos sobresalientes. Además, el <xref:System.Drawing.Graphics.DrawString%2A> método ajusta los puntos de glifo para optimizar la calidad de presentación y puede mostrar una cadena más estrecha que notificados por <xref:System.Drawing.Graphics.MeasureString%2A>. Para obtener las medidas apropiadas para las cadenas adyacentes en el diseño (por ejemplo, al implementar texto con formato), utilice el <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método o a uno de los <xref:System.Drawing.Graphics.MeasureString%2A> métodos que toma un <xref:System.Drawing.StringFormat>y pasar <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Además, asegúrese del <xref:System.Drawing.Graphics.TextRenderingHint%2A> para el <xref:System.Drawing.Graphics> es <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena para medir y un objeto de fuente establecido en Arial (16 puntos).  
  
-   Establece el tamaño máximo de presentación de la cadena, creando un objeto de tamaño para medir la cadena.  
  
-   Crea un objeto de formato de cadena y establece sus marcas de formato en <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Mide el tamaño de la cadena, utilizando la cadena, el objeto de fuente, el tamaño máximo de presentación y el formato de cadena.  
  
-   Dibuja un rectángulo rojo utilizando el tamaño medido de la cadena.  
  
-   Dibuja la cadena dentro del rectángulo dibujado.  
  
 El resultado es un rectángulo vertical que contiene una cadena vertical.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#139)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#139)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#139](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#139)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, int width, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, int32 width, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Int32,System.Drawing.StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, int width, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * int * System.Drawing.StringFormat -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, width, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a medir.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="width">Ancho máximo de la cadena.</param>
        <param name="format"><see cref="T:System.Drawing.StringFormat" /> que representa la información de formato, como el espaciado interlineal.</param>
        <summary>Mide la cadena especificada al dibujarla con la <see cref="T:System.Drawing.Font" /> que se indique y darle formato con el <see cref="T:System.Drawing.StringFormat" /> señalado.</summary>
        <returns>Este método devuelve una estructura <see cref="T:System.Drawing.SizeF" /> que representa el tamaño, en las unidades especificadas por la propiedad <see cref="P:System.Drawing.Graphics.PageUnit" />, de la cadena especificada por el parámetro <paramref name="text" /> que se dibuja con los parámetros <paramref name="font" /> y <paramref name="stringFormat" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.MeasureString%2A> método está diseñado para usarlo con la persona cadenas e incluye una pequeña cantidad de espacio adicional antes y después de la cadena para permitir glifos sobresalientes. Además, el <xref:System.Drawing.Graphics.DrawString%2A> método ajusta los puntos de glifo para optimizar la calidad de presentación y puede mostrar una cadena más estrecha que notificados por <xref:System.Drawing.Graphics.MeasureString%2A>. Para obtener las medidas apropiadas para las cadenas adyacentes en el diseño (por ejemplo, al implementar texto con formato), utilice el <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método o a uno de los <xref:System.Drawing.Graphics.MeasureString%2A> métodos que toma un <xref:System.Drawing.StringFormat>y pasar <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Además, asegúrese del <xref:System.Drawing.Graphics.TextRenderingHint%2A> para el <xref:System.Drawing.Graphics> es <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena a la medida y una fuente de objeto establecido en Arial (16 puntos).  
  
-   Establece el ancho máximo de la cadena.  
  
-   Crea un objeto de formato de cadena y establece sus marcas de formato en <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Crea un objeto de tamaño para medir la cadena.  
  
-   Mide el tamaño de la cadena, utilizando la cadena, el objeto de fuente, el ancho máximo y el formato de cadena.  
  
-   Dibuja un rectángulo rojo utilizando el tamaño medido de la cadena.  
  
-   Dibuja la cadena dentro del rectángulo dibujado.  
  
 El resultado es un rectángulo vertical que contiene una cadena vertical.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#142)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#142)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#142](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#142)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <Member MemberName="MeasureString">
      <MemberSignature Language="C#" Value="public System.Drawing.SizeF MeasureString (string text, System.Drawing.Font font, System.Drawing.SizeF layoutArea, System.Drawing.StringFormat stringFormat, out int charactersFitted, out int linesFilled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.SizeF MeasureString(string text, class System.Drawing.Font font, valuetype System.Drawing.SizeF layoutArea, class System.Drawing.StringFormat stringFormat, [out] int32&amp; charactersFitted, [out] int32&amp; linesFilled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MeasureString(System.String,System.Drawing.Font,System.Drawing.SizeF,System.Drawing.StringFormat,System.Int32@,System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::SizeF MeasureString(System::String ^ text, System::Drawing::Font ^ font, System::Drawing::SizeF layoutArea, System::Drawing::StringFormat ^ stringFormat, [Runtime::InteropServices::Out] int % charactersFitted, [Runtime::InteropServices::Out] int % linesFilled);" />
      <MemberSignature Language="F#" Value="member this.MeasureString : string * System.Drawing.Font * System.Drawing.SizeF * System.Drawing.StringFormat *  *  -&gt; System.Drawing.SizeF" Usage="graphics.MeasureString (text, font, layoutArea, stringFormat, charactersFitted, linesFilled)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="font" Type="System.Drawing.Font" />
        <Parameter Name="layoutArea" Type="System.Drawing.SizeF" />
        <Parameter Name="stringFormat" Type="System.Drawing.StringFormat" />
        <Parameter Name="charactersFitted" Type="System.Int32" RefType="out" />
        <Parameter Name="linesFilled" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a medir.</param>
        <param name="font"><see cref="T:System.Drawing.Font" /> que define el formato de texto de la cadena.</param>
        <param name="layoutArea">Estructura <see cref="T:System.Drawing.SizeF" /> que especifica el área máxima de presentación del texto.</param>
        <param name="stringFormat"><see cref="T:System.Drawing.StringFormat" /> que representa la información de formato, como el espaciado interlineal.</param>
        <param name="charactersFitted">Número de caracteres que contiene la cadena.</param>
        <param name="linesFilled">Número de líneas de texto que contiene la cadena.</param>
        <summary>Mide la cadena especificada al dibujarla con la <see cref="T:System.Drawing.Font" /> que se indique y darle formato con el <see cref="T:System.Drawing.StringFormat" /> señalado.</summary>
        <returns>Este método devuelve una estructura <see cref="T:System.Drawing.SizeF" /> que representa el tamaño, en las unidades especificadas por la propiedad <see cref="P:System.Drawing.Graphics.PageUnit" />, de la cadena especificada por el parámetro <paramref name="text" /> que se dibuja con los parámetros <paramref name="font" /> y <paramref name="stringFormat" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Drawing.Graphics.MeasureString%2A> método está diseñado para usarlo con la persona cadenas e incluye una pequeña cantidad de espacio adicional antes y después de la cadena para permitir glifos sobresalientes. Además, el <xref:System.Drawing.Graphics.DrawString%2A> método ajusta los puntos de glifo para optimizar la calidad de presentación y puede mostrar una cadena más estrecha que notificados por <xref:System.Drawing.Graphics.MeasureString%2A>. Para obtener las medidas apropiadas para las cadenas adyacentes en el diseño (por ejemplo, al implementar texto con formato), utilice el <xref:System.Drawing.Graphics.MeasureCharacterRanges%2A> método o a uno de los <xref:System.Drawing.Graphics.MeasureString%2A> métodos que toma un <xref:System.Drawing.StringFormat> y pasar <xref:System.Drawing.StringFormat.GenericTypographic%2A>. Asegúrese también de la <xref:System.Drawing.Graphics.TextRenderingHint%2A> para el <xref:System.Drawing.Graphics> es <xref:System.Drawing.Text.TextRenderingHint.AntiAlias>.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea una cadena para medir y un objeto de fuente establecido en Arial (16 puntos)  
  
-   Establece el tamaño máximo de presentación de la cadena.  
  
-   Crea un objeto de formato de cadena y establece sus marcas de formato en <xref:System.Drawing.StringFormatFlags.DirectionVertical>.  
  
-   Crea las variables de entero `charactersFitted` y `linesFilled` y un objeto de tamaño para medir la cadena.  
  
-   Mide el tamaño de la cadena y determina el número de caracteres incluidos y las líneas rellenadas, con la cadena, el objeto de fuente, el tamaño máximo de presentación y el formato de cadena.  
  
-   Dibuja un rectángulo rojo utilizando el tamaño medido de la cadena.  
  
-   Dibuja la cadena dentro del rectángulo dibujado.  
  
-   Dibuja los valores del número de caracteres incluidos y las líneas rellenadas.  
  
 El resultado es un rectángulo vertical que contiene una cadena vertical.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#140)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#140)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#140](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#140)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="font" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Forms.TextRenderer.MeasureText(System.Drawing.IDeviceContext,System.String,System.Drawing.Font,System.Drawing.Size,System.Windows.Forms.TextFormatFlags)" />
        <altmember cref="M:System.Drawing.Graphics.MeasureCharacterRanges(System.String,System.Drawing.Font,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
        <related type="Article" href="~/docs/framework/winforms/advanced/using-fonts-and-text.md">Utilizar fuentes y texto</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MultiplyTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Multiplica la transformación universal de este <see cref="T:System.Drawing.Graphics" />, según especifica <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphics.MultiplyTransform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix"><see cref="T:System.Drawing.Drawing2D.Matrix" /> de 4x4 que multiplica la transformación universal.</param>
        <summary>Multiplica la transformación universal de este <see cref="T:System.Drawing.Graphics" />, según especifica <see cref="T:System.Drawing.Drawing2D.Matrix" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método antepone la matriz especificada por el `matrix` parámetro, por lo que el resultado es `matrix` x transformación universal.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un `transformMatrix` matrix (una matriz dos por dos identidades más un vector de traslación cero).  
  
-   Convierte la matriz de transformación con un vector (200, 100).  
  
-   La matriz de transformación universal del formulario de Windows gira 30 grados, antepone la matriz de rotación de 30 grados a la matriz de transformación del formulario.  
  
-   Multiplica la matriz de transformación universal rotada por traducidos `transformMatrix`y antepone el `transformMatrix` a la matriz de transformación del mundo.  
  
-   Dibuja una elipse trasladada girada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#143)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#143)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#143](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#143)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">Representación matricial de transformaciones</related>
      </Docs>
    </Member>
    <Member MemberName="MultiplyTransform">
      <MemberSignature Language="C#" Value="public void MultiplyTransform (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MultiplyTransform(class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.MultiplyTransform(System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MultiplyTransform(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.MultiplyTransform : System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.MultiplyTransform (matrix, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="matrix"><see cref="T:System.Drawing.Drawing2D.Matrix" /> de 4x4 que multiplica la transformación universal.</param>
        <param name="order">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> que determina el orden de la multiplicación.</param>
        <summary>Multiplica la transformación universal de este <see cref="T:System.Drawing.Graphics" />, que especifica <see cref="T:System.Drawing.Drawing2D.Matrix" /> siguiendo el orden establecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de <xref:System.Drawing.Drawing2D.MatrixOrder.Prepend> para el `order` parámetro especifica que el orden de la multiplicación es `matrix` x transformación universal. Un valor de <xref:System.Drawing.Drawing2D.MatrixOrder.Append> para `order` especifica que el orden de la multiplicación es transformación universal x `matrix`.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un `transformMatrix` matrix (una matriz dos por dos identidades más un vector de traslación cero).  
  
-   Convierte la matriz de transformación con un vector (200, 100).  
  
-   La matriz de transformación universal del formulario de Windows gira 30 grados, anteponiendo la matriz de rotación de 30 grados a la matriz de transformación del formulario.  
  
-   Multiplica la matriz de transformación universal rotada por traducidos `transformMatrix`, anexando el `transformMatrix` a la matriz de transformación del mundo.  
  
-   Dibuja una elipse trasladada girada.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#144)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#144)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#144](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#144)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/0659fe00-9e0c-41c4-9118-016f2404c905">Representación matricial de transformaciones</related>
      </Docs>
    </Member>
    <Member MemberName="PageScale">
      <MemberSignature Language="C#" Value="public float PageScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 PageScale" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageScale" />
      <MemberSignature Language="VB.NET" Value="Public Property PageScale As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float PageScale { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.PageScale : single with get, set" Usage="System.Drawing.Graphics.PageScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la relación de escala entre las unidades universales y las unidades de página de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Esta propiedad especifica un valor de relación de escala entre las unidades universales y las unidades de página de este <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Drawing.Graphics.PageScale%2A> y <xref:System.Drawing.Graphics.TranslateTransform%2A> miembros para cambiar la escala y el origen cuando se dibuja un rectángulo.  
  
 En este ejemplo está diseñado para usarse con Windows Forms. Pegue el código en un formulario y llame a la `ChangePageScaleAndTranslateTransform` método cuando el control del formulario <xref:System.Windows.Forms.Control.Paint> evento pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.GraphicsProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#2)]
 [!code-vb[System.Drawing.GraphicsProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Tipos de sistemas de coordenadas</related>
      </Docs>
    </Member>
    <Member MemberName="PageUnit">
      <MemberSignature Language="C#" Value="public System.Drawing.GraphicsUnit PageUnit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.GraphicsUnit PageUnit" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PageUnit" />
      <MemberSignature Language="VB.NET" Value="Public Property PageUnit As GraphicsUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::GraphicsUnit PageUnit { System::Drawing::GraphicsUnit get(); void set(System::Drawing::GraphicsUnit value); };" />
      <MemberSignature Language="F#" Value="member this.PageUnit : System.Drawing.GraphicsUnit with get, set" Usage="System.Drawing.Graphics.PageUnit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.GraphicsUnit</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la unidad de medida usada para las coordenadas de página en este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Drawing.GraphicsUnit" /> que no sea <see cref="F:System.Drawing.GraphicsUnit.World" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La unidad de gráficos es la unidad de medida utilizada para las coordenadas de página en este <xref:System.Drawing.Graphics>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el efecto de cambiar la <xref:System.Drawing.Graphics.PageUnit%2A> propiedad.  
  
 En este ejemplo está diseñado para usarse con Windows Forms. Pegue el código en un formulario y llame a la `ChangePageUnit` método cuando el control del formulario <xref:System.Windows.Forms.Control.Paint> evento pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.GraphicsProperties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#3)]
 [!code-vb[System.Drawing.GraphicsProperties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La propiedad <see cref="P:System.Drawing.Graphics.PageUnit" /> se establece en <see cref="F:System.Drawing.GraphicsUnit.World" />, que no es una unidad física.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Tipos de sistemas de coordenadas</related>
      </Docs>
    </Member>
    <Member MemberName="PixelOffsetMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.PixelOffsetMode PixelOffsetMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.PixelOffsetMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PixelOffsetMode As PixelOffsetMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PixelOffsetMode PixelOffsetMode { System::Drawing::Drawing2D::PixelOffsetMode get(); void set(System::Drawing::Drawing2D::PixelOffsetMode value); };" />
      <MemberSignature Language="F#" Value="member this.PixelOffsetMode : System.Drawing.Drawing2D.PixelOffsetMode with get, set" Usage="System.Drawing.Graphics.PixelOffsetMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PixelOffsetMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica cómo se desplazan los píxeles durante la representación de <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Esta propiedad especifica un miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.PixelOffsetMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta propiedad para especificar cualquier mayor calidad, la representación más lenta o calidad inferior, un procesamiento más rápido del contenido de este <xref:System.Drawing.Graphics> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReleaseHdc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera un identificador de contexto de dispositivo obtenido mediante una llamada anterior al método <see cref="M:System.Drawing.Graphics.GetHdc" /> de este <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseHdc() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseHdc();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHdc : unit -&gt; unit&#xA;override this.ReleaseHdc : unit -&gt; unit" Usage="graphics.ReleaseHdc " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Drawing.IDeviceContext.ReleaseHdc</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera un identificador de contexto de dispositivo obtenido mediante una llamada anterior al método <see cref="M:System.Drawing.Graphics.GetHdc" /> de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics.GetHdc%2A> y <xref:System.Drawing.Graphics.ReleaseHdc%2A> son dos métodos que permiten obtener y liberar el identificador de un dispositivo de Windows. Siempre debe seguir una llamada a <xref:System.Drawing.Graphics.GetHdc%2A> con una llamada a <xref:System.Drawing.Graphics.ReleaseHdc%2A> cuando haya terminado con el identificador de Windows.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración relacionada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="T:System.Drawing.IDeviceContext" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdc">
      <MemberSignature Language="C#" Value="public void ReleaseHdc (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdc(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdc(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdc (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdc(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdc : nativeint -&gt; unit" Usage="graphics.ReleaseHdc hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador de un contexto de dispositivo obtenido mediante una llamada anterior al método <see cref="M:System.Drawing.Graphics.GetHdc" /> de este <see cref="T:System.Drawing.Graphics" />.</param>
        <summary>Libera un identificador de contexto de dispositivo obtenido mediante una llamada anterior al método <see cref="M:System.Drawing.Graphics.GetHdc" /> de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El contexto de dispositivo es una estructura de Windows basada en [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] que define un conjunto de objetos gráficos y sus atributos asociados, así como los modos gráficos que afectan al resultado.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.GetHdc%2A> y <xref:System.Drawing.Graphics.ReleaseHdc%2A> métodos deben aparecer en parejas. Durante el ámbito de un <xref:System.Drawing.Graphics.GetHdc%2A> y <xref:System.Drawing.Graphics.ReleaseHdc%2A> par de métodos, normalmente realiza llamadas sólo a [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] funciones. Llamadas de ese ámbito realizadas a [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] métodos de la <xref:System.Drawing.Graphics> que generó el `hdc` producirá un error en el parámetro con un `ObjectBusy` error. Además, [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] pasa por alto los cambios de estado realizados en el <xref:System.Drawing.Graphics> de la `hdc` parámetro en operaciones posteriores.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. En el ejemplo se muestra una llamada a un Windows [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] función para realizar la misma tarea que un [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics> método. El código realiza las siguientes acciones:  
  
-   Define la interoperabilidad <xref:System.Runtime.InteropServices.DllImportAttribute> atributo para el archivo DLL de Windows gdi32.dll. Este archivo DLL contiene deseado [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] función y se define la <xref:System.Drawing.Rectangle> función en ese archivo DLL como externa.  
  
-   Crea una pluma de color rojo.  
  
-   Con el lápiz, dibuja un rectángulo en la pantalla mediante el [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] <xref:System.Drawing.Graphics.DrawRectangle%2A> método.  
  
-   Define una variable de tipo puntero interno `hdc` y establece su valor en el identificador del contexto de dispositivo del formulario.  
  
-   Dibuja un rectángulo en la pantalla mediante el [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Rectangle> función.  
  
-   Libera el contexto de dispositivo representado por la `hdc` parámetro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#145)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#145)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#145](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#145)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración relacionada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHdcInternal">
      <MemberSignature Language="C#" Value="public void ReleaseHdcInternal (IntPtr hdc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseHdcInternal(native int hdc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ReleaseHdcInternal(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseHdcInternal (hdc As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseHdcInternal(IntPtr hdc);" />
      <MemberSignature Language="F#" Value="member this.ReleaseHdcInternal : nativeint -&gt; unit" Usage="graphics.ReleaseHdcInternal hdc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hdc" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hdc">Identificador de un contexto de dispositivo.</param>
        <summary>Libera un identificador de un contexto de dispositivo.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración relacionada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="RenderingOrigin">
      <MemberSignature Language="C#" Value="public System.Drawing.Point RenderingOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point RenderingOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.RenderingOrigin" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderingOrigin As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point RenderingOrigin { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingOrigin : System.Drawing.Point with get, set" Usage="System.Drawing.Graphics.RenderingOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el origen de representación de este <see cref="T:System.Drawing.Graphics" /> para la interpolación y los pinceles de trama.</summary>
        <value>Una estructura <see cref="T:System.Drawing.Point" /> que representa el origen de interpolación de 8 bits por píxel y la interpolación de 16 bits por píxel y que también se usa para establecer el origen de los pinceles de trama.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetClip">
      <MemberSignature Language="C#" Value="public void ResetClip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetClip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetClip" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetClip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetClip();" />
      <MemberSignature Language="F#" Value="member this.ResetClip : unit -&gt; unit" Usage="graphics.ResetClip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en una región infinita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando la región de recorte de un <xref:System.Drawing.Graphics> es infinito, los elementos que este <xref:System.Drawing.Graphics> dibuja no se recorta.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un rectángulo con la esquina superior izquierda en (0, 0) y establece la región de recorte en este rectángulo.  
  
-   Crea un segundo rectángulo con la esquina superior izquierda en (100, 100) y establece la región de recorte en la intersección de este rectángulo y la región de recorte actual (el primer rectángulo).  
  
-   Rellena un rectángulo grande que incluye dos rectángulos anteriores con un pincel azul sólido.  
  
-   Restablece la región de recorte en infinito.  
  
-   Dibuja rectángulos en torno a las dos regiones de recorte; utiliza una pluma de color negro para el primer rectángulo de recorte y un color rojo para la segunda región de recorte.  
  
 El resultado es que sólo la intersección de los dos rectángulos se rellena con el azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#146)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#146)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#146](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#146)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetTransform">
      <MemberSignature Language="C#" Value="public void ResetTransform ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetTransform() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ResetTransform" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetTransform ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetTransform();" />
      <MemberSignature Language="F#" Value="member this.ResetTransform : unit -&gt; unit" Usage="graphics.ResetTransform " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece la matriz de transformación universal de este <see cref="T:System.Drawing.Graphics" /> en la matriz de identidades.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz de identidad representa una transformación sin ajuste de escala, rotación o traducción. Restablecer la transformación universal de este <xref:System.Drawing.Graphics> a la matriz de identidad, significa que su transformación universal no cambia la geometría de los elementos transformados.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Convierte la transformación universal del formulario de Windows en un vector (100, 0).  
  
-   Guarda el estado de los gráficos del formulario.  
  
-   Restablece la transformación universal del formulario en una identidad y rellena un rectángulo con un pincel de color rojo sólido.  
  
-   Restaura el estado de gráfico convertido y rellena un rectángulo con un pincel azul sólido.  
  
 El resultado es un rectángulo relleno de rojo sin traducir y un rectángulo relleno de azul convertido.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#147)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#147)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#147](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#147)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restore">
      <MemberSignature Language="C#" Value="public void Restore (System.Drawing.Drawing2D.GraphicsState gstate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Restore(class System.Drawing.Drawing2D.GraphicsState gstate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Restore(System.Drawing.Drawing2D.GraphicsState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Restore (gstate As GraphicsState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Restore(System::Drawing::Drawing2D::GraphicsState ^ gstate);" />
      <MemberSignature Language="F#" Value="member this.Restore : System.Drawing.Drawing2D.GraphicsState -&gt; unit" Usage="graphics.Restore gstate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gstate" Type="System.Drawing.Drawing2D.GraphicsState" />
      </Parameters>
      <Docs>
        <param name="gstate"><see cref="T:System.Drawing.Drawing2D.GraphicsState" /> que representa el estado al que se va a restaurar este <see cref="T:System.Drawing.Graphics" />.</param>
        <summary>Restaura el estado de este <see cref="T:System.Drawing.Graphics" /> en el estado representado por un <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a la <xref:System.Drawing.Graphics.Save%2A> método de un <xref:System.Drawing.Graphics>, un bloque de información que contiene el estado de la <xref:System.Drawing.Graphics> se coloca en una pila. El <xref:System.Drawing.Graphics.Save%2A> método devuelve un <xref:System.Drawing.Drawing2D.GraphicsState> que identifica ese bloque de información. Cuando se pasa a la que identifica <xref:System.Drawing.Drawing2D.GraphicsState> a la <xref:System.Drawing.Graphics.Restore%2A> el bloque de información de método, se quita de la pila y se usa para restaurar la <xref:System.Drawing.Graphics> al estado que tenía en el momento de la <xref:System.Drawing.Graphics.Save%2A> llamada al método. Tenga en cuenta que el <xref:System.Drawing.Drawing2D.GraphicsState> devuelto por una llamada determinada al <xref:System.Drawing.Graphics.Save%2A> método se puede pasar una sola vez a la `Restore` método.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.Save%2A> método se puede anidar; es decir, puede llamar a la <xref:System.Drawing.Graphics.Save%2A> método varias veces antes de llamar a la <xref:System.Drawing.Graphics.Restore%2A> método. Cada vez que se llama el <xref:System.Drawing.Graphics.Save%2A> método, se coloca un bloque de información en la pila y recibe un <xref:System.Drawing.Drawing2D.GraphicsState> para el bloque de información. Cuando se pasa uno de esos objetos a la <xref:System.Drawing.Graphics.Restore%2A> método, el <xref:System.Drawing.Graphics> se devuelve al estado que tenía en el momento de la <xref:System.Drawing.Graphics.Save%2A> llamada al método que devolvió ese determinado <xref:System.Drawing.Drawing2D.GraphicsState>. El bloque de información colocado en la pila mediante <xref:System.Drawing.Graphics.Save%2A> llamada al método se quita de la pila y todos los bloques colocan en la pila después de que <xref:System.Drawing.Graphics.Save%2A> también se quitan la llamada al método.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.BeginContainer%2A> bloques de información de contexto de método en la misma pila de llamadas a la <xref:System.Drawing.Graphics.Save%2A> método. Al igual que un <xref:System.Drawing.Graphics.Restore%2A> llamada se empareja con un <xref:System.Drawing.Graphics.Save%2A> llamar, un <xref:System.Drawing.Graphics.EndContainer%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.Restore%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.Save%2A> método se quitan de la pila. Del mismo modo, cuando se llama a la <xref:System.Drawing.Graphics.EndContainer%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.BeginContainer%2A> método se quitan de la pila.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Convierte la transformación universal del formulario de Windows en un vector (100, 0).  
  
-   Guarda el estado de los gráficos del formulario.  
  
-   Restablece la transformación universal del formulario en una identidad y rellena un rectángulo con un pincel de color rojo sólido.  
  
-   Restaura el estado de gráficos traducido y un segundo rectángulo se rellena con un pincel azul sólido.  
  
 El resultado es un rectángulo relleno de rojo sin traducir y un rectángulo relleno de azul convertido.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#148)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#148)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#148](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#148)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RotateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica la rotación especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single -&gt; unit" Usage="graphics.RotateTransform angle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="angle">Ángulo de rotación en grados.</param>
        <summary>Aplica la rotación especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La operación de rotación consiste en multiplicar la matriz de transformación por una matriz cuyos elementos se derivan los `angle` parámetro. Este método aplica el giro, anteponiéndola a la matriz de transformación.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Convierte la matriz de transformación universal del formulario de Windows en el vector (100, 0).  
  
-   Gira la transformación universal en un ángulo de 30 grados, anteponiendo la matriz de rotación a la matriz de transformación del mundo.  
  
-   Dibuja una elipse trasladada girada con una pluma de color azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#149)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#149)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#149](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#149)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateTransform">
      <MemberSignature Language="C#" Value="public void RotateTransform (float angle, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RotateTransform(float32 angle, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.RotateTransform(System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RotateTransform (angle As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RotateTransform(float angle, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.RotateTransform : single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.RotateTransform (angle, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="angle" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="angle">Ángulo de rotación en grados.</param>
        <param name="order">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> que especifica si la rotación se agrega o antepone a la matriz de transformación.</param>
        <summary>Aplica la rotación especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" /> en el orden que se establece.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La operación de rotación consiste en multiplicar la matriz de transformación por una matriz cuyos elementos se derivan los `angle` parámetro. Este método antepone o anexa la matriz de transformación de la <xref:System.Drawing.Graphics> por la matriz de rotación según la `order` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Convierte la matriz de transformación universal del formulario de Windows en el vector (100, 0).  
  
-   Rota la transformación universal en un ángulo de 30 grados, agregando la matriz de rotación a la matriz de transformación del mundo con <xref:System.Drawing.Drawing2D.MatrixOrder.Append>.  
  
-   Dibuja una elipse rotada con una pluma de color azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#150)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#150)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#150](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.GraphicsState Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Drawing2D.GraphicsState Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.Save" />
      <MemberSignature Language="VB.NET" Value="Public Function Save () As GraphicsState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Drawing2D::GraphicsState ^ Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; System.Drawing.Drawing2D.GraphicsState" Usage="graphics.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.GraphicsState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Guarda el estado actual de este <see cref="T:System.Drawing.Graphics" /> e identifica el estado guardado con un <see cref="T:System.Drawing.Drawing2D.GraphicsState" />.</summary>
        <returns>Este método devuelve un <see cref="T:System.Drawing.Drawing2D.GraphicsState" /> que representa el estado guardado de este <see cref="T:System.Drawing.Graphics" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a la <xref:System.Drawing.Graphics.Save%2A> método de un <xref:System.Drawing.Graphics>, un bloque de información que contiene el estado de la <xref:System.Drawing.Graphics> se coloca en una pila. El <xref:System.Drawing.Graphics.Save%2A> método devuelve un <xref:System.Drawing.Drawing2D.GraphicsState> que identifica ese bloque de información. Cuando se pasa a la que identifica <xref:System.Drawing.Drawing2D.GraphicsState> a la <xref:System.Drawing.Graphics.Restore%2A> el bloque de información de método, se quita de la pila y se usa para restaurar la <xref:System.Drawing.Graphics> al estado que tenía en el momento de la <xref:System.Drawing.Graphics.Save%2A> llamada al método. Tenga en cuenta que el <xref:System.Drawing.Drawing2D.GraphicsState> devuelto por una llamada determinada al <xref:System.Drawing.Graphics.Save%2A> método se puede pasar una sola vez a la <xref:System.Drawing.Graphics.Restore%2A> método.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.Save%2A> método se puede anidar; es decir, puede llamar a la <xref:System.Drawing.Graphics.Save%2A> método varias veces antes de llamar a la <xref:System.Drawing.Graphics.Restore%2A> método. Cada vez que se llama el <xref:System.Drawing.Graphics.Save%2A> método, se coloca un bloque de información en la pila y recibe un <xref:System.Drawing.Drawing2D.GraphicsState> para el bloque de información. Cuando se pasa uno de esos objetos a la <xref:System.Drawing.Graphics.Restore%2A> método, el <xref:System.Drawing.Graphics> se devuelve al estado que tenía en el momento de la <xref:System.Drawing.Graphics.Save%2A> llamada al método que devolvió ese determinado <xref:System.Drawing.Drawing2D.GraphicsState>. El bloque de información colocado en la pila mediante <xref:System.Drawing.Graphics.Save%2A> llamada al método se quita de la pila y todos los bloques colocan en la pila después de que <xref:System.Drawing.Graphics.Save%2A> también se quitan la llamada al método.  
  
 Las llamadas a la <xref:System.Drawing.Graphics.BeginContainer%2A> bloques de información de contexto de método en la misma pila de llamadas a la <xref:System.Drawing.Graphics.Save%2A> método. Al igual que un <xref:System.Drawing.Graphics.Restore%2A> llamada se empareja con un <xref:System.Drawing.Graphics.Save%2A> llamar, un <xref:System.Drawing.Graphics.EndContainer%2A> llamada al método se empareja con un <xref:System.Drawing.Graphics.BeginContainer%2A> llamada al método.  
  
 Cuando se llama a la <xref:System.Drawing.Graphics.Restore%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.Save%2A> método se quitan de la pila. Del mismo modo, cuando se llama a la <xref:System.Drawing.Graphics.EndContainer%2A> método, todos los bloques de información colocados en la pila (por el <xref:System.Drawing.Graphics.Save%2A> método o mediante el <xref:System.Drawing.Graphics.BeginContainer%2A> método) después de la llamada correspondiente a la <xref:System.Drawing.Graphics.BeginContainer%2A> método se quitan de la pila.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Convierte la transformación universal del formulario de Windows en un vector (100, 0).  
  
-   Guarda el estado de los gráficos del formulario.  
  
-   Restablece la transformación universal del formulario en una identidad (matriz de identidad de 2 x 2 más una traslación de vector cero) y rellena un rectángulo con un pincel de color rojo sólido.  
  
-   Restaura el estado de gráfico convertido y rellena un rectángulo con un pincel azul sólido.  
  
 El resultado es un rectángulo relleno de rojo sin traducir a la izquierda y un rectángulo relleno de azul trasladado a la derecha del formulario.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#151)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#151)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#151](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#151)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ScaleTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica la operación de cambio de escala especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" />, anteponiéndola a esta última.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single -&gt; unit" Usage="graphics.ScaleTransform (sx, sy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="sx">Factor de escala en la dirección x.</param>
        <param name="sy">Factor de escala en la dirección y.</param>
        <summary>Aplica la operación de cambio de escala especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" />, anteponiéndola a esta última.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La operación de escalado consiste en multiplicar la matriz de transformación por una matriz diagonal cuyos elementos son (`sx`, `sy`, 1). Este método antepone la matriz de transformación de la <xref:System.Drawing.Graphics> por la matriz de escala.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   La matriz de transformación universal del formulario de Windows gira 30 grados.  
  
-   Escala esa matriz por un factor de 3 en la dirección del eje x y un factor de 1 en la dirección y anteponiendo la transformación de escala.  
  
-   Dibuja un rectángulo de escalado y girado, con una pluma de color azul.  
  
 El resultado sigue siendo un rectángulo.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#152)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#152)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#152](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#152)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleTransform">
      <MemberSignature Language="C#" Value="public void ScaleTransform (float sx, float sy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleTransform(float32 sx, float32 sy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.ScaleTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleTransform (sx As Single, sy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleTransform(float sx, float sy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.ScaleTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.ScaleTransform (sx, sy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sx" Type="System.Single" />
        <Parameter Name="sy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="sx">Factor de escala en la dirección x.</param>
        <param name="sy">Factor de escala en la dirección y.</param>
        <param name="order">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> que especifica si la transformación de escala se agrega o antepone a la matriz de transformación.</param>
        <summary>Aplica la operación de cambio de escala especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" /> en el orden que se establece.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La operación de escalado consiste en multiplicar la matriz de transformación por una matriz diagonal cuyos elementos son (`sx`, `sy`, 1). Este método antepone o anexa la matriz de transformación de la <xref:System.Drawing.Graphics> por la matriz de escala según el `order` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   La matriz de transformación universal del formulario de Windows gira 30 grados.  
  
-   Escala esa matriz mediante un factor de 3 en la dirección del eje x y un factor de 1 en la dirección y anexando la transformación de escala con el <xref:System.Drawing.Drawing2D.MatrixOrder.Append> miembro.  
  
-   Dibuja un rectángulo girado, el escalado con una pluma de color azul.  
  
 El resultado es un paralelogramo.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#153)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#153)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#153](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#153)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en la propiedad <see langword="Clip" /> del <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (path As GraphicsPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath -&gt; unit" Usage="graphics.SetClip path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
      </Parameters>
      <Docs>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que representa la nueva región de recorte.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en el <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ruta de acceso de gráficos que representa el `path` parámetro no está cerrado, se agrega un segmento adicional desde el último punto hasta el primer punto para cerrar la ruta de acceso.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un trazado de gráficos y agrega una elipse al trazado.  
  
-   Establece la región de recorte en el trazado elíptico.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es una elipse con rellena y negra.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#154)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#154)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#154](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#154)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (g As Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics -&gt; unit" Usage="graphics.SetClip g" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="g"><see cref="T:System.Drawing.Graphics" /> del que se va a tomar la nueva región de recorte.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en la propiedad <see langword="Clip" /> del <see cref="T:System.Drawing.Graphics" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos, así como `thisForm`, el <xref:System.Windows.Forms.Form> para el ejemplo. El código realiza las siguientes acciones:  
  
-   Crea un archivo temporal <xref:System.Drawing.Graphics> desde el `thisForm` <xref:System.Windows.Forms.Form> del ejemplo.  
  
-   Establece la región de recorte de temporal <xref:System.Drawing.Graphics> a un cuadrado pequeño.  
  
-   Actualiza la región de recorte del objeto gráfico del formulario para que temporal <xref:System.Drawing.Graphics>.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un pequeño cuadrado relleno negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#156)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#156)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#156](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#156)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que representa la nueva región de recorte.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en el rectángulo especificado mediante una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pequeño rectángulo para la región de recorte.  
  
-   Establece la región de recorte en el rectángulo.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un pequeño rectángulo relleno negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#158)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#158)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#158](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#158)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetClip (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF -&gt; unit" Usage="graphics.SetClip rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que representa la nueva región de recorte.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en el rectángulo especificado mediante una estructura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pequeño rectángulo para la región de recorte.  
  
-   Establece la región de recorte en el rectángulo.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un pequeño rectángulo relleno negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#160)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#160)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#160](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#160)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Drawing2D.GraphicsPath path, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Drawing2D.GraphicsPath path, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Drawing2D.GraphicsPath,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Drawing2D::GraphicsPath ^ path, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Drawing2D.GraphicsPath * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (path, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="path"><see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> que se va a combinar.</param>
        <param name="combineMode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica la operación de combinación que se usará.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en el resultado de la operación especificada que combina la región de recorte actual y el <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ruta de acceso de gráficos que representa el `path` parámetro no está cerrado, se agrega un segmento adicional desde el último punto hasta el primer punto para cerrar la ruta de acceso.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un trazado de gráficos y agrega una elipse al trazado.  
  
-   Establece la región de recorte en el trazado elíptico con el <xref:System.Drawing.Drawing2D.CombineMode.Replace> miembro.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es una elipse con rellena y negra.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#155)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#155)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#155](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Graphics g, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Graphics g, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Graphics,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Graphics ^ g, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Graphics * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (g, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="g"><see cref="T:System.Drawing.Graphics" /> que especifica la región de recorte que se va a combinar.</param>
        <param name="combineMode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica la operación de combinación que se usará.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en el resultado de la operación de combinación especificada de la región de recorte actual y la propiedad <see cref="P:System.Drawing.Graphics.Clip" /> del <see cref="T:System.Drawing.Graphics" /> indicado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos, así como `thisForm`, el <xref:System.Windows.Forms.Form> para el ejemplo. El código realiza las siguientes acciones:  
  
-   Crea un archivo temporal <xref:System.Drawing.Graphics> desde el `thisForm` <xref:System.Windows.Forms.Form> del ejemplo.  
  
-   Establece la región de recorte de temporal <xref:System.Drawing.Graphics> a un cuadrado pequeño.  
  
-   Actualiza la región de recorte del objeto gráfico del formulario para que el nuevo <xref:System.Drawing.Graphics> con el <xref:System.Drawing.Drawing2D.CombineMode.Replace> miembro.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un pequeño cuadrado relleno negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#157)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#157)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#157](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#157)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Rectangle rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.Rectangle rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Rectangle,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Rectangle rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Rectangle * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.Rectangle" /> que se va a combinar.</param>
        <param name="combineMode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica la operación de combinación que se usará.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en el resultado de la operación que se indica que combina la región de recorte actual y el rectángulo especificado mediante una estructura <see cref="T:System.Drawing.Rectangle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pequeño rectángulo para la región de recorte.  
  
-   Establece la región de recorte en el rectángulo con el <xref:System.Drawing.Drawing2D.CombineMode.Replace> miembro.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un pequeño rectángulo relleno negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#159)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#159)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#159](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#159)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.RectangleF rect, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(valuetype System.Drawing.RectangleF rect, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.RectangleF,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::RectangleF rect, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.RectangleF * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (rect, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="rect">Estructura <see cref="T:System.Drawing.RectangleF" /> que se va a combinar.</param>
        <param name="combineMode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica la operación de combinación que se usará.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en el resultado de la operación que se indica que combina la región de recorte actual y el rectángulo especificado mediante una estructura <see cref="T:System.Drawing.RectangleF" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pequeño rectángulo para la región de recorte.  
  
-   Establece la región de recorte en el rectángulo con el <xref:System.Drawing.Drawing2D.CombineMode.Replace> miembro.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un pequeño rectángulo relleno negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#161)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#161)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#161](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetClip">
      <MemberSignature Language="C#" Value="public void SetClip (System.Drawing.Region region, System.Drawing.Drawing2D.CombineMode combineMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetClip(class System.Drawing.Region region, valuetype System.Drawing.Drawing2D.CombineMode combineMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.SetClip(System.Drawing.Region,System.Drawing.Drawing2D.CombineMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetClip(System::Drawing::Region ^ region, System::Drawing::Drawing2D::CombineMode combineMode);" />
      <MemberSignature Language="F#" Value="member this.SetClip : System.Drawing.Region * System.Drawing.Drawing2D.CombineMode -&gt; unit" Usage="graphics.SetClip (region, combineMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="combineMode" Type="System.Drawing.Drawing2D.CombineMode" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" /> que se va a combinar.</param>
        <param name="combineMode">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CombineMode" /> que especifica la operación de combinación que se usará.</param>
        <summary>Establece la región de recorte de este <see cref="T:System.Drawing.Graphics" /> en el resultado de la operación especificada que combina la región de recorte actual y el <see cref="T:System.Drawing.Region" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un pequeño rectángulo para la región de recorte.  
  
-   Establece la región de recorte en el rectángulo con el <xref:System.Drawing.Drawing2D.CombineMode.Replace> miembro.  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un pequeño rectángulo relleno negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#162)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#162)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#162](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#162)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SmoothingMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.SmoothingMode SmoothingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.SmoothingMode SmoothingMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.SmoothingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property SmoothingMode As SmoothingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::SmoothingMode SmoothingMode { System::Drawing::Drawing2D::SmoothingMode get(); void set(System::Drawing::Drawing2D::SmoothingMode value); };" />
      <MemberSignature Language="F#" Value="member this.SmoothingMode : System.Drawing.Drawing2D.SmoothingMode with get, set" Usage="System.Drawing.Graphics.SmoothingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.SmoothingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la calidad de representación de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Drawing.Drawing2D.SmoothingMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de suavizado especifica si las líneas, curvas y los bordes de las áreas rellenas utilizan suavizado (también denominado suavizado de contorno). Una excepción es que los pinceles de degradado de trazado no obedecen el modo de suavizado. Las áreas rellenadas con un <xref:System.Drawing.Drawing2D.PathGradientBrush> se representan del mismo modo (alias) sin tener en cuenta el <xref:System.Drawing.Graphics.SmoothingMode%2A> propiedad.  
  
   
  
## Examples  
 El método siguiente muestra los efectos de la configuración de la <xref:System.Drawing.Pen.DashCap%2A>, <xref:System.Drawing.Pen.DashPattern%2A>, y <xref:System.Drawing.Graphics.SmoothingMode%2A> propiedades. El resultado del ejemplo se muestra en la siguiente ilustración.  
  
 ![Líneas con y sin suavizado aplicado. ] (~/add/media/gdi-smoothingmode.png "Líneas con y sin suavizado aplicado.")  
  
 En este ejemplo está diseñado para usarse con Windows Forms. Pegue el código en un formulario y llame a la `ShowPensAndSmoothingMode` método cuando el control del formulario <xref:System.Windows.Forms.Control.Paint> evento pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.PensExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PensExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.PensExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PensExample/CS/form1.cs#3)]
 [!code-vb[System.Drawing.PensExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PensExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextContrast">
      <MemberSignature Language="C#" Value="public int TextContrast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextContrast" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextContrast" />
      <MemberSignature Language="VB.NET" Value="Public Property TextContrast As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TextContrast { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TextContrast : int with get, set" Usage="System.Drawing.Graphics.TextContrast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de corrección de gamma para la representación de texto.</summary>
        <value>El valor de corrección gamma usado para representar texto con suavizado de contorno y ClearType.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de corrección gamma debe estar entre 0 y 12. El valor predeterminado es 4.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Drawing.Graphics.TextRenderingHint%2A> y <xref:System.Drawing.Graphics.TextContrast%2A> propiedades.  
  
 En este ejemplo está diseñado para usarse con Windows Forms. Pegue el código en un formulario y llame a la `ChangeTextRenderingHintAndTextContrast` método cuando el control del formulario <xref:System.Windows.Forms.Control.Paint> evento pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextRenderingHint">
      <MemberSignature Language="C#" Value="public System.Drawing.Text.TextRenderingHint TextRenderingHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Text.TextRenderingHint TextRenderingHint" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.TextRenderingHint" />
      <MemberSignature Language="VB.NET" Value="Public Property TextRenderingHint As TextRenderingHint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Text::TextRenderingHint TextRenderingHint { System::Drawing::Text::TextRenderingHint get(); void set(System::Drawing::Text::TextRenderingHint value); };" />
      <MemberSignature Language="F#" Value="member this.TextRenderingHint : System.Drawing.Text.TextRenderingHint with get, set" Usage="System.Drawing.Graphics.TextRenderingHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Text.TextRenderingHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo de representación para el texto asociado a este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Drawing.Text.TextRenderingHint" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La sugerencia de representación de texto especifica si el texto se representa con suavizado de contorno.  
  
> [!NOTE]
>  No se debe usar un <xref:System.Drawing.Graphics.CompositingMode%2A> el valor de propiedad <xref:System.Drawing.Drawing2D.CompositingMode.SourceCopy> cuando el <xref:System.Drawing.Graphics.TextRenderingHint%2A> propiedad está establecida en <xref:System.Drawing.Text.TextRenderingHint.ClearTypeGridFit>. Podría producirse una excepción o la imagen no se presenten correctamente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Drawing.Graphics.TextRenderingHint%2A> y <xref:System.Drawing.Graphics.TextContrast%2A> propiedades.  
  
 En este ejemplo está diseñado para usarse con Windows Forms. Pegue el código en un formulario y llame a la `ChangeTextRenderingHintAndTextContrast` método cuando el control del formulario <xref:System.Windows.Forms.Control.Paint> evento pasando `e` como <xref:System.Windows.Forms.PaintEventArgs>.  
  
 [!code-cpp[System.Drawing.GraphicsProperties#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.GraphicsProperties#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/CS/form1.cs#5)]
 [!code-vb[System.Drawing.GraphicsProperties#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.GraphicsProperties/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.Matrix Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.Matrix Transform" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Matrix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::Matrix ^ Transform { System::Drawing::Drawing2D::Matrix ^ get(); void set(System::Drawing::Drawing2D::Matrix ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix with get, set" Usage="System.Drawing.Graphics.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.Matrix</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una copia de la transformación universal geométrica para <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Una copia de <see cref="T:System.Drawing.Drawing2D.Matrix" /> que representa la transformación universal geométrica para <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GDI + utiliza tres espacios de coordenadas: universales, página y dispositivo. Coordenadas universales son las coordenadas que se utilizan para modelar un entorno gráfico determinado y las coordenadas que se pasan a los métodos de .NET Framework. Coordenadas de página hacen referencia al sistema de coordenadas utilizado por una superficie de dibujo, como un formulario o un control. Coordenadas de dispositivo son las utilizadas por el dispositivo físico que se va a dibujar, como una pantalla o una impresora. El <xref:System.Drawing.Graphics.Transform%2A> propiedad representa la transformación universal, que asigna las coordenadas universales en coordenadas de página.  
  
 Dado que la matriz devuelta y por la <xref:System.Drawing.Graphics.Transform%2A> propiedad es una copia de la transformación geométrica, debe eliminar la matriz cuando ya no lo necesita.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c61ff50a-eb1d-4e6c-83cd-f7e9764cfa9f">Tipos de sistemas de coordenadas</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformPoints">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Transforma una matriz de puntos de un espacio de coordenadas a otro usando las transformaciones universal y de página actuales de este <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.Point[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.Point[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::Point&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Point[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> que especifica el espacio de coordenadas de destino.</param>
        <param name="srcSpace">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> que especifica el espacio de coordenadas de origen.</param>
        <param name="pts">Matriz de estructuras <see cref="T:System.Drawing.Point" /> que representa los puntos que se van a transformar.</param>
        <summary>Transforma una matriz de puntos de un espacio de coordenadas a otro usando las transformaciones universal y de página actuales de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea dos puntos y dibuja una línea azul entre ellos.  
  
-   Establece la transformación del mundo para traducir en cantidades de 40 en la dirección del eje x y 30 en la dirección del eje y.  
  
-   Transforma los puntos de coordenadas universales (<xref:System.Drawing.Drawing2D.CoordinateSpace.World>) a las coordenadas de página (<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>).  
  
-   Restablece la transformación universal en la identidad.  
  
-   Dibuja una línea roja entre los puntos transformados.  
  
 El resultado es una línea azul y una línea roja convertida debajo de él.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#163)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#163)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#163](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#163)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformPoints">
      <MemberSignature Language="C#" Value="public void TransformPoints (System.Drawing.Drawing2D.CoordinateSpace destSpace, System.Drawing.Drawing2D.CoordinateSpace srcSpace, System.Drawing.PointF[] pts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransformPoints(valuetype System.Drawing.Drawing2D.CoordinateSpace destSpace, valuetype System.Drawing.Drawing2D.CoordinateSpace srcSpace, valuetype System.Drawing.PointF[] pts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TransformPoints(System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.Drawing2D.CoordinateSpace,System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransformPoints (destSpace As CoordinateSpace, srcSpace As CoordinateSpace, pts As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransformPoints(System::Drawing::Drawing2D::CoordinateSpace destSpace, System::Drawing::Drawing2D::CoordinateSpace srcSpace, cli::array &lt;System::Drawing::PointF&gt; ^ pts);" />
      <MemberSignature Language="F#" Value="member this.TransformPoints : System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.Drawing2D.CoordinateSpace * System.Drawing.PointF[] -&gt; unit" Usage="graphics.TransformPoints (destSpace, srcSpace, pts)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="srcSpace" Type="System.Drawing.Drawing2D.CoordinateSpace" />
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="destSpace">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> que especifica el espacio de coordenadas de destino.</param>
        <param name="srcSpace">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.CoordinateSpace" /> que especifica el espacio de coordenadas de origen.</param>
        <param name="pts">Matriz de estructuras <see cref="T:System.Drawing.PointF" /> que representa los puntos que se van a transformar.</param>
        <summary>Transforma una matriz de puntos de un espacio de coordenadas a otro usando las transformaciones universal y de página actuales de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea dos puntos y dibuja una línea azul entre ellos.  
  
-   Establece la transformación del mundo para traducir en cantidades de 40 en la dirección del eje x y 30 en la dirección del eje y.  
  
-   Transforma los puntos de coordenadas universales (<xref:System.Drawing.Drawing2D.CoordinateSpace.World>) a las coordenadas de página (<xref:System.Drawing.Drawing2D.CoordinateSpace.Page>).  
  
-   Restablece la transformación universal en la identidad y dibuja una línea roja entre los puntos transformados.  
  
 El resultado es una línea azul y una línea roja convertida debajo de él.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#164)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#164)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#164](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#164)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateClip">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Traslada la región de recorte de este <see cref="T:System.Drawing.Graphics" /> según las magnitudes especificadas en las direcciones horizontal y vertical.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (int dx, int dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(int32 dx, int32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Integer, dy As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(int dx, int dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : int * int -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Int32" />
        <Parameter Name="dy" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dx">Coordenada x de la traslación.</param>
        <param name="dy">Coordenada y de la traslación.</param>
        <summary>Traslada la región de recorte de este <see cref="T:System.Drawing.Graphics" /> según las magnitudes especificadas en las direcciones horizontal y vertical.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un rectángulo para la región de recorte.  
  
-   Establece la región de recorte en el rectángulo.  
  
-   Convierte la región de recorte en un vector (50, 50).  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un rectángulo traducido, pequeño, negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#165)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#165)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#165](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#165)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslateClip">
      <MemberSignature Language="C#" Value="public void TranslateClip (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateClip(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateClip(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateClip (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateClip(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateClip : single * single -&gt; unit" Usage="graphics.TranslateClip (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Coordenada x de la traslación.</param>
        <param name="dy">Coordenada y de la traslación.</param>
        <summary>Traslada la región de recorte de este <see cref="T:System.Drawing.Graphics" /> según las magnitudes especificadas en las direcciones horizontal y vertical.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Crea un rectángulo para la región de recorte.  
  
-   Establece la región de recorte en el rectángulo.  
  
-   Convierte la región de recorte en un vector (50.0F, 50.0F).  
  
-   Rellena un rectángulo grande con un pincel de color negro sólido.  
  
 El resultado es un rectángulo traducido, pequeño, negro.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#166)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#166)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#166](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#166)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TranslateTransform">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cambia el origen del sistema de coordenadas anteponiendo la traslación especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single -&gt; unit" Usage="graphics.TranslateTransform (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Coordenada x de la traslación.</param>
        <param name="dy">Coordenada y de la traslación.</param>
        <summary>Cambia el origen del sistema de coordenadas anteponiendo la traslación especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, el origen es la esquina superior izquierda de la superficie de dibujo.  La operación de traducción consiste en multiplicar la matriz de transformación por una matriz cuya parte de la traducción es el `dx` y `dy` parámetros. Este método aplica la conversión anteponiendo la matriz de traslación a la matriz de transformación.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Gira la matriz de transformación universal del formulario Windows 30.0F grados.  
  
-   Mueve el origen del objeto graphics llamando <xref:System.Drawing.Graphics.TranslateTransform%2A>, anteponiendo la traslación a la matriz de transformación.  
  
-   Dibuja una elipse rotada con una pluma de color azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#167)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#167)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#167](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#167)]  
  
 La siguiente ilustración muestra el resultado de ejecutar el ejemplo de código anterior.  
  
 ![Traducido y transformado elipse](~/add/media/ndp-tranlatetransform.png "traducido y transformado elipse")  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">Sistemas de coordenadas y transformaciones</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">Usar transformaciones en la interfaz GDI+ administrada</related>
      </Docs>
    </Member>
    <Member MemberName="TranslateTransform">
      <MemberSignature Language="C#" Value="public void TranslateTransform (float dx, float dy, System.Drawing.Drawing2D.MatrixOrder order);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TranslateTransform(float32 dx, float32 dy, valuetype System.Drawing.Drawing2D.MatrixOrder order) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Graphics.TranslateTransform(System.Single,System.Single,System.Drawing.Drawing2D.MatrixOrder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TranslateTransform (dx As Single, dy As Single, order As MatrixOrder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TranslateTransform(float dx, float dy, System::Drawing::Drawing2D::MatrixOrder order);" />
      <MemberSignature Language="F#" Value="member this.TranslateTransform : single * single * System.Drawing.Drawing2D.MatrixOrder -&gt; unit" Usage="graphics.TranslateTransform (dx, dy, order)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
        <Parameter Name="order" Type="System.Drawing.Drawing2D.MatrixOrder" />
      </Parameters>
      <Docs>
        <param name="dx">Coordenada x de la traslación.</param>
        <param name="dy">Coordenada y de la traslación.</param>
        <param name="order">Miembro de la enumeración <see cref="T:System.Drawing.Drawing2D.MatrixOrder" /> que especifica si la traslación se agrega o antepone a la matriz de transformación.</param>
        <summary>Cambia el origen del sistema de coordenadas aplicando la traslación especificada a la matriz de transformación de este <see cref="T:System.Drawing.Graphics" /> en el orden que se establece.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La operación de traducción consiste en multiplicar la matriz de transformación por una matriz cuya parte de la traducción es el `dx` y `dy` parámetros. Este método antepone o anexa la matriz de transformación de la <xref:System.Drawing.Graphics> por la matriz de traslación según el `order` parámetro.  
  
   
  
## Examples  
 El siguiente ejemplo de código está diseñado para su uso con Windows Forms y requiere <xref:System.Windows.Forms.PaintEventArgs> `e`, que es un parámetro de la <xref:System.Windows.Forms.Control.Paint> controlador de eventos. El código realiza las siguientes acciones:  
  
-   Gira la matriz de transformación universal del formulario Windows 30.0F grados.  
  
-   Mueve el origen del objeto de gráfico mediante una llamada a <xref:System.Drawing.Graphics.TranslateTransform%2A>, anexa la traslación a la matriz de transformación del mundo.  
  
-   Dibuja una elipse trasladada girada con una pluma de color azul.  
  
 [!code-cpp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CPP/form1.cpp#168)]
 [!code-csharp[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/CS/form1.cs#168)]
 [!code-vb[System.Drawing.ClassicGraphicsExamples3#168](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.ClassicGraphicsExamples3/VB/form1.vb#168)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/9fef7451-bddf-4c68-9350-400d1f1f25a3">Sistemas de coordenadas y transformaciones</related>
        <related type="Article" href="https://msdn.microsoft.com/library/1f8e18d3-d2f5-460e-a8e3-2da891c301de">Usar transformaciones en la interfaz GDI+ administrada</related>
      </Docs>
    </Member>
    <Member MemberName="VisibleClipBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF VisibleClipBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.RectangleF VisibleClipBounds" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Graphics.VisibleClipBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VisibleClipBounds As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::RectangleF VisibleClipBounds { System::Drawing::RectangleF get(); };" />
      <MemberSignature Language="F#" Value="member this.VisibleClipBounds : System.Drawing.RectangleF" Usage="System.Drawing.Graphics.VisibleClipBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el rectángulo delimitador que corresponde a la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</summary>
        <value>Estructura <see cref="T:System.Drawing.RectangleF" /> que representa un rectángulo delimitador para la región de recorte visible de este <see cref="T:System.Drawing.Graphics" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La unidad para el rectángulo resultante se designa mediante el <xref:System.Drawing.Graphics.PageUnit%2A> propiedad. La unidad predeterminada es píxeles. Un <xref:System.Drawing.Graphics> suele asociarse con un control y el origen del rectángulo será relativo al área de cliente de ese control.  
  
 La región de recorte visible es la intersección de la región de recorte de este <xref:System.Drawing.Graphics> y la región de recorte de la ventana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>