<Type Name="RoutingConfiguration" FullName="System.ServiceModel.Routing.RoutingConfiguration">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9779791ffe33949fe94cd64a3fb5fff061f05c37" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52592966" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RoutingConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RoutingConfiguration extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Routing.RoutingConfiguration" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RoutingConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutingConfiguration sealed" />
  <TypeSignature Language="F#" Value="type RoutingConfiguration = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Routing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Define la información de configuración usada por <see cref="T:System.ServiceModel.Routing.RoutingExtension" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.ServiceModel.Routing.RoutingConfiguration" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutingConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Routing.RoutingConfiguration.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutingConfiguration();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.ServiceModel.Routing.RoutingConfiguration" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutingConfiguration (System.ServiceModel.Dispatcher.MessageFilterTable&lt;System.Collections.Generic.IEnumerable&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt; filterTable, bool routeOnHeadersOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Dispatcher.MessageFilterTable`1&lt;class System.Collections.Generic.IEnumerable`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt;&gt; filterTable, bool routeOnHeadersOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Routing.RoutingConfiguration.#ctor(System.ServiceModel.Dispatcher.MessageFilterTable{System.Collections.Generic.IEnumerable{System.ServiceModel.Description.ServiceEndpoint}},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filterTable As MessageFilterTable(Of IEnumerable(Of ServiceEndpoint)), routeOnHeadersOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutingConfiguration(System::ServiceModel::Dispatcher::MessageFilterTable&lt;System::Collections::Generic::IEnumerable&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^&gt; ^ filterTable, bool routeOnHeadersOnly);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Routing.RoutingConfiguration : System.ServiceModel.Dispatcher.MessageFilterTable&lt;seq&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt; * bool -&gt; System.ServiceModel.Routing.RoutingConfiguration" Usage="new System.ServiceModel.Routing.RoutingConfiguration (filterTable, routeOnHeadersOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filterTable" Type="System.ServiceModel.Dispatcher.MessageFilterTable&lt;System.Collections.Generic.IEnumerable&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt;" />
        <Parameter Name="routeOnHeadersOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filterTable">Tabla de filtro de mensajes que se va a usar para esta configuración.</param>
        <param name="routeOnHeadersOnly">
          <see langword="true" /> si el <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" /> solo puede examinar encabezados del mensaje; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</param>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.ServiceModel.Routing.RoutingConfiguration" /> usando la clase <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" /> y el parámetro routeOnHeadersOnly especificados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Routing.RoutingConfiguration.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.Routing.RoutingConfiguration.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor booleano que indica si los mensajes se van a enviar en el orden en el que se enviaron.</summary>
        <value>
          <see langword="true" /> si los mensajes se van a enviar en el orden en que se enviaron; si no, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTable">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.MessageFilterTable&lt;System.Collections.Generic.IEnumerable&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt; FilterTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.MessageFilterTable`1&lt;class System.Collections.Generic.IEnumerable`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt;&gt; FilterTable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Routing.RoutingConfiguration.FilterTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilterTable As MessageFilterTable(Of IEnumerable(Of ServiceEndpoint))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::MessageFilterTable&lt;System::Collections::Generic::IEnumerable&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^&gt; ^ FilterTable { System::ServiceModel::Dispatcher::MessageFilterTable&lt;System::Collections::Generic::IEnumerable&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilterTable : System.ServiceModel.Dispatcher.MessageFilterTable&lt;seq&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt;" Usage="System.ServiceModel.Routing.RoutingConfiguration.FilterTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.MessageFilterTable&lt;System.Collections.Generic.IEnumerable&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la clase <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" /> usada por esta configuración.</summary>
        <value>Tabla de filtros de mensajes.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteOnHeadersOnly">
      <MemberSignature Language="C#" Value="public bool RouteOnHeadersOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteOnHeadersOnly" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteOnHeadersOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteOnHeadersOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RouteOnHeadersOnly : bool with get, set" Usage="System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el filtro puede examinar el cuerpo del mensaje.</summary>
        <value>
          <see langword="true" /> si el filtro sólo puede examinar los encabezados del mensaje; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SoapProcessingEnabled">
      <MemberSignature Language="C#" Value="public bool SoapProcessingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SoapProcessingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property SoapProcessingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SoapProcessingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SoapProcessingEnabled : bool with get, set" Usage="System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se deben procesar los mensajes entre clases <see cref="T:System.ServiceModel.Channels.MessageVersion" /> de SOAP.</summary>
        <value>Es <see langword="true" /> si se debe procesar los mensajes; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El procesamiento SOAP es el proceso donde los mensajes se convierten entre clases <xref:System.ServiceModel.Channels.MessageVersion> de SOAP.  
  
 Establecer este valor en `false` indica que el <xref:System.ServiceModel.Routing.RoutingBehavior> no debe instalar el <xref:System.ServiceModel.Routing.SoapProcessingBehavior> en los puntos de conexión de cliente. Si establece en `false`, debe agregar su propio inspector de mensajes u otro código para controlar algunos aspectos de los mensajes antes de enviarlos. También es posible deshabilitar el procesamiento SOAP en cada punto de conexión. Para obtener más información, vea la clase <xref:System.ServiceModel.Routing.SoapProcessingBehavior>.  
  
 De forma predeterminada, el <xref:System.ServiceModel.Routing.RoutingBehavior> crea y adjunta un nuevo <xref:System.ServiceModel.Routing.SoapProcessingBehavior> con <xref:System.ServiceModel.Routing.SoapProcessingBehavior.ProcessMessages%2A> establecido en `true` para cada punto de conexión de cliente. Si no desea utilizar el <xref:System.ServiceModel.Routing.SoapProcessingBehavior> en un extremo concreto, cree un nuevo <xref:System.ServiceModel.Routing.SoapProcessingBehavior> con este valor establecido en `false` y, a continuación, adjúntelo al extremo en el que desea no realizará el proceso. Si <xref:System.ServiceModel.Routing.RoutingBehavior> observa que un cliente ya tiene un  <xref:System.ServiceModel.Routing.SoapProcessingBehavior>, no intenta adjuntar otro.  
  
 Para deshabilitar la aplicación de <xref:System.ServiceModel.Routing.SoapProcessingBehavior> en cualquier punto de conexión, deshabilite el procesamiento SOAP en el <xref:System.ServiceModel.Routing.RoutingBehavior> y <xref:System.ServiceModel.Routing.RoutingConfiguration>.  
  
 Si <xref:System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled%2A> es `true`, <xref:System.ServiceModel.Routing.SoapProcessingBehavior> se agrega al punto de conexión de cliente <xref:System.ServiceModel.Description.ServiceEndpoint.Behaviors%2A> colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>