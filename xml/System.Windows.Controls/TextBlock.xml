<Type Name="TextBlock" FullName="System.Windows.Controls.TextBlock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="44ae141af3267dadfad710868e190bf288c9ffe7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30620649" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextBlock : System.Windows.FrameworkElement, IServiceProvider, System.Windows.IContentHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextBlock extends System.Windows.FrameworkElement implements class System.IServiceProvider, class System.Windows.IContentHost, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.TextBlock" />
  <TypeSignature Language="VB.NET" Value="Public Class TextBlock&#xA;Inherits FrameworkElement&#xA;Implements IContentHost, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBlock : System::Windows::FrameworkElement, IServiceProvider, System::Windows::IContentHost" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IContentHost</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Inlines")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un control ligero para mostrar pequeñas cantidades de contenido dinámico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Controls.TextBlock> puede contener una cadena en su <xref:System.Windows.Controls.TextBlock.Text%2A> propiedad o <xref:System.Windows.Documents.Inline> de flujo de elementos de contenido, como <xref:System.Windows.Documents.Bold>, <xref:System.Windows.Documents.Hyperlink>, y <xref:System.Windows.Documents.InlineUIContainer>, en su <xref:System.Windows.Controls.TextBlock.Inlines%2A> propiedad.  
  
 <xref:System.Windows.Controls.TextBlock> está diseñado para ser ligeras y está dirigido específicamente a integrar pequeños fragmentos de contenido dinámico en un [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].  <xref:System.Windows.Controls.TextBlock> está optimizado para su presentación de línea y proporciona un buen rendimiento para mostrar hasta unas pocas líneas de contenido.  
  
 <xref:System.Windows.Controls.TextBlock> no está optimizado para escenarios que necesitan para mostrar más de unas pocas líneas de contenido; para estos escenarios, un <xref:System.Windows.Documents.FlowDocument> junto con un control de vista adecuado es una opción mejor que <xref:System.Windows.Controls.TextBlock>, en términos de rendimiento.  Después de <xref:System.Windows.Controls.TextBlock>, <xref:System.Windows.Controls.FlowDocumentScrollViewer> es el siguiente control ligero para mostrar el contenido del flujo y simplemente proporciona un área de contenido desplazable con mínimo [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  <xref:System.Windows.Controls.FlowDocumentPageViewer> se optimiza en modo de "una página a la vez" para el contenido del flujo.  Por último, <xref:System.Windows.Controls.FlowDocumentReader> admite la funcionalidad definida más completa para ver el contenido del flujo, pero es más compleja peso según corresponda.  
  
 Alineación horizontal de texto dentro de un <xref:System.Windows.Controls.TextBlock> se realiza con el <xref:System.Windows.Controls.TextBlock.TextAlignment%2A> propiedad. Alinear el <xref:System.Windows.Controls.TextBlock> en el diseño de la página se realiza con el <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> y <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> propiedades.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el elemento <xref:System.Windows.Controls.TextBlock>.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockSimpleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblocksimplexaml)]  
  
 En la ilustración siguiente, se muestra cómo se representa este ejemplo.  
  
 ![Captura de pantalla: TextBlocks y botones](~/add/media/textblock-simple.png "captura de pantalla: TextBlocks y botones")  
  
 En el ejemplo siguiente se muestra cómo para muestra cómo lograr similar los resultados mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblocksimple)]
 [!code-vb[FlowDocumentSnippets#_TextBlockSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblocksimple)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Label" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBlock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBlock (System.Windows.Documents.Inline inline);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.Inline inline) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.#ctor(System.Windows.Documents.Inline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBlock(System::Windows::Documents::Inline ^ inline);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="inline" Type="System.Windows.Documents.Inline" />
      </Parameters>
      <Docs>
        <param name="inline">Objeto que deriva de la clase abstracta <see cref="T:System.Windows.Documents.Inline" /> y que se va a agregar como contenido inicial.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Controls.TextBlock" />; para ello, agrega un elemento <see cref="T:System.Windows.Documents.Inline" /> específico como contenido inicial de la presentación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de entrada válidos para `inline` incluyen <xref:System.Windows.Documents.AnchoredBlock>, <xref:System.Windows.Documents.InlineUIContainer>, <xref:System.Windows.Documents.LineBreak>, <xref:System.Windows.Documents.Run>, y <xref:System.Windows.Documents.Span>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de este constructor.  En este caso, el <xref:System.Windows.Controls.TextBlock> contiene un texto <xref:System.Windows.Documents.Run>.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockConstructorSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockconstructorsimple)]
 [!code-vb[FlowDocumentSnippets#_TextBlockConstructorSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockconstructorsimple)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inline" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">
          <see cref="T:System.Windows.Size" /> del elemento principal en que se hospeda y que <see cref="T:System.Windows.Controls.TextBlock" /> debe utilizar para organizarse a sí mismo y organizar sus elementos secundarios. Las restricciones de tamaño pueden afectar a este tamaño requerido.</param>
        <summary>Organiza los elementos secundarios y determina el tamaño de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>
          <see cref="T:System.Windows.Size" /> real utilizado para organizar el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Windows.FrameworkElement.ArrangeOverride%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Windows.Media.Brush" /> que se utiliza para rellenar el fondo del área de contenido.</summary>
        <value>Pincel que se usa para rellenar el fondo del área de contenido o <see langword="null" /> para no utilizar ningún pincel de fondo. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier <xref:System.Windows.Controls.TextBlock.Background%2A> en los elementos secundarios invalida esta configuración de nivel superior.  
  
 Para una tabla de muestras que muestran los colores de pincel predefinidos disponibles, vea <xref:System.Windows.Media.Brushes>.  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.BackgroundProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Background%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Background%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.Background" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffset">
      <MemberSignature Language="C#" Value="public double BaselineOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 BaselineOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property BaselineOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double BaselineOffset { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la cantidad que se desplaza cada línea de texto desde la línea base.</summary>
        <value>Cantidad que se desplaza cada línea de texto desde la línea de base, en píxeles independientes del dispositivo. <see cref="F:System.Double.NaN" /> indica que se calcula automáticamente un desplazamiento de línea base óptimo a partir de las características de la fuente actual. El valor predeterminado es <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La línea de base es la línea horizontal imaginaria con la que se alinea la base de cada carácter de una línea de texto.  
  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.BaselineOffset%2A?displayProperty=nameWithType> `="` *doble*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetBaselineOffset%2A> y <xref:System.Windows.Controls.TextBlock.SetBaselineOffset%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BaselineOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BaselineOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.BaselineOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BaselineOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BaselineOffsetProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BreakAfter">
      <MemberSignature Language="C#" Value="public System.Windows.LineBreakCondition BreakAfter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineBreakCondition BreakAfter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BreakAfter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BreakAfter As LineBreakCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineBreakCondition BreakAfter { System::Windows::LineBreakCondition get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineBreakCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una enumeración <see cref="T:System.Windows.LineBreakCondition" /> que indica cómo debe interrumpirse el contenido después del elemento actual.</summary>
        <value>Condiciones para interrumpir el contenido después del elemento actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve siempre <xref:System.Windows.LineBreakCondition.BreakDesired>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.BreakBefore" />
      </Docs>
    </Member>
    <Member MemberName="BreakBefore">
      <MemberSignature Language="C#" Value="public System.Windows.LineBreakCondition BreakBefore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineBreakCondition BreakBefore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BreakBefore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BreakBefore As LineBreakCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineBreakCondition BreakBefore { System::Windows::LineBreakCondition get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineBreakCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una enumeración <see cref="T:System.Windows.LineBreakCondition" /> que indica cómo debe interrumpirse el contenido antes del elemento actual.</summary>
        <value>Condiciones para interrumpir el contenido después del elemento actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve siempre <xref:System.Windows.LineBreakCondition.BreakDesired>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.BreakAfter" />
      </Docs>
    </Member>
    <Member MemberName="ContentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.ContentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Windows.Documents.TextPointer" /> en el final del contenido de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Objeto <see cref="T:System.Windows.Documents.TextPointer" /> en el final del contenido de <see cref="T:System.Windows.Controls.TextBlock" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al final del contenido se considera como la posición de inserción directamente después del último carácter en la <xref:System.Windows.Controls.TextBlock>.  
  
 El <xref:System.Windows.Documents.TextPointer> devuelto por esta propiedad siempre tiene su <xref:System.Windows.Documents.LogicalDirection> establecido en <xref:System.Windows.Documents.LogicalDirection.Forward>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.ContentStart" />
      </Docs>
    </Member>
    <Member MemberName="ContentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.ContentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Windows.Documents.TextPointer" /> en el principio del contenido de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>
          <see cref="T:System.Windows.Documents.TextPointer" /> en el principio del contenido de <see cref="T:System.Windows.Controls.TextBlock" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El principio del contenido se considera como la posición de inserción directamente delante del primer carácter de la <xref:System.Windows.Controls.TextBlock>.  
  
 El <xref:System.Windows.Documents.TextPointer> devuelto por esta propiedad siempre tiene su <xref:System.Windows.Documents.LogicalDirection> establecido en <xref:System.Windows.Documents.LogicalDirection.Backward>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.ContentEnd" />
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la familia de fuentes de nivel superior preferidas para <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Un objeto <see cref="T:System.Windows.Media.FontFamily" /> que especifica la familia de fuentes preferidas o una familia de fuentes preferidas primaria con una o varias familias de fuentes de reserva. El valor predeterminado es la fuente que determina el valor de <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier <xref:System.Windows.Controls.TextBlock.FontFamily%2A> en los elementos secundarios invalida esta configuración de nivel superior.  
  
 Cuando se especifican varias familias, las familias de fuentes de la segunda y posteriores actúan como familias de reserva para su uso en casos donde la familia de fuentes primaria no está disponible o no es aplicable.  
  
 Esta propiedad sólo especifica una preferencia.  Si la familia de fuentes especificada no está disponible, el <xref:System.Windows.Controls.TextBlock> vuelve automáticamente a la fuente determinada por la <xref:System.Windows.SystemFonts.MessageFontFamily%2A> valor.  
  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.FontFamily%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es uno de los valores de formato de cadena como se explica en valores XAML. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetFontFamily%2A> y <xref:System.Windows.Controls.TextBlock.SetFontFamily%2A>. El uso de la propiedad adjunta no es común, porque la mayoría de los elementos que puede incluirse en un <xref:System.Windows.Controls.TextBlock> compatibilidad con un análogo no asociada `FontFamily` propiedad, que el <xref:System.Windows.Controls.TextBlock> utiliza para la representación.  
  
<a name="xamlAttributeUsage_FontFamily"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object FontFamily="fontFamilyName"/>  
- or -  
<object FontFamily="fontFamilyNamesList"/>  
- or -  
<object FontFamily="fontFamilyFolderReference"/>  
- or -  
<object FontFamily="fontFamilyUriReference"/>  
```  
  
<a name="xamlValues_FontFamily"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *fontFamilyName*  
 Cadena que especifica un nombre de familia de fuentes.  Por ejemplo: `"Arial"` o `"Century Gothic"`.  
  
 *fontFamilyNamesList*  
 Cadena que especifica varios nombres de familia de fuentes, separados por punto y coma (se omite cualquier espacio en blanco después de una coma).  La primera familia de fuentes especificada actúa como la familia de fuentes primaria; familias de fuentes subsiguientes actúan como familias de reserva para su uso en casos donde la familia de fuentes primaria no está disponible o no es aplicable.  Por ejemplo, `"Arial, Century Gothic"` especifica Arial como familia de fuentes primaria, con siglo gótica como la familia de fuentes de reserva.  
  
 *fontFamilyFolderReference*  
 Cadena que especifica una carpeta que contiene la fuente, junto con un nombre de familia de fuentes.  La carpeta y el nombre de familia de fuentes se delimitan por un carácter #.  La referencia a la carpeta puede ser absoluta o relativa.  Por ejemplo: `"Custom Fonts\#My Custom Font"`.  
  
 *fontFamilyUriReference*  
 Una cadena que especifica un [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] para la fuente, junto con un nombre de familia de fuentes.  El [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] y nombre de familia de fuentes se delimitan por un carácter #.  Por ejemplo: `"http://MyFontServer/Fonts/#My Custom Font"`.  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.FontFamilyProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontFamily%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontFamily%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.FontFamily" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño de fuente de nivel superior para <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Tamaño de fuente deseado para usarlo en píxeles independientes del dispositivo. El valor predeterminado viene determinado por el valor de <see cref="P:System.Windows.SystemFonts.MessageFontSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier <xref:System.Windows.Controls.TextBlock.FontSize%2A> en los elementos secundarios invalida esta configuración de nivel superior.  
  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.FontSize%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es uno de los valores de formato de cadena como se explica en valores XAML. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetFontSize%2A> y <xref:System.Windows.Controls.TextBlock.SetFontSize%2A>. El uso de la propiedad adjunta no es común, porque la mayoría de los elementos que puede incluirse en un <xref:System.Windows.Controls.TextBlock> compatibilidad con un análogo no asociada `FontSize` propiedad, que el <xref:System.Windows.Controls.TextBlock> utiliza para la representación.  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object FontSize="double"/>  
- or -  
<object FontSize="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *double*  
 <xref:System.Double>  
  
 Representación de cadena de un <xref:System.Double> valor igual o mayor que 0,0 pero menor que <xref:System.Double.PositiveInfinity>. Un valor sin calificar se mide en píxeles independientes del dispositivo. Las cadenas no necesitan incluir explícitamente separadores decimales.  
  
 *qualifiedDouble*  
 A *doble* valor, tal como se ha descrito anteriormente, seguido de uno de estos especificadores de unidades: `px`, `in`, `cm`, `pt`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1 in == 96 px  
  
 `cm` es centímetros; 1cm==(96/2.54) px  
  
 `pt` es puntos; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.FontSizeProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontSize%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontSize%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.FontSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontStretch" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStretch As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStretch FontStretch { System::Windows::FontStretch get(); void set(System::Windows::FontStretch value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece las características de ajuste de fuente de nivel superior para <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Miembro de la clase <see cref="T:System.Windows.FontStretch" /> que especifica las características del ancho de fuente deseado que se va a utilizar. El valor predeterminado es <see cref="P:System.Windows.FontStretches.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier <xref:System.Windows.Controls.TextBlock.FontStretch%2A> en los elementos secundarios invalida esta configuración de nivel superior.  
  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.FontStretch%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es uno de los formatos de cadena de nombres de propiedad de la <xref:System.Windows.FontStretch> clase. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetFontStretch%2A> y <xref:System.Windows.Controls.TextBlock.SetFontStretch%2A>. El uso de la propiedad adjunta no es común, porque la mayoría de los elementos que puede incluirse en un <xref:System.Windows.Controls.TextBlock> compatibilidad con un análogo no asociada `FontStretch` propiedad, que el <xref:System.Windows.Controls.TextBlock> utiliza para la representación.  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.FontStretchProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontStretch%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontStretch%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontStretchProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStretchProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStretchProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.FontStretch" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStyle As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStyle FontStyle { System::Windows::FontStyle get(); void set(System::Windows::FontStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el estilo de fuente de nivel superior para <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Un miembro de la clase <see cref="T:System.Windows.FontStyles" /> que especifica el estilo de fuente deseado. El valor predeterminado viene determinado por el valor de <see cref="P:System.Windows.SystemFonts.MessageFontStyle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier <xref:System.Windows.Controls.TextBlock.FontStyle%2A> en los elementos secundarios invalida esta configuración de nivel superior.  
  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.FontStyle%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es uno de los formatos de cadena de nombres de propiedad de la <xref:System.Windows.FontStyles> clase. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetFontStyle%2A> y <xref:System.Windows.Controls.TextBlock.SetFontStyle%2A>. El uso de la propiedad adjunta no es común, porque la mayoría de los elementos que puede incluirse en un <xref:System.Windows.Controls.TextBlock> compatibilidad con un análogo no asociada `FontStyle` propiedad, que el <xref:System.Windows.Controls.TextBlock> utiliza para la representación.  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.FontStyleProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontStyle%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontStyle%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.FontStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontWeight" />
      <MemberSignature Language="VB.NET" Value="Public Property FontWeight As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontWeight FontWeight { System::Windows::FontWeight get(); void set(System::Windows::FontWeight value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el grosor de fuente de nivel superior para <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Un miembro de la clase <see cref="T:System.Windows.FontWeights" /> que especifica el espesor de fuente deseado. El valor predeterminado viene determinado por el valor de <see cref="P:System.Windows.SystemFonts.MessageFontWeight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier <xref:System.Windows.Controls.TextBlock.FontWeight%2A> en los elementos secundarios invalida esta configuración de nivel superior.  
  
 Para obtener una lista de valores válidos de peso de fuente, consulte la <xref:System.Windows.FontWeights> clase.  
  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.FontWeight%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es uno de los valores de formato de cadena de una propiedad de la <xref:System.Windows.FontWeights> clase. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetFontWeight%2A> y <xref:System.Windows.Controls.TextBlock.SetFontWeight%2A>. El uso de la propiedad adjunta no es común, porque la mayoría de los elementos que puede incluirse en un <xref:System.Windows.Controls.TextBlock> compatibilidad con un análogo no asociada `FontWeight` propiedad, que el <xref:System.Windows.Controls.TextBlock> utiliza para la representación.  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.FontWeightProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontWeight%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.FontWeight%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontWeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontWeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontWeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.FontWeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Windows.Media.Brush" /> que se va a aplicar al contenido de texto de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Pincel usado para la aplicación al contenido de texto. El valor predeterminado es <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una tabla de muestras que muestran los colores de pincel predefinidos disponibles, vea <xref:System.Windows.Media.Brushes>.  
  
 Cualquier <xref:System.Windows.Controls.TextBlock.Foreground%2A> en los elementos secundarios invalida esta configuración de nivel superior.  
  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.Foreground%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es una cadena que se resuelve en un <xref:System.Windows.Media.Brush> valor de la implementación. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetForeground%2A> y <xref:System.Windows.Controls.TextBlock.SetForeground%2A>. El uso de la propiedad adjunta no es común, porque la mayoría de los elementos que puede incluirse en un <xref:System.Windows.Controls.TextBlock> compatibilidad con un análogo no asociada `Foreground` propiedad, que el <xref:System.Windows.Controls.TextBlock> utiliza para la representación.  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.ForegroundProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Foreground%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Foreground%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.Foreground" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaselineOffset">
      <MemberSignature Language="C#" Value="public static double GetBaselineOffset (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetBaselineOffset(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetBaselineOffset(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBaselineOffset (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetBaselineOffset(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetBaselineOffset(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontFamily">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.FontFamily GetFontFamily (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.FontFamily GetFontFamily(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontFamily(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontFamily (element As DependencyObject) As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::FontFamily ^ GetFontFamily(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="F:System.Windows.Controls.TextBlock.FontFamilyProperty" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontFamily(System.Windows.DependencyObject,System.Windows.Media.FontFamily)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontSize">
      <MemberSignature Language="C#" Value="public static double GetFontSize (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetFontSize(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontSize(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontSize (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetFontSize(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontStretch">
      <MemberSignature Language="C#" Value="public static System.Windows.FontStretch GetFontStretch (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontStretch GetFontStretch(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontStretch(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontStretch (element As DependencyObject) As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontStretch GetFontStretch(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontStretch(System.Windows.DependencyObject,System.Windows.FontStretch)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontStyle">
      <MemberSignature Language="C#" Value="public static System.Windows.FontStyle GetFontStyle (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontStyle GetFontStyle(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontStyle(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontStyle (element As DependencyObject) As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontStyle GetFontStyle(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontStyle(System.Windows.DependencyObject,System.Windows.FontStyle)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontWeight">
      <MemberSignature Language="C#" Value="public static System.Windows.FontWeight GetFontWeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontWeight GetFontWeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontWeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontWeight (element As DependencyObject) As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontWeight GetFontWeight(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontWeight(System.Windows.DependencyObject,System.Windows.FontWeight)" />
      </Docs>
    </Member>
    <Member MemberName="GetForeground">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Brush GetForeground (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.Brush GetForeground(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetForeground(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetForeground (element As DependencyObject) As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Brush ^ GetForeground(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineHeight">
      <MemberSignature Language="C#" Value="public static double GetLineHeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetLineHeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetLineHeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineHeight (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetLineHeight(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static System.Windows.LineStackingStrategy GetLineStackingStrategy (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.LineStackingStrategy GetLineStackingStrategy(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetLineStackingStrategy(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineStackingStrategy (element As DependencyObject) As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::LineStackingStrategy GetLineStackingStrategy(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Estructura <see cref="T:System.Windows.Point" /> del espacio de coordenadas de <see cref="T:System.Windows.Controls.TextBlock" /> en la que se devuelve un objeto <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <param name="snapToText">
          <see langword="true" /> para devolver un objeto <see cref="T:System.Windows.Documents.TextPointer" /> en el punto de inserción más próximo a <c>point</c>, tanto si <c>point</c> está dentro del rectángulo de selección de un carácter como si no; <see langword="false" /> para devolver <see langword="null" /> si <c>point</c> no está dentro del rectángulo de selección de un carácter.</param>
        <summary>Devuelve un objeto <see cref="T:System.Windows.Documents.TextPointer" /> en la posición más próxima a una estructura <see cref="T:System.Windows.Point" /> especificada.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> para el punto especificado o <see langword="null" /> si <paramref name="snapToText" /> es <see langword="false" /> y el punto especificado no está comprendido dentro del rectángulo de selección de un carácter del área de contenido de <see cref="T:System.Windows.Controls.TextBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve siempre válido <xref:System.Windows.Documents.TextPointer> cuando `snapToText` es `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La información de diseño válida actual del control no está disponible.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRectanglesCore">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt; GetRectanglesCore (System.Windows.ContentElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Rect&gt; GetRectanglesCore(class System.Windows.ContentElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetRectanglesCore(System.Windows.ContentElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRectanglesCore (child As ContentElement) As ReadOnlyCollection(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Rect&gt; ^ GetRectanglesCore(System::Windows::ContentElement ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.ContentElement" />
      </Parameters>
      <Docs>
        <param name="child">
          <see cref="T:System.Windows.ContentElement" /> para el que se va a generar y devolver una colección de rectángulos delimitadores.</param>
        <summary>Devuelve una colección de rectángulos delimitadores de sólo lectura para el objeto <see cref="T:System.Windows.ContentElement" /> especificado.</summary>
        <returns>Colección de rectángulos delimitadores de sólo lectura para el objeto <see cref="T:System.Windows.ContentElement" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada rectángulo delimitador de la colección corresponde a una línea de contenido en el <xref:System.Windows.ContentElement>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="child" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTextAlignment">
      <MemberSignature Language="C#" Value="public static System.Windows.TextAlignment GetTextAlignment (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.TextAlignment GetTextAlignment(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetTextAlignment(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTextAlignment (element As DependencyObject) As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::TextAlignment GetTextAlignment(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero que especifica el objeto secundario de <see cref="T:System.Windows.Media.Visual" /> que se va a devolver.  Este valor debe estar comprendido entre 0 y (<see cref="P:System.Windows.Controls.TextBlock.VisualChildrenCount" /> menos 1).</param>
        <summary>Devuelve el elemento secundario de <see cref="T:System.Windows.Media.Visual" /> que se encuentra en el índice especificado.</summary>
        <returns>Objeto secundario de <see cref="T:System.Windows.Media.Visual" /> que se encuentra en el índice especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Windows.FrameworkElement.GetVisualChild%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no está comprendido entre 0 y (<see cref="P:System.Windows.Controls.TextBlock.VisualChildrenCount" /> menos 1).</exception>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Objeto <see cref="T:System.Windows.Media.PointHitTestParameters" /> que especifica los parámetros para la prueba de posicionamiento.</param>
        <summary>Devuelve un objeto <see cref="T:System.Windows.Media.PointHitTestResult" /> para el objeto <see cref="T:System.Windows.Media.PointHitTestParameters" /> especificado.</summary>
        <returns>
          <see cref="T:System.Windows.Media.PointHitTestResult" /> para los parámetros de la prueba de posicionamiento especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método está pensado para habilitar la prueba de posicionamiento precisa para el contenido representado.  
  
 Este método invalida <xref:System.Windows.UIElement.HitTestCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hitTestParameters" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostedElementsCore">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt; HostedElementsCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.IInputElement&gt; HostedElementsCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.HostedElementsCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property HostedElementsCore As IEnumerator(Of IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ HostedElementsCore { System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un enumerador que se puede utilizar para iterar los elementos hospedados en <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Enumerador que puede iterar los elementos hospedados en <see cref="T:System.Windows.Controls.TextBlock" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Inlines">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.InlineCollection Inlines { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.InlineCollection Inlines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Inlines" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Inlines As InlineCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::InlineCollection ^ Inlines { System::Windows::Documents::InlineCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.InlineCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Windows.Documents.InlineCollection" /> que contiene los elementos <see cref="T:System.Windows.Documents.Inline" /> de nivel superior que conforman el contenido de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>
          <see cref="T:System.Windows.Documents.InlineCollection" /> que contiene los elementos <see cref="T:System.Windows.Documents.Inline" /> que comprenden el contenido de <see cref="T:System.Windows.Controls.TextBlock" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Windows.Documents.InlineCollection> devuelto por esta propiedad para enumerar o manipular el contenido de un <xref:System.Windows.Controls.TextBlock>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputHitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.IInputElement InputHitTestCore (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.IInputElement InputHitTestCore(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.InputHitTestCore(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::IInputElement ^ InputHitTestCore(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Estructura <see cref="T:System.Windows.Point" /> del espacio de coordenadas de <see cref="T:System.Windows.Controls.TextBlock" /> para la que se devuelve la interfaz <see cref="T:System.Windows.IInputElement" /> correspondiente.</param>
        <summary>Devuelve la interfaz <see cref="T:System.Windows.IInputElement" /> que se encuentra en una estructura <see cref="T:System.Windows.Point" /> específica dentro de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>
          <see cref="T:System.Windows.IInputElement" /> que se encuentra en el punto especificado o <see langword="null" /> si no se puede encontrar <see cref="T:System.Windows.IInputElement" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabled">
      <MemberSignature Language="C#" Value="public bool IsHyphenationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHyphenationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.IsHyphenationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHyphenationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHyphenationEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la división automática de palabras está habilitada o deshabilitada.</summary>
        <value>
          <see langword="true" /> para indicar que la separación y la división de palabras está habilitada; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La característica de división de palabras automática permite una <xref:System.Windows.Controls.TextBlock> para interrumpir y separar las palabras, en función de las condiciones actuales de diseño automáticamente.  Esto permite palabras largas pueden comenzar en una línea y continuar en la siguiente y lo que permite conseguir una distribución más equilibrada de espacio en blanco en texto justificado.  Las palabras se dividen y con guiones según las reglas de gramática estándar.  
  
<a name="dependencyPropertyInfo_IsHyphenationEnabled"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.IsHyphenationEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHyphenationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHyphenationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHyphenationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHyphenationEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.IsHyphenationEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto de cada línea de contenido.</summary>
        <value>El alto de línea, en píxeles independientes del dispositivo, en el intervalo de 0.0034 a 160 000. Un valor de <see cref="F:System.Double.NaN" /> (equivalente a un valor de atributo de "<c>automática</c>") indica que el alto de línea se determine automáticamente a partir de las características de la fuente actual. El valor predeterminado es <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cambia este valor no cambia el alto del texto asociado; en su lugar, cambia el alto de la línea que contiene el texto. Para cambiar el tamaño del texto, use la <xref:System.Windows.Controls.TextBlock.FontSize%2A> propiedad.  
  
 Además de esta propiedad, el diseño de las líneas en un <xref:System.Windows.Controls.TextBlock> se ve afectado por su <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> propiedad.  
  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.LineHeight%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es una cadena, como se explica en valores XAML. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetLineHeight%2A> y <xref:System.Windows.Controls.TextBlock.SetLineHeight%2A>. El uso de la propiedad adjunta no es común.  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *double*  
 <xref:System.Double>  
  
 Representación de cadena de un <xref:System.Double> valor igual o mayor que `0.0034` e igual o menor, a continuación, `160000`. Un valor sin calificar se mide en píxeles independientes del dispositivo. Las cadenas no necesitan incluir explícitamente separadores decimales.  
  
 *qualifiedDouble*  
 A *doble* valor tal como se describió anteriormente, (excepto `Auto`) seguido de uno de estos especificadores de unidades: `px`, `in`, `cm`, `pt`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1 in == 96 px  
  
 `cm` es centímetros; 1cm==(96/2.54) px  
  
 `pt` es puntos; 1pt==(96/72) px  
  
 Automático  
 Hace que el alto de línea se determine automáticamente a partir de las características de la fuente actual.  Equivalente a un valor de propiedad <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.LineHeightProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.LineHeight%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.LineHeight%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> se establece en un valor no positivo.</exception>
        <altmember cref="P:System.Windows.Documents.FlowDocument.LineHeight" />
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.LineHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el mecanismo por el que se determina un cuadro de línea para cada línea de texto dentro de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Mecanismo por el que se define un cuadro de línea para cada línea de texto de <see cref="T:System.Windows.Controls.TextBlock" />. El valor predeterminado es <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es un valor de cadena de la <xref:System.Windows.LineStackingStrategy> enumeración. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetLineStackingStrategy%2A> y <xref:System.Windows.Controls.TextBlock.SetLineStackingStrategy%2A>. El uso de la propiedad adjunta no es común.  
  
<a name="dependencyPropertyInfo_LineStackingStrategy"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.LineStackingStrategyProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> propiedad para determinar cómo se crean los cuadros de línea para las líneas de texto de un <xref:System.Windows.Controls.TextBlock>. La primera <xref:System.Windows.Controls.TextBlock> tiene un <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> valo <xref:System.Windows.LineStackingStrategy.MaxHeight> y el segundo <xref:System.Windows.Controls.TextBlock> tiene un valor de <xref:System.Windows.LineStackingStrategy.BlockLineHeight>.  
  
 [!code-xaml[FlowMiscSnippets_snip#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 En la siguiente ilustración muestra el resultado del código anterior.  
  
 ![Captura de pantalla: Comparar valores de LineStackingStrategy](~/add/media/flow-linestackingstrategy.gif "captura de pantalla: comparar LineStackingStrategy valores")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un enumerador que puede iterar por los elementos secundarios lógicos del control <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Enumerador para los elementos secundarios lógicos.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Estructura <see cref="T:System.Windows.Size" /> que especifica las restricciones de tamaño de <see cref="T:System.Windows.Controls.TextBlock" />.</param>
        <summary>Se invoca para medir de nuevo el objeto <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>Estructura <see cref="T:System.Windows.Size" /> que indica el nuevo tamaño de <see cref="T:System.Windows.Controls.TextBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalide este método para implementar el comportamiento de cambio de tamaño personalizado.  
  
 Este método invalida <xref:System.Windows.FrameworkElement.MeasureOverride%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChangedCore">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChangedCore (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChangedCore(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnChildDesiredSizeChangedCore(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChildDesiredSizeChangedCore (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChildDesiredSizeChangedCore(System::Windows::UIElement ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Elemento <see cref="T:System.Windows.UIElement" /> secundario cuyo <see cref="P:System.Windows.UIElement.DesiredSize" /> ha cambiado.</param>
        <summary>Se invoca cuando un elemento secundario que se deriva de <see cref="T:System.Windows.UIElement" /> cambia su <see cref="P:System.Windows.UIElement.DesiredSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea y devuelve un objeto <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> para este control <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>Un objeto <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> para este <see cref="T:System.Windows.Controls.TextBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Argumentos del evento asociado.</param>
        <summary>Se llama cuando cambia el valor de una o más de propiedades de dependencia hospedadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyChangedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected override sealed void OnRender (System.Windows.Media.DrawingContext ctx);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRender(class System.Windows.Media.DrawingContext ctx) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnRender (ctx As DrawingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRender(System::Windows::Media::DrawingContext ^ ctx);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctx" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="ctx">
          <see cref="T:System.Windows.Media.DrawingContext" /> en el que se va a representar el control.</param>
        <summary>Representa el contenido de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es invocado por el sistema de diseño para presentar el contenido de la <xref:System.Windows.Controls.TextBlock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ctx" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica el grosor del espacio de relleno comprendido entre los límites del área de contenido y el contenido mostrado por <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Un <see cref="T:System.Windows.Thickness" /> estructura especifica la cantidad de relleno que se aplicará, en píxeles independientes del dispositivo. El valor predeterminado es <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextBlock.Padding%2A> se puede describir como uniforme en todas las direcciones (`Padding="10"`), o como cuatro valores distintos que representan a la izquierda, superior, derecho y abajo relleno de forma independiente (`Padding="5,0,10,20"`).  
  
 Si un grosor de relleno especificado supera la dimensión correspondiente del área de contenido (por ejemplo, la suma de la izquierda y derecha anchos de relleno supera el ancho del área de contenido), el grosor del relleno se reduce proporcionalmente para que no sea mayor que la dimensión del área de contenido correspondiente.  
  
<a name="xamlAttributeUsage_Padding"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object Padding="uniformThickness"/>  
- or -  
<object Padding="independentThickness"/>  
- or -  
<object Padding="qualifiedUniformThickness"/>  
- or -  
<object Padding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Padding"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *uniformThickness*  
 Representación de cadena de un único <xref:System.Double> valor que debe aplicarse uniformemente en todas las dimensiones de grosor cuatro.  Por ejemplo, un valor de `"10"` es equivalente a un valor de `"10,10,10,10"`.  Un valor sin calificar se mide en píxeles independientes del dispositivo. Las cadenas no necesitan incluir explícitamente separadores decimales.  
  
 *independentThickness*  
 Representación de cadena de cuatro ordenados <xref:System.Double> valores correspondientes a las dimensiones de grosor independiente para izquierda, superior, derecho e inferior, en este orden.  Los cuatro valores deben aparecer separados con comas; no se permiten espacios.  Por ejemplo, "5,10,15,20 da como" resultado 5 píxeles de relleno a la izquierda del contenido, 10 píxeles de relleno encima de contenido, 15 píxeles de relleno a la derecha del contenido y 20 píxeles de relleno debajo del contenido.  
  
 *qualifiedUniformThickness*  
 Un valor descrito por *uniformThickness* seguido de uno de estos especificadores de unidades: `px`, `in`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1 in == 96 px  
  
 Por ejemplo, `"1in"` proporciona relleno uniforme de 1 pulgada en todas las direcciones.  
  
 *qualifiedIndependentThickness*  
 Un valor descrito por *independentThickness*, con cada valor independiente seguido de uno de estos especificadores de unidades: `px`, `in`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1 in == 96 px  
  
 Por ejemplo: `"1.5in,0.8in,1.5in,0.8in"`.  Especificadores de unidades podrán estar mixto o se omite de uno o más valores.  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.PaddingProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Padding%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Padding%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.Padding" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBaselineOffset">
      <MemberSignature Language="C#" Value="public static void SetBaselineOffset (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBaselineOffset(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetBaselineOffset(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBaselineOffset (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBaselineOffset(System::Windows::DependencyObject ^ element, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetBaselineOffset(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontFamily">
      <MemberSignature Language="C#" Value="public static void SetFontFamily (System.Windows.DependencyObject element, System.Windows.Media.FontFamily value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontFamily(class System.Windows.DependencyObject element, class System.Windows.Media.FontFamily value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontFamily(System.Windows.DependencyObject,System.Windows.Media.FontFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontFamily (element As DependencyObject, value As FontFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontFamily(System::Windows::DependencyObject ^ element, System::Windows::Media::FontFamily ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Media.FontFamily" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontFamily" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontFamily(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontSize">
      <MemberSignature Language="C#" Value="public static void SetFontSize (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontSize(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontSize (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontSize(System::Windows::DependencyObject ^ element, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontSize" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontSize(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontStretch">
      <MemberSignature Language="C#" Value="public static void SetFontStretch (System.Windows.DependencyObject element, System.Windows.FontStretch value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontStretch(class System.Windows.DependencyObject element, valuetype System.Windows.FontStretch value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontStretch(System.Windows.DependencyObject,System.Windows.FontStretch)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontStretch (element As DependencyObject, value As FontStretch)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontStretch(System::Windows::DependencyObject ^ element, System::Windows::FontStretch value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontStretch" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontStretch" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontStretch(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontStyle">
      <MemberSignature Language="C#" Value="public static void SetFontStyle (System.Windows.DependencyObject element, System.Windows.FontStyle value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontStyle(class System.Windows.DependencyObject element, valuetype System.Windows.FontStyle value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontStyle(System.Windows.DependencyObject,System.Windows.FontStyle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontStyle (element As DependencyObject, value As FontStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontStyle(System::Windows::DependencyObject ^ element, System::Windows::FontStyle value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontStyle" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontStyle" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontStyle(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontWeight">
      <MemberSignature Language="C#" Value="public static void SetFontWeight (System.Windows.DependencyObject element, System.Windows.FontWeight value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontWeight(class System.Windows.DependencyObject element, valuetype System.Windows.FontWeight value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontWeight(System.Windows.DependencyObject,System.Windows.FontWeight)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontWeight (element As DependencyObject, value As FontWeight)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontWeight(System::Windows::DependencyObject ^ element, System::Windows::FontWeight value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontWeight" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.FontWeight" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontWeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetForeground">
      <MemberSignature Language="C#" Value="public static void SetForeground (System.Windows.DependencyObject element, System.Windows.Media.Brush value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetForeground(class System.Windows.DependencyObject element, class System.Windows.Media.Brush value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetForeground (element As DependencyObject, value As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetForeground(System::Windows::DependencyObject ^ element, System::Windows::Media::Brush ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.Foreground" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetForeground(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineHeight">
      <MemberSignature Language="C#" Value="public static void SetLineHeight (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineHeight(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineHeight (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineHeight(System::Windows::DependencyObject ^ element, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.LineHeight" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> se establece en un valor no positivo.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetLineHeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static void SetLineStackingStrategy (System.Windows.DependencyObject element, System.Windows.LineStackingStrategy value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineStackingStrategy(class System.Windows.DependencyObject element, valuetype System.Windows.LineStackingStrategy value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineStackingStrategy (element As DependencyObject, value As LineStackingStrategy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineStackingStrategy(System::Windows::DependencyObject ^ element, System::Windows::LineStackingStrategy value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.LineStackingStrategy" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetTextAlignment">
      <MemberSignature Language="C#" Value="public static void SetTextAlignment (System.Windows.DependencyObject element, System.Windows.TextAlignment value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTextAlignment(class System.Windows.DependencyObject element, valuetype System.Windows.TextAlignment value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTextAlignment (element As DependencyObject, value As TextAlignment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTextAlignment(System::Windows::DependencyObject ^ element, System::Windows::TextAlignment value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.TextAlignment" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetTextAlignment(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBaselineOffset">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeBaselineOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeBaselineOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeBaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeBaselineOffset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeBaselineOffset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si el valor efectivo de la propiedad <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> se debe serializar durante la serialización de un objeto <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>
          <see langword="true" /> si la propiedad <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> debe serializarse; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInlines">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInlines (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInlines(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeInlines(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInlines (manager As XamlDesignerSerializationManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInlines(System::Windows::Markup::XamlDesignerSerializationManager ^ manager);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">Objeto de administrador del servicio de serialización de este objeto.</param>
        <summary>Devuelve un valor que indica si el valor efectivo de la propiedad <see cref="P:System.Windows.Controls.TextBlock.Inlines" /> se debe serializar durante la serialización de un objeto <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>
          <see langword="true" /> si la propiedad <see cref="P:System.Windows.Controls.TextBlock.Inlines" /> debe serializarse; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="manager" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeText">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeText" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeText () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeText();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si el valor efectivo de la propiedad <see cref="P:System.Windows.Controls.TextBlock.Text" /> se debe serializar durante la serialización de un objeto <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>
          <see langword="true" /> si la propiedad <see cref="P:System.Windows.Controls.TextBlock.Text" /> debe serializarse; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Objeto que especifica el tipo de objeto de servicio que se va a obtener.</param>
        <summary>Este método es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.</summary>
        <returns>Objeto de servicio de tipo <paramref name="serviceType" /> o <see langword="null" /> si no hay ningún objeto de servicio de tipo <paramref name="serviceType" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.GetRectangles">
      <MemberSignature Language="C#" Value="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt; IContentHost.GetRectangles (System.Windows.ContentElement child);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Rect&gt; System.Windows.IContentHost.GetRectangles(class System.Windows.ContentElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#GetRectangles(System.Windows.ContentElement)" />
      <MemberSignature Language="VB.NET" Value="Function GetRectangles (child As ContentElement) As ReadOnlyCollection(Of Rect) Implements IContentHost.GetRectangles" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Rect&gt; ^ System.Windows.IContentHost.GetRectangles(System::Windows::ContentElement ^ child) = System::Windows::IContentHost::GetRectangles;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.GetRectangles(System.Windows.ContentElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.ContentElement" />
      </Parameters>
      <Docs>
        <param name="child">
          <see cref="T:System.Windows.ContentElement" /> para el que se va a generar y devolver una colección de rectángulos delimitadores.</param>
        <summary>Este método es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.  Utilice el método <see cref="M:System.Windows.Controls.TextBlock.GetRectanglesCore(System.Windows.ContentElement)" /> con seguridad de tipos en su lugar.</summary>
        <returns>Colección de rectángulos delimitadores de sólo lectura para el objeto <see cref="T:System.Windows.ContentElement" /> especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.HostedElements">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt; System.Windows.IContentHost.HostedElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.IInputElement&gt; System.Windows.IContentHost.HostedElements" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.System#Windows#IContentHost#HostedElements" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HostedElements As IEnumerator(Of IInputElement) Implements IContentHost.HostedElements" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ System.Windows.IContentHost.HostedElements { System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IContentHost.HostedElements</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Este tipo o miembro es compatible con la infraestructura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está pensado para ser usado directamente desde su código.  En su lugar, use la propiedad <see cref="P:System.Windows.Controls.TextBlock.HostedElementsCore" /> con seguridad de tipos.</summary>
        <value>Elementos hospedados por el host de contenido.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.InputHitTest">
      <MemberSignature Language="C#" Value="System.Windows.IInputElement IContentHost.InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Windows.IInputElement System.Windows.IContentHost.InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#InputHitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Windows::IInputElement ^ System.Windows.IContentHost.InputHitTest(System::Windows::Point point) = System::Windows::IContentHost::InputHitTest;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.InputHitTest(System.Windows.Point)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Coordenadas del mouse relativas al host de contenido.</param>
        <summary>Este método es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.  Utilice el método <see cref="M:System.Windows.Controls.TextBlock.InputHitTestCore(System.Windows.Point)" /> con seguridad de tipos en su lugar.</summary>
        <returns>Elemento que se ha alcanzado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="void IContentHost.OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.IContentHost.OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Sub OnChildDesiredSizeChanged (child As UIElement) Implements IContentHost.OnChildDesiredSizeChanged" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.IContentHost.OnChildDesiredSizeChanged(System::Windows::UIElement ^ child) = System::Windows::IContentHost::OnChildDesiredSizeChanged;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.OnChildDesiredSizeChanged(System.Windows.UIElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Elemento <see cref="T:System.Windows.UIElement" /> secundario cuyo <see cref="P:System.Windows.UIElement.DesiredSize" /> ha cambiado.</param>
        <summary>Este método es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.  Utilice el método <see cref="M:System.Windows.Controls.TextBlock.OnChildDesiredSizeChangedCore(System.Windows.UIElement)" /> con seguridad de tipos en su lugar.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a agregar como elemento secundario.</param>
        <summary>Este miembro es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a agregar al objeto.</param>
        <summary>Este miembro es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contenido de texto de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>El contenido del texto de <see cref="T:System.Windows.Controls.TextBlock" />. Tenga en cuenta que se elimina todo el contenido que no es texto, lo que da como resultado una representación en texto sin formato del contenido de <see cref="T:System.Windows.Controls.TextBlock" />. El valor predeterminado es <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad cuando desea mostrar texto sin formato en un <xref:System.Windows.Controls.TextBlock>.  Cuando necesite dar formato al texto, agregue <xref:System.Windows.Documents.Inline> objetos a la <xref:System.Windows.Controls.TextBlock.Inlines%2A> propiedad.  
  
<a name="dependencyPropertyInfo_Text"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.TextProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Text%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[SpanSnippets#_TextBlock_Text1XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/SpanSnippets/CSharp/Window1.xaml#_textblock_text1xaml)]  
  
 Como alternativa, el contenido de una ejecución de texto puede estar incluido sencillamente <xref:System.Windows.Controls.TextBlock> etiquetas de elemento.  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Text%2A> propiedad mediante programación.  
  
 [!code-csharp[SpanSnippets#_TextBlock_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/SpanSnippets/CSharp/Window1.xaml.cs#_textblock_text)]
 [!code-vb[SpanSnippets#_TextBlock_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/SpanSnippets/visualbasic/window1.xaml.vb#_textblock_text)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica la alineación horizontal del contenido del texto.</summary>
        <value>Uno de los valores <see cref="T:System.Windows.TextAlignment" /> que especifica la alineación deseada. El valor predeterminado es <see cref="F:System.Windows.TextAlignment.Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es `<` *objeto* <xref:System.Windows.Controls.TextBlock.TextAlignment%2A?displayProperty=nameWithType> `="` *valor*`".../>`, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Controls.TextBlock>, y *valor* es un valor de cadena de la <xref:System.Windows.TextAlignment> enumeración. En el código, el uso de la propiedad adjunta es compatible con <xref:System.Windows.Controls.TextBlock.GetTextAlignment%2A> y <xref:System.Windows.Controls.TextBlock.SetTextAlignment%2A>. El uso de la propiedad adjunta no es común.  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.TextAlignmentProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.TextAlignment%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.TextAlignment%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.TextAlignment" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorations">
      <MemberSignature Language="C#" Value="public System.Windows.TextDecorationCollection TextDecorations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TextDecorationCollection TextDecorations" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextDecorations" />
      <MemberSignature Language="VB.NET" Value="Public Property TextDecorations As TextDecorationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextDecorationCollection ^ TextDecorations { System::Windows::TextDecorationCollection ^ get(); void set(System::Windows::TextDecorationCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextDecorationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un objeto <see cref="T:System.Windows.TextDecorationCollection" /> que contiene los efectos que se van a aplicar al texto de <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Colección <see cref="T:System.Windows.TextDecorationCollection" /> que contiene las decoraciones de texto que se van a aplicar a este elemento. El valor predeterminado es <see langword="null" /> (no se aplican decoraciones de texto).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.TextDecoration> objeto es un adorno visual que se puede agregar al texto. Hay cuatro tipos de decoraciones de texto: subrayado, línea base, tachado y línea alta.  Para obtener más información acerca de decoraciones de texto, consulte [Cómo: crear una decoración de texto](~/docs/framework/wpf/advanced/how-to-create-a-text-decoration.md).  
  
 De forma predeterminada, esta propiedad se establece en `null` y no tiene ningún <xref:System.Windows.TextDecorationCollection> asociados a él.  Antes de agregar efectos de texto, cree un nuevo <xref:System.Windows.TextDecorationCollection> y asignarlo a esta propiedad.  
  
<a name="dependencyPropertyInfo_TextDecorations"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.TextDecorationsProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.TextDecorations%2A> atributo.  
  
 [!code-xaml[InlineSnippets#_TextBlock_TextDecXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml#_textblock_textdecxaml)]  
  
 En la ilustración siguiente, se muestra cómo se representa este ejemplo.  
  
 ![Captura de pantalla: Texto con efecto de tachado predeterminado](~/add/media/inline-textdec-strike.png "captura de pantalla: texto con efecto de tachado predeterminado")  
  
 Las ilustraciones siguientes muestran cómo el <xref:System.Windows.TextDecorations.OverLine%2A>, <xref:System.Windows.TextDecorations.Baseline%2A>, y <xref:System.Windows.TextDecorations.Underline%2A> representan decoraciones, respectivamente.  
  
 ![Captura de pantalla: TextDecorator de suprarrayado](~/add/media/inline-textdec-over.png "captura de pantalla: TextDecorator de suprarrayado")  
  
 ![Captura de pantalla: Predeterminado efecto de línea base en texto](~/add/media/inline-textdec-base.png "captura de pantalla: predeterminado efecto de línea base en texto")  
  
 ![Captura de pantalla: Texto con efecto de subrayado predeterminado](~/add/media/inline-textdec-under.png "captura de pantalla: texto con efecto de subrayado predeterminado")  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.TextDecorations%2A> propiedad mediante programación.  
  
 [!code-csharp[InlineSnippets#_TextBlock_TextDec](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml.cs#_textblock_textdec)]
 [!code-vb[InlineSnippets#_TextBlock_TextDec](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InlineSnippets/visualbasic/window1.xaml.vb#_textblock_textdec)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorationsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextDecorationsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextDecorationsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextDecorationsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextDecorationsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextDecorationsProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.TextDecorations" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffects">
      <MemberSignature Language="C#" Value="public System.Windows.Media.TextEffectCollection TextEffects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.TextEffectCollection TextEffects" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextEffects" />
      <MemberSignature Language="VB.NET" Value="Public Property TextEffects As TextEffectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::TextEffectCollection ^ TextEffects { System::Windows::Media::TextEffectCollection ^ get(); void set(System::Windows::Media::TextEffectCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextEffectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los efectos que se van a aplicar al contenido de texto de este elemento.</summary>
        <value>Colección <see cref="T:System.Windows.Media.TextEffectCollection" /> que contiene uno o varios objetos <see cref="T:System.Windows.Media.TextEffect" /> que definen los efectos que se van a aplicar al texto de <see cref="T:System.Windows.Controls.TextBlock" />. El valor predeterminado es <see langword="null" /> (no se aplican efectos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, esta propiedad se establece en `null` y no tiene ningún <xref:System.Windows.Media.TextEffectCollection> asociados a él.  Antes de agregar efectos de texto, cree un nuevo <xref:System.Windows.Media.TextEffectCollection> y asignarlo a esta propiedad.  
  
<a name="dependencyPropertyInfo_TextEffects"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.TextEffectsProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un efecto de texto simple y aplicarlo a un texto de un <xref:System.Windows.Controls.TextBlock>.  
  
 [!code-csharp[TextElementSnippets#_TextBlock_TextEffects](~/samples/snippets/csharp/VS_Snippets_Wpf/TextElementSnippets/CSharp/Window1.xaml.cs#_textblock_texteffects)]
 [!code-vb[TextElementSnippets#_TextBlock_TextEffects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextElementSnippets/visualbasic/window1.xaml.vb#_textblock_texteffects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffectsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextEffectsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextEffectsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextEffectsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextEffectsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextEffectsProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.TextEffects" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.Text" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimming">
      <MemberSignature Language="C#" Value="public System.Windows.TextTrimming TextTrimming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextTrimming TextTrimming" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextTrimming" />
      <MemberSignature Language="VB.NET" Value="Public Property TextTrimming As TextTrimming" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextTrimming TextTrimming { System::Windows::TextTrimming get(); void set(System::Windows::TextTrimming value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextTrimming</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el comportamiento de recorte de texto que se emplea cuando el contenido sobrepasa el área de contenido.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.TextTrimming" /> que especifica el comportamiento de recorte de texto que se va a utilizar. El valor predeterminado es <see cref="F:System.Windows.TextTrimming.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextTrimming"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.TextTrimmingProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimmingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextTrimmingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextTrimmingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextTrimmingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextTrimmingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextTrimmingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.TextTrimming" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrapping">
      <MemberSignature Language="C#" Value="public System.Windows.TextWrapping TextWrapping { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextWrapping TextWrapping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextWrapping" />
      <MemberSignature Language="VB.NET" Value="Public Property TextWrapping As TextWrapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextWrapping TextWrapping { System::Windows::TextWrapping get(); void set(System::Windows::TextWrapping value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextWrapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo en que <see cref="T:System.Windows.Controls.TextBlock" /> debe ajustar el texto.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.TextWrapping" />. El valor predeterminado es <see cref="F:System.Windows.TextWrapping.NoWrap" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextWrapping"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.TextBlock.TextWrappingProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.TextWrapping%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.TextWrapping%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrappingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextWrappingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextWrappingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextWrappingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextWrappingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextWrappingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.TextBlock.TextWrapping" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Typography">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Typography Typography { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Typography Typography" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Typography" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Typography As Typography" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Typography ^ Typography { System::Windows::Documents::Typography ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Typography</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las variaciones tipográficas vigentes en la actualidad del contenido de este elemento.</summary>
        <value>Una propiedad <see cref="T:System.Windows.Documents.Typography" /> que especifica las variaciones de la tipografía actualmente en vigencia. Para obtener una lista de valores de tipografía predeterminados, vea <see cref="T:System.Windows.Documents.Typography" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Controls.TextBlock.Typography%2A> propiedad solo es aplicable a [!INCLUDE[TLA#tla_opentype](~/includes/tlasharptla-opentype-md.md)] fuentes. Una variante de tipografía no tiene ningún efecto en las fuentes que no admiten la variante.  Para obtener más información acerca de este tema, consulte [tipografía en WPF](~/docs/framework/wpf/advanced/typography-in-wpf.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Typography%2A> atributo de un <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 En el ejemplo siguiente se muestra cómo establecer el <xref:System.Windows.Controls.TextBlock.Typography%2A> propiedad mediante programación.  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.Typography" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos secundarios <see cref="T:System.Windows.Media.Visual" /> hospedados por <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>Número de elementos secundarios visuales hospedados por <see cref="T:System.Windows.Controls.TextBlock" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>