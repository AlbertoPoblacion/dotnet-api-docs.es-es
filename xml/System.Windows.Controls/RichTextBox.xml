<Type Name="RichTextBox" FullName="System.Windows.Controls.RichTextBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4080981a9e14f22998d5b04f55c60793061cf53a" /><Meta Name="ms.sourcegitcommit" Value="6089a30c0522e6f43256523e82e94b2ccedfb55b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/04/2019" /><Meta Name="ms.locfileid" Value="59015987" /></Metadata><TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Controls.Primitives.TextBoxBase, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi RichTextBox extends System.Windows.Controls.Primitives.TextBoxBase implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Controls::Primitives::TextBoxBase, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Inherit)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Document")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un control de edición completo que funciona en objetos <see cref="T:System.Windows.Documents.FlowDocument" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument> es el único elemento secundario admitido para un <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Controls.RichTextBox> tiene control integrado para la propagación <xref:System.Windows.UIElement.MouseUp> y <xref:System.Windows.UIElement.MouseDown> eventos.  Por lo tanto, los controladores de eventos personalizados que escuchan `MouseUp` o `MouseDown` eventos desde un <xref:System.Windows.Controls.RichTextBox> nunca se llamará.  Si tiene que responder a estos eventos, escuchar los túneles <xref:System.Windows.UIElement.PreviewMouseUp> y <xref:System.Windows.UIElement.PreviewMouseDown> eventos en su lugar, o registrar los controladores con el <xref:System.Windows.EventSetter.HandledEventsToo%2A> argumento (esta última opción solo está disponible a través del código). No marcar el evento como controlado a menos que desee deshabilitar deliberadamente <xref:System.Windows.Controls.RichTextBox> nativo de control de estos eventos y tenga en cuenta que esto tiene efectos importantes en el control [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  
  
 Mientras <xref:System.Windows.Controls.RichTextBox> admite copiar y pegar imágenes, ciertos escenarios no son actualmente compatibles y podrían no funcionar correctamente.  En la tabla siguiente se resume estos escenarios y los resultados esperados.  
  
|Origen de copia de la imagen|Resultado de Pegar imagen|  
|-----------------------|------------------------|  
|Origen de la imagen es un metarchivo gráfico|No hay ninguna imagen se pega|  
|Origen de la imagen usa la ruta de acceso relativa o vínculo|Pega imagen confusa o en blanco|  
|Vínculo a origen de imagen no termina con un formato de imagen esperado (. PNG. JPG. GIF)|Pega imagen confusa o en blanco|  
|Origen de la imagen copiado de texto enriquecido (RTF) con formato incorrecto|Vínculo a origen de la imagen se pega (en lugar de la imagen)|  
  
 Pegar contenido HTML en un <xref:System.Windows.Controls.RichTextBox> podría provocar un comportamiento inesperado porque <xref:System.Windows.Controls.RichTextBox> usa el formato de RTF en lugar de usar directamente el formato HTML.  
  
 Siempre se ajusta el texto en un <xref:System.Windows.Controls.RichTextBox>. Si no desea que el texto se ajuste a continuación, establezca el <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> en el <xref:System.Windows.Documents.FlowDocument> sea mayor que el ancho de la <xref:System.Windows.Controls.RichTextBox>. Sin embargo, una vez que se alcanza el ancho de página el texto todavía se ajusta.  
  
 Alineación horizontal y vertical contenido dentro de un <xref:System.Windows.Controls.RichTextBox> se realiza con el <xref:System.Windows.Controls.Control.HorizontalContentAlignment%2A> y <xref:System.Windows.Controls.Control.VerticalContentAlignment%2A> propiedades. Alinear el <xref:System.Windows.Controls.RichTextBox> dentro del diseño de la página se hace con el <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> y <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> propiedades.  
  
 Las barras de desplazamiento no están visibles en un <xref:System.Windows.Controls.RichTextBox> de forma predeterminada. Para mostrar una barra de desplazamiento, establezca la <xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility%2A> propiedad <xref:System.Windows.Controls.ScrollBarVisibility.Visible> o <xref:System.Windows.Controls.ScrollBarVisibility.Auto>.  
  
 Normalmente, el <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> evento se debe usar para detectar cuándo el texto en un <xref:System.Windows.Controls.TextBox> o <xref:System.Windows.Controls.RichTextBox> cambia, en su lugar, a continuación, <xref:System.Windows.UIElement.KeyDown> como cabría esperar. Como ejemplo, vea [Cómo: Detectar cuándo cambia el texto en un control TextBox](~/docs/framework/wpf/controls/how-to-detect-when-text-in-a-textbox-has-changed.md).  
  
 <xref:System.Windows.Controls.RichTextBox> admite una variedad de comandos de teclado. Para obtener una lista de comandos de teclado, consulte <xref:System.Windows.Documents.EditingCommands>.  
  
 Las propiedades de dependencia para este control pueden establecerse mediante el estilo del control de forma predeterminada.  Si una propiedad se establece mediante un estilo predeterminado, puede cambiar la propiedad de su valor predeterminado cuando el control aparece en la aplicación. El estilo predeterminado se determina por el tema de escritorio que se utiliza cuando se ejecuta la aplicación.  Para obtener más información, consulte [Default WPF Themes](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 En el ejemplo siguiente se declara un <xref:System.Windows.Controls.RichTextBox> que contiene un sencillo <xref:System.Windows.Documents.FlowDocument>.  
  
 [!code-xaml[RichTextBoxSnippets#_RTB_XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml#_rtb_xaml)]  
  
 [!code-csharp[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/CSharp/RichTextBoxExample.cs#richtextboxcodeonlyexample)]
 [!code-vb[RichTextBoxMiscSnippets_procedural_snip#RichTextBoxCodeOnlyExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxMiscSnippets_procedural_snip/visualbasic/richtextboxexample.vb#richtextboxcodeonlyexample)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia predeterminada de la clase <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un valor vacío <xref:System.Windows.Documents.FlowDocument> que está asociado con la propiedad de documento.  En concreto, el <xref:System.Windows.Documents.FlowDocument> vacío contiene un <xref:System.Windows.Documents.Paragraph> único, que contiene un <xref:System.Windows.Documents.Run> único sin texto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox (System.Windows.Documents.FlowDocument document);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.FlowDocument document) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.#ctor(System.Windows.Documents.FlowDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (document As FlowDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox(System::Windows::Documents::FlowDocument ^ document);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.RichTextBox : System.Windows.Documents.FlowDocument -&gt; System.Windows.Controls.RichTextBox" Usage="new System.Windows.Controls.RichTextBox document" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="document" Type="System.Windows.Documents.FlowDocument" />
      </Parameters>
      <Docs>
        <param name="document"><see cref="T:System.Windows.Documents.FlowDocument" /> que se va a agregar como contenido inicial del nuevo <see cref="T:System.Windows.Controls.RichTextBox" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Controls.RichTextBox" /> y agrega un <see cref="T:System.Windows.Documents.FlowDocument" /> especificado como contenido inicial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el uso de este constructor.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_constructor)]
 [!code-vb[RichTextBoxSnippets#_RTB_Constructor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_constructor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer CaretPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer CaretPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property CaretPosition As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ CaretPosition { System::Windows::Documents::TextPointer ^ get(); void set(System::Windows::Documents::TextPointer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CaretPosition : System.Windows.Documents.TextPointer with get, set" Usage="System.Windows.Controls.RichTextBox.CaretPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición del símbolo de intercalación de entrada.</summary>
        <value>Un objeto <see cref="T:System.Windows.Documents.TextPointer" /> que especifica la posición del símbolo de intercalación de entrada.  
  
De forma predeterminada, el símbolo de intercalación está en la primera posición de inserción al comienzo del contenido hospedado por <see cref="T:System.Windows.Controls.RichTextBox" />. Vea <see cref="T:System.Windows.Documents.TextPointer" /> para obtener más información sobre terminología de posición de texto como "posición de inserción".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el uso de esta propiedad.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_caretposition)]
 [!code-vb[RichTextBoxSnippets#_RTB_CaretPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_caretposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer esta propiedad en <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Se realiza un intento para establecer esta propiedad en <see cref="T:System.Windows.Documents.TextPointer" /> que hace referencia a una posición fuera del documento actual.</exception>
        <altmember cref="T:System.Windows.Documents.TextPointer" />
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.FlowDocument Document { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.FlowDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Document" />
      <MemberSignature Language="VB.NET" Value="Public Property Document As FlowDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::FlowDocument ^ Document { System::Windows::Documents::FlowDocument ^ get(); void set(System::Windows::Documents::FlowDocument ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Documents.FlowDocument with get, set" Usage="System.Windows.Controls.RichTextBox.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.FlowDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el <see cref="T:System.Windows.Documents.FlowDocument" /> que representa el contenido de <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value>Objeto <see cref="T:System.Windows.Documents.FlowDocument" /> que representa el contenido de <see cref="T:System.Windows.Controls.RichTextBox" />.  
  
De forma predeterminada, esta propiedad está establecida en un <see cref="T:System.Windows.Documents.FlowDocument" /> vacío.  En concreto, el <see cref="T:System.Windows.Documents.FlowDocument" /> vacío contiene un <see cref="T:System.Windows.Documents.Paragraph" /> único, que contiene un <see cref="T:System.Windows.Documents.Run" /> único sin texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un objeto FlowDocument solo puede hospedarse en una sola <xref:System.Windows.Controls.RichTextBox>.  Especificar un único FlowDocument como contenido de varios <xref:System.Windows.Controls.RichTextBox> controles no se admite.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de esta propiedad.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_document)]
 [!code-vb[RichTextBoxSnippets#_RTB_Document](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_document)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer esta propiedad en <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Se realiza un intento para establecer esta propiedad en un <see cref="T:System.Windows.Documents.FlowDocument" /> que representa el contenido de otro <see cref="T:System.Windows.Controls.RichTextBox" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esta propiedad se establece mientras se ha activado un bloque de cambios.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNextSpellingErrorPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextSpellingErrorPosition (System.Windows.Documents.TextPointer position, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextSpellingErrorPosition(class System.Windows.Documents.TextPointer position, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextSpellingErrorPosition (position As TextPointer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextSpellingErrorPosition(System::Windows::Documents::TextPointer ^ position, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextSpellingErrorPosition : System.Windows.Documents.TextPointer * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetNextSpellingErrorPosition (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" /> que indica una posición desde la que buscar el siguiente error ortográfico.</param>
        <param name="direction"><see cref="T:System.Windows.Documents.LogicalDirection" /> en el que buscar el siguiente error ortográfico, a partir del valor <c>position</c> especificado.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> que señala el siguiente error ortográfico en el contenido de <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> que señala el siguiente error ortográfico en el contenido de <see cref="T:System.Windows.Controls.RichTextBox" /> o <see langword="null" /> si no hay ningún error ortográfico siguiente.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberSignature Language="F#" Value="member this.GetPositionFromPoint : System.Windows.Point * bool -&gt; System.Windows.Documents.TextPointer" Usage="richTextBox.GetPositionFromPoint (point, snapToText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">Un objeto <see cref="T:System.Windows.Point" /> que especifica la posición para la que se debe recuperar <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <param name="snapToText">Si <see langword="true" />, este método devuelve siempre un <see cref="T:System.Windows.Documents.TextPointer" /> que especifica la posición de inserción más cercana para el <see cref="T:System.Windows.Point" /> especificado, independientemente de si el <see cref="T:System.Windows.Point" /> proporcionado está o no dentro del rectángulo de selección de un carácter.  
  
Si es <see langword="false" />, este método devuelve <see langword="null" /> cuando el <see cref="T:System.Windows.Point" /> especificado no está comprendido dentro del rectángulo de selección de ningún carácter.</param>
        <summary>Devuelve un <see cref="T:System.Windows.Documents.TextPointer" /> que señala el punto de inserción más cercano a la posición especificada.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> que especifica la posición de inserción más cercana para el punto proporcionado o <see langword="null" /> si <paramref name="snapToText" /> es <see langword="false" /> y el <see cref="T:System.Windows.Point" /> proporcionado no está dentro del rectángulo de selección de ningún carácter. Observe que el <see cref="T:System.Windows.Documents.TextPointer" /> devuelto suele ser normalmente la posición entre dos caracteres. Utilice la propiedad <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> del <see cref="T:System.Windows.Documents.TextPointer" /> devuelto para determinar a cuál de los dos caracteres corresponde <see cref="T:System.Windows.Documents.TextPointer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox> usa un sistema de coordenadas estándar con el origen situado en la esquina superior izquierda de la <xref:System.Windows.Controls.RichTextBox>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se produce cuando la información de diseño para <see cref="T:System.Windows.Controls.RichTextBox" /> no está actualizada.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSpellingError">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.SpellingError GetSpellingError (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Controls.SpellingError GetSpellingError(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingError (position As TextPointer) As SpellingError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::SpellingError ^ GetSpellingError(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingError : System.Windows.Documents.TextPointer -&gt; System.Windows.Controls.SpellingError" Usage="richTextBox.GetSpellingError position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SpellingError</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" /> que especifica una posición y una dirección lógica que se resuelve como un carácter que se va a examinar para un error ortográfico. Utilice la propiedad <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> de este <see cref="T:System.Windows.Documents.TextPointer" /> para especificar la dirección del carácter que se va a examinar.</param>
        <summary>Devuelve un objeto <see cref="T:System.Windows.Controls.SpellingError" /> asociado a cualquier error ortográfico en una posición especificada en el contenido de <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Un objeto <see cref="T:System.Windows.Controls.SpellingError" /> que contiene los detalles del error ortográfico encontrado en el carácter indicado por <paramref name="position" /> o <see langword="null" /> si no hay ningún error ortográfico en el carácter especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Documents.TextPointer> como `position` normalmente especifica una posición entre dos caracteres. Use la <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propiedad de `position` para especificar qué carácter se debe examinar.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetSpellingErrorRange">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextRange GetSpellingErrorRange (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextRange GetSpellingErrorRange(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.GetSpellingErrorRange(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSpellingErrorRange (position As TextPointer) As TextRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextRange ^ GetSpellingErrorRange(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetSpellingErrorRange : System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.TextRange" Usage="richTextBox.GetSpellingErrorRange position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" /> que especifica una posición y una dirección lógica que se resuelve como un carácter que se va a examinar para un error ortográfico. Utilice la propiedad <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> de este <see cref="T:System.Windows.Documents.TextPointer" /> para especificar la dirección del carácter que se va a examinar.</param>
        <summary>Devuelve un objeto <see cref="T:System.Windows.Documents.TextRange" /> que trata cualquier palabra mal escrita en una posición especificada en el contenido de <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Un objeto <see cref="T:System.Windows.Documents.TextRange" /> que trata cualquier palabra mal escrita que incluye el carácter especificado por <paramref name="position" /> o <see langword="null" /> si no hay ningún error ortográfico en el carácter especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Documents.TextPointer> como `position` normalmente especifica una posición entre dos caracteres. Use la <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propiedad de `position` para especificar qué carácter se debe examinar.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetSpellingError(System.Windows.Documents.TextPointer)" />
        <altmember cref="M:System.Windows.Controls.RichTextBox.GetNextSpellingErrorPosition(System.Windows.Documents.TextPointer,System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabled">
      <MemberSignature Language="C#" Value="public bool IsDocumentEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDocumentEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsDocumentEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDocumentEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsDocumentEnabled : bool with get, set" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el usuario puede interactuar con los objetos <see cref="T:System.Windows.UIElement" /> y <see cref="T:System.Windows.ContentElement" /> dentro de <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value><see langword="true" /> Si el usuario puede interactuar con <see cref="T:System.Windows.UIElement" /> y <see cref="T:System.Windows.ContentElement" /> objetos dentro de la <see cref="T:System.Windows.Controls.RichTextBox" />; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> se introdujo en .NET Framework versión 3.5.  Para más información, vea [Versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea <xref:System.Windows.Controls.CheckBox> y un <xref:System.Windows.Controls.RichTextBox> que contiene un <xref:System.Windows.Documents.Hyperlink> y un <xref:System.Windows.Controls.Button>.  El <xref:System.Windows.Controls.RichTextBox.IsDocumentEnabled%2A> propiedad de la <xref:System.Windows.Controls.RichTextBox> está enlazado a la <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> propiedad de la <xref:System.Windows.Controls.CheckBox>.  Cuando el usuario selecciona el <xref:System.Windows.Controls.CheckBox>, el usuario puede interactuar con el <xref:System.Windows.Controls.Button> y <xref:System.Windows.Documents.Hyperlink>. Cuando el usuario desactiva la <xref:System.Windows.Controls.CheckBox>, <xref:System.Windows.Controls.Button> y <xref:System.Windows.Documents.Hyperlink> están deshabilitados.  
  
 [!code-xaml[RTBIsDocumentEnabled#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RTBIsDocumentEnabled/VB/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDocumentEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsDocumentEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsDocumentEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsDocumentEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsDocumentEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsDocumentEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.RichTextBox.IsDocumentEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.RichTextBox.IsDocumentEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.RichTextBox.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un enumerador que puede iterar por los elementos secundarios lógicos del control <see langword="RichTextBox" />.</summary>
        <value>Enumerador para los elementos secundarios lógicos.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="richTextBox.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">Estructura <see cref="T:System.Windows.Size" /> que especifica las restricciones de tamaño de <see cref="T:System.Windows.Controls.RichTextBox" />.</param>
        <summary>Se invoca para medir de nuevo el objeto <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Estructura <see cref="T:System.Windows.Size" /> que indica el nuevo tamaño de <see cref="T:System.Windows.Controls.RichTextBox" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Windows.Controls.Control.MeasureOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="richTextBox.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea y devuelve un objeto <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> para este control <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns>Un objeto <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> para este <see cref="T:System.Windows.Controls.RichTextBox" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpiScaleInfo, System.Windows.DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpiScaleInfo, valuetype System.Windows.DpiScale newDpiScaleInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpiScaleInfo As DpiScale, newDpiScaleInfo As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpiScaleInfo, System::Windows::DpiScale newDpiScaleInfo);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="richTextBox.OnDpiChanged (oldDpiScaleInfo, newDpiScaleInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpiScaleInfo" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpiScaleInfo" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpiScaleInfo">Configuración de escala de PPP anterior.</param>
        <param name="newDpiScaleInfo">Nueva configuración de escala de PPP.</param>
        <summary>Llamado cuando cambia el valor de PPP en el que esta cuadro de texto enriquecido se representa.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Selection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextSelection Selection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextSelection Selection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.RichTextBox.Selection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Selection As TextSelection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextSelection ^ Selection { System::Windows::Documents::TextSelection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Selection : System.Windows.Documents.TextSelection" Usage="System.Windows.Controls.RichTextBox.Selection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextSelection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Windows.Documents.TextSelection" /> que contiene la selección actual de <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value>Un objeto <see cref="T:System.Windows.Documents.TextSelection" /> que contiene la selección actual de <see cref="T:System.Windows.Controls.RichTextBox" />.  
  
El objeto <see cref="T:System.Windows.Documents.TextSelection" /> predeterminado devuelto tiene un valor de propiedad <see cref="P:System.Windows.Documents.TextRange.IsEmpty" /> de <see langword="true" />. Un objeto <see cref="T:System.Windows.Documents.TextSelection" /> vacío se representa como un símbolo de intercalación en el área de texto sin selección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Windows.Documents.TextRange.Select%2A> método para seleccionar el contenido mediante programación.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de esta propiedad.  
  
 [!code-csharp[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_rtb_selection)]
 [!code-vb[RichTextBoxSnippets#_RTB_Selection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_rtb_selection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeDocument">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.ShouldSerializeDocument" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeDocument () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeDocument();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeDocument : unit -&gt; bool" Usage="richTextBox.ShouldSerializeDocument " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si el valor efectivo de la propiedad <see cref="P:System.Windows.Controls.RichTextBox.Document" /> se debe serializar o no durante la serialización de un objeto <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <returns><see langword="true" /> si la propiedad <see cref="P:System.Windows.Controls.RichTextBox.Document" /> se debe serializar; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a agregar como elemento secundario.</param>
        <summary>Este tipo o miembro es compatible con la infraestructura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está pensado para ser usado directamente desde su código.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.RichTextBox.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Cadena que se va a agregar al objeto.</param>
        <summary>Este tipo o miembro es compatible con la infraestructura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está pensado para ser usado directamente desde su código.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>