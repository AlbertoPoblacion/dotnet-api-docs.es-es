<Type Name="NestedContainer" FullName="System.ComponentModel.NestedContainer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ff1ad8fe5eed3ccb6c84cdaef9c89968998f218b" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52224172" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NestedContainer : System.ComponentModel.Container, IDisposable, System.ComponentModel.INestedContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NestedContainer extends System.ComponentModel.Container implements class System.ComponentModel.IContainer, class System.ComponentModel.INestedContainer, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.NestedContainer" />
  <TypeSignature Language="VB.NET" Value="Public Class NestedContainer&#xA;Inherits Container&#xA;Implements IDisposable, INestedContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class NestedContainer : System::ComponentModel::Container, IDisposable, System::ComponentModel::INestedContainer" />
  <TypeSignature Language="F#" Value="type NestedContainer = class&#xA;    inherit Container&#xA;    interface INestedContainer&#xA;    interface IContainer&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Container</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.INestedContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona la implementación base para la interfaz <see cref="T:System.ComponentModel.INestedContainer" /> que permite que los contenedores tengan un componente propietario.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.NestedContainer> clase es una implementación simple de la <xref:System.ComponentModel.INestedContainer> interfaz, que define un componente que contiene cero o más componentes de forma lógica y es propiedad de un componente primario. El comportamiento de los contenedores anidados difiere de un estándar <xref:System.ComponentModel.Container> en varios aspectos, incluido lo siguiente:  
  
-   Características de sitio como <xref:System.ComponentModel.Component.DesignMode%2A> y <xref:System.ComponentModel.Component.GetService%2A> se enrutan a través del sitio del componente propietario.  
  
-   La carpeta del sitio <xref:System.ComponentModel.ISite.Name%2A> propiedad es un nombre completo que incluye el nombre del componente propietario seguido por un punto (.) y el nombre del componente secundario.  
  
-   <xref:System.ComponentModel.NestedContainer.GetService%2A> proporciona compatibilidad para el <xref:System.ComponentModel.INestedContainer> como un servicio.  
  
-   Cuando se desecha el componente propietario, también se elimina el contenedor.  
  
 Además, los diseñadores tratan los contenedores anidados de forma diferente. Solo está interesado en un contenedor de un host del diseñador, el único asociado con el host. Por lo tanto, el componente agregar y quitar eventos no se generan cuando un componente se agrega o quita de un contenedor anidado. Sin embargo, porque el flujo de servicios al contenedor anidado, se generan los eventos de cambio de componentes cuando se cambia un componente en un contenedor anidado.  
  
 Esta disparidad en el seguimiento de eventos también afecta a la funcionalidad de deshacer, que está estrechamente relacionada con la serialización. Usa el motor para deshacer estándar <xref:System.ComponentModel.Design.IReferenceService> para realizar el seguimiento de los cambios realizados en los componentes. Si el motor para deshacer no puede identificar un nombre para un componente a través del servicio de referencia, el motor pasará por alto los cambios de ese componente. Este servicio reconoce automáticamente los cambios realizados en los componentes que contiene solo si estas se exponen como propiedades públicas de solo lectura del mismo nombre en sus propietarios. En caso contrario, el desarrollador debe pasar los eventos de cambio de componente hasta el propietario. Por ejemplo, si un componente anidado `Text` propiedad se vuelve a exponerse en su componente propietario como una `Address` propiedad, cuando el `Text` se cambia la propiedad, se debe realizar mediante programación un cambio de propiedad correspondiente `Address` propiedad o de lo contrario, ese cambio no realizará el seguimiento de deshacer.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.INestedContainer" />
    <altmember cref="T:System.ComponentModel.IContainer" />
    <altmember cref="T:System.ComponentModel.ISite" />
    <altmember cref="T:System.ComponentModel.Design.IReferenceService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NestedContainer (System.ComponentModel.IComponent owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.NestedContainer.#ctor(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (owner As IComponent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NestedContainer(System::ComponentModel::IComponent ^ owner);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.NestedContainer : System.ComponentModel.IComponent -&gt; System.ComponentModel.NestedContainer" Usage="new System.ComponentModel.NestedContainer owner" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owner">Interfaz <see cref="T:System.ComponentModel.IComponent" /> propietaria del contenedor anidado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.NestedContainer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor se inscribe en su propietario <xref:System.ComponentModel.IComponent.Disposed> eventos para que el contenedor anidado <xref:System.ComponentModel.NestedContainer.Dispose%2A> automáticamente se llamará al método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="owner" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.NestedContainer.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="CreateSite">
      <MemberSignature Language="C#" Value="protected override System.ComponentModel.ISite CreateSite (System.ComponentModel.IComponent component, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.ComponentModel.ISite CreateSite(class System.ComponentModel.IComponent component, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.NestedContainer.CreateSite(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateSite (component As IComponent, name As String) As ISite" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::ComponentModel::ISite ^ CreateSite(System::ComponentModel::IComponent ^ component, System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.CreateSite : System.ComponentModel.IComponent * string -&gt; System.ComponentModel.ISite" Usage="nestedContainer.CreateSite (component, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.ComponentModel.IComponent" /> para la que se va a crear un sitio.</param>
        <param name="name">Nombre que se va a asignar a <paramref name="component" />; o bien, <see langword="null" /> para omitir la asignación de nombre.</param>
        <summary>Crea un sitio para el componente en el contenedor.</summary>
        <returns>Colección <see cref="T:System.ComponentModel.ISite" /> creada recientemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `name` parámetro es `null`, el <xref:System.ComponentModel.IComponent> se agrega al contenedor anidado sin un nombre de identificación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="component" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Container.CreateSite(System.ComponentModel.IComponent,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.NestedContainer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="nestedContainer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos utilizados por el contenedor anidado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose()` método y el <xref:System.Object.Finalize%2A> método. `Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el `disposing` parámetro es true, este método libera todos los recursos mantenidos por los objetos administrados que este <xref:System.ComponentModel.NestedContainer> referencias. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Cuando se reemplaza <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
        <altmember cref="M:System.ComponentModel.NestedContainer.#ctor(System.ComponentModel.IComponent)" />
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="protected override object GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.NestedContainer.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetService (service As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ GetService(Type ^ service);" />
      <MemberSignature Language="F#" Value="override this.GetService : Type -&gt; obj" Usage="nestedContainer.GetService service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">
          <see cref="T:System.Type" /> del servicio que se va a recuperar.</param>
        <summary>Obtiene el objeto de servicio del tipo especificado, si está disponible.</summary>
        <returns>
          <see cref="T:System.Object" /> que implementa el servicio solicitado o <see langword="null" /> si no se puede resolver el servicio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida el <xref:System.ComponentModel.Container.GetService%2A?displayProperty=nameWithType> método. Esta implementación solo resuelve las solicitudes para el <xref:System.ComponentModel.INestedContainer> y <xref:System.ComponentModel.IContainer> servicios.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.Container.GetService(System.Type)" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IComponent Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IComponent Owner" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.NestedContainer.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As IComponent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IComponent ^ Owner { System::ComponentModel::IComponent ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.ComponentModel.IComponent" Usage="System.ComponentModel.NestedContainer.Owner" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.INestedContainer.Owner</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el componente propietario de este contenedor anidado.</summary>
        <value>Interfaz <see cref="T:System.ComponentModel.IComponent" /> propietaria del contenedor anidado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El componente propietario es la característica que diferencia los contenedores anidados de los contenedores normales.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.IComponent" />
        <altmember cref="T:System.ComponentModel.IContainer" />
        <altmember cref="P:System.ComponentModel.INestedContainer.Owner" />
      </Docs>
    </Member>
    <Member MemberName="OwnerName">
      <MemberSignature Language="C#" Value="protected virtual string OwnerName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OwnerName" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.NestedContainer.OwnerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property OwnerName As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::String ^ OwnerName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerName : string" Usage="System.ComponentModel.NestedContainer.OwnerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del componente propietario.</summary>
        <value>Nombre del componente propietario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se puede invalidar para proporcionar un nombre de propietario personalizado. La implementación predeterminada busca el sitio del propietario <xref:System.ComponentModel.INestedSite> y llama a <xref:System.ComponentModel.INestedSite.FullName%2A>, o <xref:System.ComponentModel.ISite.Name%2A> si no hay ningún sitio anidado. Si ninguno está disponible, esta propiedad devuelve `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>