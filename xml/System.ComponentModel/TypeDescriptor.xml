<Type Name="TypeDescriptor" FullName="System.ComponentModel.TypeDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f63283e2770d4a1a811a89e84dd64f814fe5ede" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48751710" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit TypeDescriptor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDescriptor sealed" />
  <TypeSignature Language="F#" Value="type TypeDescriptor = class" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona información sobre las características de un componente, como sus atributos, propiedades y eventos. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework proporciona dos maneras de acceder a los metadatos de un tipo: la reflexión proporciona API en el <xref:System.Reflection?displayProperty=nameWithType> espacio de nombres y el <xref:System.ComponentModel.TypeDescriptor> clase. Reflexión es un mecanismo general disponible para todos los tipos porque su base se establece en el <xref:System.Object.GetType%2A> método de la raíz <xref:System.Object> clase. La información que se devuelve para un tipo no es extensible, en que no se puede modificar después de la compilación del tipo de destino. Para obtener más información, vea los temas de [reflexión](~/docs/framework/reflection-and-codedom/reflection.md).  
  
 En cambio, <xref:System.ComponentModel.TypeDescriptor> es un mecanismo de inspección extensible para componentes: las clases que implementan la <xref:System.ComponentModel.IComponent> interfaz. A diferencia de la reflexión, no inspecciona los métodos. <xref:System.ComponentModel.TypeDescriptor> se puede ampliar dinámicamente mediante varios servicios disponibles a través del componente de destino <xref:System.ComponentModel.Component.Site%2A>. En la tabla siguiente se muestra estos servicios.  
  
|Nombre del servicio|Descripción|  
|------------------|-----------------|  
|<xref:System.ComponentModel.IExtenderProvider>|Habilita otra clase, como <xref:System.Windows.Forms.ToolTip>, para proporcionar propiedades adicionales a un componente.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Permite que otro objeto modificar los metadatos estándar que se exponen mediante un componente.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor>|Permite que una clase dinámicamente y completamente especificar sus propios metadatos, reemplazando el mecanismo estándar de inspección de <xref:System.ComponentModel.TypeDescriptor>.|  
  
 La extensibilidad proporcionadas por <xref:System.ComponentModel.TypeDescriptor> permite la representación en tiempo de diseño de un componente difiera de su representación de tiempo de ejecución real, lo que hace que <xref:System.ComponentModel.TypeDescriptor> útil para crear la infraestructura en tiempo de diseño.  
  
 Todos los métodos de <xref:System.ComponentModel.TypeDescriptor> son `static`. No se puede crear una instancia de esta clase y no se puede heredar esta clase.  
  
 Puede establecer la propiedad y valores de dos formas diferentes de los eventos: especificarlos en la clase de componente o cambiarlos en tiempo de diseño. Dado que puede establecer estos valores de dos formas, los métodos sobrecargados de <xref:System.ComponentModel.TypeDescriptor> realizar dos tipos diferentes de parámetros: un tipo de clase o una instancia de objeto.  
  
 Si desea tener acceso a <xref:System.ComponentModel.TypeDescriptor> información y tiene una instancia del objeto, utilice el método que llama a un componente. Utilice el método que llama al tipo de clase sólo cuando no tiene una instancia del objeto.  
  
 Propiedades y eventos se almacenan en caché por <xref:System.ComponentModel.TypeDescriptor> para acelerar el proceso. Normalmente, son constantes durante la vigencia de un objeto. Sin embargo, los diseñadores y los proveedores extensores pueden cambiar el conjunto de propiedades en un objeto. Si es así, el <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método debe llamarse para actualizar la memoria caché.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.EventDescriptor" />
    <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.ComponentModel.IComponent" />
    <altmember cref="T:System.ComponentModel.ISite" />
    <related type="Article" href="http://msdn.microsoft.com/library/e81b8e2f-e06e-44fa-8129-7bdb0230101f">Información general sobre descriptores de tipos</related>
    <related type="Article" href="http://msdn.microsoft.com/library/d1a58e7f-fb39-4d50-bf84-e3b8f9bf9775">Reflexión</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega atributos de nivel de clase al componente de destino.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (object instance, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(object instance, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddAttributes (instance As Object, ParamArray attributes As Attribute()) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(System::Object ^ instance, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member AddAttributes : obj * Attribute[] -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.AddAttributes (instance, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">Instancia del componente de destino.</param>
        <param name="attributes">Matriz de objetos <see cref="T:System.Attribute" /> que se va a agregar a la clase del componente.</param>
        <summary>Agrega atributos de nivel de clase a la instancia del componente de destino.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> recién creado que se ha utilizado para agregar los atributos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Object%2CSystem.Attribute%5B%5D%29> método agrega los atributos de nivel de clase a la instancia especificada de un componente. Dado que esto es un requisito común de aplicaciones mediante el Diseñador de formularios de Windows de Visual Studio y la ventana Propiedades, este método proporciona un acceso directo mediante la creación de un proveedor de descripción de tipo que combina los atributos proporcionados con los atributos que ya existe en la clase. El valor devuelto es el proveedor de descripción de tipos que se usó para agregar los atributos. Este proveedor más adelante puede pasarse a la <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método cuando ya no son necesarios los atributos agregados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider AddAttributes (Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider AddAttributes(class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddAttributes(System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ AddAttributes(Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member AddAttributes : Type * Attribute[] -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.AddAttributes (type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <param name="attributes">Matriz de objetos <see cref="T:System.Attribute" /> que se va a agregar a la clase del componente.</param>
        <summary>Agrega atributos de nivel de clase al tipo del componente de destino.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> recién creado que se ha utilizado para agregar los atributos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.AddAttributes%28System.Type%2CSystem.Attribute%5B%5D%29> método agrega los atributos de nivel de clase para el tipo de un componente especificado. Dado que esto es un requisito común de aplicaciones mediante el Diseñador de formularios de Windows de Visual Studio y la ventana Propiedades, este método proporciona un acceso directo mediante la creación de un proveedor de descripción de tipo que combina los atributos proporcionados con los atributos que ya existe en la clase. El valor devuelto es el proveedor de descripción de tipos que se usó para agregar los atributos. Este proveedor más adelante puede pasarse a la <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método cuando ya no son necesarios los atributos agregados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
      </Docs>
    </Member>
    <Member MemberName="AddEditorTable">
      <MemberSignature Language="C#" Value="public static void AddEditorTable (Type editorBaseType, System.Collections.Hashtable table);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddEditorTable(class System.Type editorBaseType, class System.Collections.Hashtable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddEditorTable (editorBaseType As Type, table As Hashtable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddEditorTable(Type ^ editorBaseType, System::Collections::Hashtable ^ table);" />
      <MemberSignature Language="F#" Value="static member AddEditorTable : Type * System.Collections.Hashtable -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddEditorTable (editorBaseType, table)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="table" Type="System.Collections.Hashtable" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">Tipo base de editor al que se va a agregar la tabla de editor. Si ya existe una tabla de este tipo, este método no hará nada.</param>
        <param name="table">
          <see cref="T:System.Collections.Hashtable" /> que se va a sumar.</param>
        <summary>Agrega una tabla de editor para el tipo base de editor determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.AddEditorTable%2A> método agrega una tabla de editor para el tipo base del editor especificado. Normalmente, los editores se especifican como metadatos en un componente. Sin embargo, si no hay metadatos para un base de editor solicitado se encuentra un tipo en el componente, el asociado <xref:System.ComponentModel.TypeDescriptor> buscará una tabla de editor para el tipo de editor, si no se encuentra uno. Una vez que se ha agregado una tabla de editor para un descriptor de tipos, no se puede quitar y es propiedad de descriptor de tipos. El descriptor de tipo libremente puede realizar modificaciones en esta tabla.  
  
 El formato de una tabla de editor utiliza los tipos de datos como claves y los editores como valores. La parte del valor de una entrada en la tabla representa una instancia del editor. Puede tener uno de tres valores. Si contiene una cadena, el descriptor de tipos supondrá que es un nombre completo de un tipo y, a continuación, carga el tipo del objeto. Si contiene un tipo, se creará una instancia de este tipo para obtener un editor. Por último, la parte de valor puede contener una instancia del editor de valores reales. Si el descriptor de tipo se resuelve como un editor para una instancia, almacenará la instancia en la tabla para su uso futuro.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un proveedor de descripción de tipos a la lista de proveedores de este descriptor de tipos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member AddProvider : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProvider (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> que se va a sumar.</param>
        <param name="instance">Instancia del componente de destino.</param>
        <summary>Agrega un proveedor de descripción de tipos para una única instancia de un componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método agrega un proveedor de descripción de tipo que proporciona información para una sola instancia de un componente de tipo. Si se agrega un proveedor de este método, el proveedor del <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> método no se llamará porque la instancia ya existe.  
  
 Este método no mantiene una referencia codificada al componente, por lo que no impide que el componente de finalización.  
  
 Es posible agregar varios proveedores de descripción de tipo para el mismo tipo u objeto. Si esto ocurre, se usará exclusivamente el primer tipo proveedor de descripción detectado que proporciona información de tipo. Dado que los proveedores de información de tipo se almacenan en una pila, el último proveedor agregado será la primera de ellas consultada. Este comportamiento permite la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> y <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> proveedores de descripción de tipos de métodos que se usará para la inserción y extracción según sea necesario para escenarios concretos.  
  
 Si es correcto, este método llama a la <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Object%29> método en el `instance` parámetro.  
  
> [!NOTE]
>  Las dos versiones de este método generan resultados con ámbitos diferentes. El <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> método que toma un <xref:System.Object> parámetro afecta solo a esa única instancia del componente especificado. En cambio, la otra sobrecarga, que toma un <xref:System.Type> parámetro, afecta a todas las instancias del componente descrito por ese tipo.  
  
 Use el <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método si tiene que llamar desde código de confianza parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="AddProvider">
      <MemberSignature Language="C#" Value="public static void AddProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member AddProvider : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProvider (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> que se va a sumar.</param>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Agrega un proveedor de descripción de tipos para una clase de componentes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método agrega un proveedor de descripción de tipo que proporciona información de tipo para la clase especificada, las clases derivadas y todas las instancias de estos tipos.  
  
> [!NOTE]
>  El `type` parámetro puede ser cualquier tipo, incluida una interfaz. Por ejemplo, para proporcionar información de instancia para todos los componentes y de tipo personalizado, especifique `typeof(IComponent)`. Pasar `typeof(object)` llamará al proveedor para proporcionar información de todos los tipos.  
  
 Este método no mantiene una referencia a cualquier objeto, disco dura para impedir que los objetos finalizando.  
  
 Es posible agregar varios proveedores de descripción de tipo para el mismo tipo u objeto. Si esto ocurre, se usará exclusivamente el primer tipo proveedor de descripción detectado que proporciona información de tipo. Dado que los proveedores de información de tipo se almacenan en una pila, el último proveedor agregado será la primera de ellas consultada. Este comportamiento permite la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> y <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%2A> proveedores de descripción de tipos de métodos que se usará para la inserción y extracción según sea necesario para escenarios concretos.  
  
 Si es correcto, este método llama a la <xref:System.ComponentModel.TypeDescriptor.Refresh%28System.Type%29> método en el `type` parámetro.  
  
> [!NOTE]
>  Las dos versiones de este método generan resultados con ámbitos diferentes. El <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> método que toma un <xref:System.Object> parámetro afecta solo a esa única instancia del componente especificado. En cambio, la otra sobrecarga, que toma un <xref:System.Type> parámetro, afecta a todas las instancias del componente descrito por ese tipo.  
  
 Use el <xref:System.ComponentModel.TypeDescriptor.AddProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método si tiene que llamar desde código de confianza parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un proveedor de descripción de tipos a la lista de proveedores de este descriptor de tipos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member AddProviderTransparent : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProviderTransparent (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> que se va a sumar.</param>
        <param name="instance">Instancia del componente de destino.</param>
        <summary>Agrega un proveedor de descripción de tipos para una única instancia de un componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede llamar a este método desde el código de confianza parcial. Si <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> está definido, el llamador puede registrar un proveedor para la instancia especificada si su tipo también es de confianza parcial.  
  
 Use el <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método si no es necesario llamar a código de confianza parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acceder al registro. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo de asociado: el <see cref="T:System.Security.PermissionSet" /> requerido por el ensamblado que define el <paramref name="instance" /> tipo del parámetro.</permission>
      </Docs>
    </Member>
    <Member MemberName="AddProviderTransparent">
      <MemberSignature Language="C#" Value="public static void AddProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.AddProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member AddProviderTransparent : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.AddProviderTransparent (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> que se va a sumar.</param>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Agrega un proveedor de descripción de tipos para una clase de componentes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede llamar a este método desde el código de confianza parcial. Si <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> está definido, el llamador puede registrar un proveedor para el tipo especificado si también es de confianza parcial.  
  
 Use el <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método si no es necesario llamar a código de confianza parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acceder al registro. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo de asociado: el <see cref="T:System.Security.PermissionSet" /> requerido por el ensamblado que define <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ComNativeDescriptorHandler">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.ComponentModel.IComNativeDescriptorHandler ComNativeDescriptorHandler" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ComNativeDescriptorHandler As IComNativeDescriptorHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::ComponentModel::IComNativeDescriptorHandler ^ ComNativeDescriptorHandler { System::ComponentModel::IComNativeDescriptorHandler ^ get(); void set(System::ComponentModel::IComNativeDescriptorHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ComNativeDescriptorHandler : System.ComponentModel.IComNativeDescriptorHandler with get, set" Usage="System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("This property has been deprecated.  Use a type description provider to supply type information for COM types instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComNativeDescriptorHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el proveedor de la información de tipos COM (Component Object Model, Modelo de objetos componentes) del componente de destino.</summary>
        <value>Instancia <see cref="T:System.ComponentModel.IComNativeDescriptorHandler" /> que representa el proveedor de información de tipos COM.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler%2A> propiedad y el <xref:System.ComponentModel.IComNativeDescriptorHandler> interfaz están obsoletos. Para obtener más información, vea la propiedad <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      </Docs>
    </Member>
    <Member MemberName="ComObjectType">
      <MemberSignature Language="C#" Value="public static Type ComObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type ComObjectType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ComObjectType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ ComObjectType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ComObjectType : Type" Usage="System.ComponentModel.TypeDescriptor.ComObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del objeto COM (Component Object Model, Modelo de objetos componentes) que representa el componente de destino.</summary>
        <value>
          <see cref="T:System.Type" /> del objeto COM que representa este componente o <see langword="null" /> para los objetos que no sean COM.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> propiedad devuelve un tipo que se puede pasar a la <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método para definir tipos COM en un proveedor de descripción de tipo.  
  
 El <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A> propiedad y otros miembros de esta clase sustituyen la funcionalidad en el atributo obsolete <xref:System.ComponentModel.IComNativeDescriptorHandler> interfaz. Para implementar una capa de asignación entre un objeto COM y <xref:System.ComponentModel.TypeDescriptor>, agregue un <xref:System.ComponentModel.TypeDescriptionProvider> para controlar el tipo <xref:System.ComponentModel.TypeDescriptor.ComObjectType%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.TypeDescriptor.ComNativeDescriptorHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateAssociation">
      <MemberSignature Language="C#" Value="public static void CreateAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberSignature Language="F#" Value="static member CreateAssociation : obj * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.CreateAssociation (primary, secondary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">
          <see cref="T:System.Object" /> principal.</param>
        <param name="secondary">
          <see cref="T:System.Object" /> secundario.</param>
        <summary>Crea una asociación de principal-secundario entre dos objetos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método crea una asociación entre un elemento principal y un objeto secundario. Una vez creada una asociación, un diseñador u otro mecanismo de filtrado puede agregar propiedades que se enrutan a cualquiera de los objetos en el conjunto de propiedades del objeto principal. Cuando se realiza una llamada a una propiedad con el objeto principal, el <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> se llamará el método para resolver la instancia del objeto real que está relacionada con su parámetro de tipo.  
  
 Un <xref:System.WeakReference> se usa para mantener la asociación entre el objeto principal y secundaria; por lo tanto, este método no impide que cualquiera de los objetos que se está finalizando y recolección de elementos no utilizados reclame.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="primary" /> es igual a <paramref name="secondary" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, Type designerBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, class System.Type designerBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDesigner (component As IComponent, designerBaseType As Type) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, Type ^ designerBaseType);" />
      <MemberSignature Language="F#" Value="static member CreateDesigner : System.ComponentModel.IComponent * Type -&gt; System.ComponentModel.Design.IDesigner" Usage="System.ComponentModel.TypeDescriptor.CreateDesigner (component, designerBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="designerBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.ComponentModel.IComponent" /> que especifica el componente que se va a asociar al diseñador.</param>
        <param name="designerBaseType">
          <see cref="T:System.Type" /> que representa el tipo de diseñador que se va a crear.</param>
        <summary>Crea una instancia del diseñador asociado al componente especificado y del tipo especificado de diseñador.</summary>
        <returns>
          <see cref="T:System.ComponentModel.Design.IDesigner" /> que es una instancia del diseñador del componente o <see langword="null" /> si no se encuentra ningún diseñador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este método no puede encontrar un válido <xref:System.ComponentModel.DesignerAttribute>, buscará la jerarquía de clases para un diseñador. Si no encuentra un diseñador en la jerarquía de clases, devuelve `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.IComponent" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo descriptor de eventos que es idéntico a otro existente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, System.ComponentModel.EventDescriptor oldEventDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, class System.ComponentModel.EventDescriptor oldEventDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.ComponentModel.EventDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateEvent (componentType As Type, oldEventDescriptor As EventDescriptor, ParamArray attributes As Attribute()) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::ComponentModel::EventDescriptor ^ oldEventDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateEvent : Type * System.ComponentModel.EventDescriptor * Attribute[] -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateEvent (componentType, oldEventDescriptor, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldEventDescriptor" Type="System.ComponentModel.EventDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">Tipo del componente para el que se va a crear el nuevo evento.</param>
        <param name="oldEventDescriptor">Información del evento existente.</param>
        <param name="attributes">Atributos nuevos.</param>
        <summary>Crea un nuevo descriptor de eventos que es idéntico a otro existente, una vez pasado el <see cref="T:System.ComponentModel.EventDescriptor" /> existente.</summary>
        <returns>Un nuevo <see cref="T:System.ComponentModel.EventDescriptor" /> que ha combinado los atributos de metadatos especificados y los atributos de metadatos existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Obligatorio para inspeccionar a los miembros no públicos del componente. Vincular el acceso a petición necesario para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor CreateEvent (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor CreateEvent(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateEvent(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ CreateEvent(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateEvent : Type * string * Type * Attribute[] -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateEvent (componentType, name, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">Tipo del componente donde reside el evento.</param>
        <param name="name">Nombre del evento.</param>
        <param name="type">Tipo de delegado que controla el evento.</param>
        <param name="attributes">Atributos de este evento.</param>
        <summary>Crea un nuevo descriptor de eventos que es idéntico a otro existente generando dinámicamente la información sobre descriptores a partir de un evento especificado en un tipo.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> que está enlazado a un tipo.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Obligatorio para inspeccionar a los miembros no públicos del componente. Vincular el acceso a petición necesario para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (provider As IServiceProvider, objectType As Type, argTypes As Type(), args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(IServiceProvider ^ provider, Type ^ objectType, cli::array &lt;Type ^&gt; ^ argTypes, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.CreateInstance (provider, objectType, argTypes, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">Proveedor de servicios que proporciona un servicio de <see cref="T:System.ComponentModel.TypeDescriptionProvider" />. Este parámetro puede ser <see langword="null" />.</param>
        <param name="objectType">Objeto <see cref="T:System.Type" />que se va a crear.</param>
        <param name="argTypes">Matriz opcional de tipos de parámetros que se pasarán al constructor del objeto. Este parámetro puede ser <see langword="null" /> o una matriz de longitud cero.</param>
        <param name="args">Matriz opcional de valores de parámetro que se va a pasar al constructor del objeto. Si no es <see langword="null" />, el número de elementos debe ser el mismo que <c>argTypes</c>.</param>
        <summary>Crea un objeto que puede sustituir a otro tipo de datos.</summary>
        <returns>Instancia del tipo de datos suplente si se encuentra un objeto <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> asociado; de lo contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A> método buscará un <xref:System.ComponentModel.TypeDescriptionProvider> que está asociado con los valores especificados `objectType` tipo de datos. Este método primero intenta obtener un proveedor de descripción de tipos desde el `provider` parámetro. Si se produce un error, lo busca en sus propias tablas internas para un proveedor (estas entradas se crean a través de las llamadas anteriores a <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A>). Si encuentra un proveedor, este método delega la llamada de creación a ese objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> es <see langword="null" />, o <paramref name="args" /> es <see langword="null" /> cuando <paramref name="argTypes" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="argTypes" /> y <paramref name="args" /> tienen distinto número de elementos.</exception>
        <block subset="none" type="overrides">
          <para>Si la clase derivada no proporciona una instancia suplente, este método debe llamar a la implementación base.</para>
        </block>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo descriptor de propiedades para una propiedad existente de un componente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, class System.ComponentModel.PropertyDescriptor oldPropertyDescriptor, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.ComponentModel.PropertyDescriptor,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProperty (componentType As Type, oldPropertyDescriptor As PropertyDescriptor, ParamArray attributes As Attribute()) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::ComponentModel::PropertyDescriptor ^ oldPropertyDescriptor, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateProperty : Type * System.ComponentModel.PropertyDescriptor * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateProperty (componentType, oldPropertyDescriptor, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="oldPropertyDescriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> del componente del que la propiedad es miembro.</param>
        <param name="oldPropertyDescriptor">El descriptor de la propiedad existente.</param>
        <param name="attributes">Nuevos atributos de esta propiedad.</param>
        <summary>Crea un nuevo descriptor de propiedades a partir de un descriptor de propiedades existente, utilizando la matriz de atributos y el objeto <see cref="T:System.ComponentModel.PropertyDescriptor" /> existentes especificados.</summary>
        <returns>Nuevo objeto <see cref="T:System.ComponentModel.PropertyDescriptor" /> en el que están combinados los atributos de metadatos especificados y los atributos de metadatos existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Obligatorio para inspeccionar a los miembros no públicos del componente. Vincular el acceso a petición necesario para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor CreateProperty (Type componentType, string name, Type type, params Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor CreateProperty(class System.Type componentType, string name, class System.Type type, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.CreateProperty(System.Type,System.String,System.Type,System.Attribute[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ CreateProperty(Type ^ componentType, System::String ^ name, Type ^ type, ... cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CreateProperty : Type * string * Type * Attribute[] -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.CreateProperty (componentType, name, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> del componente del que la propiedad es miembro.</param>
        <param name="name">El nombre de la propiedad.</param>
        <param name="type">
          <see cref="T:System.Type" /> de la propiedad.</param>
        <param name="attributes">Nuevos atributos de esta propiedad.</param>
        <summary>Crea un descriptor de propiedades y lo enlaza dinámicamente a un tipo, utilizando el nombre de propiedad, el tipo y la matriz de atributos especificados.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.PropertyDescriptor" /> enlazado al tipo especificado y que tiene los atributos de metadatos especificados combinados con los atributos de metadatos existentes.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Obligatorio para inspeccionar a los miembros no públicos del componente. Vincular el acceso a petición necesario para <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /> tipo <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetAssociation">
      <MemberSignature Language="C#" Value="public static object GetAssociation (Type type, object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAssociation(class System.Type type, object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAssociation(Type ^ type, System::Object ^ primary);" />
      <MemberSignature Language="F#" Value="static member GetAssociation : Type * obj -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetAssociation (type, primary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <param name="primary">Objeto principal de la asociación.</param>
        <summary>Devuelve una instancia del tipo asociado al objeto principal especificado.</summary>
        <returns>Si existe una asociación, instancia del tipo secundario que se ha asociado al objeto principal; de lo contrario, si no hay ninguna asociación especificada, <paramref name="primary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se ha realizado una asociación anterior el `type` parámetro mediante el <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método, el <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> método devuelve el objeto secundario correcto para invocar el tipo solicitado. En caso contrario, <xref:System.ComponentModel.TypeDescriptor.GetAssociation%2A> busca un diseñador compatible para `type` y devuelve el diseñador, si lo hay. Este método nunca devuelve `null`.  
  
 Un <xref:System.WeakReference> se usa para mantener la asociación entre el objeto principal y secundaria; por lo tanto, este método no impide que el objeto principal o secundario que se está finalizado y recolección de elementos no utilizados reclame.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.Design.IDesignerHost.GetDesigner(System.ComponentModel.IComponent)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttributes">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la colección de atributos para un componente o un tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : obj -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente del que se desea obtener atributos.</param>
        <summary>Devuelve la colección de atributos para el componente especificado.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.AttributeCollection" /> que contiene los atributos para el componente. Si <paramref name="component" /> es <see langword="null" />, este método devuelve una colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los atributos devueltos por la <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> método se puede modificar dinámicamente desde el origen del componente original enumerar proveedores extensores (<xref:System.ComponentModel.IExtenderProvider>), filtrar servicios (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) y los filtros de atributo.  
  
 Al definir un atributo personalizado con <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> establecido en `true`, debe invalidar el <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad para que sea único. Si todas las instancias del atributo son únicas, invalidar <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para devolver la identidad del objeto del atributo. Si sólo algunas instancias del atributo son únicos, devuelven un valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que devolvería igualdad en esos casos. Por ejemplo, algunos atributos tienen un parámetro de constructor que actúa como una clave única. Para estos atributos, devolver el valor del parámetro de constructor de la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad.  
  
> [!NOTE]
>  La implementación predeterminada de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> devuelve la identidad de tipo independientemente del valor de la <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propiedad. Con el fin de devolver varias instancias de un <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> atributo desde el <xref:System.ComponentModel.AttributeCollection>, el atributo debe reemplazar el <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad.  
  
   
  
## Examples  
 Para obtener un ejemplo de este método, consulte el <xref:System.ComponentModel.AttributeCollection.Matches%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (componentType As Type) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : Type -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Devuelve una colección de atributos para el tipo de componente especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AttributeCollection" /> con los atributos del tipo del componente. Si el componente es <see langword="null" />, este método devolverá una colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 Para los atributos con <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> establecido en `true`, la colección de atributos quita las instancias duplicadas. Éstas son las instancias en el que el <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad devuelve los mismos valores.  
  
 Al definir un atributo personalizado con <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> establecido en `true`, debe invalidar el <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad para que sea único. Si todas las instancias del atributo son únicas, invalidar <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para devolver la identidad del objeto del atributo. Si sólo algunas instancias del atributo son únicos, devuelven un valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que devolvería igualdad en esos casos. Por ejemplo, algunos atributos tienen un parámetro de constructor que actúa como una clave única. Para estos atributos, devolver el valor del parámetro de constructor de la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad.  
  
> [!NOTE]
>  La implementación predeterminada de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> devuelve la identidad de tipo independientemente del valor de la <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propiedad. Con el fin de devolver varias instancias de un <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> atributo desde el <xref:System.ComponentModel.AttributeCollection>, el atributo debe reemplazar el <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.AttributeCollection GetAttributes (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.AttributeCollection GetAttributes(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetAttributes(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (component As Object, noCustomTypeDesc As Boolean) As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::AttributeCollection ^ GetAttributes(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : obj * bool -&gt; System.ComponentModel.AttributeCollection" Usage="System.ComponentModel.TypeDescriptor.GetAttributes (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente del que se desea obtener atributos.</param>
        <param name="noCustomTypeDesc">
          <see langword="true" /> para usar un conjunto de línea de base de atributos del descriptor de tipos personalizado si <c>component</c> es de tipo <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />; de lo contrario, <see langword="false" />.</param>
        <summary>Devuelve una colección de atributos para el componente especificado, así como un valor Boolean que indica que se ha creado un descriptor de tipos personalizado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.AttributeCollection" /> con los atributos del componente. Si el componente es <see langword="null" />, este método devolverá una colección vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los atributos devueltos por la <xref:System.ComponentModel.TypeDescriptor.GetAttributes%2A> método se puede modificar dinámicamente desde el origen inicial de los componentes enumerar proveedores extensores (<xref:System.ComponentModel.IExtenderProvider>), filtrar servicios (<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>) y los filtros de atributo.  
  
 Al definir un atributo personalizado con <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> establecido en `true`, debe invalidar el <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad para que sea único. Si todas las instancias del atributo son únicas, invalidar <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> para devolver la identidad del objeto del atributo. Si sólo algunas instancias del atributo son únicos, devuelven un valor de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> que devolvería igualdad en esos casos. Por ejemplo, algunos atributos tienen un parámetro de constructor que actúa como una clave única. Para estos atributos, devolver el valor del parámetro de constructor de la <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad.  
  
> [!NOTE]
>  La implementación predeterminada de <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> devuelve la identidad de tipo independientemente del valor de la <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> propiedad. Con el fin de devolver varias instancias de un <xref:System.AttributeUsageAttribute.AllowMultiple%2A?displayProperty=nameWithType> atributo desde el <xref:System.ComponentModel.AttributeCollection>, el atributo debe reemplazar el <xref:System.Attribute.TypeId%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Attribute" />
        <altmember cref="T:System.ComponentModel.AttributeCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetClassName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el nombre de la clase para el componente especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetClassName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> para el que se desea obtener el nombre de clase.</param>
        <summary>Devuelve el nombre de la clase para el componente especificado utilizando el descriptor de tipos predeterminado.</summary>
        <returns>
          <see cref="T:System.String" /> que contiene el nombre de la clase para el componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, este método devuelve el completo <xref:System.Type> nombre para el `component` tipo de parámetro. Por ejemplo, el nombre de clase para un botón es "System.Windows.Forms.Button". Si `component` implementa <xref:System.ComponentModel.ICustomTypeDescriptor>, puede devolver un nombre alternativo.  
  
 Este método es equivalente a sobrecargado <xref:System.ComponentModel.TypeDescriptor.GetClassName%28System.Object%2CSystem.Boolean%29> método con un segundo parámetro de `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (componentType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetClassName : Type -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Devuelve el nombre de la clase para el tipo especificado.</summary>
        <returns>
          <see cref="T:System.String" /> que contiene el nombre de la clase para el tipo de componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método utiliza el descriptor de tipo personalizado en caché para el tipo especificado para detectar el nombre de clase asociada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetClassName">
      <MemberSignature Language="C#" Value="public static string GetClassName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClassName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetClassName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClassName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClassName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetClassName : obj * bool -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetClassName (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> para el que se desea obtener el nombre de clase.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve el nombre de la clase para el componente especificado utilizando un descriptor de tipos personalizado.</summary>
        <returns>
          <see cref="T:System.String" /> que contiene el nombre de la clase para el componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, este método devuelve el completo <xref:System.Type> nombre para el `component` tipo de parámetro. Por ejemplo, el nombre de clase para un botón es "System.Windows.Forms.Button". Si el `component` parámetro implementa <xref:System.ComponentModel.ICustomTypeDescriptor>, puede devolver un nombre alternativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetClassName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetComponentName">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el nombre del componente especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetComponentName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> para el que se desea obtener el nombre de clase.</param>
        <summary>Devuelve el nombre del componente especificado utilizando el descriptor de tipos predeterminado.</summary>
        <returns>
          <see cref="T:System.String" /> que contiene el nombre del componente especificado o <see langword="null" /> si no hay ningún nombre de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, este método devuelve el nombre para el sitio del componente, si existe alguno. Por ejemplo, el nombre de clase para un botón es "System.Windows.Forms.Button".  
  
 Este método es equivalente a sobrecargado <xref:System.ComponentModel.TypeDescriptor.GetComponentName%28System.Object%2CSystem.Boolean%29> método con un segundo parámetro de `false`.  
  
 Este método se utiliza en tiempo de diseño para recuperar el nombre de una instancia de un componente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <Member MemberName="GetComponentName">
      <MemberSignature Language="C#" Value="public static string GetComponentName (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetComponentName(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetComponentName(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetComponentName (component As Object, noCustomTypeDesc As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetComponentName(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetComponentName : obj * bool -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetComponentName (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">
          <see cref="T:System.Object" /> para el que se desea obtener el nombre de clase.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve el nombre del componente especificado utilizando un descriptor de tipos personalizado.</summary>
        <returns>Nombre de la clase para el componente especificado o <see langword="null" /> si no hay ningún nombre de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza en tiempo de diseño para recuperar el nombre de una instancia de un componente. Normalmente, este método devuelve el nombre para el sitio del componente, si existe alguno. Por ejemplo, el nombre de clase para un botón es "System.Windows.Forms.Button". Si el componente implementa la <xref:System.ComponentModel.ICustomTypeDescriptor> interfaz, puede devolver un nombre alternativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetComponentName" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConverter">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un convertidor de tipos para un componente o un tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetConverter : obj -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se va a obtener el convertidor.</param>
        <summary>Devuelve un convertidor de tipos para el tipo del componente especificado.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.TypeConverter" /> para el componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método localiza un convertidor de tipos adecuado mediante la búsqueda de un <xref:System.ComponentModel.TypeConverterAttribute>. Si no encuentra un <xref:System.ComponentModel.TypeConverterAttribute>, recorre la jerarquía de clases base de la clase hasta que encuentra un tipo primitivo.  
  
 Este método es equivalente a sobrecargado <xref:System.ComponentModel.TypeDescriptor.GetConverter%2A> método con un segundo parámetro de `false`.  
  
   
  
## Examples  
 Para obtener un ejemplo del uso de este método, consulte el <xref:System.ComponentModel.TypeConverter> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Devuelve un convertidor de tipos para el tipo especificado.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.TypeConverter" /> del tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 Este método busca el convertidor de tipos adecuado mediante la búsqueda de un <xref:System.ComponentModel.TypeConverterAttribute>. Si no encuentra un <xref:System.ComponentModel.TypeConverterAttribute>, recorre la jerarquía de clases base de la clase hasta que encuentra un tipo primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeConverter GetConverter (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeConverter GetConverter(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetConverter (component As Object, noCustomTypeDesc As Boolean) As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeConverter ^ GetConverter(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetConverter : obj * bool -&gt; System.ComponentModel.TypeConverter" Usage="System.ComponentModel.TypeDescriptor.GetConverter (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se va a obtener el convertidor.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve un convertidor de tipos para el tipo del componente especificado con un descriptor de tipos personalizado.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.TypeConverter" /> para el componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca el convertidor de tipos adecuada, intentando encontrar un <xref:System.ComponentModel.TypeConverterAttribute>. Si no encuentra un <xref:System.ComponentModel.TypeConverterAttribute>, recorre la jerarquía de clases base de la clase hasta que encuentra un tipo primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateDesigner(System.ComponentModel.IComponent,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultEvent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el evento predeterminado para un componente o tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : obj -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se va a obtener el evento.</param>
        <summary>Devuelve el evento predeterminado para el componente especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> con el evento predeterminado o <see langword="null" /> si no hay eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a sobrecargado <xref:System.ComponentModel.TypeDescriptor.GetDefaultEvent%28System.Object%2CSystem.Boolean%29> método con un segundo parámetro de `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (componentType As Type) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : Type -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Devuelve el evento predeterminado para el tipo especificado de componente.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> con el evento predeterminado o <see langword="null" /> si no hay eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultEvent">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptor GetDefaultEvent (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultEvent(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultEvent (component As Object, noCustomTypeDesc As Boolean) As EventDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptor ^ GetDefaultEvent(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetDefaultEvent : obj * bool -&gt; System.ComponentModel.EventDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultEvent (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se va a obtener el evento.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve el evento predeterminado para un componente con un descriptor de tipos personalizado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptor" /> con el evento predeterminado o <see langword="null" /> si no hay eventos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.DefaultEventAttribute" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.CustomTypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDefaultProperty">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la propiedad predeterminada para un componente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : obj -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente del que se va a obtener la propiedad predeterminada.</param>
        <summary>Devuelve la propiedad predeterminada para el componente especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> con la propiedad predeterminada o <see langword="null" /> si no hay propiedades.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `component` parámetro es `null`, este método devuelve `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (componentType As Type) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : Type -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> que representa la clase de la que se va a obtener la propiedad.</param>
        <summary>Devuelve la propiedad predeterminada para el tipo de componente especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> con la propiedad predeterminada o <see langword="null" /> si no hay propiedades.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 Si el `componentType` parámetro es `null`, este método devuelve `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptor GetDefaultProperty (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetDefaultProperty(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProperty (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptor ^ GetDefaultProperty(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetDefaultProperty : obj * bool -&gt; System.ComponentModel.PropertyDescriptor" Usage="System.ComponentModel.TypeDescriptor.GetDefaultProperty (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente del que se va a obtener la propiedad predeterminada.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve la propiedad predeterminada para el componente especificado con un descriptor de tipos personalizado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> con la propiedad predeterminada o <see langword="null" /> si no hay propiedades.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `component` parámetro es `null`, este método devuelve `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.DefaultPropertyAttribute" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEditor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un editor con el tipo base especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="static member GetEditor : obj * Type -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (component, editorBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se va a obtener el editor.</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" /> que representa el tipo base del editor que se desea buscar.</param>
        <summary>Obtiene un editor con el tipo base especificado para el componente especificado.</summary>
        <returns>Instancia del editor que se puede convertir al tipo de editor especificado o <see langword="null" /> si no se puede encontrar ningún editor del tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo de `editorBaseType` suele ser <xref:System.Drawing.Design.UITypeEditor>, pero también puede utilizar otros tipos (por ejemplo, <xref:System.ComponentModel.ComponentEditor> y <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Puede definir varios editores para una propiedad. Utilice este método para seleccionar el editor que desee utilizar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> o <paramref name="editorBaseType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
        <related type="Article" href="http://msdn.microsoft.com/library/f068b4ea-6e8c-4c0b-aefd-188b337240da">Información general sobre editores de tipos de interfaz de usuario</related>
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (Type type, Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(class System.Type type, class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Type,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(Type ^ type, Type ^ editorBaseType);" />
      <MemberSignature Language="F#" Value="static member GetEditor : Type * Type -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (type, editorBaseType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" /> que representa el tipo base del editor que se intenta buscar.</param>
        <summary>Devuelve un editor con el tipo base determinado para el tipo especificado.</summary>
        <returns>Instancia del objeto de editor que se puede convertir al tipo base especificado o <see langword="null" /> si no se puede encontrar ningún editor del tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo de `editorBaseType` suele ser <xref:System.Drawing.Design.UITypeEditor>, pero también puede utilizar otros tipos (por ejemplo <xref:System.ComponentModel.ComponentEditor> y <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Puede definir varios editores para un tipo. Utilice este método para seleccionar el que desea usar.  
  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> o <paramref name="editorBaseType" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
        <related type="Article" href="http://msdn.microsoft.com/library/f068b4ea-6e8c-4c0b-aefd-188b337240da">Información general sobre editores de tipos de interfaz de usuario</related>
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public static object GetEditor (object component, Type editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetEditor(object component, class System.Type editorBaseType, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEditor(System.Object,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEditor (component As Object, editorBaseType As Type, noCustomTypeDesc As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetEditor(System::Object ^ component, Type ^ editorBaseType, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEditor : obj * Type * bool -&gt; obj" Usage="System.ComponentModel.TypeDescriptor.GetEditor (component, editorBaseType, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="editorBaseType" Type="System.Type" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se va a obtener el editor.</param>
        <param name="editorBaseType">
          <see cref="T:System.Type" /> que representa el tipo base del editor que se desea buscar.</param>
        <param name="noCustomTypeDesc">Marcador que especifica si se debe considerar la información de descripción de tipos personalizada.</param>
        <summary>Devuelve un editor con el tipo base especificado y con un descriptor de tipos personalizado para el componente especificado.</summary>
        <returns>Instancia del editor que se puede convertir al tipo de editor especificado o <see langword="null" /> si no se puede encontrar ningún editor del tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo de `editorBaseType` suele ser <xref:System.Drawing.Design.UITypeEditor>, pero también puede utilizar otros tipos (por ejemplo <xref:System.ComponentModel.ComponentEditor> y <xref:System.ComponentModel.InstanceCreationEditor>).  
  
 Puede definir varios editores para una propiedad. Utilice este método para seleccionar el editor que desee utilizar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> o <paramref name="editorBaseType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.AddEditorTable(System.Type,System.Collections.Hashtable)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
        <related type="Article" href="http://msdn.microsoft.com/library/f068b4ea-6e8c-4c0b-aefd-188b337240da">Información general sobre editores de tipos de interfaz de usuario</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la colección de eventos para un componente o tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se van a obtener los eventos.</param>
        <summary>Devuelve la colección de eventos para el componente especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> con los eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupera una colección de eventos que el determinado `component` proporciona la instancia del parámetro. Esta colección puede diferir del conjunto de eventos que proporciona la clase. Si el `component` se basa en un parámetro, el sitio puede agregar o quitar eventos adicionales.  
  
 Si `component` es `null`, a continuación, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
   
  
## Examples  
 Para obtener un ejemplo de este método, consulte el <xref:System.ComponentModel.EventDescriptorCollection.Count%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetEvents : Type -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Devuelve la colección de eventos para un tipo especificado de componente.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> con los eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 Si el `componentType` parámetro es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * Attribute[] -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se van a obtener los eventos.</param>
        <param name="attributes">Matriz de tipo <see cref="T:System.Attribute" /> que se puede utilizar como filtro.</param>
        <summary>Devuelve la colección de eventos para un componente especificado utilizando una matriz de atributos determinada que sirve como filtro.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> con los eventos que coinciden con los atributos especificados de este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos para el `component` parámetro puede diferir de los eventos de una clase, porque el sitio puede agregar o quitar eventos si el `component` se basa en un parámetro.  
  
 El `attributes` matriz puede tener una combinación de <xref:System.Type> y <xref:System.Attribute> objetos. El filtrado se define mediante las siguientes reglas:  
  
-   Un <xref:System.Type> se trata como un carácter comodín: coincide con cualquier evento que tiene el <xref:System.Type> en su conjunto de atributos.  
  
-   Si un evento no tiene un <xref:System.Attribute> de la misma clase, el evento no se incluye en la matriz devuelta.  
  
-   Si el atributo es una instancia de la <xref:System.Attribute> (clase), el evento debe ser una coincidencia exacta o no se incluye en la matriz devuelta.  
  
-   Si un <xref:System.Attribute> se especifica la instancia y es el evento de forma predeterminada, se incluye en la matriz devuelta incluso si no hay ninguna instancia de la <xref:System.Attribute> en el caso.  
  
 Si `component` es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * bool -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se van a obtener los eventos.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve la colección de eventos para un componente especificado con un descriptor de tipos personalizado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> con los eventos para este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método recupera una colección de eventos que el determinado `component` proporciona la instancia del parámetro. Este puede ser diferente del conjunto de eventos que proporciona la clase. Si el `component` se basa en un parámetro, el sitio puede agregar o quitar eventos adicionales.  
  
 Si `component` es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (componentType As Type, attributes As Attribute()) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetEvents : Type * Attribute[] -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (componentType, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <param name="attributes">Matriz de tipo <see cref="T:System.Attribute" /> que se puede utilizar como filtro.</param>
        <summary>Devuelve la colección de eventos para un tipo de componente especificado utilizando una matriz de atributos determinada que sirve como filtro.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> con los eventos que coinciden con los atributos especificados de este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 El `attributes` matriz de parámetros puede tener una combinación de <xref:System.Type> y <xref:System.Attribute> objetos. El filtrado se define mediante las siguientes reglas:  
  
-   Un <xref:System.Type> se trata como un carácter comodín: coincide con cualquier evento que tiene el <xref:System.Type> en su conjunto de atributos.  
  
-   Si un evento no tiene un <xref:System.Attribute> de la misma clase, el evento no se incluye en la matriz devuelta.  
  
-   Si el atributo es una instancia de la <xref:System.Attribute> (clase), el evento debe ser una coincidencia exacta o no se incluye en la matriz devuelta.  
  
-   Si un <xref:System.Attribute> se especifica la instancia y es el evento de forma predeterminada, se incluye en la matriz devuelta incluso si no hay ninguna instancia de la <xref:System.Attribute> en el caso.  
  
 Si el `componentType` parámetro es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.EventDescriptorCollection GetEvents (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.EventDescriptorCollection GetEvents(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetEvents(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvents (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As EventDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::EventDescriptorCollection ^ GetEvents(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetEvents : obj * Attribute[] * bool -&gt; System.ComponentModel.EventDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetEvents (component, attributes, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se van a obtener los eventos.</param>
        <param name="attributes">Matriz de tipo <see cref="T:System.Attribute" /> que se va a utilizar como filtro.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve la colección de eventos para un componente especificado utilizando una matriz de atributos determinada que sirve como filtro y un descriptor de tipos personalizado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.EventDescriptorCollection" /> con los eventos que coinciden con los atributos especificados de este componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos para el `component` parámetro puede diferir de los eventos de una clase, porque el sitio puede agregar o quitar eventos si el `component` se basa en un parámetro.  
  
 El `attributes` matriz de parámetros puede tener una combinación de <xref:System.Type> y <xref:System.Attribute> objetos. El filtrado se define mediante las siguientes reglas:  
  
-   Un <xref:System.Type> se trata como un carácter comodín: coincide con cualquier evento que tiene el <xref:System.Type> en su conjunto de atributos.  
  
-   Si un evento no tiene un <xref:System.Attribute> de la misma clase, el evento no se incluye en la matriz devuelta.  
  
-   Si el atributo es una instancia de la <xref:System.Attribute> (clase), el evento debe ser una coincidencia exacta o no se incluye en la matriz devuelta.  
  
-   Si un <xref:System.Attribute> se especifica la instancia y es el evento de forma predeterminada, se incluye en la matriz devuelta incluso si no hay ninguna instancia de la <xref:System.Attribute> en el caso.  
  
 Si `component` es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.EventDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetEvents" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateEvent" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public static string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetFullComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetFullComponentName : obj -&gt; string" Usage="System.ComponentModel.TypeDescriptor.GetFullComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Objeto <see cref="T:System.ComponentModel.Component" /> para el que se va a buscar el nombre.</param>
        <summary>Devuelve el nombre completo del componente.</summary>
        <returns>Nombre completo del componente especificado o <see langword="null" /> si el componente no tiene nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En muchos casos, el <xref:System.ComponentModel.TypeDescriptor.GetFullComponentName%2A> método devolverá el mismo valor que el <xref:System.ComponentModel.TypeDescriptor.GetComponentName%2A> método. Sin embargo, si el componente reside en un contenedor anidado o tiene otra semántica anidada, puede devolver un nombre completo distinto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetFullComponentName(System.Object)" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la colección de propiedades que hay en un componente o tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente del que se van a obtener las propiedades.</param>
        <summary>Devuelve la colección de propiedades para un componente especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> con las propiedades del componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las propiedades de un componente pueden diferir de las propiedades de una clase, ya que puede agregar o quitar propiedades si el componente está ubicado el sitio.  
  
 Si el `component` parámetro es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para acceder a las propiedades de un control. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.ComponentModel.Design.ComponentDesigner> clase.  
  
 [!code-csharp[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/CS/Form1.cs#8)]
 [!code-vb[System.ComponentModel.Design.DesignerServices#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.Design.DesignerServices/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
        <related type="Article" href="http://msdn.microsoft.com/library/c186c4b6-076c-438d-9ed3-f13da29c8c1f">Cómo: obtener acceso a servicios en tiempo de diseño</related>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType);" />
      <MemberSignature Language="F#" Value="static member GetProperties : Type -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties componentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> que representa el componente para el que se van a obtener propiedades.</param>
        <summary>Devuelve la colección de propiedades para un tipo especificado de componente.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> con las propiedades de un tipo de componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 Si el `componentType` parámetro es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="component">Componente del que se van a obtener las propiedades.</param>
        <param name="attributes">Matriz de tipo <see cref="T:System.Attribute" /> que se va a utilizar como filtro.</param>
        <summary>Devuelve la colección de propiedades para un componente especificado utilizando una matriz de atributos determinada que sirve como filtro.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> con las propiedades que coinciden con los atributos especificados del componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las propiedades de la `component` parámetro puede diferir de las propiedades de una clase, porque el sitio puede agregar o quitar propiedades si el `component` se basa en un parámetro.  
  
 El `attributes` matriz de parámetros se utiliza para filtrar la matriz. El filtrado se define mediante las siguientes reglas:  
  
-   Si no tiene una propiedad de un <xref:System.Attribute> de la misma clase, la propiedad no se incluye en la matriz devuelta.  
  
-   Si el atributo es una instancia de la <xref:System.Attribute> (clase), la propiedad debe ser una coincidencia exacta o no se incluye en la matriz devuelta.  
  
-   Si un <xref:System.Attribute> se especifica la instancia y es la propiedad predeterminada, se incluye en la matriz devuelta incluso si no hay ninguna instancia de la <xref:System.Attribute> en la propiedad.  
  
-   Si `attributes` tiene un atributo de forma predeterminada, el <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método coincide con el caso cuando la propiedad no tiene aplicado el atributo.  
  
 Si `component` es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo implementar el <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> método. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Windows.Forms.Design.PropertyTab> clase.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * bool -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente del que se van a obtener las propiedades.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para no tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve la colección de propiedades para un componente especificado utilizando el descriptor de tipos predeterminado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> con las propiedades de un componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las propiedades de la `component` parámetro puede diferir de las propiedades de una clase, porque el sitio puede agregar o quitar propiedades si el `component` se basa en un parámetro.  
  
 Si `component` es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (Type componentType, Attribute[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(class System.Type componentType, class System.Attribute[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Type,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (componentType As Type, attributes As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(Type ^ componentType, cli::array &lt;Attribute ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member GetProperties : Type * Attribute[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (componentType, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="componentType">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <param name="attributes">Matriz de tipo <see cref="T:System.Attribute" /> que se va a utilizar como filtro.</param>
        <summary>Devuelve la colección de propiedades para un tipo de componente especificado utilizando una matriz de atributos determinada que sirve como filtro.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> con las propiedades que coinciden con los atributos especificados de este tipo de componente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 El `attributes` matriz de parámetros se utiliza para filtrar la matriz. El filtrado se define mediante las siguientes reglas:  
  
-   Si no tiene una propiedad de un <xref:System.Attribute> de la misma clase, la propiedad no se incluye en la matriz devuelta.  
  
-   Si el atributo es una instancia de la <xref:System.Attribute> (clase), la propiedad debe ser una coincidencia exacta o no se incluye en la matriz devuelta.  
  
-   Si un <xref:System.Attribute> se especifica la instancia y es la propiedad predeterminada, se incluye en la matriz devuelta incluso si no hay ninguna instancia de la <xref:System.Attribute> en la propiedad.  
  
-   Si `attributes` tiene un atributo de forma predeterminada, el <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método coincide con el caso cuando la propiedad no tiene aplicado el atributo.  
  
 Si el `componentType` parámetro es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo implementar el <xref:System.Windows.Forms.Design.PropertyTab.GetProperties%2A> método. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Windows.Forms.Design.PropertyTab> clase.  
  
 [!code-cpp[PropertyTabExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/PropertyTabExample/CPP/class1.cpp#2)]
 [!code-csharp[PropertyTabExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/PropertyTabExample/CS/class1.cs#2)]
 [!code-vb[PropertyTabExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PropertyTabExample/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.PropertyDescriptorCollection GetProperties (object component, Attribute[] attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.PropertyDescriptorCollection GetProperties(object component, class System.Attribute[] attributes, bool noCustomTypeDesc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProperties(System.Object,System.Attribute[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProperties (component As Object, attributes As Attribute(), noCustomTypeDesc As Boolean) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::PropertyDescriptorCollection ^ GetProperties(System::Object ^ component, cli::array &lt;Attribute ^&gt; ^ attributes, bool noCustomTypeDesc);" />
      <MemberSignature Language="F#" Value="static member GetProperties : obj * Attribute[] * bool -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="System.ComponentModel.TypeDescriptor.GetProperties (component, attributes, noCustomTypeDesc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="attributes" Type="System.Attribute[]" />
        <Parameter Name="noCustomTypeDesc" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente del que se van a obtener las propiedades.</param>
        <param name="attributes">Matriz de tipo <see cref="T:System.Attribute" /> que se va a utilizar como filtro.</param>
        <param name="noCustomTypeDesc">Es <see langword="true" /> para tener en cuenta la información de descripción de tipos personalizada; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve la colección de propiedades para un componente especificado utilizando una matriz de atributos determinada que sirve como filtro y un descriptor de tipos personalizado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> con los eventos que coinciden con los atributos especificados del componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las propiedades de un `component` puede diferir de las propiedades de una clase, porque el sitio puede agregar o quitar propiedades si el `component` está situado.  
  
 El `attributes` matriz de parámetros se utiliza para filtrar la matriz. El filtrado se define mediante las siguientes reglas:  
  
-   Si no tiene una propiedad de un <xref:System.Attribute> de la misma clase, la propiedad no se incluye en la matriz devuelta.  
  
-   Si el atributo es una instancia de la <xref:System.Attribute> (clase), la propiedad debe ser una coincidencia exacta o no se incluye en la matriz devuelta.  
  
-   Si un <xref:System.Attribute> se especifica la instancia y es la propiedad predeterminada, se incluye en la matriz devuelta incluso si no hay ninguna instancia de la <xref:System.Attribute> en la propiedad.  
  
-   Si `attributes` tiene un atributo de forma predeterminada, el <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método coincide con el caso cuando la propiedad no tiene aplicado el atributo.  
  
 Si el `component` parámetro es `null`, se devuelve una colección vacía.  
  
 No se garantiza el orden de la colección devuelta para ser idénticos entre las llamadas, por lo que siempre el pedido antes de su uso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="component" /> es un objeto remoto entre procesos.</exception>
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.CustomTypeDescriptor.GetProperties" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetDefaultProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.CreateProperty" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetAttributes" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el proveedor de descripción de tipos para el componente o tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProvider (instance As Object) As TypeDescriptionProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member GetProvider : obj -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.GetProvider instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instancia del componente de destino.</param>
        <summary>Devuelve el proveedor de descripción de tipos para el componente especificado.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> asociado al componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> método siempre devolverá un proveedor de descripción de tipo. Incluso el valor predeterminado <xref:System.ComponentModel.TypeDescriptor> implementación se basa en un <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetProvider">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.TypeDescriptionProvider GetProvider (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.TypeDescriptionProvider GetProvider(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetProvider(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::TypeDescriptionProvider ^ GetProvider(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetProvider : Type -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="System.ComponentModel.TypeDescriptor.GetProvider type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeDescriptionProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Devuelve el proveedor de descripción de tipos para el tipo especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> asociado al tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.GetProvider%2A> método siempre devolverá un proveedor de descripción de tipo. Incluso el valor predeterminado <xref:System.ComponentModel.TypeDescriptor> implementación se basa en un <xref:System.ComponentModel.TypeDescriptionProvider>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.RemoveProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetReflectionType" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetEditor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetConverter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetReflectionType">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que se puede utilizar para llevar a cabo la reflexión.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetReflectionType (instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member GetReflectionType : obj -&gt; Type" Usage="System.ComponentModel.TypeDescriptor.GetReflectionType instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instancia del componente de destino.</param>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que se puede utilizar para llevar a cabo la reflexión teniendo en cuenta un objeto.</summary>
        <returns>
          <see cref="T:System.Type" /> para el objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> método es una versión de bajo nivel de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> se utiliza normalmente para realizar la reflexión estándar con respecto a un objeto al que no puede encontrarse ningún descriptor de tipos personalizado para él.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public static Type GetReflectionType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetReflectionType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.GetReflectionType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetReflectionType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetReflectionType : Type -&gt; Type" Usage="System.ComponentModel.TypeDescriptor.GetReflectionType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que se puede utilizar para realizar la reflexión teniendo en cuenta un tipo de clase.</summary>
        <returns>
          <see cref="T:System.Type" /> de la clase especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> método es una versión de bajo nivel de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. <xref:System.ComponentModel.TypeDescriptor.GetReflectionType%2A> se utiliza normalmente para realizar la reflexión estándar contra una clase cuando no puede encontrarse ningún descriptor de tipos personalizado para él.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetClassName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetComponentName" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="InterfaceType">
      <MemberSignature Language="C#" Value="public static Type InterfaceType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Type InterfaceType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InterfaceType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Type ^ InterfaceType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InterfaceType : Type" Usage="System.ComponentModel.TypeDescriptor.InterfaceType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un tipo que representa un proveedor de descripción de tipo para todos los tipos de interfaz.</summary>
        <value>
          <see cref="T:System.Type" /> que representa un proveedor de descripción de tipo personalizado para todos los tipos de interfaz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.InterfaceType%2A> procedimientos property get un <xref:System.Type> objeto que puede pasar a la <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> métodos para definir un proveedor de descripción de tipos para tipos de interfaz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Borra las propiedades y los eventos de la memoria caché.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Refresh (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="static member Refresh : obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que han cambiado las propiedades o eventos.</param>
        <summary>Borra de la memoria caché las propiedades y los eventos correspondientes al componente especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propiedades y eventos se almacenan en caché por <xref:System.ComponentModel.TypeDescriptor> para acelerar el proceso. Normalmente, son constantes durante la vigencia de un objeto. Sin embargo, los diseñadores y los proveedores extensores pueden cambiar el conjunto de propiedades en un objeto. En este caso, debe llamar a este método para borrar los descriptores de eventos y propiedades del objeto. Este método sólo se usa en tiempo de diseño. No se utiliza durante el tiempo de ejecución.  
  
 Este método también provoca un <xref:System.ComponentModel.TypeDescriptor.Refreshed> eventos cuando cambian las propiedades o eventos de un componente. Este evento solo se produce si se ha producido una llamada anterior a la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> o <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> método que la información almacenada en caché.  
  
   
  
## Examples  
 Para obtener un ejemplo del uso de este método, consulte el <xref:System.ComponentModel.RefreshEventHandler> clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member Refresh : System.Reflection.Assembly -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">
          <see cref="T:System.Reflection.Assembly" /> que representa el ensamblado que se va a actualizar. Se actualizará cada <see cref="T:System.Type" /> de este ensamblado.</param>
        <summary>Borra de la memoria caché las propiedades y los eventos correspondientes al ensamblado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propiedades y eventos se almacenan en caché por <xref:System.ComponentModel.TypeDescriptor> para acelerar el proceso. Normalmente, son constantes durante la vigencia de un objeto. Sin embargo, los diseñadores y los proveedores extensores pueden cambiar el conjunto de propiedades en un objeto. Si es así, puede llamar a este método para borrar los descriptores de eventos y propiedades del objeto. Este método sólo se usa en tiempo de diseño. No se utiliza durante el tiempo de ejecución.  
  
 Antes de realizar una llamada a la <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método para borrar la memoria caché, se debe llamar a la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para el ensamblado específico de la información en la caché.  
  
 Este método también provoca un <xref:System.ComponentModel.TypeDescriptor.Refreshed> eventos para notificar a todas las clases que desean recibir una notificación cuando la propiedad conjunto de cambios de un componente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Assembly" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (System.Reflection.Module module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Reflection.Module module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Reflection.Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(System::Reflection::Module ^ module);" />
      <MemberSignature Language="F#" Value="static member Refresh : System.Reflection.Module -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh module" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="module">
          <see cref="T:System.Reflection.Module" /> que representa el módulo que se va a actualizar. Se actualizará cada <see cref="T:System.Type" /> de este módulo.</param>
        <summary>Borra de la memoria caché las propiedades y los eventos correspondientes al módulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propiedades y eventos se almacenan en caché por <xref:System.ComponentModel.TypeDescriptor> para acelerar el proceso. Normalmente, son constantes durante la vigencia de un objeto. Sin embargo, los diseñadores y los proveedores extensores pueden cambiar el conjunto de propiedades en un objeto. Si es así, puede llamar a este método para borrar los descriptores de eventos y propiedades del objeto. Este método sólo se usa en tiempo de diseño. No se utiliza durante el tiempo de ejecución.  
  
 Antes de realizar una llamada a la <xref:System.ComponentModel.TypeDescriptor.Refresh%2A> método para borrar la memoria caché, se debe llamar a la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> método para el módulo específico de la información en la caché.  
  
 Este método también provoca un <xref:System.ComponentModel.TypeDescriptor.Refreshed> eventos para notificar a todas las clases que desean recibir una notificación cuando la propiedad conjunto de cambios de un componente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public static void Refresh (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Refresh(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.Refresh(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Refresh(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member Refresh : Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.Refresh type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Borra de la memoria caché las propiedades y los eventos correspondientes al tipo de componente especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a esta versión de este método solo cuando no tiene una instancia del objeto.  
  
 Propiedades y eventos se almacenan en caché por <xref:System.ComponentModel.TypeDescriptor> para acelerar el proceso. Normalmente, son constantes durante la vigencia de un objeto. Sin embargo, los diseñadores y los proveedores extensores pueden cambiar el conjunto de propiedades en un objeto. Si es así, puede llamar a este método para borrar los descriptores de eventos y propiedades del objeto. Este método sólo se usa en tiempo de diseño. No se utiliza durante el tiempo de ejecución.  
  
 Este método también provoca un <xref:System.ComponentModel.TypeDescriptor.Refreshed> eventos cuando cambian las propiedades o eventos de un componente. Este evento solo se produce si se ha producido una llamada anterior a la <xref:System.ComponentModel.TypeDescriptor.GetProperties%2A> o <xref:System.ComponentModel.TypeDescriptor.GetEvents%2A> método que la información almacenada en caché.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.ComponentModel.IExtenderProvider" />
        <altmember cref="T:System.ComponentModel.Design.IDesigner" />
        <altmember cref="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      </Docs>
    </Member>
    <Member MemberName="Refreshed">
      <MemberSignature Language="C#" Value="public static event System.ComponentModel.RefreshEventHandler Refreshed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RefreshEventHandler Refreshed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.TypeDescriptor.Refreshed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Refreshed As RefreshEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::ComponentModel::RefreshEventHandler ^ Refreshed;" />
      <MemberSignature Language="F#" Value="member this.Refreshed : System.ComponentModel.RefreshEventHandler " Usage="member this.Refreshed : System.ComponentModel.RefreshEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RefreshEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se borra la caché de un componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de cómo controlar eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Para obtener un ejemplo del uso de este evento, vea el <xref:System.ComponentModel.RefreshEventHandler> clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociation">
      <MemberSignature Language="C#" Value="public static void RemoveAssociation (object primary, object secondary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociation(object primary, object secondary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociation(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociation (primary As Object, secondary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociation(System::Object ^ primary, System::Object ^ secondary);" />
      <MemberSignature Language="F#" Value="static member RemoveAssociation : obj * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveAssociation (primary, secondary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
        <Parameter Name="secondary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">
          <see cref="T:System.Object" /> principal.</param>
        <param name="secondary">
          <see cref="T:System.Object" /> secundario.</param>
        <summary>Quita una asociación entre dos objetos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.RemoveAssociation%2A> método quita una asociación entre dos objetos formado por el <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método.  
  
 Un <xref:System.WeakReference> se usa para mantener la asociación entre el objeto principal y secundaria; por lo tanto, este método no influye en cuando cualquiera de los objetos se finaliza o reclamado por la recolección de elementos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAssociations">
      <MemberSignature Language="C#" Value="public static void RemoveAssociations (object primary);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveAssociations(object primary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveAssociations(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveAssociations (primary As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveAssociations(System::Object ^ primary);" />
      <MemberSignature Language="F#" Value="static member RemoveAssociations : obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveAssociations primary" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="primary" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="primary">
          <see cref="T:System.Object" /> principal de una asociación.</param>
        <summary>Quita todas las asociaciones de un objeto principal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptor.RemoveAssociations%2A> método quita todas las asociaciones entre un objeto principal y todos sus objetos secundarios, creados mediante llamadas a la <xref:System.ComponentModel.TypeDescriptor.CreateAssociation%2A> método.  
  
 Un <xref:System.WeakReference> se usa para mantener la asociación entre el objeto principal y secundaria; por lo tanto, este método no tiene influencia cuando se finaliza o recolección de elementos no utilizados reclame principal de los objetos secundarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="primary" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateAssociation(System.Object,System.Object)" />
        <altmember cref="M:System.ComponentModel.TypeDescriptor.GetAssociation(System.Type,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProvider">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita un proveedor de descripción de tipos previamente agregado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProvider (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member RemoveProvider : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProvider (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> que se va a quitar.</param>
        <param name="instance">Instancia del componente de destino.</param>
        <summary>Quita un proveedor de descripción de tipos previamente agregado que está asociado al objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método quita un proveedor de descripción de tipos agregado previamente con el <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método. Si quita un proveedor, un <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento para el objeto asociado.  
  
 Use el <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método si tiene que llamar desde código de confianza parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveProvider">
      <MemberSignature Language="C#" Value="public static void RemoveProvider (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProvider(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProvider(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProvider(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RemoveProvider : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProvider (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> que se va a quitar.</param>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Quita un proveedor de descripción de tipos previamente agregado que está asociado al tipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método quita un proveedor de descripción de tipos agregado previamente con el <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método. Si quita un proveedor, un <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento para el tipo asociado.  
  
 Use el <xref:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método si tiene que llamar desde código de confianza parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Estado asociado:</permission>
        <altmember cref="T:System.ComponentModel.TypeDescriptionProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.GetProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveProviderTransparent">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita un proveedor de descripción de tipos previamente agregado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveProviderTransparent (provider As TypeDescriptionProvider, instance As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="static member RemoveProviderTransparent : System.ComponentModel.TypeDescriptionProvider * obj -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProviderTransparent (provider, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> que se va a quitar.</param>
        <param name="instance">Instancia del componente de destino.</param>
        <summary>Quita un proveedor de descripción de tipos previamente agregado que está asociado al objeto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método quita un proveedor de descripción de tipos agregado previamente con el <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método. Si quita un proveedor, un <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento para el objeto asociado.  
  
 Se puede llamar a este método desde el código de confianza parcial. Si <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> está definido, el llamador puede registrar un proveedor para la instancia especificada si su tipo también es de confianza parcial.  
  
 Use el <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Object%29> método si no es necesario llamar a código de confianza parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acceder al registro. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo de asociado: el <see cref="T:System.Security.PermissionSet" /> requerido por el ensamblado que define el <paramref name="instance" /> tipo del parámetro.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveProviderTransparent">
      <MemberSignature Language="C#" Value="public static void RemoveProviderTransparent (System.ComponentModel.TypeDescriptionProvider provider, Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveProviderTransparent(class System.ComponentModel.TypeDescriptionProvider provider, class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.RemoveProviderTransparent(System.ComponentModel.TypeDescriptionProvider,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveProviderTransparent(System::ComponentModel::TypeDescriptionProvider ^ provider, Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RemoveProviderTransparent : System.ComponentModel.TypeDescriptionProvider * Type -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.RemoveProviderTransparent (provider, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.ComponentModel.TypeDescriptionProvider" />
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> que se va a quitar.</param>
        <param name="type">
          <see cref="T:System.Type" /> del componente de destino.</param>
        <summary>Quita un proveedor de descripción de tipos previamente agregado que está asociado al tipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método quita un proveedor de descripción de tipos agregado previamente con el <xref:System.ComponentModel.TypeDescriptor.AddProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método. Si quita un proveedor, un <xref:System.ComponentModel.TypeDescriptor.Refreshed> evento para el tipo asociado.  
  
 Se puede llamar a este método desde el código de confianza parcial. Si <xref:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess> está definido, el llamador puede anular el registro de un proveedor para el tipo especificado si también es de confianza parcial.  
  
 Use el <xref:System.ComponentModel.TypeDescriptor.RemoveProvider%28System.ComponentModel.TypeDescriptionProvider%2CSystem.Type%29> método si no es necesario llamar a código de confianza parcial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o ambos parámetros son <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.TypeDescriptorPermission">Para acceder al registro. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.TypeDescriptorPermissionFlags.RestrictedRegistrationAccess" /></permission>
        <permission cref="P:System.Reflection.Assembly.PermissionSet">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Tipo de asociado: el <see cref="T:System.Security.PermissionSet" /> requerido por el ensamblado que define <paramref name="type" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptorArray">
      <MemberSignature Language="C#" Value="public static void SortDescriptorArray (System.Collections.IList infos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SortDescriptorArray(class System.Collections.IList infos) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptor.SortDescriptorArray(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SortDescriptorArray (infos As IList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SortDescriptorArray(System::Collections::IList ^ infos);" />
      <MemberSignature Language="F#" Value="static member SortDescriptorArray : System.Collections.IList -&gt; unit" Usage="System.ComponentModel.TypeDescriptor.SortDescriptorArray infos" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="infos" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="infos">
          <see cref="T:System.Collections.IList" /> que contiene los descriptores que se van a ordenar.</param>
        <summary>Ordena los descriptores utilizando el nombre del descriptor.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="infos" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.EventDescriptor" />
        <altmember cref="T:System.ComponentModel.PropertyDescriptor" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptor.Refresh" />
      </Docs>
    </Member>
  </Members>
</Type>