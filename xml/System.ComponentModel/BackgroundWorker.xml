<Type Name="BackgroundWorker" FullName="System.ComponentModel.BackgroundWorker">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e3100d5df8f298b733355b4ac8b472c23b7f225f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370319" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BackgroundWorker : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BackgroundWorker extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.BackgroundWorker" />
  <TypeSignature Language="VB.NET" Value="Public Class BackgroundWorker&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class BackgroundWorker : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("DoWork")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ejecuta una operación en un subproceso distinto.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.ComponentModel.BackgroundWorker> clase le permite ejecutar una operación en un subproceso dedicado independiente. Operaciones que consumen muchos recursos como las descargas y las transacciones de base de datos pueden hacer que la interfaz de usuario (UI) para parece como si ha dejado de responder mientras se están ejecutando. Si desea una interfaz de usuario con capacidad de respuesta y está sufriendo grandes retrasos asociados con estas operaciones, la <xref:System.ComponentModel.BackgroundWorker> clase ofrece una solución apropiada.  
  
 Para ejecutar una operación consume mucho tiempo en segundo plano, se crea un <xref:System.ComponentModel.BackgroundWorker> y realizar escuchas de eventos que notifican el progreso de la operación y la señal cuando finaliza la operación. Puede crear el <xref:System.ComponentModel.BackgroundWorker> mediante programación o puede arrastrarlo al formulario desde el **componentes** pestaña de la **cuadro de herramientas**. Si crea el <xref:System.ComponentModel.BackgroundWorker> en el Diseñador de Windows Forms, se mostrará en la Bandeja de componentes y sus propiedades se mostrará en la ventana Propiedades.  
  
 Para configurar una operación en segundo plano, agregue un controlador de eventos para el <xref:System.ComponentModel.BackgroundWorker.DoWork> eventos. Llame a la operación consume mucho tiempo en este controlador de eventos. Para iniciar la operación, llame a <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>. Para recibir notificaciones de las actualizaciones de progreso, controle el <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos. Para recibir una notificación cuando se complete la operación, controle el <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> eventos.  
  
> [!NOTE]
>  Debe tener cuidado de no manipular los objetos de interfaz de usuario en su <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos. En su lugar, se comunican con la interfaz de usuario a través de la <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> y <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> eventos.  
>   
>  <xref:System.ComponentModel.BackgroundWorker> no se serializan eventos a través de <xref:System.AppDomain> los límites. No use un <xref:System.ComponentModel.BackgroundWorker> componente para realizar operaciones multiproceso en más de una <xref:System.AppDomain>.  
  
 Si la operación en segundo plano requiere un parámetro, llame a <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> con el parámetro. Dentro de la <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos, puede extraer el parámetro de la <xref:System.ComponentModel.DoWorkEventArgs.Argument%2A?displayProperty=nameWithType> propiedad.  
  
 Para más información sobre <xref:System.ComponentModel.BackgroundWorker>, vea [Cómo: Ejecutar una operación en segundo plano](~/docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra los conceptos básicos de la <xref:System.ComponentModel.BackgroundWorker> clase para ejecutar de forma asincrónica una operación que consume mucho tiempo. En la siguiente ilustración muestra un ejemplo de la salida.  
  
 ![Ejemplo sencillo de BackgroundWorker](~/add/media/backgroundworker-simple.png "ejemplo sencillo de BackgroundWorker")  
  
 Para probar este código, cree una aplicación de formularios Windows Forms. Agregar un <xref:System.Windows.Forms.Label> control denominado `resultLabel` y agregar dos <xref:System.Windows.Forms.Button> controles denominados `startAsyncButton` y `cancelAsyncButton`. Crear <xref:System.Windows.Forms.Control.Click> controladores de eventos de ambos botones. Desde el **componentes** ficha del cuadro de herramientas, agregue un <xref:System.ComponentModel.BackgroundWorker> componente denominado `backgroundWorker1`. Crear <xref:System.ComponentModel.BackgroundWorker.DoWork>, <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>, y <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> controladores de eventos para el <xref:System.ComponentModel.BackgroundWorker>. En el código para el formulario, reemplace el código existente por el código siguiente.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/cs/form1.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/vb/form1.vb#1)]  
  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker> clase para ejecutar de forma asincrónica una operación que consume mucho tiempo. En la siguiente ilustración muestra un ejemplo de la salida.  
  
 ![Ejemplo de BackgroundWorker Fibonacci](~/add/media/backgroundworker-fibonacci.png "ejemplo BackgroundWorker Fibonacci")  
  
 La operación calcula el número de Fibonacci seleccionado, informa de las actualizaciones de progreso que realiza el cálculo y permite un cálculo pendiente cancelarse.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#1)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BackgroundWorker ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BackgroundWorker();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.BackgroundWorker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solicita la cancelación de una operación en segundo plano pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> envía una solicitud para finalizar la operación en segundo plano pendiente y establece la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propiedad `true`.  
  
 Cuando se llama a <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>, su método de trabajo tiene una oportunidad para detener su ejecución y salir. El código de trabajo debe comprobar periódicamente la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propiedad para ver si se ha establecido en `true`.  
  
> [!CAUTION]
>  Tenga en cuenta que el código en el <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos puede finalizar su trabajo mientras se efectúa una solicitud de cancelación y el bucle de sondeo puede perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> se establece en `true`. En este caso, el <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> marca de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> en su <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> controlador de eventos no se establecerá en `true`, incluso si se realizó una solicitud de cancelación. Esta situación se denomina un *condición de anticipación* y es un problema habitual en la programación multiproceso. Para obtener más información acerca del diseño multithreading problemas, vea [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método para cancelar una operación asincrónica ("en segundo plano"). Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.ComponentModel.BackgroundWorker> clase.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#4)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#4)]
 [!code-vb[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancellationPending">
      <MemberSignature Language="C#" Value="public bool CancellationPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CancellationPending" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationPending As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CancellationPending { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la aplicación ha solicitado la cancelación de una operación en segundo plano.</summary>
        <value>
          <see langword="true" /> si la aplicación ha solicitado la cancelación de una operación en segundo plano; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> es `true`, la <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método se ha llamado en el <xref:System.ComponentModel.BackgroundWorker>.  
  
 Esta propiedad está pensada para su uso por el subproceso de trabajo, debe comprobar periódicamente <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> y anular la operación en segundo plano cuando se establece en `true`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propiedad para consultar un <xref:System.ComponentModel.BackgroundWorker> sobre su estado de cancelación. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.ComponentModel.BackgroundWorker> clase.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWork">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.DoWorkEventHandler DoWork;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.DoWorkEventHandler DoWork" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.DoWork" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoWork As DoWorkEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::DoWorkEventHandler ^ DoWork;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DoWorkEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se llama a <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena cuando se llama a la <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método. Esto es donde se inicia la operación que realiza el trabajo puede requerir mucho tiempo.  
  
 El código en el <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos debe comprobar periódicamente la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> valor de propiedad y anular la operación si es `true`. Cuando esto ocurre, puede establecer la <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> marca de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> a `true`y el <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> marca de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> en su <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> controlador de eventos se establecerá en `true`.  
  
> [!CAUTION]
>  Tenga en cuenta que el código en el <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos puede finalizar su trabajo mientras se efectúa una solicitud de cancelación y el bucle de sondeo puede perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> se establece en `true`. En este caso, el <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> marca de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> en su <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> controlador de eventos no se establecerá en `true`, incluso si se realizó una solicitud de cancelación. Esta situación se denomina un *condición de anticipación* y es un problema habitual en la programación multiproceso. Para obtener más información acerca del diseño multithreading problemas, vea [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Si la operación genera un resultado, puede asignar el resultado a la <xref:System.ComponentModel.DoWorkEventArgs.Result%2A?displayProperty=nameWithType> propiedad. Esta opción estará disponible para el <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> controlador de eventos en el <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propiedad.  
  
 Si la operación provoca una excepción que no controla el código, el <xref:System.ComponentModel.BackgroundWorker> detecta la excepción y la pasa a la <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> controlador de eventos, donde se expone como la <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propiedad de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType>. Si está ejecutando en el depurador de Visual Studio, el depurador se interrumpirá en el punto en el <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos que se generó la excepción no controlada. Si tiene más de una <xref:System.ComponentModel.BackgroundWorker>, no debe hacer referencia cualquiera de ellos directamente, como este modo se uniría su <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos a una instancia específica de <xref:System.ComponentModel.BackgroundWorker>. En su lugar, debe tener acceso a su <xref:System.ComponentModel.BackgroundWorker> convirtiendo el `sender` parámetro en su <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos.  
  
 Debe tener cuidado de no manipular los objetos de interfaz de usuario en su <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos. En su lugar, se comunican con la interfaz de usuario a través de la <xref:System.ComponentModel.BackgroundWorker> eventos.  
  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.DoWork> evento para iniciar una operación asincrónica. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.ComponentModel.BackgroundWorker> clase.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#5)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#5)]
 [!code-vb[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBusy">
      <MemberSignature Language="C#" Value="public bool IsBusy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBusy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBusy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBusy { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.ComponentModel.BackgroundWorker" /> está ejecutando una operación asincrónica.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.ComponentModel.BackgroundWorker" /> está ejecutando una operación asincrónica; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.BackgroundWorker> inicia una operación asincrónica cuando se llama a <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.ComponentModel.BackgroundWorker.IsBusy%2A> propiedad que se va a esperar la finalización de un <xref:System.ComponentModel.BackgroundWorker> operación. Este ejemplo de código forma parte de un ejemplo más extenso que se describe en [Cómo: descargar un archivo en segundo plano](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <altmember cref="T:System.EventArgs" />
        <altmember cref="Overload:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      </Docs>
    </Member>
    <Member MemberName="OnDoWork">
      <MemberSignature Language="C#" Value="protected virtual void OnDoWork (System.ComponentModel.DoWorkEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoWork(class System.ComponentModel.DoWorkEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnDoWork(System.ComponentModel.DoWorkEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoWork (e As DoWorkEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoWork(System::ComponentModel::DoWorkEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.DoWorkEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProgressChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnProgressChanged (System.ComponentModel.ProgressChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProgressChanged(class System.ComponentModel.ProgressChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProgressChanged (e As ProgressChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProgressChanged(System::ComponentModel::ProgressChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ProgressChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> método para informar del progreso de una operación asincrónica. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.ComponentModel.AsyncOperationManager> clase.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#24)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#24)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnRunWorkerCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRunWorkerCompleted (System.ComponentModel.RunWorkerCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRunWorkerCompleted(class System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRunWorkerCompleted (e As RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRunWorkerCompleted(System::ComponentModel::RunWorkerCompletedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.RunWorkerCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> en una clase derivada, asegúrese de llamar al método <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> de la clase base para que los delegados registrados reciban el evento.</para>
        </block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      </Docs>
    </Member>
    <Member MemberName="ProgressChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ProgressChangedEventHandler ProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ProgressChangedEventHandler ProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProgressChanged As ProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ProgressChangedEventHandler ^ ProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se llama a <see cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena cuando se llama a la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método.  
  
 Para obtener más información sobre el control de eventos, vea [NIB: consumir eventos](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> evento para notificar el progreso de una operación asincrónica al usuario. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.ComponentModel.BackgroundWorker> clase.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#7)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#7)]
 [!code-vb[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReportProgress">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Genera el evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Porcentaje, de 0 a 100, de la operación en segundo plano que se ha completado.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si necesita la operación en segundo plano para informar sobre su progreso, puede llamar a la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para generar el <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos. El <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> debe ser el valor de la propiedad `true`, o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> producirá un <xref:System.InvalidOperationException>.  
  
 Depende de usted para implementar de forma significativa de medir el progreso de la operación en segundo plano como un porcentaje de la tarea total completado.  
  
 La llamada a la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método es asincrónico y devuelve inmediatamente. El <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> controlador de eventos que se ejecuta en el subproceso que creó el <xref:System.ComponentModel.BackgroundWorker>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para informar del progreso de una operación asincrónica al usuario. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.ComponentModel.BackgroundWorker> clase.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> se establece en <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress, System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Porcentaje, de 0 a 100, de la operación en segundo plano que se ha completado.</param>
        <param name="userState">Objeto de estado que se ha pasado a <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si necesita la operación en segundo plano para informar sobre su progreso, puede llamar a la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para generar el <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos. El <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> el valor de propiedad debe estar `true`, o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> producirá un <xref:System.InvalidOperationException>.  
  
 Depende de usted para implementar de forma significativa de medir el progreso de la operación en segundo plano como un porcentaje de la tarea total completado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para informar del progreso de una operación asincrónica al usuario. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Windows.Forms.ToolStripProgressBar> clase.  
  
 [!code-csharp[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> se establece en <see langword="false" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunWorkerAsync">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia la ejecución de una operación en segundo plano.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia la ejecución de una operación en segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método envía una solicitud para iniciar la operación que se ejecuta de forma asincrónica. Cuando se atiende la solicitud, el <xref:System.ComponentModel.BackgroundWorker.DoWork> se genera el evento, que a su vez inicia la ejecución de la operación en segundo plano.  
  
 Si ya se está ejecutando la operación en segundo plano, la llamada a <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> nuevo, se producirá un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método para iniciar una operación asincrónica. Forma parte de un ejemplo más extenso que se describe en [Cómo: descargar un archivo en segundo plano](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> es <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync (object argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync(object argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync (argument As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync(System::Object ^ argument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="argument">Parámetro que utiliza la operación en segundo plano que se va a ejecutar en el controlador de eventos <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</param>
        <summary>Inicia la ejecución de una operación en segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método envía una solicitud para iniciar la operación que se ejecuta de forma asincrónica. Cuando se atiende la solicitud, el <xref:System.ComponentModel.BackgroundWorker.DoWork> se genera el evento, que a su vez inicia la ejecución de la operación en segundo plano.  
  
 Si la operación requiere un parámetro, puede proporcionarlo como el `argument` parámetro <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
 Si ya se está ejecutando la operación en segundo plano, la llamada a <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> nuevo, se producirá un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método para iniciar una operación asincrónica. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.ComponentModel.BackgroundWorker> clase.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#3)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#3)]
 [!code-vb[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> es <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
      </Docs>
    </Member>
    <Member MemberName="RunWorkerCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RunWorkerCompleted As RunWorkerCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::RunWorkerCompletedEventHandler ^ RunWorkerCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RunWorkerCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la operación en segundo plano se ha completado, se ha cancelado o ha producido una excepción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena cuando el <xref:System.ComponentModel.BackgroundWorker.DoWork> devuelve el controlador de eventos.  
  
 Si la operación se completa correctamente y su resultado se asigna en el <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos, puede obtener acceso al resultado a través de la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propiedad.  
  
 El <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propiedad de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indica que se inició una excepción por la operación.  
  
 El <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> propiedad de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indica si la operación en segundo plano ha procesado una solicitud de cancelación. Si el código en el <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos detecta una solicitud de cancelación mediante la comprobación de la <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> marca y estableciendo el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> marca de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> a `true`, el <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> marca de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> también se establecerá en `true`.  
  
> [!CAUTION]
>  Tenga en cuenta que el código en el <xref:System.ComponentModel.BackgroundWorker.DoWork> controlador de eventos puede finalizar su trabajo mientras se efectúa una solicitud de cancelación y el bucle de sondeo puede perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> se establece en `true`. En este caso, el <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> marca de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> en su <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> controlador de eventos no se establecerá en `true`, incluso si se realizó una solicitud de cancelación. Esta situación se denomina un *condición de anticipación* y es un problema habitual en la programación multiproceso. Para obtener más información acerca del diseño multithreading problemas, vea [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Su <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> siempre debería comprobar el controlador de eventos el <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> y <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A?displayProperty=nameWithType> propiedades antes de acceder a la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propiedad. Si se produce una excepción o si se canceló la operación, obtener acceso a la <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propiedad provoca una excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> eventos para controlar el resultado de una operación asincrónica. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.ComponentModel.BackgroundWorker> clase.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#6)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#6)]
 [!code-vb[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkerReportsProgress">
      <MemberSignature Language="C#" Value="public bool WorkerReportsProgress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerReportsProgress" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerReportsProgress As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerReportsProgress { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si <see cref="T:System.ComponentModel.BackgroundWorker" /> puede crear informes sobre las actualizaciones de progreso.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.ComponentModel.BackgroundWorker" /> admite las actualizaciones de progreso; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> propiedad `true` si desea que el <xref:System.ComponentModel.BackgroundWorker> para admitir las actualizaciones de progreso. Cuando esta propiedad es `true`, código de usuario puede llamar a la <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para generar el <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WorkerSupportsCancellation">
      <MemberSignature Language="C#" Value="public bool WorkerSupportsCancellation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerSupportsCancellation" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerSupportsCancellation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerSupportsCancellation { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si <see cref="T:System.ComponentModel.BackgroundWorker" /> admite la cancelación asincrónica.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.ComponentModel.BackgroundWorker" /> admite la cancelación; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation%2A> propiedad `true` si desea que el <xref:System.ComponentModel.BackgroundWorker> para admitir la cancelación. Cuando esta propiedad es `true`, puede llamar a la <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método interrumpir una operación en segundo plano.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      </Docs>
    </Member>
  </Members>
</Type>