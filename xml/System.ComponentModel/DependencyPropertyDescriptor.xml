<Type Name="DependencyPropertyDescriptor" FullName="System.ComponentModel.DependencyPropertyDescriptor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8b92ae7ae04745f0947cc4f73be429fa86e1532f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30380009" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyPropertyDescriptor : System.ComponentModel.PropertyDescriptor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyDescriptor extends System.ComponentModel.PropertyDescriptor" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.DependencyPropertyDescriptor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyDescriptor&#xA;Inherits PropertyDescriptor" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyDescriptor sealed : System::ComponentModel::PropertyDescriptor" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.PropertyDescriptor</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una extensión de <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se tiene en cuenta para las características de propiedad adicionales de una propiedad de dependencia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase se utiliza principalmente por aplicaciones de diseñador. Estas aplicaciones pueden necesitar informar de las características de la propiedad de dependencia a través de ventanas de propiedades u otras herramientas que se usa para editar los valores de propiedad.  
  
 Para comprobar una propiedad específica para determinar si tiene <xref:System.ComponentModel.DependencyPropertyDescriptor> disponibles para que actúe como un <xref:System.ComponentModel.PropertyDescriptor>, llame a <xref:System.ComponentModel.DependencyPropertyDescriptor.FromProperty%28System.ComponentModel.PropertyDescriptor%29?displayProperty=nameWithType>, o <xref:System.ComponentModel.DependencyPropertyDescriptor.FromName%2A?displayProperty=nameWithType>. Si cualquiera de estos métodos devuelven `null`, a continuación, la propiedad no es una propiedad de dependencia. Si el método devuelve un válido <xref:System.ComponentModel.DependencyPropertyDescriptor> , entonces la propiedad es una propiedad de dependencia.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddValueChanged">
      <MemberSignature Language="C#" Value="public override void AddValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void AddValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.AddValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub AddValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void AddValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el cual se va a agregar el controlador.</param>
        <param name="handler">Delegado que se va a agregar como agente de escucha.</param>
        <summary>Habilita la notificación a otros objetos cuando cambia esta propiedad.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.AttributeCollection Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.AttributeCollection Attributes" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As AttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::AttributeCollection ^ Attributes { System::ComponentModel::AttributeCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AttributeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de atributos de este miembro.</summary>
        <value>Colección de atributos <see cref="T:System.ComponentModel.AttributeCollection" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanResetValue">
      <MemberSignature Language="C#" Value="public override bool CanResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.CanResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CanResetValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool CanResetValue(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente cuya capacidad de restablecerse se va a probar.</param>
        <summary>Devuelve un valor que indica si al restablecer un objeto, cambia su valor.</summary>
        <returns>
          <see langword="true" /> si al restablecer el componente cambia su valor; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.PropertyDescriptor.CanResetValue(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public override string Category { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Category" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Category" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Category As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Category { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de la categoría a la que pertenece el miembro, tal como se especifica en <see cref="T:System.ComponentModel.CategoryAttribute" />.</summary>
        <value>Nombre de la categoría a la que pertenece el miembro. Si no hay ningún <see cref="T:System.ComponentModel.CategoryAttribute" />, el nombre de categoría se establece en la categoría predeterminada, <see langword="Misc" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ComponentType">
      <MemberSignature Language="C#" Value="public override Type ComponentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ComponentType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.ComponentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ComponentType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ComponentType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del componente al que está enlazada esta propiedad.</summary>
        <value>
          <see cref="T:System.Type" /> que representa el tipo de componente al que está enlazada esta propiedad. Cuando se llama al método <see cref="M:System.ComponentModel.DependencyPropertyDescriptor.GetValue(System.Object)" /> o <see cref="M:System.ComponentModel.DependencyPropertyDescriptor.SetValue(System.Object,System.Object)" />, el objeto especificado puede ser una instancia de este tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.TypeConverter Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.TypeConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Converter As TypeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::TypeConverter ^ Converter { System::ComponentModel::TypeConverter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el convertidor de tipos de esta propiedad.</summary>
        <value>
          <see cref="T:System.ComponentModel.TypeConverter" /> que se utiliza para convertir el <see cref="T:System.Type" /> de esta propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad puede ser `null` en casos donde los atributos <xref:System.ComponentModel.TypeConverter> no es una clase pública.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverterAttribute" />
      </Docs>
    </Member>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el identificador de la propiedad de dependencia.</summary>
        <value>Identificador de la propiedad de dependencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad puede ser `null` si un <xref:System.ComponentModel.DependencyPropertyDescriptor> se creó la instancia para una propiedad que no es una propiedad de dependencia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Description">
      <MemberSignature Language="C#" Value="public override string Description { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Description" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Description" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Description As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Description { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la descripción del miembro tal como se especifica en <see cref="T:System.ComponentModel.DescriptionAttribute" />.</summary>
        <value>Descripción del miembro. Si no hay ningún objeto <see cref="T:System.ComponentModel.DescriptionAttribute" />, el valor de propiedad se establece en el valor predeterminado, que es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignerCoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback DesignerCoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback DesignerCoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.DesignerCoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DesignerCoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ DesignerCoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una devolución de llamada que los diseñadores usan para modificar el valor vigente de una propiedad de dependencia antes de que el valor de propiedad de dependencia se almacene en el motor de propiedad de dependencia.</summary>
        <value>Devolución de llamada que los diseñadores usan para modificar el valor vigente de una propiedad de dependencia antes de que el valor de propiedad de dependencia se almacene en el motor de propiedad de dependencia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignTimeOnly">
      <MemberSignature Language="C#" Value="public override bool DesignTimeOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignTimeOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.DesignTimeOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DesignTimeOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool DesignTimeOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si este miembro debe establecerse sólo en tiempo de diseño según se especifica en <see cref="T:System.ComponentModel.DesignOnlyAttribute" />.</summary>
        <value>
          <see langword="true" /> si este miembro debe establecerse sólo en tiempo de diseño; <see langword="false" /> si el miembro puede establecerse en tiempo de ejecución. Si no hay ningún <see cref="T:System.ComponentModel.DesignOnlyAttribute" />, el valor que se devuelve es el valor predeterminado, siendo éste <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayName">
      <MemberSignature Language="C#" Value="public override string DisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayName" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.DisplayName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DisplayName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre que se puede mostrar en una ventana, como la ventana Propiedades.</summary>
        <value>Nombre que se va a mostrar para la propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> que se va a comparar con la instancia actual.</param>
        <summary>Compara dos instancias de <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> para determinar si sus valores son iguales.</summary>
        <returns>
          <see langword="true" /> si los valores son equivalentes; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromName">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> para el nombre de propiedad especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromName">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.DependencyPropertyDescriptor FromName (string name, Type ownerType, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.DependencyPropertyDescriptor FromName(string name, class System.Type ownerType, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.FromName(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromName (name As String, ownerType As Type, targetType As Type) As DependencyPropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::DependencyPropertyDescriptor ^ FromName(System::String ^ name, Type ^ ownerType, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DependencyPropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">El nombre registrado de una propiedad de dependencia o una propiedad adjunta.</param>
        <param name="ownerType">
          <see cref="T:System.Type" /> del objeto que posee la definición de propiedad.</param>
        <param name="targetType">
          <see cref="T:System.Type" /> del objeto para el que se desea establecer la propiedad.</param>
        <summary>Devuelve <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> para el nombre de propiedad especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `name` pueden hacer referencia a una propiedad de dependencia o una propiedad adjunta y es el `name` parámetro que se pasa a la <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.RegisterAttached%2A> llamada que define la propiedad en cuestión. `ownerType` se pasa el tipo de objeto que posee la propiedad, de nuevo como a <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.RegisterAttached%2A>. `targetType` es el tipo de objeto que desea establecer la propiedad. Para las propiedades de dependencia, `ownerType` y `targetType` son del mismo tipo. Para las propiedades asociadas, suelen ser diferentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromName">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.DependencyPropertyDescriptor FromName (string name, Type ownerType, Type targetType, bool ignorePropertyType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.DependencyPropertyDescriptor FromName(string name, class System.Type ownerType, class System.Type targetType, bool ignorePropertyType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.FromName(System.String,System.Type,System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromName (name As String, ownerType As Type, targetType As Type, ignorePropertyType As Boolean) As DependencyPropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::DependencyPropertyDescriptor ^ FromName(System::String ^ name, Type ^ ownerType, Type ^ targetType, bool ignorePropertyType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DependencyPropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Type" />
        <Parameter Name="ignorePropertyType" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">El nombre registrado de una propiedad de dependencia o una propiedad adjunta.</param>
        <param name="ownerType">
          <see cref="T:System.Type" /> del objeto que posee la definición de propiedad.</param>
        <param name="targetType">
          <see cref="T:System.Type" /> del objeto para el que se desea establecer la propiedad.</param>
        <param name="ignorePropertyType">Especifica que debe omitirse el tipo de propiedad.</param>
        <summary>Devuelve <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> para el nombre de propiedad especificado.</summary>
        <returns>
          <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `name` pueden hacer referencia a una propiedad de dependencia o una propiedad adjunta y es el `name` parámetro que se pasa a la <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.RegisterAttached%2A> llamada que define la propiedad en cuestión. `ownerType` se pasa el tipo de objeto que posee la propiedad, de nuevo como a <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.RegisterAttached%2A>. `targetType` es el tipo de objeto que desea establecer la propiedad. Para las propiedades de dependencia, `ownerType` y `targetType` son del mismo tipo. Para las propiedades asociadas, suelen ser diferentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromProperty">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> basándose en el objeto <see cref="T:System.ComponentModel.PropertyDescriptor" /> especificado o el tipo proporcionado, según la signatura utilizada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.DependencyPropertyDescriptor FromProperty (System.ComponentModel.PropertyDescriptor property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.DependencyPropertyDescriptor FromProperty(class System.ComponentModel.PropertyDescriptor property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.FromProperty(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromProperty (property As PropertyDescriptor) As DependencyPropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::DependencyPropertyDescriptor ^ FromProperty(System::ComponentModel::PropertyDescriptor ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DependencyPropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="property">
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> que se va a comprobar.</param>
        <summary>Devuelve un objeto <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> para el objeto <see cref="T:System.ComponentModel.PropertyDescriptor" /> proporcionado.</summary>
        <returns>Si la propiedad descrita por el parámetro <paramref name="property" /> es una propiedad de dependencia, devuelve una clase <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> válida. De lo contrario, devuelve <see langword="null" /><see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es el método principal usado por aplicaciones de diseñador para obtener un <xref:System.ComponentModel.DependencyPropertyDescriptor> en función de la comprobación de todas las propiedades de un <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromProperty">
      <MemberSignature Language="C#" Value="public static System.ComponentModel.DependencyPropertyDescriptor FromProperty (System.Windows.DependencyProperty dependencyProperty, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ComponentModel.DependencyPropertyDescriptor FromProperty(class System.Windows.DependencyProperty dependencyProperty, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.FromProperty(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ComponentModel::DependencyPropertyDescriptor ^ FromProperty(System::Windows::DependencyProperty ^ dependencyProperty, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DependencyPropertyDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dependencyProperty">Identificador de una propiedad de dependencia.</param>
        <param name="targetType">Tipo del objeto en el que está establecida la propiedad.</param>
        <summary>Devuelve un <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> para un tipo de destino y una propiedad de dependencia proporcionados.</summary>
        <returns>
          <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" /> para la propiedad de dependencia proporcionada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `dependencyProperty` pueden hacer referencia a una propiedad de dependencia o una propiedad adjunta. `targetType` es el tipo de objeto que desea establecer la propiedad. Para las propiedades de dependencia, que el tipo es equivalente a la <xref:System.Windows.DependencyProperty.OwnerType%2A> para el `dependencyProperty`. Para propiedades adjuntas el `targetType` suele ser otro <xref:System.Windows.DependencyObject> tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildProperties">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.PropertyDescriptorCollection GetChildProperties (object instance, Attribute[] filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ComponentModel.PropertyDescriptorCollection GetChildProperties(object instance, class System.Attribute[] filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.GetChildProperties(System.Object,System.Attribute[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChildProperties (instance As Object, filter As Attribute()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ComponentModel::PropertyDescriptorCollection ^ GetChildProperties(System::Object ^ instance, cli::array &lt;Attribute ^&gt; ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
        <Parameter Name="filter" Type="System.Attribute[]" />
      </Parameters>
      <Docs>
        <param name="instance">Componente cuyas propiedades se van a obtener.</param>
        <param name="filter">Matriz de tipo <see cref="T:System.Attribute" /> que se va a utilizar como filtro.</param>
        <summary>Devuelve un <see cref="T:System.ComponentModel.PropertyDescriptorCollection" />.</summary>
        <returns>
          <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> con las propiedades que coinciden con los atributos especificados del componente especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEditor">
      <MemberSignature Language="C#" Value="public override object GetEditor (Type editorBaseType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetEditor(class System.Type editorBaseType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.GetEditor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEditor (editorBaseType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetEditor(Type ^ editorBaseType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editorBaseType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="editorBaseType">Tipo base del editor que se utiliza para diferenciar entre varios editores compatibles con una propiedad.</param>
        <summary>Obtiene un editor del tipo especificado.</summary>
        <returns>Instancia del tipo de editor solicitado o <see langword="null" /> si no se encuentra ningún editor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de este objeto <see cref="T:System.ComponentModel.DependencyPropertyDescriptor" />.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El código hash de <xref:System.ComponentModel.DependencyPropertyDescriptor> se basa en el identificador para una propiedad de dependencia y el tipo en el que se establece. Esta implementación garantiza que un <xref:System.ComponentModel.DependencyPropertyDescriptor> no devuelve el mismo código hash para las propiedades que son heredadas por las clases derivadas posibles muchos o para las propiedades que en caso contrario, se reasignará a través del sistema de propiedad incorrecto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (component As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Instancia del componente.</param>
        <summary>Devuelve el valor actual de la propiedad en un componente.</summary>
        <returns>Valor solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAttached">
      <MemberSignature Language="C#" Value="public bool IsAttached { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttached" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.IsAttached" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttached As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttached { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la propiedad está registrada como una propiedad adjunta y se usa de modo adjunto.</summary>
        <value>
          <see langword="true" /> Si la propiedad es una propiedad adjunta; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBrowsable">
      <MemberSignature Language="C#" Value="public override bool IsBrowsable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowsable" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.IsBrowsable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsBrowsable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowsable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica el valor de <see cref="T:System.ComponentModel.BrowsableAttribute" /> en la propiedad.</summary>
        <value>
          Es <see langword="true" /> si se especificó <see cref="T:System.ComponentModel.BrowsableAttribute" /> en la propiedad; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalizable">
      <MemberSignature Language="C#" Value="public override bool IsLocalizable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalizable" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.IsLocalizable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsLocalizable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsLocalizable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si esta propiedad se debe traducir, según se especifica en <see cref="T:System.ComponentModel.LocalizableAttribute" />.</summary>
        <value>
          Es <see langword="true" /> si el miembro está marcado con el constructor <see cref="T:System.ComponentModel.LocalizableAttribute" /> del valor true; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si esta propiedad es de sólo lectura.</summary>
        <value>
          <see langword="true" /> si la propiedad es de sólo lectura; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 Propiedades de dependencia se registran como de solo lectura mediante llamadas al método concreto y por convención la [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] propiedades de contenedor que son las propiedades vistas mediante la reflexión y los descriptores también deben ser de solo lectura. Sin embargo, puesto que se trata de una convención y no es un requisito para compilar, puede volver a comprobar el estado de solo lectura del identificador de propiedad de dependencia. Para ello, obtenga el identificador (<xref:System.Windows.DependencyProperty>) valor de este <xref:System.ComponentModel.DependencyPropertyDescriptor> y, a continuación, compruebe el valor de <xref:System.Windows.DependencyProperty.ReadOnly%2A>. Tenga en cuenta que el <xref:System.Windows.DependencyProperty.ReadOnly%2A> se encuentra en el identificador, no los metadatos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Metadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ Metadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los metadatos asociados a la propiedad de dependencia.</summary>
        <value>Metadatos de la propiedad de dependencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor puede ser `null` si no hay ningún metadato o si la propiedad no es una propiedad de dependencia.  
  
 Metadatos que tienen la coincidencia de los conceptos en [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] atributos se vuelven a exponer como atributos en el <xref:System.ComponentModel.DependencyPropertyDescriptor.Attributes%2A> colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public override Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ PropertyType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la clase <see cref="T:System.Type" /> representada de la propiedad de dependencia.</summary>
        <value>El <see cref="T:System.Type" /> de la propiedad de dependencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el <xref:System.Type> que la propiedad de dependencia se registró con.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveValueChanged">
      <MemberSignature Language="C#" Value="public override void RemoveValueChanged (object component, EventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void RemoveValueChanged(object component, class System.EventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.RemoveValueChanged(System.Object,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub RemoveValueChanged (component As Object, handler As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void RemoveValueChanged(System::Object ^ component, EventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="handler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el cual se va a agregar el controlador.</param>
        <param name="handler">Delegado que se va a agregar como agente de escucha.</param>
        <summary>Habilita la notificación a otros objetos cuando cambia esta propiedad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetValue">
      <MemberSignature Language="C#" Value="public override void ResetValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResetValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.ResetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResetValue (component As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResetValue(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente cuyo valor de propiedad se va a restablecer en el valor predeterminado.</param>
        <summary>Restablece el valor de esta propiedad del componente en el valor predeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public override void SetValue (object component, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetValue(object component, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetValue (component As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetValue(System::Object ^ component, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente con el valor de propiedad que se va a establecer.</param>
        <param name="value">Nuevo valor.</param>
        <summary>Establece el valor del componente en otro valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValue">
      <MemberSignature Language="C#" Value="public override bool ShouldSerializeValue (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ShouldSerializeValue(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.ShouldSerializeValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ShouldSerializeValue (component As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ShouldSerializeValue(System::Object ^ component);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente con la propiedad cuya persistencia se va a examinar.</param>
        <summary>Indica si se debe conservar el valor de esta propiedad mediante procesos de serialización.</summary>
        <returns>
          <see langword="true" /> si se debe almacenar la propiedad; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeEvents">
      <MemberSignature Language="C#" Value="public override bool SupportsChangeEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeEvents" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.DependencyPropertyDescriptor.SupportsChangeEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SupportsChangeEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeEvents { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si las notificaciones de cambio de valor de esta propiedad pueden originarse fuera del descriptor de la propiedad (por ejemplo, en el propio componente) o si se originarán únicamente en las llamadas directas al método <see cref="M:System.ComponentModel.DependencyPropertyDescriptor.SetValue(System.Object,System.Object)" />.</summary>
        <value>
          Es <see langword="true" /> si las notificaciones de esta propiedad pueden originarse fuera del descriptor de la propiedad (por ejemplo, en el propio componente). Es <see langword="false" /> si las notificaciones se originarán únicamente en las llamadas directas realizadas al método <see cref="M:System.ComponentModel.DependencyPropertyDescriptor.SetValue(System.Object,System.Object)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por ejemplo, para la `true` caso, el componente puede implementar la <xref:System.ComponentModel.INotifyPropertyChanged> tener explícito o interfaz `propertyName.Changed` eventos para esta propiedad.  
  
 Esta propiedad se basa en subyacente <xref:System.ComponentModel.PropertyDescriptor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.DependencyPropertyDescriptor.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el valor de esta instancia en la representación de cadena equivalente.</summary>
        <returns>Devuelve el valor de <see cref="P:System.ComponentModel.MemberDescriptor.Name" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>