<Type Name="TypeDescriptionProvider" FullName="System.ComponentModel.TypeDescriptionProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="89efbe5222e2a61f9fcf3b7ab14c88aacd2502ee" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39817374" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TypeDescriptionProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TypeDescriptionProvider extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptionProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TypeDescriptionProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDescriptionProvider abstract" />
  <TypeSignature Language="F#" Value="type TypeDescriptionProvider = class" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona metadatos complementarios a la clase <see cref="T:System.ComponentModel.TypeDescriptor" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.ComponentModel.TypeDescriptionProvider> clase extiende dinámicamente la información de tipo asociada con un tipo u objeto agregando, modificando o ocultando características como atributos, propiedades y eventos. Puede haber varias clases de proveedor de descripción de tipo que ofrecen los metadatos para un único <xref:System.ComponentModel.TypeDescriptor>.  
  
 Hay dos formas de asociar un <xref:System.ComponentModel.TypeDescriptionProvider> con un <xref:System.ComponentModel.TypeDescriptor>:  
  
-   En tiempo de diseño, cuando la clase de destino se puede asignar adecuado <xref:System.ComponentModel.TypeDescriptionProviderAttribute> etiqueta.  
  
-   En tiempo de ejecución, cuando uno de los <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> métodos de la <xref:System.ComponentModel.TypeDescriptor> puede llamar a la clase. Estos métodos sobrecargados requieren el objeto de destino o su tipo de clase.  
  
 La <xref:System.ComponentModel.TypeDescriptionProvider> clase se basa en un objeto primario del mismo tipo, proporcionado durante la construcción. Esto permite que las clases que derivan de <xref:System.ComponentModel.CustomTypeDescriptor> para invalidar los métodos de forma selectiva.  
  
 Las instancias de <xref:System.ComponentModel.TypeDescriptionProvider> solo se generan a petición, minimiza el impacto de la información de tipo personalizado en el rendimiento.  
  
 Esta clase no puede heredarse.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>El tipo derivado puede marcarse como <see langword="internal" /> o <see langword="private" />, pero se puede crear una instancia del tipo con el <see cref="T:System.ComponentModel.TypeDescriptor" /> clase. No escriba código inseguro pensando que el llamador es de confianza. En su lugar, se supone que los llamadores pueden crear instancias del tipo en confianza parcial.</para>
    </block>
    <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
    <altmember cref="T:System.ComponentModel.TypeDescriptionProviderAttribute" />
    <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.TypeDescriptionProvider" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDescriptionProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDescriptionProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.TypeDescriptionProvider" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor es equivalente a llamar al otro <xref:System.ComponentModel.TypeDescriptionProvider.%23ctor%28System.ComponentModel.TypeDescriptionProvider%29> constructor con un valor de parámetro es `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.#ctor(System.ComponentModel.TypeDescriptionProvider)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDescriptionProvider (System.ComponentModel.TypeDescriptionProvider parent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.TypeDescriptionProvider parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.#ctor(System.ComponentModel.TypeDescriptionProvider)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (parent As TypeDescriptionProvider)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDescriptionProvider(System::ComponentModel::TypeDescriptionProvider ^ parent);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.TypeDescriptionProvider : System.ComponentModel.TypeDescriptionProvider -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="new System.ComponentModel.TypeDescriptionProvider parent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="parent" Type="System.ComponentModel.TypeDescriptionProvider" />
      </Parameters>
      <Docs>
        <param name="parent">Proveedor de descripción de tipo primario.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.TypeDescriptionProvider" /> con un proveedor de descripción de tipo primario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `parent` parámetro es `null`, todos los <xref:System.ComponentModel.TypeDescriptionProvider> métodos devolverán valores predeterminados. De lo contrario, todos los <xref:System.ComponentModel.TypeDescriptionProvider> delegarán métodos a los métodos de `parent`.  
  
 La tabla siguiente muestran los valores devueltos de forma predeterminada para <xref:System.ComponentModel.TypeDescriptionProvider> métodos.  
  
|Método|Valor devuelto predeterminado|  
|------------|--------------------------|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A>|`null`|  
|<xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A>|Un objeto recién creado mediante una llamada a la <xref:System.Activator.CreateInstance%2A> método.|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A>|Una instancia predeterminada de un <xref:System.ComponentModel.CustomTypeDescriptor> clase.|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A>|Una instancia predeterminada de un <xref:System.ComponentModel.CustomTypeDescriptor> clase.|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A>|El `objectType` primer parámetro.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.CustomTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateInstance (provider As IServiceProvider, objectType As Type, argTypes As Type(), args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(IServiceProvider ^ provider, Type ^ objectType, cli::array &lt;Type ^&gt; ^ argTypes, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj&#xA;override this.CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj" Usage="typeDescriptionProvider.CreateInstance (provider, objectType, argTypes, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">Proveedor de servicios opcional.</param>
        <param name="objectType">Tipo de objeto que se va a crear. Este parámetro nunca es <see langword="null" />.</param>
        <param name="argTypes">Matriz opcional de tipos que representan los tipos de parámetro que se van a pasar al constructor del objeto. Esta matriz puede ser <see langword="null" /> o de longitud cero.</param>
        <param name="args">Matriz opcional de valores de parámetros que se pasarán al constructor del objeto.</param>
        <summary>Crea un objeto que puede sustituir a otro tipo de datos.</summary>
        <returns>Objeto <see cref="T:System.Object" /> sustituto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IServiceProvider> especificado por el `provider` parámetro se pasa el <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A?displayProperty=nameWithType> método de la <xref:System.ComponentModel.TypeDescriptor> clase. Si `provider` no `null`, el proveedor de servicios puede usarse por el proveedor de descripción de tipo para obtener contexto adicional sobre la llamada de creación.  
  
 El <xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A> método es `virtual` y, de forma predeterminada, devuelve el resultado de la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método si `provider` es `null`. Si `provider` es `null`, este método invocará el <xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A> método del proveedor del elemento primario.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si la clase derivada no está interesada en proporcionar una instancia sustituta, simplemente debe llamar a la implementación base.</para>
        </block>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetCache">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary GetCache (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary GetCache(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetCache(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCache (instance As Object) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ GetCache(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetCache : obj -&gt; System.Collections.IDictionary&#xA;override this.GetCache : obj -&gt; System.Collections.IDictionary" Usage="typeDescriptionProvider.GetCache instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Objeto para el que se va a obtener la memoria caché.</param>
        <summary>Obtiene una memoria caché por cada objeto, a la que se obtiene acceso como una interfaz <see cref="T:System.Collections.IDictionary" /> de pares de clave y valor.</summary>
        <returns>Interfaz <see cref="T:System.Collections.IDictionary" /> si el objeto proporcionado admite almacenamiento en caché; de lo contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.ComponentModel.TypeDescriptor> que necesite realizar operaciones complejas en las colecciones de metadatos. Dado que los tipos no se descargan durante la vida de un dominio, el <xref:System.ComponentModel.TypeDescriptor> clase almacenará automáticamente en caché los resultados de estas operaciones en función de tipo. Sin embargo, algunas operaciones de usar las instancias del objeto activo. No se puede almacenar en caché estas operaciones dentro de la <xref:System.ComponentModel.TypeDescriptor> clase porque almacenarlos en memoria caché podrían impedir el objeto recolectado. En su lugar, el <xref:System.ComponentModel.TypeDescriptor> clase permite que una memoria caché por cada objeto, puede tener acceso como una <xref:System.Collections.IDictionary> de pares clave/valor, que existe en un objeto. El <xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A> método devuelve una instancia de esta caché. El <xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A> método devolverá `null` si no hay ninguna caché compatible para un objeto.  
  
 El valor predeterminado <xref:System.ComponentModel.TypeDescriptionProvider> usando <xref:System.ComponentModel.TypeDescriptor> examina el objeto para ver si es un componente basado en el que implementa el <xref:System.ComponentModel.Design.IDictionaryService> interfaz. Si el objeto es, usa el servicio de diccionario para almacenar la caché del objeto. De lo contrario, el objeto devuelve `null`. Otros proveedores de descripción de tipo pueden proporcionar su propia implementación aquí. Por ejemplo, los objetos de dependencia solo pueden adjuntar una propiedad de tipo <xref:System.Collections.IDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.ComponentModel.Design.IDictionaryService" />
      </Docs>
    </Member>
    <Member MemberName="GetExtendedTypeDescriptor">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ICustomTypeDescriptor GetExtendedTypeDescriptor (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExtendedTypeDescriptor (instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::ICustomTypeDescriptor ^ GetExtendedTypeDescriptor(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetExtendedTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor&#xA;override this.GetExtendedTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetExtendedTypeDescriptor instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Objeto para el que se va a obtener el descriptor de tipos extendido.</param>
        <summary>Obtiene un descriptor de tipos extendido personalizado para el objeto dado.</summary>
        <returns>Interfaz <see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> que puede proporcionar metadatos extendidos para el objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un descriptor de tipos extendido es un descriptor de tipos personalizado que ofrece propiedades que se agregaron otros objetos a este objeto, pero que no están definidos realmente en el objeto. Por ejemplo, en el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] modelo de componentes, los objetos que implementan la <xref:System.ComponentModel.IExtenderProvider> interfaz puede adjuntar propiedades a otros objetos que residen en el mismo contenedor lógico. Sobrecargado <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> métodos no devuelven un descriptor de tipo que proporciona estas propiedades extendidas adicionales. El <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> método devuelve el conjunto de estas propiedades extendidas. El <xref:System.ComponentModel.TypeDescriptor> combinará automáticamente los resultados de estas dos colecciones de propiedades. Mientras el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] modelo de componentes admite solo las propiedades extendidas, <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> puede usarse para los atributos extendidos, así como eventos, si lo admite el proveedor de descripción de tipos.  
  
 <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> es `virtual` y, de forma predeterminada, devuelve un descriptor de tipos personalizado que devuelve resultados vacíos si se ha pasado ningún proveedor primario. Si se ha pasado un proveedor primario, este método invocará el proveedor primario <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetExtenderProviders">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IExtenderProvider[] GetExtenderProviders (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IExtenderProvider[] GetExtenderProviders(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetExtenderProviders(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetExtenderProviders (instance As Object) As IExtenderProvider()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual cli::array &lt;System::ComponentModel::IExtenderProvider ^&gt; ^ GetExtenderProviders(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetExtenderProviders : obj -&gt; System.ComponentModel.IExtenderProvider[]&#xA;override this.GetExtenderProviders : obj -&gt; System.ComponentModel.IExtenderProvider[]" Usage="typeDescriptionProvider.GetExtenderProviders instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IExtenderProvider[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Objeto para el que se van a obtener proveedores extensores.</param>
        <summary>Obtiene los proveedores extensores del objeto especificado.</summary>
        <returns>Matriz de proveedores extensores para <paramref name="instance" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public virtual string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetFullComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFullComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetFullComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member GetFullComponentName : obj -&gt; string&#xA;override this.GetFullComponentName : obj -&gt; string" Usage="typeDescriptionProvider.GetFullComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Componente especificado.</param>
        <summary>Obtiene el nombre del componente especificado o <see langword="null" /> si el componente no tiene nombre.</summary>
        <returns>Nombre del componente especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetReflectionType">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza una reflexión normal en un objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReflectionType (instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetReflectionType(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetReflectionType : obj -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instancia del tipo (no debe ser <see langword="null" />).</param>
        <summary>Realiza una reflexión normal en el objeto indicado.</summary>
        <returns>El tipo de reflexión para esta <paramref name="instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> método es una versión de nivel inferior de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. Si no puede encontrarse ningún descriptor de tipos personalizado para un objeto, <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> se llama para realizar una reflexión normal en el objeto.  
  
 Utilice esta sobrecarga del método si ha llamado a un miembro del descriptor de tipo que usa una instancia en lugar de un tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public Type GetReflectionType (Type objectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetReflectionType(class System.Type objectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReflectionType (objectType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetReflectionType(Type ^ objectType);" />
      <MemberSignature Language="F#" Value="member this.GetReflectionType : Type -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType objectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Tipo de objeto para el que va a recuperar la interfaz <see cref="T:System.Reflection.IReflect" />.</param>
        <summary>Realiza una reflexión normal en un tipo.</summary>
        <returns>El tipo de reflexión para esta <paramref name="objectType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> método es una versión de nivel inferior de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. Si no puede encontrarse ningún descriptor de tipos personalizado para un objeto, <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> se llama para realizar una reflexión normal en el objeto.  
  
 Utilice esta sobrecarga del método si ha llamado a un miembro del descriptor de tipo que utiliza un tipo en lugar de una instancia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="objectType" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public virtual Type GetReflectionType (Type objectType, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetReflectionType(class System.Type objectType, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReflectionType (objectType As Type, instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetReflectionType(Type ^ objectType, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetReflectionType : Type * obj -&gt; Type&#xA;override this.GetReflectionType : Type * obj -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType (objectType, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objectType">Tipo de objeto para el que va a recuperar la interfaz <see cref="T:System.Reflection.IReflect" />.</param>
        <param name="instance">Instancia del tipo. Puede ser <see langword="null" />.</param>
        <summary>Realiza una reflexión normal en el objeto indicado con el tipo especificado.</summary>
        <returns>El tipo de reflexión para esta <paramref name="objectType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> método es una versión de nivel inferior de la <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método. Si no puede encontrarse ningún descriptor de tipos personalizado para un objeto, <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> se llama para realizar una reflexión normal en el objeto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Este método es un prototipo <see langword="virtual" />y de forma predeterminada devuelve <paramref name="objectType" /> si se ha pasado ningún proveedor primario. Si se ha pasado un proveedor primario, este método invocará el proveedor primario <see cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetReflectionType" /> método.</para>
        </block>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeType">
      <MemberSignature Language="C#" Value="public virtual Type GetRuntimeType (Type reflectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetRuntimeType(class System.Type reflectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeType (reflectionType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetRuntimeType(Type ^ reflectionType);" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeType : Type -&gt; Type&#xA;override this.GetRuntimeType : Type -&gt; Type" Usage="typeDescriptionProvider.GetRuntimeType reflectionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reflectionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="reflectionType">Tipo que se va a convertir en su equivalente en tiempo de ejecución.</param>
        <summary>Convierte un tipo de reflexión en un tipo en tiempo de ejecución.</summary>
        <returns>
          <see cref="T:System.Type" /> que representa el equivalente en tiempo de ejecución de <paramref name="reflectionType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType%2A> método invierte la <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> hacer una copia de método para convertir un tipo de reflexión en un tipo en tiempo de ejecución. Mediante el <xref:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType%2A> método es preferible el <xref:System.Type.UnderlyingSystemType%2A> propiedad, que se utilizó en versiones anteriores para devolver el tipo en tiempo de ejecución.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reflectionType" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeDescriptor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un descriptor de tipos personalizado para el tipo o el objeto indicado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeDescriptor (instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Instancia del tipo. Puede ser <see langword="null" /> si no se ha pasado ninguna instancia a la clase <see cref="T:System.ComponentModel.TypeDescriptor" />.</param>
        <summary>Obtiene un descriptor de tipos personalizado para el objeto indicado.</summary>
        <returns>Interfaz <see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> que puede proporcionar metadatos para el tipo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (Type objectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(class System.Type objectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeDescriptor (objectType As Type) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(Type ^ objectType);" />
      <MemberSignature Language="F#" Value="member this.GetTypeDescriptor : Type -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor objectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Tipo de objeto para el que se va a recuperar el descriptor de tipos.</param>
        <summary>Obtiene un descriptor de tipos personalizado para el tipo indicado.</summary>
        <returns>Interfaz <see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> que puede proporcionar metadatos para el tipo.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (Type objectType, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(class System.Type objectType, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeDescriptor (objectType As Type, instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(Type ^ objectType, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeDescriptor : Type * obj -&gt; System.ComponentModel.ICustomTypeDescriptor&#xA;override this.GetTypeDescriptor : Type * obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor (objectType, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objectType">Tipo de objeto para el que se va a recuperar el descriptor de tipos.</param>
        <param name="instance">Instancia del tipo. Puede ser <see langword="null" /> si no se ha pasado ninguna instancia a la clase <see cref="T:System.ComponentModel.TypeDescriptor" />.</param>
        <summary>Obtiene un descriptor de tipos personalizado para el tipo y el objeto indicados.</summary>
        <returns>Interfaz <see cref="T:System.ComponentModel.ICustomTypeDescriptor" /> que puede proporcionar metadatos para el tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es un prototipo `virtual` y, de forma predeterminada, devuelve un descriptor vacío si se ha pasado ningún proveedor primario. Si se ha pasado un proveedor primario, este método invocará el proveedor primario <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>El <see cref="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type,System.Object)" /> método debe devolver un descriptor de tipos personalizado para el objeto. Si el método no proporciona información de tipo para el objeto, debe devolver <see langword="null" />.</para>
        </block>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsSupportedType">
      <MemberSignature Language="C#" Value="public virtual bool IsSupportedType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupportedType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.IsSupportedType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupportedType(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member IsSupportedType : Type -&gt; bool&#xA;override this.IsSupportedType : Type -&gt; bool" Usage="typeDescriptionProvider.IsSupportedType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo cuya compatibilidad se va a probar.</param>
        <summary>Obtiene un valor que indica si el tipo especificado es compatible con la descripción de tipos y su cadena de proveedores de descripción de tipos.</summary>
        <returns>Es <see langword="true" /> si <paramref name="type" /> es compatible con la descripción de tipos y su cadena de proveedores de descripción de tipos; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>