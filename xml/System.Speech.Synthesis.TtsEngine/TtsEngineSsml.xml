<Type Name="TtsEngineSsml" FullName="System.Speech.Synthesis.TtsEngine.TtsEngineSsml">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c80a1ca495dfe40157bf97e75246761ad6921d28" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36408831" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TtsEngineSsml" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TtsEngineSsml extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TtsEngineSsml" />
  <TypeSignature Language="C++ CLI" Value="public ref class TtsEngineSsml abstract" />
  <TypeSignature Language="F#" Value="type TtsEngineSsml = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Clase base abstracta que se implementará en todo el texto para los motores de síntesis de voz.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para construir un motor de texto a voz personalizado, una aplicación siempre debe implementar una clase derivada de la clase base abstracta <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml>.  
  
 Una implementación correctamente registrada de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml> , a continuación, puede utilizarse como una voz de sintetizador por <xref:System.Speech.Synthesis> las aplicaciones basadas en el espacio de nombres.  
  
 Objetos heredar <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml> debe reemplazar los miembros siguientes: <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.%23ctor%2A>, <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.AddLexicon%2A>, <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.RemoveLexicon%2A>, <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.GetOutputFormat%2A> y <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>.  
  
 El miembro más importante de la <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml> es de clase para que se implementen los <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A> método.  
  
 El <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A> método es llamado por el analizador de texto de infraestructuras recibir:  
  
1.  Una referencia a la <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> interfaz, que proporciona acceso a los servicios del sistema, como incluso puesta en cola y escribir la salida de audio.  
  
2.  Una matriz de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instancia generado a partir de datos de lenguaje de marcado de síntesis de voz (SSML). Además de texto se representan como voz, el análisis del SSML almacena información sobre los atributos solicitados de voz en un <xref:System.Speech.Synthesis.TtsEngine.FragmentState> instancia asociado a cada entrada <xref:System.Speech.Synthesis.TtsEngine.TextFragment> objeto.  
  
 Una aplicación de sintetizador de voz, opcionalmente, puede enviar solicitudes para un formato de salida especificado mediante la implementación de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.GetOutputFormat%2A> para ser llamado por la plataforma cuando intenta proporcionar la salida de audio correcta.  
  
 Un implementador también puede proporcionar compatibilidad para administrar definiciones externas de pronunciación o léxicos, por su implementación de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.AddLexicon%2A> y <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.RemoveLexicon%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TtsEngineSsml (string registryKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string registryKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (registryKey As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TtsEngineSsml(System::String ^ registryKey);" />
      <MemberSignature Language="F#" Value="new System.Speech.Synthesis.TtsEngine.TtsEngineSsml : string -&gt; System.Speech.Synthesis.TtsEngine.TtsEngineSsml" Usage="new System.Speech.Synthesis.TtsEngine.TtsEngineSsml registryKey" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="registryKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="registryKey">Nombre completo de la clave del Registro para Voice Token asociado a la implementación de <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" />. motor.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" /> según una clave del Registro Voice Token apropiada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las llamadas a este constructor genera normalmente <xref:System.Speech.Synthesis> aplicaciones basadas en seleccionando una voz de sintetizador para ser usado por una instancia de <xref:System.Speech.Synthesis.SpeechSynthesizer>.  
  
 A <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml> debe ser el registro en HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Speech\Voices\Tokens.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLexicon">
      <MemberSignature Language="C#" Value="public abstract void AddLexicon (Uri uri, string mediaType, System.Speech.Synthesis.TtsEngine.ITtsEngineSite site);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddLexicon(class System.Uri uri, string mediaType, class System.Speech.Synthesis.TtsEngine.ITtsEngineSite site) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.AddLexicon(System.Uri,System.String,System.Speech.Synthesis.TtsEngine.ITtsEngineSite)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void AddLexicon(Uri ^ uri, System::String ^ mediaType, System::Speech::Synthesis::TtsEngine::ITtsEngineSite ^ site);" />
      <MemberSignature Language="F#" Value="abstract member AddLexicon : Uri * string * System.Speech.Synthesis.TtsEngine.ITtsEngineSite -&gt; unit" Usage="ttsEngineSsml.AddLexicon (uri, mediaType, site)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="mediaType" Type="System.String" />
        <Parameter Name="site" Type="System.Speech.Synthesis.TtsEngine.ITtsEngineSite" />
      </Parameters>
      <Docs>
        <param name="uri">Una instancia válida de <see langword="System.Uri" /> que indica la ubicación de la información de léxico.</param>
        <param name="mediaType">Cadena que contiene el tipo de medio del léxico. Los tipos de medios no distinguen entre mayúsculas y minúsculas.</param>
        <param name="site">Una referencia a una interfaz <see cref="T:System.Speech.Synthesis.TtsEngine.ITtsEngineSite" /> usada para interactuar con la infraestructura de la plataforma.</param>
        <summary>Agrega un léxico a <see langword="Synthesizer" /><see langword="Voice" /> implementado por la instancia actual de <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una biblioteca de objetos de pronunciación es una colección de palabras o frases junto con su pronunciación especificado mediante un alfabeto pronunciación adecuado.  
  
 Normalmente se llama a este método por la infraestructura de plataforma en respuesta a un <xref:System.Speech.Synthesis> en función de las aplicaciones que llaman <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.AddLexicon%2A> y el uso de la voz de sintetizador implementada actualmente <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml> instancia.  
  
 El valor de `mediaType` es normalmente una especificación de MIME, como la especificación de SSML usa MIME para las especificaciones de medios.  
  
   
  
## Examples  
 La implementación de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.AddLexicon%2A> utiliza la <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> interfaz pasa al cargar una biblioteca de objetos de un recurso. A continuación, almacena una `System.IO.Stream` a la biblioteca de objetos en un `System.Collections.Generic.Dictionary` instancia, indizado por la URI de la biblioteca de objetos.  
  
```  
public static Dictionary<Uri, Stream> _aLexicons = new Dictionary<Uri, Stream>();  
  
 public void AddLexicon(Uri uri, string mediaType, ITtsEngineSite site) {  
    Stream stream = site.LoadResource(uri, mediaType);  
    _aLexicons.Add(uri, stream);  
}  
  
 public void RemoveLexicon(Uri uri, ITtsEngineSite site) {  
     Stream stream;  
     if (_aLexicons.TryGetValue(uri, out stream)) {  
         stream.Close();  
         _aLexicons.Remove(uri);  
     }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Es responsabilidad de la implementación para estar totalmente familiarizado con y ser capaz de procesar la biblioteca de objetos que se almacenan en <paramref name="uri" />. La implementación también debe realizar un seguimiento y administrar las duraciones de todos los tipos de léxico agrega.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetOutputFormat">
      <MemberSignature Language="C#" Value="public abstract IntPtr GetOutputFormat (System.Speech.Synthesis.TtsEngine.SpeakOutputFormat speakOutputFormat, IntPtr targetWaveFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance native int GetOutputFormat(valuetype System.Speech.Synthesis.TtsEngine.SpeakOutputFormat speakOutputFormat, native int targetWaveFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.GetOutputFormat(System.Speech.Synthesis.TtsEngine.SpeakOutputFormat,System.IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract IntPtr GetOutputFormat(System::Speech::Synthesis::TtsEngine::SpeakOutputFormat speakOutputFormat, IntPtr targetWaveFormat);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputFormat : System.Speech.Synthesis.TtsEngine.SpeakOutputFormat * nativeint -&gt; nativeint" Usage="ttsEngineSsml.GetOutputFormat (speakOutputFormat, targetWaveFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speakOutputFormat" Type="System.Speech.Synthesis.TtsEngine.SpeakOutputFormat" />
        <Parameter Name="targetWaveFormat" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="speakOutputFormat">Miembro válido de la enumeración de <see cref="T:System.Speech.Synthesis.TtsEngine.SpeakOutputFormat" /> que indica el tipo de formato solicitado de la salida de audio.</param>
        <param name="targetWaveFormat">Puntero a un <see langword="struct" /> que contiene el valor de detalle para el tipo de formato de audio solicitado por el argumento <c>speakOutputFormat</c>.</param>
        <summary>Devuelve el mejor resultado de audio coincidente admitido por una respuesta del motor de síntesis dada a una solicitud para el motor de sintetizador de compatibilidad con un formato de salida determinado.</summary>
        <returns>Devuelve una instancia de <see langword="IntPtr" /> válida que hace referencia a un <see langword="struct" /> que contiene información detallada sobre el formato de salida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La estructura utilizada como `targetWaveFormat` y devuelto por el método debe compatible con la `WAVEFORMATEX` disponible en SAPI, y se debe asignar el valor devuelto con `CoTaskMemAlloc`.  
  
 El `struct` debe proporcionar funcionalidad equivalente a la:  
  
```  
internal struct WaveFormat  
{  
    public Int16 FormatTag;  
    public Int16 Channels;  
    public int SamplesPerSec;  
    public int AvgBytesPerSec;  
    public Int16 BlockAlign;  
    public Int16 BitsPerSample;  
    public Int16 Size;  
}  
```  
  
   
  
## Examples  
 La implementación del ejemplo siguiente valida las entradas seleccionadas, su uso si están dentro de las tolerancias, de lo contrario con los valores predeterminados.  
  
```  
public IntPtr GetOutputFormat(SpeakOutputFormat format, IntPtr targetWaveFormat) {  
    WaveFormat waveFormat = new WaveFormat();  
    WaveFormat rq=new WaveFormat();  
    Marshal.PtrToStructure(targetWaveFormat,rq);  
  
    waveFormat.AvgBytesPerSec = AvgBytesPerSec Min < rq.AvgBytesPerSec && rq.AvgBytesPerSec < AvgBytesPerSecMax? rq.AvgBytesPerSec : 3200;  
    waveFormat.BitsPerSample = BitsPerSampleMin < rq.AvgBytesPerSec && rq.BitsPerSample < BitsPerSampleMax ? rq.AvgBytesPerSec : 3200; 16;  
    waveFormat.BlockAlign = 2;  
    waveFormat.Channels = 1;  
    waveFormat.FormatTag = 1;  
    waveFormat.SamplesPerSec = 16000;  
    waveFormat.Size = 0;  
  
    IntPtr wfx = Marshal.AllocCoTaskMem(Marshal.SizeOf(waveFormat));  
    Marshal.StructureToPtr(waveFormat, wfx, false);  
  
    //Console.WriteLine ("GetOutputFormat called");  
    return wfx;  
}  
internal struct WaveFormat {  
    public Int16 FormatTag;  
    public Int16 Channels;  
    public int SamplesPerSec;  
    public int AvgBytesPerSec;  
    public Int16 BlockAlign;  
    public Int16 BitsPerSample;  
    public Int16 Size;  
}  
```  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Objeto que herede de <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" /> debe examinar el formato de salida solicitado según lo especificado por <paramref name="targetWaveFormat" /> y devolver el formato más cercano que admite.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RemoveLexicon">
      <MemberSignature Language="C#" Value="public abstract void RemoveLexicon (Uri uri, System.Speech.Synthesis.TtsEngine.ITtsEngineSite site);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveLexicon(class System.Uri uri, class System.Speech.Synthesis.TtsEngine.ITtsEngineSite site) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.RemoveLexicon(System.Uri,System.Speech.Synthesis.TtsEngine.ITtsEngineSite)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void RemoveLexicon(Uri ^ uri, System::Speech::Synthesis::TtsEngine::ITtsEngineSite ^ site);" />
      <MemberSignature Language="F#" Value="abstract member RemoveLexicon : Uri * System.Speech.Synthesis.TtsEngine.ITtsEngineSite -&gt; unit" Usage="ttsEngineSsml.RemoveLexicon (uri, site)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="site" Type="System.Speech.Synthesis.TtsEngine.ITtsEngineSite" />
      </Parameters>
      <Docs>
        <param name="uri">Una instancia válida de <see langword="System.Uri" /> que indica la ubicación de la información de léxico.</param>
        <param name="site">Una referencia a una interfaz <see cref="T:System.Speech.Synthesis.TtsEngine.ITtsEngineSite" /> pasada por la infraestructura de la plataforma para permitir el acceso a los recursos de la infraestructura.</param>
        <summary>Quita un léxico cargado actualmente por <see langword="Synthesizer" /><see langword="Voice" /> implementado por la instancia actual de <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una biblioteca de objetos de pronunciación es una colección de palabras o frases junto con su pronunciación especificado mediante un alfabeto pronunciación adecuado.  
  
 Normalmente se llama a este método en respuesta a un <xref:System.Speech.Synthesis> en función de las aplicaciones que llaman <xref:System.Speech.Synthesis.SpeechSynthesizer.RemoveLexicon%2A> y el uso de la voz de sintetizador implementada actualmente <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml> instancia.  
  
   
  
## Examples  
 La implementación de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.RemoveLexicon%2A> usa la biblioteca de objetos del URI para consultar una instancia `System.Collections.Generic.Dictionary` para el `System.IO.Stream`, cierra la secuencia y quita el uri que hace referencia a la biblioteca de objetos.  
  
```  
public static Dictionary<Uri, Stream> _aLexicons = new Dictionary<Uri, Stream>();  
  
 public void AddLexicon(Uri uri, string mediaType, ITtsEngineSite site) {  
    Stream stream = site.LoadResource(uri, mediaType);  
    _aLexicons.Add(uri, stream);  
}  
  
 public void RemoveLexicon(Uri uri, ITtsEngineSite site) {  
     Stream stream;  
     if (_aLexicons.TryGetValue(uri, out stream)) {  
         stream.Close();  
         _aLexicons.Remove(uri);  
     }  
}  
```  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Es responsabilidad de la implementación para estar totalmente familiarizado con y ser capaz de procesar la biblioteca de objetos que se almacenan en <paramref name="uri" />. La implementación también debe realizar un seguimiento y administrar las duraciones de todas las políticas que se quitan.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Speak">
      <MemberSignature Language="C#" Value="public abstract void Speak (System.Speech.Synthesis.TtsEngine.TextFragment[] fragment, IntPtr waveHeader, System.Speech.Synthesis.TtsEngine.ITtsEngineSite site);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Speak(class System.Speech.Synthesis.TtsEngine.TextFragment[] fragment, native int waveHeader, class System.Speech.Synthesis.TtsEngine.ITtsEngineSite site) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak(System.Speech.Synthesis.TtsEngine.TextFragment[],System.IntPtr,System.Speech.Synthesis.TtsEngine.ITtsEngineSite)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Speak (fragment As TextFragment(), waveHeader As IntPtr, site As ITtsEngineSite)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Speak(cli::array &lt;System::Speech::Synthesis::TtsEngine::TextFragment ^&gt; ^ fragment, IntPtr waveHeader, System::Speech::Synthesis::TtsEngine::ITtsEngineSite ^ site);" />
      <MemberSignature Language="F#" Value="abstract member Speak : System.Speech.Synthesis.TtsEngine.TextFragment[] * nativeint * System.Speech.Synthesis.TtsEngine.ITtsEngineSite -&gt; unit" Usage="ttsEngineSsml.Speak (fragment, waveHeader, site)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fragment" Type="System.Speech.Synthesis.TtsEngine.TextFragment[]" />
        <Parameter Name="waveHeader" Type="System.IntPtr" />
        <Parameter Name="site" Type="System.Speech.Synthesis.TtsEngine.ITtsEngineSite" />
      </Parameters>
      <Docs>
        <param name="fragment">Una matriz de instancias de <see cref="T:System.Speech.Synthesis.TtsEngine.TextFragment" /> que contienen el texto que se convertirá en voz.</param>
        <param name="waveHeader">
          <see langword="IntPtr" /> que señala a una estructura que contiene formato de salida de audio.</param>
        <param name="site">Una referencia a una interfaz <see cref="T:System.Speech.Synthesis.TtsEngine.ITtsEngineSite" /> pasada por la infraestructura de la plataforma para permitir el acceso a los recursos de la infraestructura.</param>
        <summary>Presenta la matriz <see cref="T:System.Speech.Synthesis.TtsEngine.TextFragment" /> indicada en el formato de salida especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La estructura utilizada como `waveHeader` y devuelto por el método debe compatible con la `WAVEFORMATEX` disponible en SAPI.  
  
 El `struct` debe proporcionar funcionalidad equivalente a la:  
  
```  
internal struct WaveFormat  
{  
    public Int16 FormatTag;  
    public Int16 Channels;  
    public int SamplesPerSec;  
    public int AvgBytesPerSec;  
    public Int16 BlockAlign;  
    public Int16 BitsPerSample;  
    public Int16 Size;  
}  
```  
  
   
  
## Examples  
 En el ejemplo siguiente forma parte de una implementación de síntesis de voz personalizados heredando de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml>y el uso de la utilización de <xref:System.Speech.Synthesis.TtsEngine.TextFragment>, <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo>, <xref:System.Speech.Synthesis.TtsEngine.FragmentState>, y <xref:System.Speech.Synthesis.TtsEngine.TtsEventId>  
  
 La implementación de <xref:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak%2A>  
  
1.  Recibe una matriz de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instancias y crea una nueva matriz de <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instancias que se pasan a la `Speak` método en un motor de síntesis subyacente.  
  
2.  Si el <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction> por obtener valor de enumeración de la <xref:System.Speech.Synthesis.TtsEngine.FragmentState.Action%2A> propiedad en el <xref:System.Speech.Synthesis.TtsEngine.FragmentState> devuelto por la <xref:System.Speech.Synthesis.TtsEngine.TextFragment.State%2A> propiedad de cada <xref:System.Speech.Synthesis.TtsEngine.TextFragment> instancia es <xref:System.Speech.Synthesis.TtsEngine.TtsEngineAction.Speak>, la implementación  
  
    -   Traduce Americanism a Britishisms en el texto que se va a hablar.  
  
    -   Si el <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite.EventInterest%2A> propiedad en el <xref:System.Speech.Synthesis.TtsEngine.ITtsEngineSite> interfaces proporcionadas para la compatibilidad de implementación el <xref:System.Speech.Synthesis.TtsEngine.TtsEventId.WordBoundary> tipo de evento, un <xref:System.Speech.Synthesis.TtsEngine.SpeechEventInfo> instancia se utiliza para crear un evento que se crea un indicador de progreso de sintetizador de unidad.  
  
3.  A continuación, se llama a un motor de representación de voz con modificados <xref:System.Speech.Synthesis.TtsEngine.TextFragment> matriz.  
  
```  
private const int WordBoundaryFlag = 1 << (int)TtsEventId.WordBoundary;  
private readonly char[] spaces = new char[] { ' ', '\t', '\r', '\n' };  
internal struct UsVsUk  
{  
  internal string UK;  
  internal string US;  
}  
  
override public void Speak (TextFragment [] frags, IntPtr wfx, ITtsEngineSite site)  
{  
  TextFragment [] newFrags=new TextFragment[frags.Length];  
  
  for (int i=0;i<frags.Length;i++){  
    newFrags[i].State=frags[i].State;  
    //truncate  
    newFrags[i].TextToSpeak = frags[i].TextToSpeak.Substring(frags[i].TextOffset,  
                               frags[i].TextLength);  
    newFrags[i].TextLength = newFrags[i].TextToSpeak.Length;  
    newFrags[i].TextOffset = 0;  
    if (newFrags[i].State.Action == TtsEngineAction.Speak) {  
      //Us to UK conversion  
      foreach (UsVsUk term in TransList) {  
      newFrags[i].TextToSpeak.Replace(term.US, term.UK);  
      }  
      //Generate progress meter events if supported  
      if ((site.EventInterest & WordBoundaryFlag) != 0) {  
      string[] subs = newFrags[i].TextToSpeak.Split(spaces);  
  
      foreach (string s in subs) {  
        int offset = newFrags[i].TextOffset;  
        SpeechEventInfo spEvent = new SpeechEventInfo((Int16)TtsEventId.WordBoundary,   
                (Int16)EventParameterType.Undefined,   
                 s.Length, new IntPtr(offset));  
        offset += s.Length;  
        if (s.Trim().Length > 0) {  
          SpeechEventInfo[] events = new SpeechEventInfo[1];  
          events[0] = spEvent;  
          site.AddEvents(events, 1);  
        }  
      }  
      }  
    }  
  }  
    _baseSynthesize.Speak(newFrags, wfx, site);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Sintetizador de voz personalizado implementa con <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" /> y <see cref="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak(System.Speech.Synthesis.TtsEngine.TextFragment[],System.IntPtr,System.Speech.Synthesis.TtsEngine.ITtsEngineSite)" /> profesional como filtros o los intermediarios entre aplicaciones de sintetizador construidos usando la infraestructura de plataforma a través de los miembros de la <see cref="N:System.Speech.Synthesis" /> espacio de nombres y motores de síntesis de voz de sistema subyacente.  Un <see cref="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak(System.Speech.Synthesis.TtsEngine.TextFragment[],System.IntPtr,System.Speech.Synthesis.TtsEngine.ITtsEngineSite)" /> implementación: 1.  Intercepte o modificar aspectos del entrante <see cref="T:System.Speech.Synthesis.TtsEngine.TextFragment" /> objetos 2.  Genera los eventos necesarios con la referencia de sitio a un <see cref="T:System.Speech.Synthesis.TtsEngine.ITtsEngineSite" /> 3 de la instancia.  Genera la voz sintetizada real.  Generación de voz normalmente se realiza mediante una llamada a <c>hablar</c> en uno de la proporcionados por el sistema operativo de motores de representación de la oración.  Si uno de los motores de representación de voz disponibles no se utiliza, un objeto que herede de <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" /> debe crear su propio motor de representación de voz.  El acceso a la <c>hablar</c> método sobre el uso de obtenido el registro y la reflexión.  Al heredar de <see cref="T:System.Speech.Synthesis.TtsEngine.TtsEngineSsml" />, debe reemplazar los miembros siguientes: <see cref="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.#ctor(System.String)" />, <see cref="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.AddLexicon(System.Uri,System.String,System.Speech.Synthesis.TtsEngine.ITtsEngineSite)" />, <see cref="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.RemoveLexicon(System.Uri,System.Speech.Synthesis.TtsEngine.ITtsEngineSite)" />, <see cref="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.GetOutputFormat(System.Speech.Synthesis.TtsEngine.SpeakOutputFormat,System.IntPtr)" />, y <see cref="M:System.Speech.Synthesis.TtsEngine.TtsEngineSsml.Speak(System.Speech.Synthesis.TtsEngine.TextFragment[],System.IntPtr,System.Speech.Synthesis.TtsEngine.ITtsEngineSite)" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>