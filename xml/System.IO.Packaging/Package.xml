<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e633ba759596ecfd98d51e13ceacad970601b282" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37759525" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a container that can store multiple data objects.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> es una clase abstracta que se puede usar para organizar objetos en una sola entidad de un formato físico definido para la portabilidad y un acceso eficiente.  
  
 Un archivo ZIP es el formato físico principal para el <xref:System.IO.Packaging.Package>.  Otros <xref:System.IO.Packaging.Package> implementaciones podrían usar otros formatos físicos, como un documento XML, una base de datos o servicio Web.  
  
 Al igual que un sistema de archivos, los elementos incluidos en un <xref:System.IO.Packaging.Package> se hace referencia en una organización jerárquica de carpetas y archivos.  
  
 Aunque <xref:System.IO.Packaging.Package> es una clase abstracta, la <xref:System.IO.Packaging.ZipPackage> clase derivada sirve como valor predeterminado por el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Un <xref:System.IO.Packaging.PackagePart> ("elemento") es la clase abstracta que representa un objeto que se almacena en un <xref:System.IO.Packaging.Package>.  
  
 Un <xref:System.IO.Packaging.PackageRelationship> ("relación") define una asociación entre un origen de <xref:System.IO.Packaging.Package> o <xref:System.IO.Packaging.PackagePart> y un objeto de destino.  Un <xref:System.IO.Packaging.PackageRelationship> puede ser uno de los dos tipos, cada uno de los cuales puede tener uno de dos formas:  
  
-   Una relación de nivel de paquete (creado por el <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> método) se relaciona con un <xref:System.IO.Packaging.Package> como:  
  
    -   Un elemento de destino en el paquete.  
  
    -   Un recurso de destino fuera del paquete.  
  
-   Una relación de nivel de elemento (creado por el <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> método) se relaciona con un origen de <xref:System.IO.Packaging.PackagePart> como:  
  
    -   Otro elemento de destino en el paquete.  
  
    -   Un recurso de destino fuera del paquete.  
  
 Origen de la relación <xref:System.IO.Packaging.Package> u origen <xref:System.IO.Packaging.PackagePart> se considera el "propietario" de la relación.  Cuando se elimina el objeto de origen, también se eliminan todas las relaciones que posee el objeto de origen.  El proceso de creación o eliminación de una relación no cambia físicamente los objetos de origen o destino de ninguna manera.  
  
 Un <xref:System.IO.Packaging.PackageDigitalSignature> ("firma digital") es una composición de elementos y relaciones que representan una firma digital que se incluye con un <xref:System.IO.Packaging.Package>.  La firma digital identifica al originador y valida que los elementos y relaciones contenidos en el <xref:System.IO.Packaging.Package> no se han modificado.  
  
 Los paquetes también admiten Digital Rights Management (DRM) que permite a los elementos de contenido en un <xref:System.IO.Packaging.Package> cifrarse con derechos de acceso específicos concedidos a los usuarios autorizados.  
  
 Según el <xref:System.IO.Packaging.Package> arquitectura, una <xref:System.Windows.Xps.Packaging.XpsDocument> es un tipo de paquete diseñado para almacenar documentos en función de la apertura [XML Paper Specification (XPS)](http://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework usa paquetes para almacenar contenido, recursos y las relaciones de las páginas y documentos mediante un archivo ZIP estándar de forma predeterminada. Como con cualquier archivo ZIP, la aplicación puede utilizar el <xref:System.IO.Packaging> clases para almacenar y, opcionalmente, proteger cualquier tipo o el número de archivos de datos en un único contenedor de acceso eficiente.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra los pasos básicos para crear un <xref:System.IO.Packaging.Package>.  En este ejemplo, se crea un paquete para que contenga un documento junto con una imagen gráfica que se muestra como parte del documento.  (Esto es similar al caso en el que tiene un archivo HTML una \<IMG > etiqueta a la que hace referencia a un archivo de imagen externo.)  Dos <xref:System.IO.Packaging.PackageRelationship> elementos también se incluyen en el paquete.  El primero, una relación de "nivel de paquete", define la parte del documento como elemento raíz del paquete.  Una relación en segundo lugar, el "nivel de elemento" define la asociación entre el elemento del documento (el "origen" de la relación de nivel de elemento) y su uso de la parte de la imagen (el "destino" de la relación de nivel de elemento).  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">The file IO permissions for the package.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class that uses a given <see cref="T:System.IO.FileAccess" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> es un constructor protegido de la <xref:System.IO.Packaging.Package> clase base abstracta. Cuando se llama en una clase derivada, el <xref:System.IO.Packaging.Package.%23ctor%2A> constructor inicializa una nueva instancia de la clase derivada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="openFileAccess" /> is not valid.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">The file IO permissions for the package.</param>
        <param name="streaming">
          <see langword="true" /> to open the package for streaming; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.Packaging.Package" /> class that uses a given <see cref="T:System.IO.FileAccess" /> and streaming option.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> es un constructor protegido de la <xref:System.IO.Packaging.Package> abstracta de la clase base. Cuando se llama en una clase derivada, el <xref:System.IO.Packaging.Package.%23ctor%2A> constructor inicializa una nueva instancia de la clase derivada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="openFileAccess" /> is not valid.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves and closes the package plus all underlying part streams.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para el <xref:System.IO.Packaging.Package> clase <xref:System.IO.Packaging.Package.Close%2A> y <xref:System.IO.Packaging.Package.Dispose%2A> realizar la misma operación: no hay ninguna razón para llamar a <xref:System.IO.Packaging.Package.Dispose%2A> si llama a <xref:System.IO.Packaging.Package.Close%2A>, o viceversa.  
  
 <xref:System.IO.Packaging.Package.Close%2A> y <xref:System.IO.Packaging.Package.Dispose%2A> llaman internamente a <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  El `using` instrucción (diferente de la `using` directiva de espacio de nombres) es la manera recomendada para <xref:System.IO.Packaging.Package.Close%2A> y <xref:System.IO.Packaging.Package.Dispose%2A> un paquete.  [Escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055) y [leer un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160034) muestran cómo cerrar y eliminar un paquete mediante el uso de la `using` instrucción.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a new package part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Inicializa un valor vacío <xref:System.IO.Stream> para el nuevo elemento.  El <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> método puede utilizarse para obtener una referencia a la instancia de la secuencia asociada con la parte.  
  
 Para obtener más información acerca de los elementos del paquete, vea la sección 1.1 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo <xref:System.IO.Packaging.PackagePart> y, a continuación, almacenar datos en la parte.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> llama internamente a la clase derivada <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> método para crear realmente la parte basada en el formato físico implementado en la clase derivada.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the new part.</param>
        <param name="contentType">The content type of the data stream.</param>
        <summary>Creates a new uncompressed part with a given URI and content type.</summary>
        <returns>The new created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Inicializa un valor vacío <xref:System.IO.Stream> para el nuevo elemento.  El <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> método puede utilizarse para obtener una referencia a la instancia de la secuencia asociada con la parte.  
  
 La parte <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> es <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Para obtener más información acerca de los elementos del paquete, vea la sección 1.1 en la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo <xref:System.IO.Packaging.PackagePart> y, a continuación, almacenar datos en la parte.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> or <paramref name="contentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is already present in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only (a new part cannot be added).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> llama internamente a la clase derivada <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> método para crear realmente la parte basada en el formato físico implementado en la clase derivada.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] of the new part.</param>
        <param name="contentType">The content type of the data stream.</param>
        <param name="compressionOption">The compression option for the data stream, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> or <see cref="F:System.IO.Packaging.CompressionOption.Normal" /> compression.</param>
        <summary>Creates a new part with a given URI, content type, and compression option.</summary>
        <returns>The new created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para el valor predeterminado <xref:System.IO.Packaging.ZipPackage> clase derivada, el <xref:System.IO.Packaging.Package.CreatePart%2A> método sólo es compatible con dos `compressionOption` valores, <xref:System.IO.Packaging.CompressionOption.NotCompressed> o <xref:System.IO.Packaging.CompressionOption.Normal> compresión.  Otros <xref:System.IO.Packaging.CompressionOption> valores de <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, o <xref:System.IO.Packaging.CompressionOption.SuperFast> usar <xref:System.IO.Packaging.CompressionOption.Normal> compresión.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> crea un valor vacío <xref:System.IO.Stream> para el nuevo elemento.  El <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> método puede utilizarse para obtener una referencia a la instancia de la secuencia asociada con la parte.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo <xref:System.IO.Packaging.PackagePart> y, a continuación, almacenar datos en la parte.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> or <paramref name="contentType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is already present in the package.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="compressionOption" /> value is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only (a new part cannot be added).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> llama internamente a la clase derivada <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> método para crear realmente la parte basada en el formato físico implementado en la clase derivada.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] for the part being created.</param>
        <param name="contentType">The content type of the data stream.</param>
        <param name="compressionOption">The compression option for the data stream.</param>
        <summary>When overridden in a derived class, creates a new part in the package.</summary>
        <returns>The created part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase derivada <xref:System.IO.Packaging.Package.CreatePartCore%2A> llama al método el <xref:System.IO.Packaging.Package.CreatePart%2A> método para crear un elemento basado en el formato físico implementado en la clase derivada.  
  
 De forma predeterminada, un <xref:System.IO.Packaging.ZipPackage> derivados de la implementación de la clase del resumen <xref:System.IO.Packaging.Package> proporcionado y usa la clase.  En la operación de forma predeterminada, <xref:System.IO.Packaging.Package.CreatePart%2A> llama internamente a <xref:System.IO.Packaging.Package.CreatePartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> clase para crear un nuevo elemento en un archivo ZIP.  
  
 Para el valor predeterminado <xref:System.IO.Packaging.ZipPackage> clase derivada, el <xref:System.IO.Packaging.Package.CreatePartCore%2A> método sólo es compatible con dos `compressionOption` valores, <xref:System.IO.Packaging.CompressionOption.NotCompressed> o <xref:System.IO.Packaging.CompressionOption.Normal> compresión.  Otros <xref:System.IO.Packaging.CompressionOption> valores de <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, o <xref:System.IO.Packaging.CompressionOption.SuperFast> usar <xref:System.IO.Packaging.CompressionOption.Normal> compresión.  
  
 Para obtener más información sobre el modelo y los elementos del paquete, consulte el capítulo 1 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La clase derivada <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> implementación debe hacer ninguna suposición sobre el orden o las operaciones realizadas por el <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> método que lo llama.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a package-level relationship to a given part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de paquete define una asociación entre el paquete y un elemento de destino asociado o un recurso.  Una relación de nivel de paquete puede ser una de estas dos formas.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un destino <xref:System.IO.Packaging.PackagePart> dentro del paquete.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un recurso de destino fuera del paquete.  
  
 En una relación de paquete, el paquete se considera el "propietario" de la relación.  Cuando se elimina el paquete, también se eliminan todas las relaciones que posee el paquete.  El proceso de creación o eliminación de la relación no modifica físicamente el elemento de destino o recurso de ninguna manera.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra la creación de un <xref:System.IO.Packaging.PackageRelationship> entre un <xref:System.IO.Packaging.Package> y un elemento de documento raíz.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the target part.</param>
        <param name="targetMode">Indicates if the target part is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> or <see cref="F:System.IO.Packaging.TargetMode.External" /> to the package.</param>
        <param name="relationshipType">A URI that uniquely defines the role of the relationship.</param>
        <summary>Creates a package-level relationship to a part with a given URI, target mode, and relationship type.</summary>
        <returns>The package-level relationship to the specified part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de paquete define una asociación entre el paquete y un elemento de destino asociado o un recurso.  Una relación de nivel de paquete puede ser una de estas dos formas.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un elemento de destino en el paquete.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un recurso de destino fuera del paquete.  
  
 En una relación de paquete, el paquete se considera el "propietario" de la relación.  Cuando se elimina el paquete, también se eliminan todas las relaciones que posee el paquete.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> no cambia físicamente el elemento de destino o recurso de ninguna manera.  
  
 El destino de una relación no puede ser otra relación.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` debe ser un URI relativo que se forma según la [RFC 3986](http://tools.ietf.org/html/rfc3986) especificación de sintaxis genérica del identificador uniforme de recursos (URI).  El URI relativo interno puede ser una ruta absoluta que comienza por una barra diagonal ("/") caracteres como "/ page1.xaml" o "/ images/picture4.jpg", o una ruta de acceso relativa como ".. / imagespicture1.jpg "que se resuelve en la raíz del paquete ("/ ") como el URI base.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.External>, `targetUri` puede ser cualquier absoluta o URI relativo el formato correcto según el [RFC 3986](http://tools.ietf.org/html/rfc3986) especificación de sintaxis genérica del identificador uniforme de recursos (URI).  "http://www.microsoft.com/page2.xml" es un ejemplo de un URI absoluto que hace referencia a un recurso de destino externo "page2.xml".  "images/picture1.jpg" es un ejemplo de un URI relativo que también hace referencia a un destino externo resource "1.jpg" pero que se resuelve en el URI del propio paquete.  
  
 `relationshipType` debe ser un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] que se forma según la [RFC 3986](http://tools.ietf.org/html/rfc3986) especificación de sintaxis genérica del identificador uniforme de recursos (URI).  En la tabla siguiente se muestra el nivel de paquete `relationshipType` URI definen por la especificación de Open Packaging Conventions (OPC).  
  
|Relación de nivel de paquete|URI del tipo de relación|  
|---------------------------------|---------------------------|  
|Propiedades básicas|http://schemas.openxmlformats.org/package/2006/relationships/meta datos/core-properties|  
|Firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit firma de firma de al|  
|Certificado de firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit certificado de firma de al|  
|Origen de la firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit al-/ origen de la firma|  
|Vista en miniatura|http://schemas.openxmlformats.org/package/2006/relationships/meta datos/vista en miniatura|  
  
 Para obtener más información sobre el empaquetado y relaciones de paquete, vea la sección 1.3 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar <xref:System.IO.Packaging.Package.CreateRelationship%2A> para crear un <xref:System.IO.Packaging.PackageRelationship> entre un <xref:System.IO.Packaging.Package> y un elemento de documento raíz.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> or <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="targetUri" /> part is a <see cref="T:System.IO.Packaging.PackageRelationship" />, or <paramref name="targetMode" /> is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> and <paramref name="targetUri" /> is an absolute URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="targetMode" /> is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the target part.</param>
        <param name="targetMode">Indicates if the target part is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> or <see cref="F:System.IO.Packaging.TargetMode.External" /> to the package.</param>
        <param name="relationshipType">A URI that uniquely defines the role of the relationship.</param>
        <param name="id">A unique XML identifier.</param>
        <summary>Creates a package-level relationship to a part with a given URI, target mode, relationship type, and [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>The package-level relationship to the specified part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de paquete define una asociación entre el paquete y un elemento de destino asociado o un recurso.  Una relación de nivel de paquete puede ser una de estas dos formas.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un elemento de destino en el paquete.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un recurso de destino fuera del paquete.  
  
 En una relación de paquete, el paquete se considera el "propietario" de la relación.  Cuando se elimina el paquete, también se eliminan todas las relaciones que posee el paquete.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> no cambia físicamente el elemento de destino o recurso de ninguna manera.  
  
 El destino de una relación no puede ser otra relación.  
  
 `id` debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en el esquema XML parte 2: especificación de los tipos de datos (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Si `id` se especifica como `null` se generará automáticamente un identificador único.  Un `id` especificado por un valor vacío cadena no es válida.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` debe ser un URI relativo que se forma según la [RFC 3986](http://tools.ietf.org/html/rfc3986) especificación de sintaxis genérica del identificador uniforme de recursos (URI).  El URI relativo interno puede ser una ruta absoluta que comienza por una barra diagonal ("/") caracteres como "/ page1.xaml" o "/ images/picture4.jpg", o una ruta de acceso relativa como ".. / imagespicture1.jpg "que se resuelve en la raíz del paquete ("/ ") como el URI base.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.External>, `targetUri` puede ser cualquier absoluta o URI relativo el formato correcto según el [RFC 3986](http://tools.ietf.org/html/rfc3986) especificación de sintaxis genérica del identificador uniforme de recursos (URI).  "http://www.microsoft.com/page2.xml" es un ejemplo de un URI absoluto que hace referencia a un recurso de destino externo "page2.xml".  "images/picture1.jpg" es un ejemplo de un URI relativo que también hace referencia a un destino externo resource "1.jpg" pero que se resuelve en el URI del propio paquete.  
  
 `relationshipType` debe ser un URI que se forma según la [RFC 3986](http://tools.ietf.org/html/rfc3986) especificación de sintaxis genérica del identificador uniforme de recursos (URI).  En la tabla siguiente se muestra el nivel de paquete `relationshipType` URI definen por la especificación de Open Packaging Conventions (OPC).  
  
|Relación de nivel de paquete|URI del tipo de relación|  
|---------------------------------|---------------------------|  
|Propiedades básicas|http://schemas.openxmlformats.org/package/2006/relationships/meta datos/core-properties|  
|Firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit firma de firma de al|  
|Certificado de firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit certificado de firma de al|  
|Origen de la firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit al-/ origen de la firma|  
|Vista en miniatura|http://schemas.openxmlformats.org/package/2006/relationships/meta datos/vista en miniatura|  
  
 Para obtener más información sobre el empaquetado y relaciones de paquete, vea la sección 1.3 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar <xref:System.IO.Packaging.Package.CreateRelationship%2A> para crear un <xref:System.IO.Packaging.PackageRelationship> entre un <xref:System.IO.Packaging.Package> y un elemento de documento raíz.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> or <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="targetUri" /> part is a <see cref="T:System.IO.Packaging.PackageRelationship" />, or <paramref name="targetMode" /> is <see cref="F:System.IO.Packaging.TargetMode.Internal" /> and <paramref name="targetUri" /> is an absolute URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="targetMode" /> is not valid.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier; or a part with the specified <paramref name="id" /> already occurs in the package.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] of the part to delete.</param>
        <summary>Deletes a part with a given URI from the package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` debe ser un URI relativo que consta de una ruta de acceso absoluta que comienza con una barra diagonal ("/") caracteres.  La ruta de acceso absoluta es relativa a la raíz del paquete y se ha creado según la [RFC 3986](http://tools.ietf.org/html/rfc3986) especificación de sintaxis genérica del identificador uniforme de recursos (URI).  "/ page1.xaml" y "/ images/picture4.jpg" son ejemplos de URI válido de parte.  
  
 No se produce ninguna excepción si un elemento con los valores especificados `partUri` no está en el paquete.  (Puede usar el <xref:System.IO.Packaging.Package.PartExists%2A> método para determinar si un elemento con un determinado `partUri` está en el paquete.)  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> llama internamente a la clase derivada <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> método para eliminar el elemento basada en el formato físico implementado en la clase derivada.</para>
        </block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The <see cref="P:System.IO.Packaging.PackagePart.Uri" /> of the <see cref="T:System.IO.Packaging.PackagePart" /> to delete.</param>
        <summary>When overridden in a derived class, deletes a part with a given URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, un <xref:System.IO.Packaging.ZipPackage> derivados de la implementación de la clase del resumen <xref:System.IO.Packaging.Package> proporcionado y usa la clase.  En la operación de forma predeterminada, <xref:System.IO.Packaging.Package.DeletePart%2A> llama internamente a <xref:System.IO.Packaging.Package.DeletePartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> basándose en el formato físico implementado en la clase derivada de la operación de eliminación de la clase para realizar la real.  
  
 Para obtener más información sobre el modelo y los elementos del paquete, consulte el capítulo 1 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La clase derivada <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> implementación llama a la <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> método a la parte especificada según el formato físico implementado en la clase derivada.  La clase derivada <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> implementación debe hacer ninguna suposición sobre el orden o las operaciones realizadas por el <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> método que lo llama.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the <see cref="T:System.IO.Packaging.PackageRelationship" /> to delete.</param>
        <summary>Deletes a package-level relationship.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de paquete define una asociación entre el paquete y un elemento de destino asociado o un recurso.  Una relación de nivel de paquete puede ser una de estas dos formas.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un elemento de destino en el paquete.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un recurso de destino fuera del paquete.  
  
 En una relación de paquete, el paquete se considera el "propietario" de la relación.  Cuando se elimina el paquete, también se eliminan todas las relaciones que posee el paquete.  
  
 No se produce ninguna excepción si una relación con los valores especificados `id` no está en el paquete.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> no cambia físicamente el elemento de destino de ninguna manera.  
  
 Para obtener más información acerca de las relaciones de paquete, vea la sección 1.3 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Flushes and saves the content of all parts and relationships, closes the package, and releases all resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para asegurarse de que todos los cambios se guardan correctamente, <xref:System.IO.Packaging.Package.Dispose%2A> también finaliza, vacía y cierra todos los elementos y relaciones que se encuentran en el paquete.  
  
 Para el <xref:System.IO.Packaging.Package> (clase), <xref:System.IO.Packaging.Package.Dispose%2A> y <xref:System.IO.Packaging.Package.Close%2A> realizar la misma operación: no hay ninguna razón para llamar a <xref:System.IO.Packaging.Package.Dispose%2A> si llama a <xref:System.IO.Packaging.Package.Close%2A>, o viceversa.  
  
 <xref:System.IO.Packaging.Package.Close%2A> y <xref:System.IO.Packaging.Package.Dispose%2A> llaman internamente a <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Las clases derivadas que asignan y administran los recursos de memoria no deben invalidar este método para liberar recursos cuando <xref:System.IO.Packaging.Package.Dispose%2A> se llama. Las invalidaciones de la clase derivada también deben llamar <xref:System.IO.Packaging.Package.Flush%2A> y la clase base <xref:System.IO.Packaging.Package.Dispose%2A> método para asegurarse de que se realiza siempre que la limpieza de clase base.  
  
> [!NOTE]
>  El `using` instrucción (diferente de la `using` directiva de espacio de nombres) es la manera recomendada para <xref:System.IO.Packaging.Package.Close%2A> y <xref:System.IO.Packaging.Package.Dispose%2A> un paquete. [Escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055) se muestra cómo cerrar y eliminar un paquete mediante el uso de la `using` instrucción.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the file access setting for the package.</summary>
        <value>Uno de los <see cref="T:System.IO.FileAccess" /> valores: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, o <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad <xref:System.IO.Packaging.Package.FileOpenAccess%2A> no tiene ningún valor predeterminado.  La configuración de acceso de archivo se especifica en el <xref:System.IO.Packaging.Package.%23ctor%2A> llame al constructor al crear un nuevo paquete, o el <xref:System.IO.Packaging.Package.Open%2A> llamar al abrir un paquete existente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Saves the contents of all parts and relationships that are contained in the package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> llama internamente a la clase derivada <xref:System.IO.Packaging.Package.FlushCore%2A> implementación para realizar la operación de vaciado específica del formato real.  La clase derivada <xref:System.IO.Packaging.Package.FlushCore%2A> método es responsable de guardar el contenido y de relaciones para la implementación de la clase derivada física específica.  
  
 De forma predeterminada, un <xref:System.IO.Packaging.ZipPackage> implementación derivada de la abstracta <xref:System.IO.Packaging.Package> se proporciona y se usa la clase base. En la operación de forma predeterminada, <xref:System.IO.Packaging.Package.Flush%2A> llama internamente a <xref:System.IO.Packaging.Package.FlushCore%2A> para guardar los elementos y relaciones en un paquete de archivo ZIP.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> se llama de forma automática el <xref:System.IO.Packaging.Package.Close%2A> y <xref:System.IO.Packaging.Package.Dispose%2A> métodos.  Cuando <xref:System.IO.Packaging.Package.Close%2A> o <xref:System.IO.Packaging.Package.Dispose%2A> se llama no es necesario llamar a <xref:System.IO.Packaging.Package.Flush%2A> por separado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is read-only and cannot be modified.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> llama internamente a la clase derivada <see cref="M:System.IO.Packaging.Package.FlushCore" /> método para vaciar el elemento basado en el formato físico implementado en la clase derivada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, saves the content of all parts and relationships to the derived class store.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> llama a la <xref:System.IO.Packaging.Package.Flush%2A> método para realizar la operación de vaciado real basada en el formato físico implementado en la clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La clase derivada <see cref="M:System.IO.Packaging.Package.FlushCore" /> implementación no debe hacer ninguna suposición sobre el orden o las operaciones realizadas por el <see cref="M:System.IO.Packaging.Package.Flush" /> método que lo llama.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the part to return.</param>
        <summary>Returns the part with a given URI.</summary>
        <returns>The part with the specified <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.InvalidOperationException> se produce si un elemento con los valores especificados `partUri` no existe.  
  
 El <xref:System.IO.Packaging.Package.PartExists%2A> método puede utilizarse para determinar si `partUri` hace referencia a un elemento existente.  
  
 De forma predeterminada, un <xref:System.IO.Packaging.ZipPackage> implementación derivada de la abstracta <xref:System.IO.Packaging.Package> se proporciona y se usa la clase base.  En la operación de forma predeterminada, <xref:System.IO.Packaging.Package.GetPart%2A> llama internamente a <xref:System.IO.Packaging.Package.GetPartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> clase para devolver un elemento solicitado desde un archivo ZIP.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo buscar, recuperar y leer los elementos contenidos en un paquete.  Para obtener un ejemplo completo, vea [leer un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">A part with the specified <paramref name="partUri" /> is not in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> llama internamente a la clase derivada <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> método para vaciar el elemento basado en el formato físico implementado en la clase derivada.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] of the part to retrieve.</param>
        <summary>When overridden in a derived class, returns the part addressed by a given URI.</summary>
        <returns>The requested part; or <see langword="null" />, if a part with the specified <paramref name="partUri" /> is not in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, un <xref:System.IO.Packaging.ZipPackage> implementación derivada de la abstracta <xref:System.IO.Packaging.Package> proporcionado y usa la clase.  En la operación de forma predeterminada, <xref:System.IO.Packaging.Package.GetPart%2A> llama internamente a <xref:System.IO.Packaging.Package.GetPartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> clase para recuperar una parte de un archivo ZIP.  
  
 Para obtener más información sobre el modelo y los elementos del paquete, consulte el capítulo 1 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La clase derivada <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> implementación llama a la <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> método para tener acceso y devolver la parte especificada basada en el formato físico implementado en la clase derivada.  La clase derivada <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> implementación debe hacer ninguna suposición sobre el orden o las operaciones realizadas por el <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> método que lo llama.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a collection of all the parts in the package.</summary>
        <returns>A collection of all the <see cref="T:System.IO.Packaging.PackagePart" /> elements that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> Devuelve una colección de todas las partes que se encuentran en el paquete, incluidos <xref:System.IO.Packaging.PackageRelationship> partes.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> nunca devolverá `null`; sin embargo, la colección devuelta contendrá cero elementos si el paquete no contiene ningún elemento.  
  
 De forma predeterminada, un <xref:System.IO.Packaging.ZipPackage> implementación derivada de la abstracta <xref:System.IO.Packaging.Package> se proporciona y se usa la clase base.  En la operación de forma predeterminada, <xref:System.IO.Packaging.Package.GetParts%2A> llamadas la <xref:System.IO.Packaging.Package.GetPartsCore%2A> método de la <xref:System.IO.Packaging.ZipPackage> clase para devolver las partes de un archivo ZIP.  
  
 Para obtener más información sobre los paquetes y los elementos del paquete, vea la sección 1.1 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.IO.Packaging.Package.GetParts%2A> método para obtener una colección de los elementos que se encuentran en un <xref:System.IO.Packaging.Package>.  El código fuente del programa completo, vea [creación de un paquete con un ejemplo de la firma Digital](http://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> llama internamente a la clase derivada <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> método para vaciar el elemento basado en el formato físico implementado en la clase derivada.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns an array of all the parts in the package.</summary>
        <returns>An array of all the parts that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase derivada <xref:System.IO.Packaging.Package.GetPartsCore%2A> implementación llama a la <xref:System.IO.Packaging.Package.GetParts%2A> método para tener acceso y devolver la matriz de partes basada en el formato físico implementado en la clase derivada.  
  
 De forma predeterminada, un <xref:System.IO.Packaging.ZipPackage> implementación derivada de la abstracta <xref:System.IO.Packaging.Package> proporcionado y usa la clase.  En la operación de forma predeterminada, <xref:System.IO.Packaging.Package.GetParts%2A> llama internamente a <xref:System.IO.Packaging.Package.GetPartCore%2A> de la <xref:System.IO.Packaging.ZipPackage> clase para recuperar las partes de un archivo ZIP.  
  
 Para obtener más información sobre el modelo y los elementos del paquete, consulte el capítulo 1 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La clase derivada <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> implementación debe hacer ninguna suposición sobre el orden o las operaciones realizadas por el <see cref="M:System.IO.Packaging.Package.GetParts" /> método que lo llama.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the relationship to return.</param>
        <summary>Returns the package-level relationship with a given identifier.</summary>
        <returns>The package-level relationship with the specified <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en el esquema XML parte 2: especificación de los tipos de datos (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Para obtener más información sobre el empaquetado y relaciones de paquete, vea la sección 1.3 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
        <exception cref="T:System.InvalidOperationException">A relationship with the specified <paramref name="id" /> is not in the package.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a collection of all the package-level relationships.</summary>
        <returns>A collection of all the package-level relationships that are contained in the package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> nunca devolverá `null`; sin embargo, la colección devuelta puede contener cero elementos si el paquete no contiene ninguna relación de nivel de paquete.  
  
 Una relación de nivel de paquete define una asociación entre el paquete y un elemento de destino asociado o un recurso.  Una relación de nivel de paquete puede ser una de estas dos formas.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un elemento de destino en el paquete.  
  
-   Entre un <xref:System.IO.Packaging.Package> a un recurso de destino fuera del paquete.  
  
 En una relación de paquete, el paquete se considera el "propietario" de la relación.  Cuando se elimina el paquete, también se eliminan todas las relaciones que posee el paquete.  El proceso de creación o eliminación de la relación no modifica físicamente el elemento de destino o recurso de ninguna manera.  
  
 Para obtener más información sobre el empaquetado y relaciones de paquete, vea la sección 1.3 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">The <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> to match and return in the collection.</param>
        <summary>Returns a collection of all the package-level relationships that match a given <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>A collection of package-level relationships that match the specified <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> nunca devolverá `null`; sin embargo, la colección devuelta puede contener cero elementos si no hay ninguna relación de nivel de paquete que coinciden con la cadena `relationshipType`.  
  
 En la tabla siguiente se muestra el nivel de paquete `relationshipType` URI definen por la especificación de Open Packaging Conventions (OPC).  
  
|Relación de nivel de paquete|URI del tipo de relación|  
|---------------------------------|---------------------------|  
|Propiedades básicas|http://schemas.openxmlformats.org/package/2006/relationships/meta datos/core-properties|  
|Firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit firma de firma de al|  
|Certificado de firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit certificado de firma de al|  
|Origen de la firma digital|http://schemas.openxmlformats.org/package/2006/relationships/digit al-/ origen de la firma|  
|Vista en miniatura|http://schemas.openxmlformats.org/package/2006/relationships/meta datos/vista en miniatura|  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo recuperar las relaciones que se han definido para el paquete.  Para obtener un ejemplo completo, vea [leer un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> is an empty string.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a package.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> es el tipo de paquete predeterminado que usa el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo <xref:System.IO.Packaging.Package> que incorpora <xref:System.IO.Packaging.PackageRelationship> y <xref:System.IO.Packaging.PackagePart> elementos junto con los datos almacenados.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <summary>Opens a package on a given IO stream.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> es el tipo de paquete predeterminado que usa el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or, the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <summary>Opens a package at a given path and file name.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> es el tipo de paquete predeterminado que usa el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Esto <xref:System.IO.Packaging.Package.Open%2A> método abre el paquete con los atributos predeterminados <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, y <xref:System.IO.FileShare.None> (para especificar atributos diferentes use una de las otras sobrecargas del método Open).  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo <xref:System.IO.Packaging.Package> que incorpora <xref:System.IO.Packaging.PackageRelationship> y <xref:System.IO.Packaging.PackagePart> elementos junto con los datos almacenados.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <summary>Opens a package with a given IO stream and file mode.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> es el tipo de paquete predeterminado que usa el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="packageMode" /> value is not valid.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or, the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> es el tipo de paquete predeterminado que usa el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Esto <xref:System.IO.Packaging.Package.Open%2A> método abre el paquete con los atributos predeterminados <xref:System.IO.FileAccess.ReadWrite> y <xref:System.IO.FileShare.None> (para especificar atributos diferentes use una de las otras sobrecargas del método Open).  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo <xref:System.IO.Packaging.Package> que incorpora <xref:System.IO.Packaging.PackageRelationship> y <xref:System.IO.Packaging.PackagePart> elementos junto con los datos almacenados.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Value for <paramref name="packageMode" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">The IO stream on which to open the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <summary>Opens a package with a given IO stream, file mode, and file access setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> es el tipo de paquete predeterminado que usa el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="packageMode" /> or <paramref name="packageAccess" /> is not valid.</exception>
        <exception cref="T:System.IO.IOException">The package to open requires read or read/write permission and the specified <paramref name="stream" /> is write-only; or the package to open requires write or read/write permission and the specified <paramref name="stream" /> is read-only.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode and file access setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> es el tipo de paquete predeterminado que usa el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Esto <xref:System.IO.Packaging.Package.Open%2A> método abre el paquete con el valor predeterminado es <xref:System.IO.FileShare.None> atributo (para especificar un atributo diferente, use el <xref:System.IO.Packaging.Package.Open%2A> sobrecarga del método).  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo abrir y leer un <xref:System.IO.Packaging.Package> que contiene <xref:System.IO.Packaging.PackageRelationship> y <xref:System.IO.Packaging.PackagePart> elementos junto con los datos almacenados.  Para obtener un ejemplo completo, vea [leer un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Value for <paramref name="packageMode" /> or <paramref name="packageAccess" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">The path and file name of the package.</param>
        <param name="packageMode">The file mode in which to open the package.</param>
        <param name="packageAccess">The file access in which to open the package.</param>
        <param name="packageShare">The file sharing mode in which to open the package.</param>
        <summary>Opens a package at a given path using a given file mode, file access, and file share setting.</summary>
        <returns>The opened package.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> es el tipo de paquete predeterminado que usa el <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo <xref:System.IO.Packaging.Package> que incorpora <xref:System.IO.Packaging.PackageRelationship> y <xref:System.IO.Packaging.PackagePart> elementos junto con los datos almacenados.  Para obtener un ejemplo completo, vea [escribir un ejemplo de paquete](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value for <paramref name="packageMode" />, <paramref name="packageAccess" />, or <paramref name="packageShare" /> is not valid.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the core properties of the package.</summary>
        <value>Las propiedades básicas del paquete.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre las propiedades básicas del paquete, vea la sección 3.1 de la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">The <see cref="T:System.Uri" /> of the part to check for.</param>
        <summary>Indicates whether a part with a given URI is in the package.</summary>
        <returns>
          <see langword="true" /> if a part with the specified <paramref name="partUri" /> is in the package; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `partUri` debe comenzar con un carácter de barra diagonal "/" y ser absoluto desde la raíz del paquete.  
  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> is not a valid <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only (information cannot be read).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">The <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> of the relationship to check for.</param>
        <summary>Indicates whether a package-level relationship with a given ID is contained in the package.</summary>
        <returns>
          <see langword="true" /> if a package-level relationship with the specified <paramref name="id" /> is in the package; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea la especificación de Open Packaging Conventions (OPC) disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> is not a valid XML identifier.</exception>
        <exception cref="T:System.ObjectDisposedException">The package is not open (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> or <see cref="M:System.IO.Packaging.Package.Close" /> has been called).</exception>
        <exception cref="T:System.IO.IOException">The package is write-only.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended for application use.  Use the type-safe <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> method instead.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>