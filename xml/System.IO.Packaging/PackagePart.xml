<Type Name="PackagePart" FullName="System.IO.Packaging.PackagePart">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bd36673001d31d8622d2ce270e9819b862ca76e2" /><Meta Name="ms.sourcegitcommit" Value="0609891c89ddaa91e4c02970acb00072fcc29baf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="05/13/2019" /><Meta Name="ms.locfileid" Value="65558086" /></Metadata><TypeSignature Language="C#" Value="public abstract class PackagePart" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PackagePart extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.PackagePart" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PackagePart" />
  <TypeSignature Language="C++ CLI" Value="public ref class PackagePart abstract" />
  <TypeSignature Language="F#" Value="type PackagePart = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una clase base de los elementos almacenados en un <see cref="T:System.IO.Packaging.Package" />.  Esta clase es abstracta.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.IO.Packaging.PackagePart> consta de tres elementos básicos:  
  
|Access|Descripción|  
|------------|-----------------|  
|<xref:System.IO.Packaging.PackagePart.Uri%2A>|El [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento.|  
|<xref:System.IO.Packaging.PackagePart.ContentType%2A>|El [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de la secuencia de contenido.|  
|<xref:System.IO.Packaging.PackagePart.GetStream%2A>|El flujo de datos de contenido de la parte.|  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Packaging.PackagePart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Identificadores URI de paquete en WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
  
 [Especificación Open Packaging Conventions](https://go.microsoft.com/fwlink/?LinkID=71255)  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="package">El elemento primario <see cref="T:System.IO.Packaging.Package" /> del elemento.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento, relativo a la raíz <see cref="T:System.IO.Packaging.Package" /> principal.</param>
        <summary>Inicializa una nueva instancia de la <see cref="T:System.IO.Packaging.PackagePart" /> clase con un elemento primario especificado <see cref="P:System.IO.Packaging.PackagePart.Package" /> y parte [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` debe ser válido <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] formada de acuerdo con la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación y el [empaquetado abierto Convenciones](https://go.microsoft.com/fwlink/?LinkID=71255) especificación.  
  
 Utilice este constructor cuando el <xref:System.IO.Packaging.PackagePart.ContentType%2A> del elemento no se inmediatamente conoce y se establecerán más adelante cuando <xref:System.IO.Packaging.Package.CreatePart%2A> se llama.  
  
 De forma predeterminada, el <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> propiedad del elemento se inicializa en <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> o <paramref name="partUri" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="package">El elemento primario <see cref="T:System.IO.Packaging.Package" /> del elemento.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento, relativo a la raíz <see cref="T:System.IO.Packaging.Package" /> principal.</param>
        <param name="contentType">El [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de flujo de datos de elemento de contenido.</param>
        <summary>Inicializa una nueva instancia de la <see cref="T:System.IO.Packaging.PackagePart" /> clase con un elemento primario especificado <see cref="P:System.IO.Packaging.PackagePart.Package" />, parte [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)], y [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de contenido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` debe ser válido <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] formada de acuerdo con la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación y el [empaquetado abierto Convenciones](https://go.microsoft.com/fwlink/?LinkID=71255) especificación.  
  
 De forma predeterminada, el <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> propiedad del elemento se inicializa en <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 `contentType` debe ser un [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo formadas de acuerdo con la [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, sección 3.7.  En la tabla siguiente se muestra un ejemplo del contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipos utilizados en [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] documentos.  
  
|Descripción|Tipo de contenido|  
|-----------------|------------------|  
|Fuente|application/vnd.ms-opentype|  
|Perfil ICC|application/vnd.ms-color.iccprofile|  
|Imagen JPEG|image/jpeg|  
|Fuente ofuscado|application/vnd.ms-package.obfuscated-opentype|  
|Imagen PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Imagen TIFF|imagen tiff|  
|Imagen de Windows Media Photo|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> o <paramref name="partUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> no es válido <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType, compressionOption)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="package">El elemento primario <see cref="T:System.IO.Packaging.Package" /> del elemento.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento, relativo a la raíz <see cref="T:System.IO.Packaging.Package" /> principal.</param>
        <param name="contentType">El [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de flujo de datos del elemento de contenido.</param>
        <param name="compressionOption">La opción de compresión de la secuencia de datos de elemento.</param>
        <summary>Inicializa una nueva instancia de la <see cref="T:System.IO.Packaging.PackagePart" /> clase con un elemento primario especificado <see cref="P:System.IO.Packaging.PackagePart.Package" />, parte [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)], [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de contenido, y <see cref="T:System.IO.Packaging.CompressionOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` debe ser válido <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] formada de acuerdo con la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación y el [empaquetado abierto Convenciones](https://go.microsoft.com/fwlink/?LinkID=71255) especificación.  
  
 `contentType` debe ser un [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo formadas de acuerdo con la [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, sección 3.7.  En la tabla siguiente se muestra un ejemplo del contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipos utilizados en [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] documentos.  
  
|Descripción|Tipo de contenido|  
|-----------------|------------------|  
|Fuente|application/vnd.ms-opentype|  
|Perfil ICC|application/vnd.ms-color.iccprofile|  
|Imagen JPEG|image/jpeg|  
|Fuente ofuscado|application/vnd.ms-package.obfuscated-opentype|  
|Imagen PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Imagen TIFF|imagen tiff|  
|Imagen de Windows Media Photo|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="package" /> o <paramref name="partUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> no es válido <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El <paramref name="compressionOption" /> valor no es válido.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName="CompressionOption">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.CompressionOption CompressionOption { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Packaging.CompressionOption CompressionOption" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompressionOption As CompressionOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::CompressionOption CompressionOption { System::IO::Packaging::CompressionOption get(); };" />
      <MemberSignature Language="F#" Value="member this.CompressionOption : System.IO.Packaging.CompressionOption" Usage="System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.CompressionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la opción de compresión de la secuencia de contenido del elemento.</summary>
        <value>La opción de compresión de la secuencia de contenido del elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> es una propiedad de solo lectura que se puede tener acceso solo cuando el elemento primario <xref:System.IO.Packaging.Package> está abierto.  
  
 El <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> propiedad se establece automáticamente la <xref:System.IO.Packaging.PackagePart.%23ctor%2A> constructor.  Una vez que se establece mediante el constructor, el <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> no se puede cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.IO.Packaging.PackagePart.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de la secuencia de contenido.</summary>
        <value>El [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo del flujo de datos de contenido para el elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> es una propiedad de solo lectura que se puede tener acceso solo cuando el elemento primario <xref:System.IO.Packaging.Package> está abierto.  
  
 El <xref:System.IO.Packaging.PackagePart.ContentType%2A> propiedad se establece automáticamente la <xref:System.IO.Packaging.PackagePart.%23ctor%2A> constructor.  Una vez que se establece mediante el constructor, el <xref:System.IO.Packaging.PackagePart.ContentType%2A> no se puede cambiar.  
  
 El <xref:System.IO.Packaging.PackagePart.ContentType%2A> propiedad es un [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo formadas de acuerdo con la [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, sección 3.7.  En la tabla siguiente se muestra un ejemplo del contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipos utilizados en [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] documentos.  
  
|Descripción|Tipo de contenido|  
|-----------------|------------------|  
|Fuente|application/vnd.ms-opentype|  
|Perfil ICC|application/vnd.ms-color.iccprofile|  
|Imagen JPEG|image/jpeg|  
|Fuente ofuscado|application/vnd.ms-package.obfuscated-opentype|  
|Imagen PNG|image/png|  
|PrintTicket|application/vnd.ms-printing.printticket+xml|  
|Imagen TIFF|imagen tiff|  
|Imagen de Windows Media Photo|image/vnd.ms-photo|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).  
  
-o bien- 
La cadena devuelta por la clase derivada <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> método está vacío.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una relación de nivel de elemento entre este <see cref="T:System.IO.Packaging.PackagePart" /> a un destino especificado <see cref="T:System.IO.Packaging.PackagePart" /> o un recurso externo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de elemento define una asociación entre este elemento y un elemento de destino o recurso.  Una relación de nivel de elemento puede ser una de estas dos formas.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un destino <xref:System.IO.Packaging.PackagePart> dentro de la <xref:System.IO.Packaging.Package>.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un recurso de destino fuera del paquete.  
  
 En una relación de elementos, el elemento de origen se considera el "propietario" de la relación.  Cuando se elimina el elemento de origen, también se eliminan todas las relaciones que posee el elemento.  El proceso de creación o eliminación de la relación no modifica físicamente el elemento de destino o recurso de ninguna manera.  
  
 El <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> método físicamente no cambia el elemento de origen o el elemento de destino o recurso de ninguna manera.  
  
 El destino de una relación no puede ser otra relación.  
  
 Para obtener más información acerca de las relaciones de paquete, vea la sección 1.3 de la *Open Packaging Conventions (OPC)* especificación está disponible para su descarga en <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 Para obtener más información acerca de XPS documenta Véase el *Open XML Paper Specification (XPS)* disponibles para su descarga en <https://go.microsoft.com/fwlink/?LinkID=67000>.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento de destino.</param>
        <param name="targetMode">Uno de los valores de enumeración. Por ejemplo, <see cref="F:System.IO.Packaging.TargetMode.Internal" /> si el elemento de destino está dentro de la <see cref="T:System.IO.Packaging.Package" />; o <see cref="F:System.IO.Packaging.TargetMode.External" /> si el destino es un recurso fuera de la <see cref="T:System.IO.Packaging.Package" />.</param>
        <param name="relationshipType">El rol de la relación.</param>
        <summary>Crea una relación de nivel de elemento entre este <see cref="T:System.IO.Packaging.PackagePart" /> a un destino especificado <see cref="T:System.IO.Packaging.PackagePart" /> o un recurso externo.</summary>
        <returns>La relación de nivel de elemento entre este <see cref="T:System.IO.Packaging.PackagePart" /> al destino <see cref="T:System.IO.Packaging.PackagePart" /> o un recurso externo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de elemento define una asociación entre este elemento y un elemento de destino o recurso.  Una relación de nivel de elemento puede ser una de estas dos formas.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un destino <xref:System.IO.Packaging.PackagePart> dentro de la <xref:System.IO.Packaging.Package>.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un recurso de destino fuera del paquete.  
  
 En una relación de elementos, el elemento de origen se considera el "propietario" de la relación.  Cuando se elimina el elemento de origen, también se eliminan todas las relaciones que posee el elemento.  El proceso de creación o eliminación de la relación no modifica físicamente el elemento de destino o recurso de ninguna manera.  
  
 El <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> método físicamente no cambia el elemento de origen o el elemento de destino o recurso de ninguna manera.  
  
 El destino de una relación no puede ser otra relación.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` debe ser un URI relativo que se forma de acuerdo con la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  El URI relativo interno puede ser una ruta absoluta que comienza por una barra diagonal ("/") caracteres como "/ page1.xaml" o "/ images/picture4.jpg", o una ruta de acceso relativa como ".. / imagespicture1.jpg "que se resuelve en la raíz del paquete ("/ ") como el URI base.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.External>, `targetUri` puede ser cualquier absoluta o URI relativo el formato correcto de acuerdo con la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  "https://www.microsoft.com/page2.xml" es un ejemplo de un URI absoluto que hace referencia a un recurso de destino externo "page2.xml".  "images/picture1.jpg" es un ejemplo de un URI relativo que también hace referencia a un destino externo resource "1.jpg" pero que se resuelve en el URI del propio paquete.  
  
 `relationshipType` debe ser un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] que se forma según la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  Tipos de paquetes diferentes pueden definir tipos de relación de nivel de elemento diferente.  En la tabla siguiente se muestra el nivel de elemento `relationshipType` URI definen para los documentos que se ajustan a la *Open XML Paper Specification (XPS)*.  
  
|Relación de nivel de elemento de documento XPS|URI del tipo de relación|  
|-------------------------------------------|---------------------------|  
|Definiciones de firma digital|[http://schemas.microsoft.com/xps/2005/06/signature-definitions](https://schemas.microsoft.com/xps/2005/06/signature-definitions)|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Recurso necesario|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|Fuente restringida|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Para obtener más información acerca de las relaciones de paquete, vea la sección 1.3 de la *Open Packaging Conventions (OPC)* especificación está disponible para su descarga en <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 Para obtener más información acerca de XPS documenta Véase el *Open XML Paper Specification (XPS)* disponibles para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=67000 ](https://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> o <paramref name="relationshipType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El <paramref name="targetMode" /> no es válido el parámetro <see cref="T:System.IO.Packaging.TargetMode" /> valor de enumeración.</exception>
        <exception cref="T:System.ArgumentException">El elemento identificado por el <paramref name="targetUri" /> es una relación (el destino de una relación no puede ser otra relación).  
  
-o bien- 
 <paramref name="targetMode" /> se especifica como <see cref="F:System.IO.Packaging.TargetMode.Internal" /> pero <paramref name="targetUri" /> es externo absoluto [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.IO.IOException">El paquete es de solo lectura (no se puede agregar una nueva relación).</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento de destino.</param>
        <param name="targetMode">Uno de los valores de enumeración. Por ejemplo, <see cref="F:System.IO.Packaging.TargetMode.Internal" /> si el elemento de destino está dentro de la <see cref="T:System.IO.Packaging.Package" />; o <see cref="F:System.IO.Packaging.TargetMode.External" /> si el destino es un recurso fuera de la <see cref="T:System.IO.Packaging.Package" />.</param>
        <param name="relationshipType">El rol de la relación.</param>
        <param name="id">Un identificador único para la relación.</param>
        <summary>Crea una relación de nivel de elemento entre este <see cref="T:System.IO.Packaging.PackagePart" /> a un destino especificado <see cref="T:System.IO.Packaging.PackagePart" /> o un recurso externo.</summary>
        <returns>La relación de nivel de elemento entre este <see cref="T:System.IO.Packaging.PackagePart" /> al destino <see cref="T:System.IO.Packaging.PackagePart" /> o un recurso externo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de elemento define una asociación entre este elemento y un elemento de destino o recurso.  Una relación de nivel de elemento puede ser una de estas dos formas.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un destino <xref:System.IO.Packaging.PackagePart> dentro de la <xref:System.IO.Packaging.Package>.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un recurso de destino fuera del paquete.  
  
 En una relación de elementos, el elemento de origen se considera el "propietario" de la relación.  Cuando se elimina el elemento de origen, también se eliminan todas las relaciones que posee el elemento.  El proceso de creación o eliminación de la relación no modifica físicamente el elemento de destino o recurso de ninguna manera.  
  
 `id` Debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en la *XML Schema Part 2: Los tipos de datos* especificación (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 El <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> método físicamente no cambia el elemento de origen o el elemento de destino o recurso de ninguna manera.  
  
 El destino de una relación no puede ser otra relación.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` debe ser un URI relativo que se forma de acuerdo con la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  El URI relativo interno puede ser una ruta absoluta que comienza por una barra diagonal ("/") caracteres como "/ page1.xaml" o "/ images/picture4.jpg", o una ruta de acceso relativa como ".. / imagespicture1.jpg "que se resuelve en la raíz del paquete ("/ ") como el URI base.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.External>, `targetUri` puede ser cualquier absoluta o URI relativo el formato correcto de acuerdo con la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  "https://www.microsoft.com/page2.xml" es un ejemplo de un URI absoluto que hace referencia a un recurso de destino externo "page2.xml".  "images/picture1.jpg" es un ejemplo de un URI relativo que también hace referencia a un destino externo resource "1.jpg" pero que se resuelve en el URI del propio paquete.  
  
 `relationshipType` debe ser un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] que se forma según la [RFC 3986](https://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  Tipos de paquetes diferentes pueden definir tipos de relación de nivel de elemento diferente.  En la tabla siguiente se muestra el nivel de elemento `relationshipType` URI definen para los documentos que se ajustan a la *Open XML Paper Specification (XPS)*.  
  
|Relación de nivel de elemento de documento XPS|URI del tipo de relación|  
|-------------------------------------------|---------------------------|  
|Definiciones de firma digital|http://schemas.microsoft.com/xps/2005/06/signature-definitions|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Recurso necesario|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|Fuente restringida|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Para obtener más información acerca de las relaciones de paquete, vea la sección 1.3 de la *Open Packaging Conventions (OPC)* especificación está disponible para su descarga en <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 Para obtener más información acerca de XPS documenta Véase el *Open XML Paper Specification (XPS)* disponibles para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=67000 ](https://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> o <paramref name="relationshipType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El <paramref name="targetMode" /> no es válido el parámetro <see cref="T:System.IO.Packaging.TargetMode" /> valor de enumeración.</exception>
        <exception cref="T:System.ArgumentException">El elemento identificado por el <paramref name="targetUri" /> es una relación (el destino de una relación no puede ser otra relación).  
  
-o bien- 
 <paramref name="targetMode" /> se especifica como <see cref="F:System.IO.Packaging.TargetMode.Internal" /> pero <paramref name="targetUri" /> es externo absoluto [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.IO.IOException">El paquete es de solo lectura (no se puede agregar una nueva relación).</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> no es un identificador XML válido.  
  
-o bien- 
Un elemento con los valores especificados <paramref name="id" /> ya existe.</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="packagePart.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> de la relación que se va a eliminar.</param>
        <summary>Elimina un nivel de elemento especificado <see cref="T:System.IO.Packaging.PackageRelationship" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en la *XML Schema Part 2: Los tipos de datos* especificación (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Si el texto especificado `id` no coincide con el <xref:System.IO.Packaging.PackageRelationship.Id%2A> para cualquiera de las relaciones que pertenecen a este elemento, no se elimina ninguna relación y se produce ninguna excepción.  
  
 Distinto de eliminar la relación especificada, el <xref:System.IO.Packaging.PackagePart.DeleteRelationship%2A> método físicamente no cambie este elemento o el elemento de destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">El paquete es de solo lectura (no se puede eliminar las relaciones).</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> no es un identificador XML válido.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetContentTypeCore">
      <MemberSignature Language="C#" Value="protected virtual string GetContentTypeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetContentTypeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetContentTypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContentTypeCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetContentTypeCore();" />
      <MemberSignature Language="F#" Value="abstract member GetContentTypeCore : unit -&gt; string&#xA;override this.GetContentTypeCore : unit -&gt; string" Usage="packagePart.GetContentTypeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, devuelve el [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de contenido del elemento.</summary>
        <returns>El [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de contenido del elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> es un método virtual de la <xref:System.IO.Packaging.PackagePart> clase base abstracta. Implemente este método solo en tipos derivados que no se puede proporcionar el valor del tipo de contenido en el momento de construcción, o si calcular el contenido del tipo de valor es una operación no trivial o costosa. El valor devuelto debe ser válido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de contenido.  
  
 Pueden llamar las clases derivadas <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> para inicializar el <xref:System.IO.Packaging.PackagePart.ContentType%2A> propiedad de la clase derivada en un valor predeterminado.  Después de la <xref:System.IO.Packaging.PackagePart.ContentType%2A> propiedad se ha establecido no se puede cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La clase derivada no proporciona una implementación de invalidación necesaria para la <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> de la relación que se va a devolver.</param>
        <summary>Devuelve la relación que tiene especificado <see cref="P:System.IO.Packaging.PackageRelationship.Id" />.</summary>
        <returns>La relación que coincide con el especificado <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en la *XML Schema Part 2: Los tipos de datos* especificación (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Puede usar el <xref:System.IO.Packaging.PackagePart.RelationshipExists%2A> método para determinar si una relación con un determinado <xref:System.IO.Packaging.PackageRelationship.Id%2A> es propiedad de este elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> no es un identificador XML válido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" /> es una cadena vacía.</exception>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).  
  
-o bien- 
Una relación con los valores especificados <paramref name="id" /> no existe en el paquete.</exception>
        <exception cref="T:System.IO.IOException">El paquete es de sólo escritura (no se puede leer la información de relación).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección de todas las relaciones que pertenecen a este elemento.</summary>
        <returns>Una colección de todas las relaciones que pertenecen a la parte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección devuelta nunca es `null`; sin embargo, la colección puede contener cero elementos si el elemento no define las relaciones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.IO.IOException">El paquete es de sólo escritura (no se puede leer la información de relación).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">El <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> de las relaciones para buscar y devolver en la colección.</param>
        <summary>Devuelve una colección de las relaciones que coinciden con un determinado <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>Una colección de las relaciones que coinciden con la cadena <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección devuelta nunca es `null`; sin embargo, la colección puede contener cero elementos si ninguna relación coincide con el especificado `relationshipType` que se definió para el elemento.  
  
 Los espacios iniciales o finales en el `relationshipType` cadena se recortan automáticamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="relationshipType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" /> es una cadena vacía.</exception>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.IO.IOException">El paquete es de sólo escritura (no se puede leer la información de relación).</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la secuencia de datos de contenido de elemento.</summary>
        <block subset="none" type="usage"><para>
            <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> la clase derivada llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método para abrir y devolver el flujo de datos del elemento realmente basada en el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.IO.Stream" Usage="packagePart.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la secuencia de datos de contenido de elemento.</summary>
        <returns>El flujo de datos de contenido para el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre la secuencia de contenido con <xref:System.IO.FileMode> de <xref:System.IO.FileMode.OpenOrCreate> y <xref:System.IO.FileAccess> permisos que son los mismos que el elemento primario <xref:System.IO.Packaging.Package>.  
  
 La sobrecarga <xref:System.IO.Packaging.PackagePart.GetStream%2A> método le permite establecer un determinado <xref:System.IO.FileMode>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.IO.IOException">El objeto de secuencia devuelto por la <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método de la subclase derivada es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> la clase derivada llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método para abrir y devolver el flujo de datos del elemento realmente basada en el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode -&gt; System.IO.Stream" Usage="packagePart.GetStream mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">El modo de E/S en el que se va a abrir la secuencia de contenido.</param>
        <summary>Devuelve la secuencia de contenido abierta en una E/S especificada <see cref="T:System.IO.FileMode" />.</summary>
        <returns>La secuencia de contenido del elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileAccess> permisos de la secuencia de contenido devuelto son los mismos que los permisos del elemento primario <xref:System.IO.Packaging.Package>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El <paramref name="mode" /> no es válido el parámetro <see cref="T:System.IO.FileMode" /> valor de enumeración.</exception>
        <exception cref="T:System.IO.IOException">El <paramref name="mode" /> parámetro no es compatible con la secuencia de paquete y la parte.  
  
-o bien- 
El objeto de secuencia devuelto por la <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método de la subclase derivada es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> la clase derivada llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método para abrir y devolver el flujo de datos del elemento realmente basada en el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStream (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">El modo de E/S en el que se va a abrir la secuencia de contenido.</param>
        <param name="access">Los permisos de acceso para usarlo en la apertura de la secuencia de contenido.</param>
        <summary>Devuelve la secuencia de contenido del elemento abierta con un determinado <see cref="T:System.IO.FileMode" /> y <see cref="T:System.IO.FileAccess" />.</summary>
        <returns>La secuencia de contenido para el elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El <paramref name="mode" /> no es válido el parámetro <see cref="T:System.IO.FileMode" /> valor de enumeración.  
  
-o bien- 
El <paramref name="access" /> no es válido el parámetro <see cref="T:System.IO.FileAccess" /> valor de enumeración.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="mode" /> o <paramref name="access" /> no es compatible con la secuencia de paquete y la parte.  
  
-o bien- 
El <paramref name="access" /> parámetro se especifica como <see cref="F:System.IO.FileAccess.Read" /> pero la <paramref name="mode" /> parámetro requiere acceso de escritura.  (<see cref="T:System.IO.FileMode" /> valores de <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, <see cref="F:System.IO.FileMode.Truncate" />, y <see cref="F:System.IO.FileMode.Append" /> requieren <see cref="F:System.IO.FileAccess.Write" /> o <see cref="F:System.IO.FileAccess.ReadWrite" /> acceso.) 
-o bien- 
El objeto de secuencia devuelto por la <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método de la subclase derivada es <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> la clase derivada llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método para abrir y devolver el flujo de datos del elemento realmente basada en el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetStreamCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Stream GetStreamCore (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Stream GetStreamCore(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetStreamCore (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Stream ^ GetStreamCore(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="abstract member GetStreamCore : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStreamCore (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">El modo de E/S en el que se va a abrir la secuencia de contenido.</param>
        <param name="access">Los permisos de acceso para usarlo en la apertura de la secuencia de contenido.</param>
        <summary>Cuando se invalida en una clase derivada, devuelve la secuencia de contenido del elemento abierta con un determinado <see cref="T:System.IO.FileMode" /> y <see cref="T:System.IO.FileAccess" />.</summary>
        <returns>El flujo de datos de contenido de la parte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las aplicaciones no deben llamar a <xref:System.IO.Packaging.PackagePart.GetStreamCore%2A> directamente, pero en su lugar, debe llamar a <xref:System.IO.Packaging.PackagePart.GetStream%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La clase derivada <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> implementación debe hacer ninguna suposición sobre el orden o las operaciones realizadas por el <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> método que lo llama.</para></block>
        <block subset="none" type="usage"><para>La clase derivada <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> llama al método el <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> métodos para abrir y devolver el flujo de datos de elemento según el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.Package Package { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.Package Package" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Package" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Package As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::Package ^ Package { System::IO::Packaging::Package ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Package : System.IO.Packaging.Package" Usage="System.IO.Packaging.PackagePart.Package" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento primario <see cref="T:System.IO.Packaging.Package" /> del elemento.</summary>
        <value>El paquete primario del elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Package%2A> es una propiedad de solo lectura que se puede tener acceso solo cuando el elemento primario <xref:System.IO.Packaging.Package> está abierto.  
  
 El <xref:System.IO.Packaging.PackagePart.Package%2A> propiedad se establece automáticamente la <xref:System.IO.Packaging.PackagePart.%23ctor%2A> constructor.  Una vez que se establece mediante el constructor, el elemento primario <xref:System.IO.Packaging.PackagePart.Package%2A> para el elemento no se puede cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="packagePart.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">El <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> de la relación que se va a comprobar.</param>
        <summary>Devuelve un valor que indica si este elemento tiene una relación con un determinado <see cref="P:System.IO.Packaging.PackageRelationship.Id" />.</summary>
        <returns><see langword="true" /> Si este elemento tiene una relación con los valores especificados <paramref name="id" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en la *XML Schema Part 2: Los tipos de datos* especificación (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> no es un identificador XML válido.</exception>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <exception cref="T:System.IO.IOException">El paquete es de sólo escritura (no se puede leer la información de relación).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Uri">
      <MemberSignature Language="C#" Value="public Uri Uri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Uri" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Uri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Uri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Uri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Uri : Uri" Usage="System.IO.Packaging.PackagePart.Uri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento.</summary>
        <value>El [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento relativo a la raíz del paquete.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> es una propiedad de solo lectura que se puede tener acceso solo cuando el elemento primario <xref:System.IO.Packaging.Package> está abierto.  
  
 El <xref:System.IO.Packaging.PackagePart.Uri%2A> propiedad se establece automáticamente la <xref:System.IO.Packaging.PackagePart.%23ctor%2A> constructor.  Una vez que se establece mediante el constructor, el <xref:System.IO.Packaging.PackagePart.Uri%2A> del elemento no se puede cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento se ha eliminado.  
  
-o bien- 
El <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" /> se ha llamado).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ComparePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
  </Members>
</Type>