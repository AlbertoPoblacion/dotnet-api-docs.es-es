<Type Name="PackagePart" FullName="System.IO.Packaging.PackagePart">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="60a9ff924e1111f2b0bb4f9f355839cd04c5d886" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46593403" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PackagePart" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PackagePart extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.PackagePart" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PackagePart" />
  <TypeSignature Language="C++ CLI" Value="public ref class PackagePart abstract" />
  <TypeSignature Language="F#" Value="type PackagePart = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una clase base de los elementos almacenados en <see cref="T:System.IO.Packaging.Package" />.  Esta clase es abstracta.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.IO.Packaging.PackagePart> consta de tres elementos básicos:  
  
|Access|Descripción|  
|------------|-----------------|  
|<xref:System.IO.Packaging.PackagePart.Uri%2A>|El [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento.|  
|<xref:System.IO.Packaging.PackagePart.ContentType%2A>|El [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de la secuencia de contenido.|  
|<xref:System.IO.Packaging.PackagePart.GetStream%2A>|Flujo de datos de contenido del elemento.|  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Packaging.PackagePart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Identificadores URI de paquete en WPF](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
  
 [Especificación Open Packaging Conventions](http://go.microsoft.com/fwlink/?LinkID=71255)  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="package">Objeto <see cref="T:System.IO.Packaging.Package" /> primario del elemento.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento, relativo a la raíz <see cref="T:System.IO.Packaging.Package" /> principal.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Packaging.PackagePart" /> con una propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> principal especificada y un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` debe ser válido <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] formada de acuerdo con la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación y el [empaquetado abierto Convenciones](http://go.microsoft.com/fwlink/?LinkID=71255) especificación.  
  
 Utilice este constructor cuando el <xref:System.IO.Packaging.PackagePart.ContentType%2A> del elemento no se inmediatamente conoce y se establecerán más adelante cuando <xref:System.IO.Packaging.Package.CreatePart%2A> se llama.  
  
 De forma predeterminada, el <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> propiedad del elemento se inicializa en <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="package" /> o <paramref name="partUri" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="package">Objeto <see cref="T:System.IO.Packaging.Package" /> primario del elemento.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento, relativo a la raíz <see cref="T:System.IO.Packaging.Package" /> principal.</param>
        <param name="contentType">Tipo de contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] del flujo de datos del elemento.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Packaging.PackagePart" /> con una propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> principal especificada, el [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento y el tipo de contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` debe ser válido <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] formada de acuerdo con la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación y el [empaquetado abierto Convenciones](http://go.microsoft.com/fwlink/?LinkID=71255) especificación.  
  
 De forma predeterminada, el <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> propiedad del elemento se inicializa en <xref:System.IO.Packaging.CompressionOption.NotCompressed>.  
  
 `contentType` debe ser un [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo formadas de acuerdo con la [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, sección 3.7.  En la tabla siguiente se muestra un ejemplo del contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipos utilizados en [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] documentos.  
  
|Descripción|Tipo de contenido|  
|-----------------|------------------|  
|Tipo de letra|Application/vnd.ms-opentype|  
|Perfil ICC|Application/vnd.ms-color.iccprofile|  
|Imagen JPEG|Image/jpeg|  
|Fuente ofuscado|application/vnd.ms-package.obfuscated-opentype|  
|Imagen PNG|image/png|  
|PrintTicket|Application/vnd.ms-Printing.PrintTicket+XML|  
|Imagen TIFF|imagen tiff|  
|Imagen de Windows Media Photo|imagen/vnd.ms-foto|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="package" /> o <paramref name="partUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> no es un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] válido de <see cref="T:System.IO.Packaging.PackagePart" />.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PackagePart (System.IO.Packaging.Package package, Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IO.Packaging.Package package, class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.#ctor(System.IO.Packaging.Package,System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PackagePart(System::IO::Packaging::Package ^ package, Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.PackagePart : System.IO.Packaging.Package * Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="new System.IO.Packaging.PackagePart (package, partUri, contentType, compressionOption)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="package" Type="System.IO.Packaging.Package" />
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="package">Objeto <see cref="T:System.IO.Packaging.Package" /> primario del elemento.</param>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento, relativo a la raíz <see cref="T:System.IO.Packaging.Package" /> principal.</param>
        <param name="contentType">Tipo de contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] del flujo de datos del elemento.</param>
        <param name="compressionOption">Opción de compresión del flujo de datos del elemento.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.Packaging.PackagePart" /> con una propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" />principal especificada, el [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento, el contenido de tipo [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] y <see cref="T:System.IO.Packaging.CompressionOption" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` debe ser válido <xref:System.IO.Packaging.PackagePart> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] formada de acuerdo con la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación y el [empaquetado abierto Convenciones](http://go.microsoft.com/fwlink/?LinkID=71255) especificación.  
  
 `contentType` debe ser un [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo formadas de acuerdo con la [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, sección 3.7.  En la tabla siguiente se muestra un ejemplo del contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipos utilizados en [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] documentos.  
  
|Descripción|Tipo de contenido|  
|-----------------|------------------|  
|Tipo de letra|Application/vnd.ms-opentype|  
|Perfil ICC|Application/vnd.ms-color.iccprofile|  
|Imagen JPEG|Image/jpeg|  
|Fuente ofuscado|application/vnd.ms-package.obfuscated-opentype|  
|Imagen PNG|image/png|  
|PrintTicket|Application/vnd.ms-Printing.PrintTicket+XML|  
|Imagen TIFF|imagen tiff|  
|Imagen de Windows Media Photo|imagen/vnd.ms-foto|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="package" /> o <paramref name="partUri" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> no es un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] válido de <see cref="T:System.IO.Packaging.PackagePart" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor <paramref name="compressionOption" /> no es válido.</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName="CompressionOption">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.CompressionOption CompressionOption { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Packaging.CompressionOption CompressionOption" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompressionOption As CompressionOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::CompressionOption CompressionOption { System::IO::Packaging::CompressionOption get(); };" />
      <MemberSignature Language="F#" Value="member this.CompressionOption : System.IO.Packaging.CompressionOption" Usage="System.IO.Packaging.PackagePart.CompressionOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.CompressionOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la opción de compresión de la secuencia de contenido del elemento.</summary>
        <value>Opción de compresión de la secuencia de contenido del elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> es una propiedad de solo lectura que se puede tener acceso solo cuando el elemento primario <xref:System.IO.Packaging.Package> está abierto.  
  
 El <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> propiedad se establece automáticamente la <xref:System.IO.Packaging.PackagePart.%23ctor%2A> constructor.  Una vez que se establece mediante el constructor, el <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> no se puede cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string" Usage="System.IO.Packaging.PackagePart.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] de la secuencia de contenido.</summary>
        <value>El tipo [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] del flujo de datos de contenido del elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.ContentType%2A> es una propiedad de solo lectura que se puede tener acceso solo cuando el elemento primario <xref:System.IO.Packaging.Package> está abierto.  
  
 El <xref:System.IO.Packaging.PackagePart.ContentType%2A> propiedad se establece automáticamente la <xref:System.IO.Packaging.PackagePart.%23ctor%2A> constructor.  Una vez que se establece mediante el constructor, el <xref:System.IO.Packaging.PackagePart.ContentType%2A> no se puede cambiar.  
  
 El <xref:System.IO.Packaging.PackagePart.ContentType%2A> propiedad es un [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo formadas de acuerdo con la [RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616.html) *Hypertext Transfer Protocol - HTTP*, sección 3.7.  En la tabla siguiente se muestra un ejemplo del contenido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipos utilizados en [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] documentos.  
  
|Descripción|Tipo de contenido|  
|-----------------|------------------|  
|Tipo de letra|Application/vnd.ms-opentype|  
|Perfil ICC|Application/vnd.ms-color.iccprofile|  
|Imagen JPEG|Image/jpeg|  
|Fuente ofuscado|application/vnd.ms-package.obfuscated-opentype|  
|Imagen PNG|image/png|  
|PrintTicket|Application/vnd.ms-Printing.PrintTicket+XML|  
|Imagen TIFF|imagen tiff|  
|Imagen de Windows Media Photo|imagen/vnd.ms-foto|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).  
  
O bien 
La cadena devuelta por el método <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" /> de la clase derivada está vacía.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.GetStream" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una relación de nivel de elemento entre este objeto <see cref="T:System.IO.Packaging.PackagePart" /> y un objeto <see cref="T:System.IO.Packaging.PackagePart" /> de destino especificado o un recurso externo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de elemento define una asociación entre este elemento y un elemento de destino o recurso.  Una relación de nivel de elemento puede ser una de estas dos formas.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un destino <xref:System.IO.Packaging.PackagePart> dentro de la <xref:System.IO.Packaging.Package>.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un recurso de destino fuera del paquete.  
  
 En una relación de elementos, el elemento de origen se considera el "propietario" de la relación.  Cuando se elimina el elemento de origen, también se eliminan todas las relaciones que posee el elemento.  El proceso de creación o eliminación de la relación no modifica físicamente el elemento de destino o recurso de ninguna manera.  
  
 El <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> método físicamente no cambia el elemento de origen o el elemento de destino o recurso de ninguna manera.  
  
 El destino de una relación no puede ser otra relación.  
  
 Para obtener más información acerca de las relaciones de paquete, vea la sección 1.3 de la *Open Packaging Conventions (OPC)* especificación está disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 Para obtener más información acerca de XPS documenta Véase el *Open XML Paper Specification (XPS)* disponibles para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento de destino.</param>
        <param name="targetMode">Uno de los valores de enumeración. Por ejemplo, <see cref="F:System.IO.Packaging.TargetMode.Internal" /> si el elemento de destino está en <see cref="T:System.IO.Packaging.Package" />; o <see cref="F:System.IO.Packaging.TargetMode.External" /> si el destino es un recurso externo respecto a <see cref="T:System.IO.Packaging.Package" />.</param>
        <param name="relationshipType">Rol de la relación.</param>
        <summary>Crea una relación de nivel de elemento entre este objeto <see cref="T:System.IO.Packaging.PackagePart" /> y un objeto <see cref="T:System.IO.Packaging.PackagePart" /> de destino especificado o un recurso externo.</summary>
        <returns>La relación de nivel de elemento entre <see cref="T:System.IO.Packaging.PackagePart" /> y <see cref="T:System.IO.Packaging.PackagePart" /> de destino o recurso externo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de elemento define una asociación entre este elemento y un elemento de destino o recurso.  Una relación de nivel de elemento puede ser una de estas dos formas.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un destino <xref:System.IO.Packaging.PackagePart> dentro de la <xref:System.IO.Packaging.Package>.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un recurso de destino fuera del paquete.  
  
 En una relación de elementos, el elemento de origen se considera el "propietario" de la relación.  Cuando se elimina el elemento de origen, también se eliminan todas las relaciones que posee el elemento.  El proceso de creación o eliminación de la relación no modifica físicamente el elemento de destino o recurso de ninguna manera.  
  
 El <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> método físicamente no cambia el elemento de origen o el elemento de destino o recurso de ninguna manera.  
  
 El destino de una relación no puede ser otra relación.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` debe ser un URI relativo que se forma de acuerdo con la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  El URI relativo interno puede ser una ruta absoluta que comienza por una barra diagonal ("/") caracteres como "/ page1.xaml" o "/ images/picture4.jpg", o una ruta de acceso relativa como ".. / imagespicture1.jpg "que se resuelve en la raíz del paquete ("/ ") como el URI base.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.External>, `targetUri` puede ser cualquier absoluta o URI relativo el formato correcto de acuerdo con la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  "http://www.microsoft.com/page2.xml" es un ejemplo de un URI absoluto que hace referencia a un recurso de destino externo "page2.xml".  "images/picture1.jpg" es un ejemplo de un URI relativo que también hace referencia a un destino externo resource "1.jpg" pero que se resuelve en el URI del propio paquete.  
  
 `relationshipType` debe ser un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] que se forma según la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  Tipos de paquetes diferentes pueden definir tipos de relación de nivel de elemento diferente.  En la tabla siguiente se muestra el nivel de elemento `relationshipType` URI definen para los documentos que se ajustan a la *Open XML Paper Specification (XPS)*.  
  
|Relación de nivel de elemento de documento XPS|URI del tipo de relación|  
|-------------------------------------------|---------------------------|  
|Definiciones de firma digital|[http://schemas.microsoft.com/xps/2005/06/signature-definitions](http://schemas.microsoft.com/xps/2005/06/signature-definitions)|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Recurso necesario|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|Fuente restringida|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Para obtener más información acerca de las relaciones de paquete, vea la sección 1.3 de la *Open Packaging Conventions (OPC)* especificación está disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 Para obtener más información acerca de XPS documenta Véase el *Open XML Paper Specification (XPS)* disponibles para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="targetUri" /> o <paramref name="relationshipType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="targetMode" /> no es un valor válido de la enumeración <see cref="T:System.IO.Packaging.TargetMode" />.</exception>
        <exception cref="T:System.ArgumentException">El elemento identificado por el <paramref name="targetUri" /> es una relación (el destino de una relación no puede ser otra relación).  
  
O bien 
 <paramref name="targetMode" /> se especifica como <see cref="F:System.IO.Packaging.TargetMode.Internal" /> pero <paramref name="targetUri" /> es un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]externo absoluto.</exception>
        <exception cref="T:System.IO.IOException">El paquete es de sólo lectura; es decir, no se pueden agregar relaciones nuevas.</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento de destino.</param>
        <param name="targetMode">Uno de los valores de enumeración. Por ejemplo, <see cref="F:System.IO.Packaging.TargetMode.Internal" /> si el elemento de destino está en <see cref="T:System.IO.Packaging.Package" />; o <see cref="F:System.IO.Packaging.TargetMode.External" /> si el destino es un recurso externo respecto a <see cref="T:System.IO.Packaging.Package" />.</param>
        <param name="relationshipType">Rol de la relación.</param>
        <param name="id">Identificador único de la relación.</param>
        <summary>Crea una relación de nivel de elemento entre este objeto <see cref="T:System.IO.Packaging.PackagePart" /> y un objeto <see cref="T:System.IO.Packaging.PackagePart" /> de destino especificado o un recurso externo.</summary>
        <returns>La relación de nivel de elemento entre <see cref="T:System.IO.Packaging.PackagePart" /> y <see cref="T:System.IO.Packaging.PackagePart" /> de destino o recurso externo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una relación de nivel de elemento define una asociación entre este elemento y un elemento de destino o recurso.  Una relación de nivel de elemento puede ser una de estas dos formas.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un destino <xref:System.IO.Packaging.PackagePart> dentro de la <xref:System.IO.Packaging.Package>.  
  
-   Entre un origen de <xref:System.IO.Packaging.PackagePart> a un recurso de destino fuera del paquete.  
  
 En una relación de elementos, el elemento de origen se considera el "propietario" de la relación.  Cuando se elimina el elemento de origen, también se eliminan todas las relaciones que posee el elemento.  El proceso de creación o eliminación de la relación no modifica físicamente el elemento de destino o recurso de ninguna manera.  
  
 `id` Debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en la *XML Schema Part 2: Datatypes* especificación (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 El <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A> método físicamente no cambia el elemento de origen o el elemento de destino o recurso de ninguna manera.  
  
 El destino de una relación no puede ser otra relación.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` debe ser un URI relativo que se forma de acuerdo con la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  El URI relativo interno puede ser una ruta absoluta que comienza por una barra diagonal ("/") caracteres como "/ page1.xaml" o "/ images/picture4.jpg", o una ruta de acceso relativa como ".. / imagespicture1.jpg "que se resuelve en la raíz del paquete ("/ ") como el URI base.  
  
 Si `targetMode` se especifica como <xref:System.IO.Packaging.TargetMode.External>, `targetUri` puede ser cualquier absoluta o URI relativo el formato correcto de acuerdo con la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  "http://www.microsoft.com/page2.xml" es un ejemplo de un URI absoluto que hace referencia a un recurso de destino externo "page2.xml".  "images/picture1.jpg" es un ejemplo de un URI relativo que también hace referencia a un destino externo resource "1.jpg" pero que se resuelve en el URI del propio paquete.  
  
 `relationshipType` debe ser un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] que se forma según la [RFC 3986](http://tools.ietf.org/html/rfc3986) *sintaxis genérica del identificador uniforme de recursos (URI)* especificación.  Tipos de paquetes diferentes pueden definir tipos de relación de nivel de elemento diferente.  En la tabla siguiente se muestra el nivel de elemento `relationshipType` URI definen para los documentos que se ajustan a la *Open XML Paper Specification (XPS)*.  
  
|Relación de nivel de elemento de documento XPS|URI del tipo de relación|  
|-------------------------------------------|---------------------------|  
|Definiciones de firma digital|http://schemas.microsoft.com/xps/2005/06/signature-definitions|  
|DiscardControl|http://schemas.microsoft.com/xps/2005/06/discard-control|  
|DocumentStructure|http://schemas.microsoft.com/xps/2005/06/documentstructure|  
|PrintTicket|http://schemas.microsoft.com/xps/2005/06/printticket|  
|Recurso necesario|http://schemas.microsoft.com/xps/2005/06/required-resource|  
|Fuente restringida|http://schemas.microsoft.com/xps/2005/06/restricted-font|  
|StartPart|http://schemas.microsoft.com/xps/2005/06/fixedrepresentation|  
|StoryFragments|http://schemas.microsoft.com/xps/2005/06/storyfragments|  
  
 Para obtener más información acerca de las relaciones de paquete, vea la sección 1.3 de la *Open Packaging Conventions (OPC)* especificación está disponible para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 Para obtener más información acerca de XPS documenta Véase el *Open XML Paper Specification (XPS)* disponibles para su descarga en [ http://go.microsoft.com/fwlink/?LinkID=67000 ](http://go.microsoft.com/fwlink/?LinkID=67000).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="targetUri" /> o <paramref name="relationshipType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="targetMode" /> no es un valor válido de la enumeración <see cref="T:System.IO.Packaging.TargetMode" />.</exception>
        <exception cref="T:System.ArgumentException">El elemento identificado por el <paramref name="targetUri" /> es una relación (el destino de una relación no puede ser otra relación).  
  
O bien 
 <paramref name="targetMode" /> se especifica como <see cref="F:System.IO.Packaging.TargetMode.Internal" /> pero <paramref name="targetUri" /> es un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]externo absoluto.</exception>
        <exception cref="T:System.IO.IOException">El paquete es de sólo lectura; es decir, no se pueden agregar relaciones nuevas.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> no es un identificador XML válido.  
  
O bien 
Ya existe un elemento con el <paramref name="id" /> especificado.</exception>
        <altmember cref="Overload:System.IO.Packaging.Package.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="packagePart.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">La <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> de la relación que se va a eliminar.</param>
        <summary>Elimina un <see cref="T:System.IO.Packaging.PackageRelationship" /> del nivel de elemento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en la *XML Schema Part 2: Datatypes* especificación (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Si el texto especificado `id` no coincide con el <xref:System.IO.Packaging.PackageRelationship.Id%2A> para cualquiera de las relaciones que pertenecen a este elemento, no se elimina ninguna relación y se produce ninguna excepción.  
  
 Distinto de eliminar la relación especificada, el <xref:System.IO.Packaging.PackagePart.DeleteRelationship%2A> método físicamente no cambie este elemento o el elemento de destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Paquete de sólo lectura; no se pueden eliminar las relaciones.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> no es un identificador XML válido.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetContentTypeCore">
      <MemberSignature Language="C#" Value="protected virtual string GetContentTypeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetContentTypeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetContentTypeCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContentTypeCore () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetContentTypeCore();" />
      <MemberSignature Language="F#" Value="abstract member GetContentTypeCore : unit -&gt; string&#xA;override this.GetContentTypeCore : unit -&gt; string" Usage="packagePart.GetContentTypeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, devuelve el tipo [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] del contenido del elemento.</summary>
        <returns>Tipo [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] del contenido del elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> es un método virtual de la <xref:System.IO.Packaging.PackagePart> clase base abstracta. Implemente este método solo en tipos derivados que no se puede proporcionar el valor del tipo de contenido en el momento de construcción, o si calcular el contenido del tipo de valor es una operación no trivial o costosa. El valor devuelto debe ser válido [!INCLUDE[TLA2#tla_mime](~/includes/tla2sharptla-mime-md.md)] tipo de contenido.  
  
 Pueden llamar las clases derivadas <xref:System.IO.Packaging.PackagePart.GetContentTypeCore%2A> para inicializar el <xref:System.IO.Packaging.PackagePart.ContentType%2A> propiedad de la clase derivada en un valor predeterminado.  Después de la <xref:System.IO.Packaging.PackagePart.ContentType%2A> propiedad se ha establecido no se puede cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La clase derivada no proporciona ninguna implementación de invalidación necesaria para el método <see cref="M:System.IO.Packaging.PackagePart.GetContentTypeCore" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="packagePart.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Propiedad <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> de la relación que se va a devolver.</param>
        <summary>Devuelve la relación que tiene una <see cref="P:System.IO.Packaging.PackageRelationship.Id" />especificada.</summary>
        <returns>Relación que coincide con el <paramref name="id" />especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en la *XML Schema Part 2: Datatypes* especificación (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Puede usar el <xref:System.IO.Packaging.PackagePart.RelationshipExists%2A> método para determinar si una relación con un determinado <xref:System.IO.Packaging.PackageRelationship.Id%2A> es propiedad de este elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> no es un identificador XML válido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> es una cadena vacía.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).  
  
O bien 
No existe en el paquete ninguna relación con el <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.IO.IOException">Paquete es de sólo escritura; es decir, no se puede leer la información de la relación.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección de todas las relaciones que tiene este elemento.</summary>
        <returns>Colección de todas las relaciones que tiene el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección devuelta nunca es `null`; sin embargo, la colección puede contener cero elementos si el elemento no define las relaciones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Paquete es de sólo escritura; es decir, no se puede leer la información de la relación.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="packagePart.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">Propiedad <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> de las relaciones que se van a buscar y devolver en la colección.</param>
        <summary>Devuelve una colección de las relaciones que coinciden con una <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />especificada.</summary>
        <returns>Colección de las relaciones que coinciden con el <paramref name="relationshipType" />especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección devuelta nunca es `null`; sin embargo, la colección puede contener cero elementos si ninguna relación coincide con el especificado `relationshipType` que se definió para el elemento.  
  
 Los espacios iniciales o finales en el `relationshipType` cadena se recortan automáticamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> es una cadena vacía.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Paquete es de sólo escritura; es decir, no se puede leer la información de la relación.</exception>
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink/?LinkID=71255">Especificación Open Packaging Conventions</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el flujo de datos de contenido del elemento.</summary>
        <block subset="none" type="usage">
          <para>
            <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> la clase derivada llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método para abrir y devolver el flujo de datos del elemento realmente basada en el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.IO.Stream" Usage="packagePart.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el flujo de datos de contenido del elemento.</summary>
        <returns>Flujo de datos de contenido del elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre la secuencia de contenido con <xref:System.IO.FileMode> de <xref:System.IO.FileMode.OpenOrCreate> y <xref:System.IO.FileAccess> permisos que son los mismos que el elemento primario <xref:System.IO.Packaging.Package>.  
  
 La sobrecarga <xref:System.IO.Packaging.PackagePart.GetStream%2A> método le permite establecer un determinado <xref:System.IO.FileMode>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">El valor del objeto de secuencia devuelto por el método <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la subclase derivada es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> la clase derivada llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método para abrir y devolver el flujo de datos del elemento realmente basada en el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="M:System.IO.Packaging.PackagePart.GetStream" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode -&gt; System.IO.Stream" Usage="packagePart.GetStream mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">Modo de E/S en el que se va a abrir la secuencia de contenido.</param>
        <summary>Devuelve la secuencia de contenido abierta en <see cref="T:System.IO.FileMode" /> de E/S especificado.</summary>
        <returns>Secuencia de contenido del elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileAccess> permisos de la secuencia de contenido devuelto son los mismos que los permisos del elemento primario <xref:System.IO.Packaging.Package>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="mode" /> no es un valor válido de la enumeración <see cref="T:System.IO.FileMode" />.</exception>
        <exception cref="T:System.IO.IOException">El parámetro <paramref name="mode" /> no es compatible con el paquete ni con la secuencia del elemento.  
  
O bien 
El valor del objeto de secuencia devuelto por el método <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la subclase derivada es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> la clase derivada llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método para abrir y devolver el flujo de datos del elemento realmente basada en el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode)" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetStream (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetStream(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetStream(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.GetStream : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStream (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Modo de E/S en el que se va a abrir la secuencia de contenido.</param>
        <param name="access">Permisos de acceso que se van a usar para abrir la secuencia de contenido.</param>
        <summary>Devuelve la secuencia de contenido del elemento abierta con un <see cref="T:System.IO.FileMode" /> y un <see cref="T:System.IO.FileAccess" /> especificados.</summary>
        <returns>Secuencia de contenido del elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="mode" /> no es un valor válido de la enumeración <see cref="T:System.IO.FileMode" />.  
  
O bien 
El parámetro <paramref name="access" /> no es un valor válido de la enumeración <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> o <paramref name="access" /> no son compatibles con el paquete ni con la secuencia del elemento.  
  
O bien 
El parámetro <paramref name="access" /> se especifica como <see cref="F:System.IO.FileAccess.Read" /> pero el parámetro <paramref name="mode" /> requiere acceso de escritura.  (Los valores <see cref="T:System.IO.FileMode" /> de <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, <see cref="F:System.IO.FileMode.Truncate" /> y <see cref="F:System.IO.FileMode.Append" /> requieren acceso de <see cref="F:System.IO.FileAccess.Write" /> o <see cref="F:System.IO.FileAccess.ReadWrite" />.) 
O bien 
El valor del objeto de secuencia devuelto por el método <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la subclase derivada es <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> la clase derivada llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> método para abrir y devolver el flujo de datos del elemento realmente basada en el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="M:System.IO.Packaging.PackagePart.GetStream(System.IO.FileMode,System.IO.FileAccess)" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetStreamCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Stream GetStreamCore (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Stream GetStreamCore(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetStreamCore (mode As FileMode, access As FileAccess) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Stream ^ GetStreamCore(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="abstract member GetStreamCore : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Stream" Usage="packagePart.GetStreamCore (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Modo de E/S en el que se va a abrir la secuencia de contenido.</param>
        <param name="access">Permisos de acceso que se van a usar para abrir la secuencia de contenido.</param>
        <summary>Cuando se invalida en una clase derivada, devuelve la secuencia de contenido del elemento que se inició con un <see cref="T:System.IO.FileMode" /> y un <see cref="T:System.IO.FileAccess" /> especificados.</summary>
        <returns>Flujo de datos de contenido del elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las aplicaciones no deben llamar a <xref:System.IO.Packaging.PackagePart.GetStreamCore%2A> directamente, pero en su lugar, debe llamar a <xref:System.IO.Packaging.PackagePart.GetStream%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La clase derivada <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> implementación debe hacer ninguna suposición sobre el orden o las operaciones realizadas por el <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> método que lo llama.</para>
        </block>
        <block subset="none" type="usage">
          <para>La clase derivada <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> llama al método el <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> métodos para abrir y devolver el flujo de datos de elemento según el formato físico implementado en la clase derivada.  
  
De forma predeterminada, el <see cref="T:System.IO.Packaging.ZipPackagePart" /> implementación de subclase de la abstracta <see cref="T:System.IO.Packaging.PackagePart" /> proporcionado y usa la clase.  En la operación de forma predeterminada, <see cref="Overload:System.IO.Packaging.PackagePart.GetStream" /> llama internamente a <see cref="M:System.IO.Packaging.PackagePart.GetStreamCore(System.IO.FileMode,System.IO.FileAccess)" /> de la <see cref="T:System.IO.Packaging.ZipPackagePart" /> clase para abrir y devolver el flujo de datos de la parte de un archivo ZIP.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.Package Package { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.Package Package" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Package" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Package As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::Package ^ Package { System::IO::Packaging::Package ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Package : System.IO.Packaging.Package" Usage="System.IO.Packaging.PackagePart.Package" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.IO.Packaging.Package" /> primario del elemento.</summary>
        <value>El paquete primario del elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Package%2A> es una propiedad de solo lectura que se puede tener acceso solo cuando el elemento primario <xref:System.IO.Packaging.Package> está abierto.  
  
 El <xref:System.IO.Packaging.PackagePart.Package%2A> propiedad se establece automáticamente la <xref:System.IO.Packaging.PackagePart.%23ctor%2A> constructor.  Una vez que se establece mediante el constructor, el elemento primario <xref:System.IO.Packaging.PackagePart.Package%2A> para el elemento no se puede cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.PackagePart.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="packagePart.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">La propiedad <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> de la relación que se va a comprobar.</param>
        <summary>Devuelve un valor que indica si este elemento tiene una relación con una <see cref="P:System.IO.Packaging.PackageRelationship.Id" />especificada.</summary>
        <returns>Es <see langword="true" /> si este elemento tiene relación con el <paramref name="id" /> especificado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Debe ser un identificador XML válido.  El `id` tipo es xsd: ID y debe seguir las convenciones de nomenclatura prescritas en la *XML Schema Part 2: Datatypes* especificación (consulte [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> no es un identificador XML válido.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Paquete es de sólo escritura; es decir, no se puede leer la información de la relación.</exception>
        <altmember cref="Overload:System.IO.Packaging.PackagePart.CreateRelationship" />
        <altmember cref="M:System.IO.Packaging.PackagePart.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.PackagePart.GetRelationshipsByType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Uri">
      <MemberSignature Language="C#" Value="public Uri Uri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Uri" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.PackagePart.Uri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Uri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Uri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Uri : Uri" Usage="System.IO.Packaging.PackagePart.Uri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento.</summary>
        <value>El [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] del elemento relativo a la raíz del paquete.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.PackagePart.Uri%2A> es una propiedad de solo lectura que se puede tener acceso solo cuando el elemento primario <xref:System.IO.Packaging.Package> está abierto.  
  
 El <xref:System.IO.Packaging.PackagePart.Uri%2A> propiedad se establece automáticamente la <xref:System.IO.Packaging.PackagePart.%23ctor%2A> constructor.  Una vez que se establece mediante el constructor, el <xref:System.IO.Packaging.PackagePart.Uri%2A> del elemento no se puede cambiar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha eliminado el elemento.  
  
O bien 
La propiedad <see cref="P:System.IO.Packaging.PackagePart.Package" /> no está abierta (se ha llamado a <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> o <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ComparePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
  </Members>
</Type>