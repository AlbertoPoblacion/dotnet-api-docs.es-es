<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="490163b95a1c739f285d903ae3e13cfd6489a285" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36637589" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="72f38-101">Representa una memoria caché de objetos, y proporciona los métodos y las propiedades base para tener acceso a la memoria caché de objetos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="72f38-101">Represents an object cache and provides the base methods and properties for accessing the object cache.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-102">El <xref:System.Runtime.Caching.ObjectCache> tipo es el tipo primario de la caché de objetos en memoria.</span><span class="sxs-lookup"><span data-stu-id="72f38-102">The <xref:System.Runtime.Caching.ObjectCache> type is the primary type for the in-memory object cache.</span></span> <span data-ttu-id="72f38-103">Para desarrollar una implementación de caché personalizado, derive de la <xref:System.Runtime.Caching.ObjectCache> clase.</span><span class="sxs-lookup"><span data-stu-id="72f38-103">To develop a custom cache implementation, you derive from the <xref:System.Runtime.Caching.ObjectCache> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="72f38-104">El <xref:System.Runtime.Caching.ObjectCache> clase es una novedad de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].</span><span class="sxs-lookup"><span data-stu-id="72f38-104">The <xref:System.Runtime.Caching.ObjectCache> class is new as of the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].</span></span>  
  
 <span data-ttu-id="72f38-105">Integrado <xref:System.Runtime.Caching.MemoryCache> clase se deriva de la <xref:System.Runtime.Caching.ObjectCache> clase.</span><span class="sxs-lookup"><span data-stu-id="72f38-105">The built-in <xref:System.Runtime.Caching.MemoryCache> class derives from the <xref:System.Runtime.Caching.ObjectCache> class.</span></span> <span data-ttu-id="72f38-106">El <xref:System.Runtime.Caching.MemoryCache> clase es la implementación de la caché de objeto concreta solo en el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] que se deriva de la <xref:System.Runtime.Caching.ObjectCache> clase.</span><span class="sxs-lookup"><span data-stu-id="72f38-106">The <xref:System.Runtime.Caching.MemoryCache> class is the only concrete object cache implementation in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] that derives from the <xref:System.Runtime.Caching.ObjectCache> class.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="72f38-107">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="72f38-107">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <span data-ttu-id="72f38-108">
        <para>Dado que la <see cref="T:System.Runtime.Caching.ObjectCache" /> tipo representa funciones comunes de caché, no hay ningún requisito para saber cómo un <see cref="T:System.Runtime.Caching.ObjectCache" /> instancia se debe crear una instancia y obtenida. Además, no es necesario que las implementaciones concretas de la <see cref="T:System.Runtime.Caching.ObjectCache" /> clase debe ser singletons.  <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> no es un singleton, pero debe crear solo pocos o potencialmente solo uno <see cref="T:System.Runtime.Caching.MemoryCache" /> instancia y el código que almacena en caché elementos deberían usar esas instancias.  </para></block>  Al heredar de la <see cref="T:System.Runtime.Caching.ObjectCache" /> (clase), debe invalidar sus métodos.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="72f38-108">
          <para>Because the <see cref="T:System.Runtime.Caching.ObjectCache" /> type represents only common cache functions, there is no requirement for how an <see cref="T:System.Runtime.Caching.ObjectCache" /> instance must be instantiated and obtained. In addition, there is no requirement that concrete implementations of the <see cref="T:System.Runtime.Caching.ObjectCache" /> class must be singletons.  <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> is not a singleton, but you should create only a few or potentially only one <see cref="T:System.Runtime.Caching.MemoryCache" /> instance and code that caches items should use those instances.  </para></block>  When you inherit from the <see cref="T:System.Runtime.Caching.ObjectCache" /> class, you must override its methods.</para>
        </span>
      </span>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="72f38-109">Este método lo invocan los constructores de las clases derivadas para inicializar la clase <see cref="T:System.Runtime.Caching.ObjectCache" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-109">Called from constructors in derived classes in order to initialize the <see cref="T:System.Runtime.Caching.ObjectCache" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-110">Cuando se invalida en una clase derivada, inserta una entrada de caché sin que sea necesario devolver una entrada existente con la misma clave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-110">When overridden in a derived class, inserts a cache entry into the cache, without requiring that an existing cache entry with a matching key be returned.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-111">El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas del método intentan insertar una entrada de caché en la memoria caché, sin sobrescribir o quitar una entrada de caché existente que tiene la misma clave.</span><span class="sxs-lookup"><span data-stu-id="72f38-111">The <xref:System.Runtime.Caching.ObjectCache.Add%2A> method overloads try to insert a cache entry into the cache, without overwriting or removing an existing cache entry that has the same key.</span></span> <span data-ttu-id="72f38-112">La entrada de caché puede ser un tipo <xref:System.Runtime.Caching.CacheItem> objeto o un objeto genérico.</span><span class="sxs-lookup"><span data-stu-id="72f38-112">The cache entry can be a typed <xref:System.Runtime.Caching.CacheItem> object or a generic object.</span></span>  
  
 <span data-ttu-id="72f38-113">El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas de método y la <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método tienen una diferencia significativa.</span><span class="sxs-lookup"><span data-stu-id="72f38-113">The <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> method overloads and the <xref:System.Runtime.Caching.ObjectCache.Add%2A> method overloads have one significant difference.</span></span> <span data-ttu-id="72f38-114">Cuando estos métodos insertan una entrada de caché, si se encuentra una entrada coincidente en la memoria caché, el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método devuelven la entrada de caché existente, pero la <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método no tienen que serlo.</span><span class="sxs-lookup"><span data-stu-id="72f38-114">When these methods insert a cache entry, if a matching entry is found in the cache, the <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> method overloads return the existing cache entry, but the <xref:System.Runtime.Caching.ObjectCache.Add%2A> method overloads do not.</span></span> <span data-ttu-id="72f38-115">Con estas sobrecargas de método diferentes permite a los llamadores optimizar su código basado en si necesitan la entrada de caché existente.</span><span class="sxs-lookup"><span data-stu-id="72f38-115">Having these different method overloads enables callers to optimize their code based on whether they need the existing cache entry.</span></span> <span data-ttu-id="72f38-116">En las memorias caché distribuidas, devolver un valor existente utilizando el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> método podría ser más cara que devolver un valor booleano mediante <xref:System.Runtime.Caching.ObjectCache.Add%2A> método.</span><span class="sxs-lookup"><span data-stu-id="72f38-116">In distributed caches, returning an existing value by using the <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> method might be more expensive than returning a Boolean value by using <xref:System.Runtime.Caching.ObjectCache.Add%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="72f38-117">Objeto que se va a agregar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-117">The object to add.</span>
          </span>
        </param>
        <param name="policy">
          <span data-ttu-id="72f38-118">Objeto que contiene detalles sobre la expulsión de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-118">An object that contains eviction details for the cache entry.</span>
          </span>
          <span data-ttu-id="72f38-119">Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-119">This object provides more options for eviction than a simple absolute expiration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-120">Cuando se reemplaza en una clase derivada, intenta insertar una entrada en la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" /> y agrega detalles sobre cómo debe expulsarse la entrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-120">When overridden in a derived class, tries to insert a cache entry into the cache as a <see cref="T:System.Runtime.Caching.CacheItem" /> instance, and adds details about how the entry should be evicted.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-121">Es <see langword="true" /> si la inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="item" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-121">
              <see langword="true" /> if insertion succeeded, or <see langword="false" /> if there is an already an entry in the cache that has the same key as <paramref name="item" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-122">El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> de la clase, porque la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>.</span><span class="sxs-lookup"><span data-stu-id="72f38-122">The <xref:System.Runtime.Caching.ObjectCache.Add%2A> method overloads are virtual (not abstract) on the <xref:System.Runtime.Caching.ObjectCache> class, because the <xref:System.Runtime.Caching.ObjectCache.Add%2A> method internally calls <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>.</span></span> <span data-ttu-id="72f38-123">Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar.</span><span class="sxs-lookup"><span data-stu-id="72f38-123">This reduces the number of method overloads that a cache implementer has to provide.</span></span> <span data-ttu-id="72f38-124">Si una implementación de caché no requiere ningún comportamiento especial para la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="72f38-124">If a cache implementation does not require any special behavior for the <xref:System.Runtime.Caching.ObjectCache.Add%2A> method, it can just implement the <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> method overloads.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-125">Identificador único de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-125">A unique identifier for the cache entry.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="72f38-126">Objeto que se va a insertar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-126">The object to insert.</span>
          </span>
        </param>
        <param name="absoluteExpiration">
          <span data-ttu-id="72f38-127">Fecha y hora fijas a las que expirará la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-127">The fixed date and time at which the cache entry will expire.</span>
          </span>
          <span data-ttu-id="72f38-128">Este parámetro es necesario cuando se llama al método <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-128">This parameter is required when the <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" /> method is called.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-129">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-129">Optional.</span>
          </span>
          <span data-ttu-id="72f38-130">Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-130">A named region in the cache to which the cache entry can be added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-131">Como en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] no se implementan regiones, el valor predeterminado es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-131">Because regions are not implemented in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the default value is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-132">Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché sin sobrescribir ninguna entrada existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-132">When overridden in a derived class, inserts a cache entry into the cache without overwriting any existing cache entry.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-133">Es <see langword="true" /> si la inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="key" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-133">
              <see langword="true" /> if insertion succeeded, or <see langword="false" /> if there is an already an entry in the cache that has the same key as <paramref name="key" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-134">El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> de la clase, porque la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>.</span><span class="sxs-lookup"><span data-stu-id="72f38-134">The <xref:System.Runtime.Caching.ObjectCache.Add%2A> method overloads are virtual (not abstract) on the <xref:System.Runtime.Caching.ObjectCache> class, because the <xref:System.Runtime.Caching.ObjectCache.Add%2A> method internally calls <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>.</span></span> <span data-ttu-id="72f38-135">Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar.</span><span class="sxs-lookup"><span data-stu-id="72f38-135">This reduces the number of method overloads that a cache implementer has to provide.</span></span> <span data-ttu-id="72f38-136">Si una implementación de caché no requiere ningún comportamiento especial para la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="72f38-136">If a cache implementation does not require any special behavior for the <xref:System.Runtime.Caching.ObjectCache.Add%2A> method, it can just implement the <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> method overloads.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-137">Identificador único de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-137">A unique identifier for the cache entry.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="72f38-138">Objeto que se va a insertar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-138">The object to insert.</span>
          </span>
        </param>
        <param name="policy">
          <span data-ttu-id="72f38-139">Objeto que contiene detalles sobre la expulsión de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-139">An object that contains eviction details for the cache entry.</span>
          </span>
          <span data-ttu-id="72f38-140">Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-140">This object provides more options for eviction than a simple absolute expiration.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-141">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-141">Optional.</span>
          </span>
          <span data-ttu-id="72f38-142">Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-142">A named region in the cache to which the cache entry can be added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-143">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-143">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-144">Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica información sobre cómo se expulsará la entrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-144">When overridden in a derived class, inserts a cache entry into the cache, specifying information about how the entry will be evicted.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-145">Es <see langword="true" /> si el intento de inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="key" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-145">
              <see langword="true" /> if the insertion try succeeds, or <see langword="false" /> if there is an already an entry in the cache with the same key as <paramref name="key" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-146">El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> de la clase, porque la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>.</span><span class="sxs-lookup"><span data-stu-id="72f38-146">The <xref:System.Runtime.Caching.ObjectCache.Add%2A> method overloads are virtual (not abstract) on the <xref:System.Runtime.Caching.ObjectCache> class, because the <xref:System.Runtime.Caching.ObjectCache.Add%2A> method internally calls <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>.</span></span> <span data-ttu-id="72f38-147">Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar.</span><span class="sxs-lookup"><span data-stu-id="72f38-147">This reduces the number of method overloads that a cache implementer has to provide.</span></span> <span data-ttu-id="72f38-148">Si una implementación de caché no requiere ningún comportamiento especial para la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.</span><span class="sxs-lookup"><span data-stu-id="72f38-148">If a cache implementation does not require any special behavior for the <xref:System.Runtime.Caching.ObjectCache.Add%2A> method, it can just implement the <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> method overloads.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-149">Cuando se reemplaza en una clase derivada, intenta insertar una entrada en la memoria caché y devuelve una entrada existente con la misma clave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-149">When overridden in a derived class, tries to insert a cache entry into the cache, and returns an existing cache entry with a matching key.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-150">El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método insertan una entrada en la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-150">The <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> method overloads insert an entry into the cache.</span></span> <span data-ttu-id="72f38-151">Si ya existe una entrada de caché con una clave coincidente, devuelven la entrada existente.</span><span class="sxs-lookup"><span data-stu-id="72f38-151">If a cache entry with a matching key already exists, they return the existing entry.</span></span> <span data-ttu-id="72f38-152">La entrada de caché puede ser un <xref:System.Runtime.Caching.CacheItem> objeto o un objeto genérico.</span><span class="sxs-lookup"><span data-stu-id="72f38-152">The cache entry can be a <xref:System.Runtime.Caching.CacheItem> object or a generic object.</span></span>  
  
 <span data-ttu-id="72f38-153">Hay una diferencia entre el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas y el <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="72f38-153">There is one difference between the <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> overloads and the <xref:System.Runtime.Caching.ObjectCache.Add%2A> overloads.</span></span> <span data-ttu-id="72f38-154">Cuando estos métodos sobrecargados intentan insertar una entrada de caché, si se encuentra una entrada existente que ha insertado una clave que coincida con otra entrada de caché, el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas devuelven la entrada de caché existente.</span><span class="sxs-lookup"><span data-stu-id="72f38-154">When these overloaded methods try to insert a cache entry, if an existing entry is found that has a key that matches an existing inserted cache entry, the <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> overloads return the existing cache entry.</span></span> <span data-ttu-id="72f38-155">El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas no tienen que serlo.</span><span class="sxs-lookup"><span data-stu-id="72f38-155">The <xref:System.Runtime.Caching.ObjectCache.Add%2A> overloads do not.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="72f38-156">Objeto que se va a insertar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-156">The object to insert.</span>
          </span>
        </param>
        <param name="policy">
          <span data-ttu-id="72f38-157">Objeto que contiene detalles sobre la expulsión de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-157">An object that contains eviction details for the cache entry.</span>
          </span>
          <span data-ttu-id="72f38-158">Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-158">This object provides more options for eviction than a simple absolute expiration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-159">Cuando se invalida en una clase derivada, inserta el objeto <see cref="T:System.Runtime.Caching.CacheItem" /> especificado en la memoria caché, y especifica información sobre cómo se expulsará la entrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-159">When overridden in a derived class, inserts the specified <see cref="T:System.Runtime.Caching.CacheItem" /> object into the cache, specifying information about how the entry will be evicted.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-160">Si existe una entrada de caché con la misma clave, se devuelve la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-160">If a cache entry with the same key exists, the specified cache entry; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-161">Identificador único de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-161">A unique identifier for the cache entry.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="72f38-162">Objeto que se va a insertar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-162">The object to insert.</span>
          </span>
        </param>
        <param name="absoluteExpiration">
          <span data-ttu-id="72f38-163">Fecha y hora fijas a las que expirará la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-163">The fixed date and time at which the cache entry will expire.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-164">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-164">Optional.</span>
          </span>
          <span data-ttu-id="72f38-165">Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-165">A named region in the cache to which the cache entry can be added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-166">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-166">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-167">Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché utilizando una clave, un objeto para la entrada de caché, un valor de expiración absoluto y una región opcional a la que se va a agregar la entrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-167">When overridden in a derived class, inserts a cache entry into the cache, by using a key, an object for the cache entry, an absolute expiration value, and an optional region to add the cache into.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-168">Si ya existe una entrada de caché con la misma clave, se devuelve el valor de la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-168">If a cache entry with the same key exists, the specified cache entry's value; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-169">Esto <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> sobrecarga del método devuelve un valor de objeto, no un <xref:System.Runtime.Caching.CacheItem> objeto.</span><span class="sxs-lookup"><span data-stu-id="72f38-169">This <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> method overload returns an object value, not a <xref:System.Runtime.Caching.CacheItem> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-170">Identificador único de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-170">A unique identifier for the cache entry.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="72f38-171">Objeto que se va a insertar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-171">The object to insert.</span>
          </span>
        </param>
        <param name="policy">
          <span data-ttu-id="72f38-172">Objeto que contiene detalles sobre la expulsión de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-172">An object that contains eviction details for the cache entry.</span>
          </span>
          <span data-ttu-id="72f38-173">Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-173">This object provides more options for eviction than a simple absolute expiration.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-174">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-174">Optional.</span>
          </span>
          <span data-ttu-id="72f38-175">Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-175">A named region in the cache to which the cache entry can be added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-176">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-176">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-177">Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica una clave y un valor para la entrada, así como información sobre cómo va a expulsarse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-177">When overridden in a derived class, inserts a cache entry into the cache, specifying a key and a value for the cache entry, and information about how the entry will be evicted.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-178">Si ya existe una entrada de caché con la misma clave, se devuelve el valor de la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-178">If a cache entry with the same key exists, the specified cache entry's value; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-179">El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> método devuelve un valor de objeto, no un <xref:System.Runtime.Caching.CacheItem> objeto.</span><span class="sxs-lookup"><span data-stu-id="72f38-179">The <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> method returns an object value, not a <xref:System.Runtime.Caching.CacheItem> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-180">Identificador único de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-180">A unique identifier for the cache entry.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-181">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-181">Optional.</span>
          </span>
          <span data-ttu-id="72f38-182">Región con nombre de la memoria caché donde puede encontrarse la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-182">A named region in the cache where the cache can be found, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-183">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-183">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-184">Cuando se invalida en una clase derivada, comprueba si la entrada ya existe en la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-184">When overridden in a derived class, checks whether the cache entry already exists in the cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-185">Es <see langword="true" /> si la memoria caché contiene una entrada con el mismo valor de clave que <paramref name="key" />; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-185">
              <see langword="true" /> if the cache contains a cache entry with the same key value as <paramref name="key" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">
          <span data-ttu-id="72f38-186">Identificadores únicos de las entradas de caché que se van a supervisar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-186">The unique identifiers for cache entries to monitor.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-187">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-187">Optional.</span>
          </span>
          <span data-ttu-id="72f38-188">Región con nombre de la memoria caché donde existen las claves de caché en el parámetro <c>keys</c>, si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-188">A named region in the cache where the cache keys in the <c>keys</c> parameter exist, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-189">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-189">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-190">Cuando se reemplaza en una clase derivada, crea un objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> que puede activar eventos en respuesta a los cambios realizados en las entradas especificadas de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-190">When overridden in a derived class, creates a <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> object that can trigger events in response to changes to specified cache entries.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-191">Supervisor de cambios que supervisa las entradas de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-191">A change monitor that monitors cache entries in the cache.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-192">Cuando un derivada <xref:System.Runtime.Caching.ObjectCache> clase invalida la base de <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> método, debe crear la implementación de la memoria caché un <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objeto.</span><span class="sxs-lookup"><span data-stu-id="72f38-192">When a derived <xref:System.Runtime.Caching.ObjectCache> class overrides the base <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> method, the cache implementation must create a <xref:System.Runtime.Caching.CacheEntryChangeMonitor> object.</span></span> <span data-ttu-id="72f38-193">Este monitor de cambios especializado notifica a los llamadores cuando hay cambios en las entradas de caché que se especifican en el `keys` parámetro.</span><span class="sxs-lookup"><span data-stu-id="72f38-193">This specialized change monitor notifies callers when there are changes to the cache entries that are specified in the `keys` parameter.</span></span> <span data-ttu-id="72f38-194">Por ejemplo, si un elemento supervisado en el `keys` parámetro se actualizó o se quitó de la memoria caché, la supervisión de cambios creada por este método desencadena un evento.</span><span class="sxs-lookup"><span data-stu-id="72f38-194">For example, if a monitored item in the `keys` parameter is updated or removed from the cache, the change monitor created by this method triggers an event.</span></span>  
  
 <span data-ttu-id="72f38-195">Si una implementación de caché es compatible con las regiones de caché con nombre, puede especificarse un valor de cadena como el `regionName` parámetro.</span><span class="sxs-lookup"><span data-stu-id="72f38-195">If a cache implementation supports named cache regions, a string value can be specified as the `regionName` parameter.</span></span> <span data-ttu-id="72f38-196">En caso contrario, el parámetro tiene como valor predeterminado `null`.</span><span class="sxs-lookup"><span data-stu-id="72f38-196">Otherwise, the parameter defaults to `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="72f38-197">No todas las implementaciones de la memoria caché admiten monitores de cambio de entrada de caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-197">Not all cache implementations support cache-entry change monitors.</span></span> <span data-ttu-id="72f38-198">Para determinar si su implementación de caché es compatible con <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objetos, consulte la documentación para la implementación de caché específica.</span><span class="sxs-lookup"><span data-stu-id="72f38-198">To determine whether your cache implementation supports <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objects, see the documentation for the specific cache implementation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-199">Cuando se reemplaza en una clase derivada, obtiene una descripción de las características proporcionadas por una implementación de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-199">When overridden in a derived class, gets a description of the features that a cache implementation provides.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="72f38-200">Combinación bit a bit de las marcas que indican las características predeterminadas de una implementación de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-200">A bitwise combination of flags that indicate the default capabilities of a cache implementation.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-201">Identificador único para la entrada de caché que se va a obtener.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-201">A unique identifier for the cache entry to get.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-202">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-202">Optional.</span>
          </span>
          <span data-ttu-id="72f38-203">Región con nombre de la memoria caché a la que se agregó la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-203">A named region in the cache to which the cache entry was added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-204">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-204">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-205">Cuando se reemplaza en una clase derivada, obtiene la entrada especificada de la memoria caché como un objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-205">When overridden in a derived class, gets the specified cache entry from the cache as an object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-206">Entrada de caché identificada por <paramref name="key" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-206">The cache entry that is identified by <paramref name="key" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-207">Identificador único para la entrada de caché que se va a obtener.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-207">A unique identifier for the cache entry to get.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-208">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-208">Optional.</span>
          </span>
          <span data-ttu-id="72f38-209">Región con nombre de la memoria caché a la que se agregó la entrada de caché, si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-209">A named region in the cache to which the cache was added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-210">Como en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] no se implementan regiones, el valor predeterminado es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-210">Because regions are not implemented in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the default is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-211">Cuando se reemplaza en una clase derivada, obtiene la entrada especificada de la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-211">When overridden in a derived class, gets the specified cache entry from the cache as a <see cref="T:System.Runtime.Caching.CacheItem" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-212">Entrada de caché identificada por <paramref name="key" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-212">The cache entry that is identified by <paramref name="key" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-213">Esta sobrecarga de método existe porque algunas implementaciones de la memoria caché pueden aumentar la <xref:System.Runtime.Caching.CacheItem> clase.</span><span class="sxs-lookup"><span data-stu-id="72f38-213">This method overload exists because some cache implementations might extend the <xref:System.Runtime.Caching.CacheItem> class.</span></span> <span data-ttu-id="72f38-214">En ese caso, el <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> sobrecarga del método no devolverá necesariamente toda la información sobre los datos almacenados en caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-214">In that case, the <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> method overload will not necessarily return all the information about cached data.</span></span> <span data-ttu-id="72f38-215">Sin embargo, la <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> sobrecarga del método permite que las memorias caché personalizadas devolver algo más que el valor de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-215">However, the <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> method overload enables custom caches to return more than just the cache value.</span></span>  
  
 <span data-ttu-id="72f38-216">El <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> método es similar a la <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> método, salvo que la <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> método devuelve de la entrada de caché como un <xref:System.Runtime.Caching.CacheItem> instancia.</span><span class="sxs-lookup"><span data-stu-id="72f38-216">The <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> method is like the <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> method, except that the <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> method returns return the cache entry as a <xref:System.Runtime.Caching.CacheItem> instance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">
          <span data-ttu-id="72f38-217">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-217">Optional.</span>
          </span>
          <span data-ttu-id="72f38-218">Región con nombre de la memoria caché para la que se debe calcular el recuento de entradas de caché, si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-218">A named region in the cache for which the cache entry count should be computed, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-219">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-219">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-220">Cuando se reemplaza en una clase derivada, obtiene el número total de entradas de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-220">When overridden in a derived class, gets the total number of cache entries in the cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-221">Número de entradas de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-221">The number of cache entries in the cache.</span>
          </span>
          <span data-ttu-id="72f38-222">Si <paramref name="regionName" /> no es <see langword="null" />, se devuelve el número de entradas en la región especificada de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-222">If <paramref name="regionName" /> is not <see langword="null" />, the count indicates the number of entries that are in the specified cache region.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="72f38-223">Cuando se reemplaza en una clase derivada, crea un enumerador que puede usarse para iterar por una colección de entradas de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-223">When overridden in a derived class, creates an enumerator that can be used to iterate through a collection of cache entries.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-224">Objeto de enumerador que proporciona acceso a las entradas de la memoria caché en la caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-224">The enumerator object that provides access to the cache entries in the cache.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-225">Los implementadores de la memoria caché pueden invalidar y extender este método para proporcionar un medio personalizado para recorrer en iteración una colección de entradas de caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-225">Cache implementers can override and extend this method to provide a custom means of iterating through a collection of cache entries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="72f38-226">Devuelve un enumerador es normalmente una operación más costosa que devolver la entrada de caché completa.</span><span class="sxs-lookup"><span data-stu-id="72f38-226">Returning an enumerator is typically a more expensive operation than returning the entire cache entry.</span></span>  
  
 <span data-ttu-id="72f38-227">Este método llama a las implementaciones de interfaz explícita que la <xref:System.Runtime.Caching.ObjectCache> clase tiene para la <xref:System.Collections.IEnumerable.GetEnumerator%2A> y <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="72f38-227">This method is called by the explicit interface implementations that the <xref:System.Runtime.Caching.ObjectCache> class has for the <xref:System.Collections.IEnumerable.GetEnumerator%2A> and <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> methods.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-228">Obtiene un conjunto de entradas de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-228">Gets a set of cache entries.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">
          <span data-ttu-id="72f38-229">Colección de identificadores únicos correspondientes a las entradas de caché que se van a obtener.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-229">A collection of unique identifiers for the cache entries to get.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-230">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-230">Optional.</span>
          </span>
          <span data-ttu-id="72f38-231">Región con nombre de la memoria caché a la que se agregaron una o varias entradas de caché, si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-231">A named region in the cache to which the cache entry or entries were added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-232">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-232">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-233">Cuando se reemplaza en una clase derivada, obtiene un conjunto de entradas de la memoria caché que corresponden a las claves especificadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-233">When overridden in a derived class, gets a set of cache entries that correspond to the specified keys.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-234">Diccionario de pares clave-valor que representan entradas de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-234">A dictionary of key/value pairs that represent cache entries.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-235">El <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método es una optimización de rendimiento para las memorias caché distribuidas que admiten la captura de varias entradas de caché de la memoria caché durante una llamada de red único.</span><span class="sxs-lookup"><span data-stu-id="72f38-235">The <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> method overload is a performance optimization for distributed caches that support fetching multiple cache entries from the cache during a single network call.</span></span>  
  
 <span data-ttu-id="72f38-236">Aunque un llamador puede pasar una o más claves al método, no hay ninguna garantía de que todas las claves representan las entradas en la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-236">Although a caller can pass one or more keys to the method, there is no guarantee that all keys represent entries in the cache.</span></span> <span data-ttu-id="72f38-237">Por lo tanto, el diccionario devuelto podría contener menos elementos que el número de claves que se pasaron al método.</span><span class="sxs-lookup"><span data-stu-id="72f38-237">Therefore, the returned dictionary might contain fewer items than the number of keys that were passed to the method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">
          <span data-ttu-id="72f38-238">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-238">Optional.</span>
          </span>
          <span data-ttu-id="72f38-239">Región con nombre de la memoria caché a la que se agregaron una o varias entradas de caché, si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-239">A named region in the cache to which the cache entry or entries were added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-240">Como en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] no se implementan regiones, el valor predeterminado es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-240">Because regions are not implemented in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the default is <see langword="null" />.</span>
          </span>
        </param>
        <param name="keys">
          <span data-ttu-id="72f38-241">Colección de identificadores únicos correspondientes a las entradas de caché que se van a obtener.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-241">A collection of unique identifiers for the cache entries to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-242">Obtiene un conjunto de entradas de la memoria caché que corresponden a las claves especificadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-242">Gets a set of cache entries that correspond to the specified keys.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-243">Diccionario de pares clave-valor que representan entradas de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-243">A dictionary of key/value pairs that represent cache entries.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-244">El <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> sobrecarga del método es similar a la <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método, pero permite pasar la región con nombre mediante la sintaxis de parámetro opcional que es compatible con los lenguajes administrados como C#.</span><span class="sxs-lookup"><span data-stu-id="72f38-244">The <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> method overload is like the <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> method overload, but lets you pass the named region by using optional parameter syntax that is supported by managed languages such as C#.</span></span>  
  
 <span data-ttu-id="72f38-245">Este método es un método virtual porque el <xref:System.Runtime.Caching.ObjectCache> clase proporciona una implementación predeterminada que pasa la `params` de matriz para el <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="72f38-245">This method is a virtual method because the <xref:System.Runtime.Caching.ObjectCache> class provides a default implementation that passes the `params` array to the <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-246">Obtiene o establece una referencia a un entorno de hospedaje administrado que está disponible para las implementaciones de <see cref="T:System.Runtime.Caching.ObjectCache" /> y puede proporcionar servicios específicos del host a las implementaciones de <see cref="T:System.Runtime.Caching.ObjectCache" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-246">Gets or set a reference to a managed hosting environment that is available to <see cref="T:System.Runtime.Caching.ObjectCache" /> implementations and that can provide host-specific services to <see cref="T:System.Runtime.Caching.ObjectCache" /> implementations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="72f38-247">Referencia a un entorno de hospedaje administrado que reconoce la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-247">A reference to a cache-aware managed hosting environment.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-248">El <xref:System.Runtime.Caching.ObjectCache.Host%2A> propiedad está pensada para usarse en [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] entornos de host y entorno de host implementaciones de caché que implementan el comportamiento que depende de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="72f38-248">The <xref:System.Runtime.Caching.ObjectCache.Host%2A> property is intended for use by [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] host environments and by cache implementations that implement behavior that depends on the .NET Framework host environment.</span></span>  
  
 <span data-ttu-id="72f38-249">La tabla siguiente enumera el conjunto de servicios de entorno de host que podrían estar disponibles en un entorno de hospedaje administrado y que están disponibles para <xref:System.Runtime.Caching.ObjectCache> las implementaciones a través del <xref:System.Runtime.Caching.ObjectCache.Host%2A> propiedad:</span><span class="sxs-lookup"><span data-stu-id="72f38-249">The following table lists the set of host environment services that might be available from a managed hosting environment and that are available to <xref:System.Runtime.Caching.ObjectCache> implementations through the <xref:System.Runtime.Caching.ObjectCache.Host%2A> property:</span></span>  
  
|<span data-ttu-id="72f38-250">web de Office</span><span class="sxs-lookup"><span data-stu-id="72f38-250">Service</span></span>|<span data-ttu-id="72f38-251">Descripción</span><span class="sxs-lookup"><span data-stu-id="72f38-251">Description</span></span>|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|<span data-ttu-id="72f38-252">Permite a los entornos de host proporcionar identificadores de dominio de aplicación que podrían ser necesarios en una implementación de la memoria caché para características como identificar los contadores de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="72f38-252">Lets host environments provide application domain identifiers that might be needed by a cache implementation for features such as identifying performance counters.</span></span>|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|<span data-ttu-id="72f38-253">Permite a los entornos de host proporcionar un sistema de notificación de cambio de archivo personalizado, en lugar de usar el uno incluido en el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span><span class="sxs-lookup"><span data-stu-id="72f38-253">Lets host environments provide a custom file-change notification system, instead of using the one provided in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span>|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|<span data-ttu-id="72f38-254">Permite el consumo de memoria caché de informes de implementaciones de caché al entorno de host.</span><span class="sxs-lookup"><span data-stu-id="72f38-254">Lets cache implementations report cache memory consumption to the host environment.</span></span> <span data-ttu-id="72f38-255">Esto permite administrar centralmente el consumo de memoria a través de varias implementaciones de la memoria caché de los entornos de host.</span><span class="sxs-lookup"><span data-stu-id="72f38-255">This enables host environments to centrally manage memory consumption across multiple cache implementations.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="72f38-256">Los llamadores del valor de esta propiedad, requieren permisos de seguridad de acceso de código sin restricciones.</span><span class="sxs-lookup"><span data-stu-id="72f38-256">Callers of this property value require unrestricted code access security permissions.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="72f38-257">El valor que se asigna a la propiedad es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-257">The value being assigned to the property is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="72f38-258">Se intentó establecer el valor de propiedad más de una vez.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-258">An attempt was made to set the property value more than one time.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">
          <span data-ttu-id="72f38-259">de plena confianza para todos los descriptores de acceso de esta propiedad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-259">for full trust for all accessors of this property.</span>
          </span>
          <span data-ttu-id="72f38-260">Esta propiedad no se puede usar por código de confianza parcial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-260">This property cannot be used by partially trusted code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-261">Obtiene un valor que indica que una entrada de caché no tiene ninguna expiración absoluta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-261">Gets a value that indicates that a cache entry has no absolute expiration.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-262">Una entrada de caché que se inserta en la memoria caché con el <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> valor del campo como el valor de expiración no debe caducar nunca en función de un punto absoluto en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="72f38-262">A cache entry that is inserted into the cache with the <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> field value set as the expiration value should never expire based on an absolute point in time.</span></span> <span data-ttu-id="72f38-263">Sin embargo, una entrada de caché con esta configuración puede ser expulsada de la memoria caché por otras razones que vengan determinados por una implementación de caché concreta, como una expulsión de evento de supervisión de cambios causada por la presión de memoria.</span><span class="sxs-lookup"><span data-stu-id="72f38-263">However, a cache entry with this setting can be evicted from the cache for other reasons that are determined by a particular cache implementation, such as a change-monitor event eviction caused by memory pressure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-264">Identificador único de una entrada de caché en la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-264">A unique identifier for a cache entry in the cache.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-265">Obtiene o establece el indizador predeterminado para la clase <see cref="T:System.Runtime.Caching.ObjectCache" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-265">Gets or sets the default indexer for the <see cref="T:System.Runtime.Caching.ObjectCache" /> class.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="72f38-266">Clave que sirve de indizador en la instancia de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-266">A key that serves as an indexer into the cache instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-267">El comportamiento del descriptor de acceso set de esta propiedad es similar a la <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="72f38-267">The behavior of the set accessor of this property is like the <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> method.</span></span> <span data-ttu-id="72f38-268">Internamente, una implementación de la memoria caché podría establecer la expiración absoluta del valor especificado para el <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> método.</span><span class="sxs-lookup"><span data-stu-id="72f38-268">Internally, a cache implementation could set the absolute expiration of the specified value to the <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> method.</span></span> <span data-ttu-id="72f38-269">Sin embargo este comportamiento es el usuario quien hasta la implementación de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-269">However this behavior is ultimately up to the cache implementation.</span></span>  
  
 <span data-ttu-id="72f38-270">El comportamiento del descriptor de acceso get es como llamar a la <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> método y usar `null` para el nombre de región.</span><span class="sxs-lookup"><span data-stu-id="72f38-270">The behavior of get accessor is like calling the <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> method and using `null` for the region name.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-271">Obtiene el nombre de una instancia específica de <see cref="T:System.Runtime.Caching.ObjectCache" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-271">Gets the name of a specific <see cref="T:System.Runtime.Caching.ObjectCache" /> instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="72f38-272">Nombre de una instancia específica de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-272">The name of a specific cache instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-273">Algunas implementaciones de la memoria caché podrían admitir varias instancias de la memoria caché que se ejecuta en una sola aplicación.</span><span class="sxs-lookup"><span data-stu-id="72f38-273">Some cache implementations might support multiple instances of the cache that is running in a single application.</span></span> <span data-ttu-id="72f38-274">Esta propiedad permite a los implementadores de la memoria caché devolver un nombre que identifica una instancia de caché específica.</span><span class="sxs-lookup"><span data-stu-id="72f38-274">This property lets cache implementers return a name that identifies a specific cache instance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-275">Indica que una entrada de caché no tiene ningún tiempo de expiración variable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-275">Indicates that a cache entry has no sliding expiration time.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-276">Expiración que se basa en la duración o una ventana definida de tiempo también se conoce como la expiración variable.</span><span class="sxs-lookup"><span data-stu-id="72f38-276">Expiration that is based on duration or a defined window of time is also referred to as sliding expiration.</span></span> <span data-ttu-id="72f38-277">Normalmente, una implementación de caché que extrae elementos que se basan en la expiración variable quitará un elemento que no se tuvo acceso en el intervalo de tiempo especificado.</span><span class="sxs-lookup"><span data-stu-id="72f38-277">Normally, a cache implementation that evicts items that are based on sliding expiration will remove an item that has not been accessed in the specified window of time.</span></span>  
  
 <span data-ttu-id="72f38-278">Una entrada de caché que se inserta en la memoria caché con el <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> establecido como el valor de expiración nunca se debe expulsar debido a falta de actividad en una ventana deslizante de tiempo del valor del campo.</span><span class="sxs-lookup"><span data-stu-id="72f38-278">A cache entry that is inserted into the cache with the <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> field value set as the expiration value should never be evicted because of non-activity in a sliding time window.</span></span> <span data-ttu-id="72f38-279">Sin embargo, un elemento de caché se pueda expulsar si tiene una expiración absoluta, o si se produce algún otro evento de expulsión, tal una presión de memoria o el monitor de cambio.</span><span class="sxs-lookup"><span data-stu-id="72f38-279">However, a cache item can be evicted if it has an absolute expiration, or if some other eviction event occurs, such a change monitor or memory pressure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-280">Identificador único de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-280">A unique identifier for the cache entry.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-281">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-281">Optional.</span>
          </span>
          <span data-ttu-id="72f38-282">Región con nombre de la memoria caché a la que se agregó la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-282">A named region in the cache to which the cache entry was added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-283">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-283">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-284">Cuando se reemplaza en una clase derivada, quita la entrada de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-284">When overridden in a derived class, removes the cache entry from the cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-285">Objeto que representa el valor de la entrada de caché que se quitó y que se especificó mediante la clave, o <see langword="null" /> si no se encontró la entrada especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-285">An object that represents the value of the removed cache entry that was specified by the key, or <see langword="null" /> if the specified entry was not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-286">Si invalide este método en una implementación de caché personalizado, si hay una entrada de caché en la memoria caché que corresponde a `key`, se debe devolver el valor del elemento quitado.</span><span class="sxs-lookup"><span data-stu-id="72f38-286">If you override this method in a custom cache implementation, if there is a cache entry in the cache that corresponds to `key`, the value of the removed item should be returned.</span></span> <span data-ttu-id="72f38-287">Si no se quitó nada de la memoria caché, el método debe devolver `null`.</span><span class="sxs-lookup"><span data-stu-id="72f38-287">If nothing was removed from the cache, the method should return `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="72f38-288">Algunas implementaciones de caché distribuida podrían no admitir la capacidad de devolver el valor que se ha quitado de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-288">Some distributed cache implementations might not support the ability to return the value that was removed from the cache.</span></span> <span data-ttu-id="72f38-289">Esto podría deberse a que la implementación de la memoria caché no permite devolver el valor de un elemento de la memoria caché quitada.</span><span class="sxs-lookup"><span data-stu-id="72f38-289">This might be because the cache implementation does not support returning the value of a removed cache item.</span></span> <span data-ttu-id="72f38-290">También es posible que el cálculo de referencias del objeto como un valor devuelto es demasiado costoso.</span><span class="sxs-lookup"><span data-stu-id="72f38-290">It might also be because marshaling the object as a return value is too expensive.</span></span> <span data-ttu-id="72f38-291">En tales casos, las implementaciones de caché pueden devolver `null`.</span><span class="sxs-lookup"><span data-stu-id="72f38-291">In such cases, cache implementations can return `null`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="72f38-292">Cuando se reemplaza en una clase derivada, inserta una entrada en la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-292">When overridden in a derived class, inserts a cache entry into the cache.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-293">El comportamiento típico de la <xref:System.Runtime.Caching.ObjectCache.Set%2A> métodos de sobrecarga es una operación de inserción o actualización.</span><span class="sxs-lookup"><span data-stu-id="72f38-293">The typical behavior of the <xref:System.Runtime.Caching.ObjectCache.Set%2A> overload methods is an insert-or-update operation.</span></span> <span data-ttu-id="72f38-294">Una entrada de caché es inserta como una nueva entrada si la entrada especificada no existe o se actualiza la entrada de caché con un nuevo valor si ya existe.</span><span class="sxs-lookup"><span data-stu-id="72f38-294">A cache entry is either inserted as a new entry if the specified entry does not exist, or the cache entry is updated with a new value if it already exists.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="72f38-295">Elemento de caché que se va a agregar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-295">The cache item to add.</span>
          </span>
        </param>
        <param name="policy">
          <span data-ttu-id="72f38-296">Objeto que contiene detalles sobre la expulsión de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-296">An object that contains eviction details for the cache entry.</span>
          </span>
          <span data-ttu-id="72f38-297">Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-297">This object provides more options for eviction than a simple absolute expiration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-298">Cuando se invalida en una clase derivada, inserta la entrada de caché en la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" />, y especifica información sobre cómo se expulsará la entrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-298">When overridden in a derived class, inserts the cache entry into the cache as a <see cref="T:System.Runtime.Caching.CacheItem" /> instance, specifying information about how the entry will be evicted.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-299">Si la clave de `item` no existe, `item` se inserta como una nueva entrada de caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-299">If the key for `item` does not exist, `item` is inserted as a new cache entry.</span></span> <span data-ttu-id="72f38-300">Si un elemento con una clave que coincida con `item` existe, el valor de `item` se utiliza para actualizar o sobrescribir el valor de la entrada de caché existente.</span><span class="sxs-lookup"><span data-stu-id="72f38-300">If an item with a key that matches `item` exists, the value from `item` is used to update or overwrite the value of the existing cache entry.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-301">Identificador único de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-301">A unique identifier for the cache entry.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="72f38-302">Objeto que se va a insertar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-302">The object to insert.</span>
          </span>
        </param>
        <param name="absoluteExpiration">
          <span data-ttu-id="72f38-303">Fecha y hora fijas a las que expirará la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-303">The fixed date and time at which the cache entry will expire.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-304">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-304">Optional.</span>
          </span>
          <span data-ttu-id="72f38-305">Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-305">A named region in the cache to which the cache entry can be added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-306">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-306">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-307">Cuando se reemplaza en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica los detalles de la expiración basada en el tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-307">When overridden in a derived class, inserts a cache entry into the cache, specifying time-based expiration details.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-308">Si un elemento que coincida con `key` no existe en la memoria caché, `value` y `key` se usan para insertar como una nueva entrada de caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-308">If an item that matches `key` does not exist in the cache, `value` and `key` are used to insert as a new cache entry.</span></span> <span data-ttu-id="72f38-309">Si un elemento con una clave que coincida con `item` existe, se actualiza o sobrescribir mediante la entrada de caché `value`.</span><span class="sxs-lookup"><span data-stu-id="72f38-309">If an item with a key that matches `item` exists, the cache entry is updated or overwritten by using `value`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">
          <span data-ttu-id="72f38-310">Identificador único de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-310">A unique identifier for the cache entry.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="72f38-311">Objeto que se va a insertar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-311">The object to insert.</span>
          </span>
        </param>
        <param name="policy">
          <span data-ttu-id="72f38-312">Objeto que contiene detalles sobre la expulsión de la entrada de caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-312">An object that contains eviction details for the cache entry.</span>
          </span>
          <span data-ttu-id="72f38-313">Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-313">This object provides more options for eviction than a simple absolute expiration.</span>
          </span>
        </param>
        <param name="regionName">
          <span data-ttu-id="72f38-314">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-314">Optional.</span>
          </span>
          <span data-ttu-id="72f38-315">Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-315">A named region in the cache to which the cache entry can be added, if regions are implemented.</span>
          </span>
          <span data-ttu-id="72f38-316">El valor predeterminado para el parámetro opcional es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-316">The default value for the optional parameter is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="72f38-317">Cuando se reemplaza en una clase derivada, inserta una entrada en la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-317">When overridden in a derived class, inserts a cache entry into the cache.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-318">Esta sobrecarga del método permite proporcionar más detalles de expulsión o expiración que los que están disponibles en tiempo de expiración absoluta.</span><span class="sxs-lookup"><span data-stu-id="72f38-318">This method overload lets you provide more eviction or expiration details than those that are available in time-based absolute expiration.</span></span>  
  
 <span data-ttu-id="72f38-319">Si un elemento que coincida con `key` no existe en la memoria caché, `value` y `key` se usan para insertar como una nueva entrada de caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-319">If an item that matches `key` does not exist in the cache, `value` and `key` are used to insert as a new cache entry.</span></span> <span data-ttu-id="72f38-320">Si un elemento con una clave que coincida con `item` existe, se actualiza o sobrescribir mediante la entrada de caché `value`.</span><span class="sxs-lookup"><span data-stu-id="72f38-320">If an item with a key that matches `item` exists, the cache entry is updated or overwritten by using `value`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="72f38-321">Admite la iteración en una colección genérica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-321">Supports iteration over a generic collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="72f38-322">Objeto de enumerador que proporciona acceso a los elementos de la memoria caché.</span>
          <span class="sxs-lookup">
            <span data-stu-id="72f38-322">The enumerator object that provides access to the items in the cache.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="72f38-323">Este miembro es una implementación explícita de un miembro de interfaz.</span><span class="sxs-lookup"><span data-stu-id="72f38-323">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="72f38-324">Se puede utilizar solo cuando un derivada <xref:System.Runtime.Caching.ObjectCache> instancia se convierte en un <xref:System.Collections.IEnumerable> interfaz.</span><span class="sxs-lookup"><span data-stu-id="72f38-324">It can be used only when a derived <xref:System.Runtime.Caching.ObjectCache> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="72f38-325">Los desarrolladores pueden usar este método para recorrer en iteración una colección genérica de entradas de caché.</span><span class="sxs-lookup"><span data-stu-id="72f38-325">Developers can use this method to iterate through a generic collection of cache entries.</span></span>  
  
 <span data-ttu-id="72f38-326">Este es el valor predeterminado <xref:System.Collections.IEnumerable.GetEnumerator%2A> implementación que internamente llama el <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> método.</span><span class="sxs-lookup"><span data-stu-id="72f38-326">This is the default <xref:System.Collections.IEnumerable.GetEnumerator%2A> implementation that internally calls the <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>