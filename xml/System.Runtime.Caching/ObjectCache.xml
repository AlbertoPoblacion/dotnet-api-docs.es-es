<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="490163b95a1c739f285d903ae3e13cfd6489a285" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36637589" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa una memoria caché de objetos, y proporciona los métodos y las propiedades base para tener acceso a la memoria caché de objetos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache> tipo es el tipo primario de la caché de objetos en memoria. Para desarrollar una implementación de caché personalizado, derive de la <xref:System.Runtime.Caching.ObjectCache> clase.  
  
> [!NOTE]
>  El <xref:System.Runtime.Caching.ObjectCache> clase es una novedad de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Integrado <xref:System.Runtime.Caching.MemoryCache> clase se deriva de la <xref:System.Runtime.Caching.ObjectCache> clase. El <xref:System.Runtime.Caching.MemoryCache> clase es la implementación de la caché de objeto concreta solo en el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] que se deriva de la <xref:System.Runtime.Caching.ObjectCache> clase.  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <block subset="none" type="overrides">
      <para>Dado que la <see cref="T:System.Runtime.Caching.ObjectCache" /> tipo representa funciones comunes de caché, no hay ningún requisito para saber cómo un <see cref="T:System.Runtime.Caching.ObjectCache" /> instancia se debe crear una instancia y obtenida. Además, no es necesario que las implementaciones concretas de la <see cref="T:System.Runtime.Caching.ObjectCache" /> clase debe ser singletons.  <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> no es un singleton, pero debe crear solo pocos o potencialmente solo uno <see cref="T:System.Runtime.Caching.MemoryCache" /> instancia y el código que almacena en caché elementos deberían usar esas instancias.  </para></block>  Al heredar de la <see cref="T:System.Runtime.Caching.ObjectCache" /> (clase), debe invalidar sus métodos.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Este método lo invocan los constructores de las clases derivadas para inicializar la clase <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché sin que sea necesario devolver una entrada existente con la misma clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas del método intentan insertar una entrada de caché en la memoria caché, sin sobrescribir o quitar una entrada de caché existente que tiene la misma clave. La entrada de caché puede ser un tipo <xref:System.Runtime.Caching.CacheItem> objeto o un objeto genérico.  
  
 El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas de método y la <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método tienen una diferencia significativa. Cuando estos métodos insertan una entrada de caché, si se encuentra una entrada coincidente en la memoria caché, el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método devuelven la entrada de caché existente, pero la <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método no tienen que serlo. Con estas sobrecargas de método diferentes permite a los llamadores optimizar su código basado en si necesitan la entrada de caché existente. En las memorias caché distribuidas, devolver un valor existente utilizando el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> método podría ser más cara que devolver un valor booleano mediante <xref:System.Runtime.Caching.ObjectCache.Add%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a agregar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Cuando se reemplaza en una clase derivada, intenta insertar una entrada en la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" /> y agrega detalles sobre cómo debe expulsarse la entrada.</summary>
        <returns>Es <see langword="true" /> si la inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="item" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> de la clase, porque la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar. Si una implementación de caché no requiere ningún comportamiento especial para la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché. Este parámetro es necesario cuando se llama al método <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" />.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. Como en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] no se implementan regiones, el valor predeterminado es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché sin sobrescribir ninguna entrada existente.</summary>
        <returns>Es <see langword="true" /> si la inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> de la clase, porque la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar. Si una implementación de caché no requiere ningún comportamiento especial para la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica información sobre cómo se expulsará la entrada.</summary>
        <returns>Es <see langword="true" /> si el intento de inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> de la clase, porque la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar. Si una implementación de caché no requiere ningún comportamiento especial para la <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, intenta insertar una entrada en la memoria caché y devuelve una entrada existente con la misma clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método insertan una entrada en la memoria caché. Si ya existe una entrada de caché con una clave coincidente, devuelven la entrada existente. La entrada de caché puede ser un <xref:System.Runtime.Caching.CacheItem> objeto o un objeto genérico.  
  
 Hay una diferencia entre el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas y el <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas. Cuando estos métodos sobrecargados intentan insertar una entrada de caché, si se encuentra una entrada existente que ha insertado una clave que coincida con otra entrada de caché, el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas devuelven la entrada de caché existente. El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas no tienen que serlo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Cuando se invalida en una clase derivada, inserta el objeto <see cref="T:System.Runtime.Caching.CacheItem" /> especificado en la memoria caché, y especifica información sobre cómo se expulsará la entrada.</summary>
        <returns>Si existe una entrada de caché con la misma clave, se devuelve la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché utilizando una clave, un objeto para la entrada de caché, un valor de expiración absoluto y una región opcional a la que se va a agregar la entrada.</summary>
        <returns>Si ya existe una entrada de caché con la misma clave, se devuelve el valor de la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> sobrecarga del método devuelve un valor de objeto, no un <xref:System.Runtime.Caching.CacheItem> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica una clave y un valor para la entrada, así como información sobre cómo va a expulsarse.</summary>
        <returns>Si ya existe una entrada de caché con la misma clave, se devuelve el valor de la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> método devuelve un valor de objeto, no un <xref:System.Runtime.Caching.CacheItem> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché donde puede encontrarse la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, comprueba si la entrada ya existe en la memoria caché.</summary>
        <returns>Es <see langword="true" /> si la memoria caché contiene una entrada con el mismo valor de clave que <paramref name="key" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Identificadores únicos de las entradas de caché que se van a supervisar.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché donde existen las claves de caché en el parámetro <c>keys</c>, si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, crea un objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> que puede activar eventos en respuesta a los cambios realizados en las entradas especificadas de la memoria caché.</summary>
        <returns>Supervisor de cambios que supervisa las entradas de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un derivada <xref:System.Runtime.Caching.ObjectCache> clase invalida la base de <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> método, debe crear la implementación de la memoria caché un <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objeto. Este monitor de cambios especializado notifica a los llamadores cuando hay cambios en las entradas de caché que se especifican en el `keys` parámetro. Por ejemplo, si un elemento supervisado en el `keys` parámetro se actualizó o se quitó de la memoria caché, la supervisión de cambios creada por este método desencadena un evento.  
  
 Si una implementación de caché es compatible con las regiones de caché con nombre, puede especificarse un valor de cadena como el `regionName` parámetro. En caso contrario, el parámetro tiene como valor predeterminado `null`.  
  
> [!NOTE]
>  No todas las implementaciones de la memoria caché admiten monitores de cambio de entrada de caché. Para determinar si su implementación de caché es compatible con <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objetos, consulte la documentación para la implementación de caché específica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene una descripción de las características proporcionadas por una implementación de caché.</summary>
        <value>Combinación bit a bit de las marcas que indican las características predeterminadas de una implementación de caché.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a obtener.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregó la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la entrada especificada de la memoria caché como un objeto.</summary>
        <returns>Entrada de caché identificada por <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a obtener.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregó la entrada de caché, si se implementan regiones. Como en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] no se implementan regiones, el valor predeterminado es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la entrada especificada de la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Entrada de caché identificada por <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de método existe porque algunas implementaciones de la memoria caché pueden aumentar la <xref:System.Runtime.Caching.CacheItem> clase. En ese caso, el <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> sobrecarga del método no devolverá necesariamente toda la información sobre los datos almacenados en caché. Sin embargo, la <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> sobrecarga del método permite que las memorias caché personalizadas devolver algo más que el valor de la memoria caché.  
  
 El <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> método es similar a la <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> método, salvo que la <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> método devuelve de la entrada de caché como un <xref:System.Runtime.Caching.CacheItem> instancia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Opcional. Región con nombre de la memoria caché para la que se debe calcular el recuento de entradas de caché, si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene el número total de entradas de la memoria caché.</summary>
        <returns>Número de entradas de la memoria caché. Si <paramref name="regionName" /> no es <see langword="null" />, se devuelve el número de entradas en la región especificada de la memoria caché.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, crea un enumerador que puede usarse para iterar por una colección de entradas de la memoria caché.</summary>
        <returns>Objeto de enumerador que proporciona acceso a las entradas de la memoria caché en la caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los implementadores de la memoria caché pueden invalidar y extender este método para proporcionar un medio personalizado para recorrer en iteración una colección de entradas de caché.  
  
> [!NOTE]
>  Devuelve un enumerador es normalmente una operación más costosa que devolver la entrada de caché completa.  
  
 Este método llama a las implementaciones de interfaz explícita que la <xref:System.Runtime.Caching.ObjectCache> clase tiene para la <xref:System.Collections.IEnumerable.GetEnumerator%2A> y <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un conjunto de entradas de la memoria caché.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Colección de identificadores únicos correspondientes a las entradas de caché que se van a obtener.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregaron una o varias entradas de caché, si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un conjunto de entradas de la memoria caché que corresponden a las claves especificadas.</summary>
        <returns>Diccionario de pares clave-valor que representan entradas de caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método es una optimización de rendimiento para las memorias caché distribuidas que admiten la captura de varias entradas de caché de la memoria caché durante una llamada de red único.  
  
 Aunque un llamador puede pasar una o más claves al método, no hay ninguna garantía de que todas las claves representan las entradas en la memoria caché. Por lo tanto, el diccionario devuelto podría contener menos elementos que el número de claves que se pasaron al método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregaron una o varias entradas de caché, si se implementan regiones. Como en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] no se implementan regiones, el valor predeterminado es <see langword="null" />.</param>
        <param name="keys">Colección de identificadores únicos correspondientes a las entradas de caché que se van a obtener.</param>
        <summary>Obtiene un conjunto de entradas de la memoria caché que corresponden a las claves especificadas.</summary>
        <returns>Diccionario de pares clave-valor que representan entradas de caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> sobrecarga del método es similar a la <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método, pero permite pasar la región con nombre mediante la sintaxis de parámetro opcional que es compatible con los lenguajes administrados como C#.  
  
 Este método es un método virtual porque el <xref:System.Runtime.Caching.ObjectCache> clase proporciona una implementación predeterminada que pasa la `params` de matriz para el <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una referencia a un entorno de hospedaje administrado que está disponible para las implementaciones de <see cref="T:System.Runtime.Caching.ObjectCache" /> y puede proporcionar servicios específicos del host a las implementaciones de <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Referencia a un entorno de hospedaje administrado que reconoce la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Host%2A> propiedad está pensada para usarse en [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] entornos de host y entorno de host implementaciones de caché que implementan el comportamiento que depende de .NET Framework.  
  
 La tabla siguiente enumera el conjunto de servicios de entorno de host que podrían estar disponibles en un entorno de hospedaje administrado y que están disponibles para <xref:System.Runtime.Caching.ObjectCache> las implementaciones a través del <xref:System.Runtime.Caching.ObjectCache.Host%2A> propiedad:  
  
|web de Office|Descripción|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Permite a los entornos de host proporcionar identificadores de dominio de aplicación que podrían ser necesarios en una implementación de la memoria caché para características como identificar los contadores de rendimiento.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Permite a los entornos de host proporcionar un sistema de notificación de cambio de archivo personalizado, en lugar de usar el uno incluido en el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Permite el consumo de memoria caché de informes de implementaciones de caché al entorno de host. Esto permite administrar centralmente el consumo de memoria a través de varias implementaciones de la memoria caché de los entornos de host.|  
  
> [!NOTE]
>  Los llamadores del valor de esta propiedad, requieren permisos de seguridad de acceso de código sin restricciones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor que se asigna a la propiedad es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer el valor de propiedad más de una vez.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">de plena confianza para todos los descriptores de acceso de esta propiedad. Esta propiedad no se puede usar por código de confianza parcial.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica que una entrada de caché no tiene ninguna expiración absoluta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una entrada de caché que se inserta en la memoria caché con el <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> valor del campo como el valor de expiración no debe caducar nunca en función de un punto absoluto en el tiempo. Sin embargo, una entrada de caché con esta configuración puede ser expulsada de la memoria caché por otras razones que vengan determinados por una implementación de caché concreta, como una expulsión de evento de supervisión de cambios causada por la presión de memoria.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de una entrada de caché en la memoria caché.</param>
        <summary>Obtiene o establece el indizador predeterminado para la clase <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Clave que sirve de indizador en la instancia de la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento del descriptor de acceso set de esta propiedad es similar a la <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> método. Internamente, una implementación de la memoria caché podría establecer la expiración absoluta del valor especificado para el <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> método. Sin embargo este comportamiento es el usuario quien hasta la implementación de la memoria caché.  
  
 El comportamiento del descriptor de acceso get es como llamar a la <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> método y usar `null` para el nombre de región.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de una instancia específica de <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Nombre de una instancia específica de la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunas implementaciones de la memoria caché podrían admitir varias instancias de la memoria caché que se ejecuta en una sola aplicación. Esta propiedad permite a los implementadores de la memoria caché devolver un nombre que identifica una instancia de caché específica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que una entrada de caché no tiene ningún tiempo de expiración variable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Expiración que se basa en la duración o una ventana definida de tiempo también se conoce como la expiración variable. Normalmente, una implementación de caché que extrae elementos que se basan en la expiración variable quitará un elemento que no se tuvo acceso en el intervalo de tiempo especificado.  
  
 Una entrada de caché que se inserta en la memoria caché con el <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> establecido como el valor de expiración nunca se debe expulsar debido a falta de actividad en una ventana deslizante de tiempo del valor del campo. Sin embargo, un elemento de caché se pueda expulsar si tiene una expiración absoluta, o si se produce algún otro evento de expulsión, tal una presión de memoria o el monitor de cambio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregó la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, quita la entrada de la memoria caché.</summary>
        <returns>Objeto que representa el valor de la entrada de caché que se quitó y que se especificó mediante la clave, o <see langword="null" /> si no se encontró la entrada especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si invalide este método en una implementación de caché personalizado, si hay una entrada de caché en la memoria caché que corresponde a `key`, se debe devolver el valor del elemento quitado. Si no se quitó nada de la memoria caché, el método debe devolver `null`.  
  
> [!NOTE]
>  Algunas implementaciones de caché distribuida podrían no admitir la capacidad de devolver el valor que se ha quitado de la memoria caché. Esto podría deberse a que la implementación de la memoria caché no permite devolver el valor de un elemento de la memoria caché quitada. También es posible que el cálculo de referencias del objeto como un valor devuelto es demasiado costoso. En tales casos, las implementaciones de caché pueden devolver `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, inserta una entrada en la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento típico de la <xref:System.Runtime.Caching.ObjectCache.Set%2A> métodos de sobrecarga es una operación de inserción o actualización. Una entrada de caché es inserta como una nueva entrada si la entrada especificada no existe o se actualiza la entrada de caché con un nuevo valor si ya existe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Elemento de caché que se va a agregar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Cuando se invalida en una clase derivada, inserta la entrada de caché en la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" />, y especifica información sobre cómo se expulsará la entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave de `item` no existe, `item` se inserta como una nueva entrada de caché. Si un elemento con una clave que coincida con `item` existe, el valor de `item` se utiliza para actualizar o sobrescribir el valor de la entrada de caché existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica los detalles de la expiración basada en el tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un elemento que coincida con `key` no existe en la memoria caché, `value` y `key` se usan para insertar como una nueva entrada de caché. Si un elemento con una clave que coincida con `item` existe, se actualiza o sobrescribir mediante la entrada de caché `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, inserta una entrada en la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método permite proporcionar más detalles de expulsión o expiración que los que están disponibles en tiempo de expiración absoluta.  
  
 Si un elemento que coincida con `key` no existe en la memoria caché, `value` y `key` se usan para insertar como una nueva entrada de caché. Si un elemento con una clave que coincida con `item` existe, se actualiza o sobrescribir mediante la entrada de caché `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Admite la iteración en una colección genérica.</summary>
        <returns>Objeto de enumerador que proporciona acceso a los elementos de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Se puede utilizar solo cuando un derivada <xref:System.Runtime.Caching.ObjectCache> instancia se convierte en un <xref:System.Collections.IEnumerable> interfaz.  
  
 Los desarrolladores pueden usar este método para recorrer en iteración una colección genérica de entradas de caché.  
  
 Este es el valor predeterminado <xref:System.Collections.IEnumerable.GetEnumerator%2A> implementación que internamente llama el <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>