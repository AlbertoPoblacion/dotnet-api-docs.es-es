<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e67a12a32cead4499fca0cce4c15e8b203835d9" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53568517" /></Metadata><TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa una memoria caché de objetos, y proporciona los métodos y las propiedades base para tener acceso a la memoria caché de objetos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache> tipo es el tipo primario para la caché de objetos en memoria. Para desarrollar una implementación de caché personalizadas, deriva de la <xref:System.Runtime.Caching.ObjectCache> clase.  
  
> [!NOTE]
>  El <xref:System.Runtime.Caching.ObjectCache> clase es nueva como de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Integrado <xref:System.Runtime.Caching.MemoryCache> clase se deriva de la <xref:System.Runtime.Caching.ObjectCache> clase. El <xref:System.Runtime.Caching.MemoryCache> clase es la implementación de caché de objeto concreta solo en el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] que se deriva el <xref:System.Runtime.Caching.ObjectCache> clase.  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <block subset="none" type="overrides"><para>Dado que el <see cref="T:System.Runtime.Caching.ObjectCache" /> tipo representa funciones comunes de caché, no hay ningún requisito para cómo un <see cref="T:System.Runtime.Caching.ObjectCache" /> instancia debe ser crear una instancia y obtenida. Además, no hay ningún requisito que las implementaciones concretas de la <see cref="T:System.Runtime.Caching.ObjectCache" /> clase debe ser singletons con estado.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> no es un singleton, pero debe crear solo pocos o potencialmente solo uno <see cref="T:System.Runtime.Caching.MemoryCache" /> instancia y el código que se almacena en caché los elementos deben usar esas instancias.  
  
</para></block>  
  
 Al heredar de la <see cref="T:System.Runtime.Caching.ObjectCache" /> (clase), debe invalidar sus métodos.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Este método lo invocan los constructores de las clases derivadas para inicializar la clase <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché sin que sea necesario devolver una entrada existente con la misma clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas del método intentan insertar una entrada de caché en la memoria caché, sin sobrescribir o quitar una entrada existente que tiene la misma clave. La entrada de caché puede ser un tipo <xref:System.Runtime.Caching.CacheItem> objeto o un objeto genérico.  
  
 El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método y el <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas de método tienen una diferencia significativa. Cuando estos métodos insertan una entrada de caché, si se encuentra una entrada coincidente en la memoria caché, el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método devuelven la entrada de caché existente, pero la <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas del método no lo hacen. Estas sobrecargas de método diferentes permite que los llamadores optimizar su código basado en si necesitan la entrada de caché existente. En las memorias caché distribuidas, devolviendo un valor existente mediante el uso de la <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> método podría ser más costoso que devolver un valor booleano mediante <xref:System.Runtime.Caching.ObjectCache.Add%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a agregar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Cuando se reemplaza en una clase derivada, intenta insertar una entrada en la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" /> y agrega detalles sobre cómo debe expulsarse la entrada.</summary>
        <returns>Es <see langword="true" /> si la inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="item" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas del método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> clase, porque el <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente a <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar. Si una implementación de caché no requiere ningún comportamiento especial para el <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché. Este parámetro es necesario cuando se llama al método <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" />.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. Dado que no se implementan regiones en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el valor predeterminado es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché sin sobrescribir ninguna entrada existente.</summary>
        <returns>Es <see langword="true" /> si la inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas del método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> clase, porque el <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente a <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar. Si una implementación de caché no requiere ningún comportamiento especial para el <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica información sobre cómo se expulsará la entrada.</summary>
        <returns>Es <see langword="true" /> si el intento de inserción se realiza correctamente; es <see langword="false" /> si ya hay una entrada en la memoria caché que tiene la misma clave que <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas del método son virtuales (no abstractas) en el <xref:System.Runtime.Caching.ObjectCache> clase, porque el <xref:System.Runtime.Caching.ObjectCache.Add%2A> método llama internamente a <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Esto reduce el número de sobrecargas del método que un implementador de la memoria caché tiene que proporcionar. Si una implementación de caché no requiere ningún comportamiento especial para el <xref:System.Runtime.Caching.ObjectCache.Add%2A> método, simplemente puede implementar el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, intenta insertar una entrada en la memoria caché y devuelve una entrada existente con la misma clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas del método inserción una entrada en la memoria caché. Si ya existe una entrada de caché con una clave coincidente, devuelven la entrada existente. La entrada de caché puede ser un <xref:System.Runtime.Caching.CacheItem> objeto o un objeto genérico.  
  
 Hay una diferencia entre el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas y el <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas. Cuando estos métodos sobrecargados intentan insertar una entrada de caché, si se encuentra una entrada existente que ha insertado una clave que coincida con una existente entrada de caché, el <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> sobrecargas devuelven la entrada de caché existente. El <xref:System.Runtime.Caching.ObjectCache.Add%2A> sobrecargas no lo hacen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Cuando se invalida en una clase derivada, inserta el objeto <see cref="T:System.Runtime.Caching.CacheItem" /> especificado en la memoria caché, y especifica información sobre cómo se expulsará la entrada.</summary>
        <returns>Si existe una entrada de caché con la misma clave, se devuelve la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché utilizando una clave, un objeto para la entrada de caché, un valor de expiración absoluto y una región opcional a la que se va a agregar la entrada.</summary>
        <returns>Si ya existe una entrada de caché con la misma clave, se devuelve el valor de la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> sobrecarga del método devuelve un valor de objeto, no un <xref:System.Runtime.Caching.CacheItem> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica una clave y un valor para la entrada, así como información sobre cómo va a expulsarse.</summary>
        <returns>Si ya existe una entrada de caché con la misma clave, se devuelve el valor de la entrada de caché especificada; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> método devuelve un valor de objeto, no un <xref:System.Runtime.Caching.CacheItem> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché donde puede encontrarse la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se invalida en una clase derivada, comprueba si la entrada ya existe en la memoria caché.</summary>
        <returns>Es <see langword="true" /> si la memoria caché contiene una entrada con el mismo valor de clave que <paramref name="key" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Identificadores únicos de las entradas de caché que se van a supervisar.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché donde existen las claves de caché en el parámetro <paramref name="keys" />, si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, crea un objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> que puede activar eventos en respuesta a los cambios realizados en las entradas especificadas de la memoria caché.</summary>
        <returns>Supervisor de cambios que supervisa las entradas de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando una derivada <xref:System.Runtime.Caching.ObjectCache> clase reemplaza la base de <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> método, debe crear la implementación de la memoria caché un <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objeto. Este monitor de cambios especializado notifica a los llamadores cuando hay cambios en las entradas de caché que se especifican en el `keys` parámetro. Por ejemplo, si un elemento supervisado en el `keys` parámetro se actualiza o quita de la caché, la supervisión de cambios creada por este método desencadena un evento.  
  
 Si una implementación de caché es compatible con las regiones de memoria caché con nombre, se puede especificar un valor de cadena como el `regionName` parámetro. En caso contrario, el parámetro el valor predeterminado es `null`.  
  
> [!NOTE]
>  No todas las implementaciones de la memoria caché admiten monitores de cambio de entrada de caché. Para determinar si se admite su implementación de caché <xref:System.Runtime.Caching.CacheEntryChangeMonitor> objetos, consulte la documentación de la implementación de caché específica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene una descripción de las características proporcionadas por una implementación de caché.</summary>
        <value>Combinación bit a bit de las marcas que indican las características predeterminadas de una implementación de caché.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a obtener.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregó la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la entrada especificada de la memoria caché como un objeto.</summary>
        <returns>Entrada de caché identificada por <paramref name="key" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a obtener.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregó la entrada de caché, si se implementan regiones. Dado que no se implementan regiones en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el valor predeterminado es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la entrada especificada de la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Entrada de caché identificada por <paramref name="key" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método existe porque algunas implementaciones de la memoria caché podrían ampliar la <xref:System.Runtime.Caching.CacheItem> clase. En ese caso, el <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> sobrecarga del método no devolverá necesariamente toda la información sobre los datos almacenados en caché. Sin embargo, el <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> sobrecarga del método permite que las memorias caché personalizadas devolver algo más que el valor de la memoria caché.  
  
 El <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> método es similar a la <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> método, salvo que el <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> método devuelve valor devuelto de la entrada de caché como un <xref:System.Runtime.Caching.CacheItem> instancia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Opcional. Región con nombre de la memoria caché para la que se debe calcular el recuento de entradas de caché, si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene el número total de entradas de la memoria caché.</summary>
        <returns>Número de entradas de la memoria caché. Si <paramref name="regionName" /> no es <see langword="null" />, se devuelve el número de entradas en la región especificada de la memoria caché.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, crea un enumerador que puede usarse para iterar por una colección de entradas de la memoria caché.</summary>
        <returns>Objeto de enumerador que proporciona acceso a las entradas de la memoria caché en la caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los implementadores de la memoria caché pueden invalidar y ampliar este método para proporcionar un medio personalizado para recorrer en iteración una colección de entradas de caché.  
  
> [!NOTE]
>  Devuelve un enumerador es normalmente una operación más costosa que devolver la entrada de caché completa.  
  
 Este método se llama a las implementaciones de interfaz explícita que la <xref:System.Runtime.Caching.ObjectCache> clase tiene para el <xref:System.Collections.IEnumerable.GetEnumerator%2A> y <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un conjunto de entradas de la memoria caché.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Colección de identificadores únicos correspondientes a las entradas de caché que se van a obtener.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregaron una o varias entradas de caché, si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un conjunto de entradas de la memoria caché que corresponden a las claves especificadas.</summary>
        <returns>Diccionario de pares clave-valor que representan entradas de caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método es una optimización del rendimiento para las memorias caché distribuidas que admiten la captura de varias entradas de caché de la memoria caché durante una llamada de red único.  
  
 Aunque un llamador puede pasar una o varias claves para el método, no hay ninguna garantía de que todas las claves representan las entradas de la memoria caché. Por lo tanto, el diccionario devuelto podría contener menos elementos que el número de claves que se pasaron al método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregaron una o varias entradas de caché, si se implementan regiones. Dado que no se implementan regiones en [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el valor predeterminado es <see langword="null" />.</param>
        <param name="keys">Colección de identificadores únicos correspondientes a las entradas de caché que se van a obtener.</param>
        <summary>Obtiene un conjunto de entradas de la memoria caché que corresponden a las claves especificadas.</summary>
        <returns>Diccionario de pares clave-valor que representan entradas de caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> sobrecarga del método es similar a la <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método, pero permite pasar la región con nombre mediante la sintaxis de parámetro opcional que es compatible con los lenguajes administrados como C#.  
  
 Este método es un método virtual porque el <xref:System.Runtime.Caching.ObjectCache> clase proporciona una implementación predeterminada que pasa el `params` de matriz a la <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una referencia a un entorno de hospedaje administrado que está disponible para las implementaciones de <see cref="T:System.Runtime.Caching.ObjectCache" /> y puede proporcionar servicios específicos del host a las implementaciones de <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Referencia a un entorno de hospedaje administrado que reconoce la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ObjectCache.Host%2A> propiedad está pensada para su uso por [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] entornos de host y en implementaciones de caché que implementan el comportamiento que depende de .NET Framework hospedar el entorno.  
  
 En la tabla siguiente enumera el conjunto de servicios de host del entorno que podrían estar disponibles en un entorno de hospedaje administrado y que están disponibles para <xref:System.Runtime.Caching.ObjectCache> implementaciones a través de la <xref:System.Runtime.Caching.ObjectCache.Host%2A> propiedad:  
  
|web de Office|Descripción|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Permite a los entornos de host proporcionar identificadores de dominio de aplicación que podrían ser necesarios en una implementación de caché para las características, como la identificación de los contadores de rendimiento.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Permite a los entornos de host proporcionan un sistema de notificación de cambio de archivo personalizado, en lugar de utilizar el proporcionado en uno el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Permite el consumo de memoria caché de informes de caché implementaciones al entorno de host. Esto permite que los entornos de host administrar centralmente el consumo de memoria a través de varias implementaciones de caché.|  
  
> [!NOTE]
>  Los autores de llamadas de este valor de propiedad requieren permisos de seguridad de acceso de código sin restricciones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor que se asigna a la propiedad es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer el valor de propiedad más de una vez.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">para plena confianza para todos los descriptores de acceso de esta propiedad. Esta propiedad no se puede usar por código de confianza parcial.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica que una entrada de caché no tiene ninguna expiración absoluta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una entrada de caché que se inserta en la memoria caché con el <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> valor del campo como el valor de expiración no debe expirar nunca basándose en un punto absoluto en el tiempo. Sin embargo, se puede expulsar una entrada de caché con esta configuración de la memoria caché por otras razones que vienen determinados por una implementación de caché concreta, como una expulsión de evento de supervisión de cambios causado por la presión de memoria.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de una entrada de caché en la memoria caché.</param>
        <summary>Obtiene o establece el indizador predeterminado para la clase <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Clave que sirve de indizador en la instancia de la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento del descriptor de acceso set de esta propiedad es similar a la <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> método. Internamente, una implementación de caché pudo establecer una expiración absoluta del valor especificado para el <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> método. Pero este comportamiento es en última instancia, hasta la implementación de caché.  
  
 El comportamiento del descriptor de acceso get es como llamar a la <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> método y el uso de `null` para el nombre de la región.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de una instancia específica de <see cref="T:System.Runtime.Caching.ObjectCache" />.</summary>
        <value>Nombre de una instancia específica de la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunas implementaciones de caché pueden admitir varias instancias de la memoria caché que se está ejecutando en una sola aplicación. Esta propiedad permite a los implementadores de la memoria caché devolver un nombre que identifica una instancia de caché específica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que una entrada de caché no tiene ningún tiempo de expiración variable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Expiración que se basa en la duración o una ventana de tiempo definida se conoce también como fecha de expiración variable. Normalmente, una implementación de caché que extrae elementos que se basan en la fecha de expiración variable quitará un elemento que no se ha tenido acceso en la ventana de tiempo especificada.  
  
 Una entrada de caché que se inserta en la memoria caché con el <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> establecido como el valor de expiración nunca se debe expulsar debido a falta de actividad en una ventana deslizante de tiempo del valor del campo. Sin embargo, se puede expulsar un elemento de caché si tiene una expiración absoluta, o si se produce algún otro evento de expulsión, este tipo una presión de memoria o el monitor de cambio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se agregó la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, quita la entrada de la memoria caché.</summary>
        <returns>Objeto que representa el valor de la entrada de caché que se quitó y que se especificó mediante la clave, o <see langword="null" /> si no se encontró la entrada especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si invalida este método en una implementación de caché personalizada, si hay una entrada de caché en la memoria caché que se corresponde con `key`, se debe devolver el valor del elemento quitado. Si no hay nada se quitó de la memoria caché, el método debe devolver `null`.  
  
> [!NOTE]
>  Algunas implementaciones de caché distribuida podrían no admitir la capacidad de devolver el valor que se quitó de la memoria caché. Esto puede deberse a la implementación de caché no admite devolver el valor de un elemento de caché que se quitó. Es posible también que el cálculo de referencias del objeto como un valor devuelto es demasiado costoso. En tales casos, las implementaciones de caché pueden devolver `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, inserta una entrada en la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento típico de la <xref:System.Runtime.Caching.ObjectCache.Set%2A> métodos de sobrecarga es una operación de inserción o actualización. Una entrada de caché es inserta como una nueva entrada si la entrada especificada no existe o se actualiza la entrada de caché con un nuevo valor si ya existe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Elemento de caché que se va a agregar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Cuando se invalida en una clase derivada, inserta la entrada de caché en la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" />, y especifica información sobre cómo se expulsará la entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave para `item` no existe, `item` se inserta como una nueva entrada de caché. Si un elemento con una clave que coincida con `item` existe, el valor de `item` se usa para actualizar o sobrescribir el valor de la entrada de caché existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, inserta una entrada de caché en la memoria caché, y especifica los detalles de la expiración basada en el tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un elemento que coincida con `key` no existe en la memoria caché, `value` y `key` se utilizan para insertar como una nueva entrada de caché. Si un elemento con una clave que coincida con `item` existe, se actualiza o sobrescribir mediante la entrada de caché `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único de la entrada de caché.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Opcional. Región con nombre de la memoria caché a la que se puede agregar la entrada si se implementan regiones. El valor predeterminado para el parámetro opcional es <see langword="null" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, inserta una entrada en la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método permite proporcionar más detalles de expulsión o expiración que los que están disponibles en basado en tiempo de expiración absoluta.  
  
 Si un elemento que coincida con `key` no existe en la memoria caché, `value` y `key` se utilizan para insertar como una nueva entrada de caché. Si un elemento con una clave que coincida con `item` existe, se actualiza o sobrescribir mediante la entrada de caché `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Admite la iteración sobre una colección fuertemente tipada.</summary>
        <returns>Objeto de enumerador que proporciona acceso a las entradas de la memoria caché en la caché.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Admite la iteración en una colección genérica.</summary>
        <returns>Objeto de enumerador que proporciona acceso a los elementos de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Puede usarse solo cuando una derivada <xref:System.Runtime.Caching.ObjectCache> instancia se convierte en un <xref:System.Collections.IEnumerable> interfaz.  
  
 Los desarrolladores pueden usar este método para recorrer en iteración una colección genérica de entradas de caché.  
  
 Este es el valor predeterminado <xref:System.Collections.IEnumerable.GetEnumerator%2A> implementación que internamente llama el <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>