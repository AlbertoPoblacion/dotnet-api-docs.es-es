<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa8f739063475b844ca1c37c795d7728c6ae75a7" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53390058" /></Metadata><TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona una clase base para un tipo personalizado derivado que supervisa los cambios de estado de los datos de los que depende un elemento de caché.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Runtime.Caching.ChangeMonitor> clase se utiliza como la clase base para las clases derivadas de monitor que están especializadas en las implementaciones de caché concreta. Un <xref:System.Runtime.Caching.ChangeMonitor> instancia supervisa los cambios realizados en el estado de los datos que depende de un elemento de caché. Por ejemplo, el elemento puede ser una entidad de datos o de archivos cuyo contenido se almacenan en caché. Si se actualiza la entidad de datos o archivo, también se debe cambiar la entrada de caché asociada. Elementos comunes que se pueden supervisar incluyen entidades de datos (por ejemplo, los campos de la base de datos, valores, filas o tablas), otra entrada de caché y los archivos y los atributos de archivo.  
  
 Un cambio de dependencia es un cambio en el estado de una dependencia. En una implementación de caché típica, una vez un <xref:System.Runtime.Caching.ChangeMonitor> instancia notifica a la memoria caché que ha cambiado una dependencia, la memoria caché realiza la acción necesaria, como invalidar la entrada de caché insertado.  
  
 Derivados <xref:System.Runtime.Caching.ChangeMonitor> clases se pueden personalizar para supervisar los cambios de dependencia para específicos distintos almacenes de datos. Por ejemplo, existen implementaciones de caché para un sistema de archivos, memoria física o una base de datos. La <xref:System.Runtime.Caching.ChangeMonitor> clase examina los cambios que se producen fuera de la memoria caché y, a continuación, las alertas de la memoria caché que se han producido cambios.  
  
 El [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] incluye las siguientes clases que derivan de <xref:System.Runtime.Caching.ChangeMonitor> clase:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Cada una de estas clases funciona con diferentes tipos de dependencias. Por ejemplo, la clase derivada <xref:System.Runtime.Caching.FileChangeMonitor> clase supervisa los cambios realizados en una memoria caché para los datos de sistema de archivos (archivos y carpetas) que depende del elemento en caché.  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <block subset="none" type="overrides"><para>Si se puede crear una implementación de caché o un cambio derivado supervisar tipo, debe seguir ciertas instrucciones. En la lista siguiente se resume estas instrucciones. Para obtener más información, consulte la documentación de métodos o propiedades individuales.  
  
-El constructor de una clase derivada debe establecer el <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> propiedad, empezar a supervisar y llamar a <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método antes de que el método devuelve. Si un constructor encuentra un error durante las construcciones y debe tener que desechar los recursos, el constructor solo puede llamar a la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecargar después la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> se llama al método porque el <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga producirá una <see cref="T:System.InvalidOperationException" /> excepción si no se ha completado la inicialización.  
  
-Si se producen cambios en los datos que se está supervisando antes de que la inicialización se complete, debe llamar al constructor el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método antes de llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método.  
  
-Después de una derivada <see cref="T:System.Runtime.Caching.ChangeMonitor" /> se crea una instancia de tipo, debe insertar el monitor en un personalizado <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación. O si ya ha terminado con la supervisión de cambios, llame a la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método.  
  
-Después un <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia se inserta en un <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación, el <see cref="T:System.Runtime.Caching.ObjectCache" /> instancia requieren que se elimina la supervisión de cambios. Aunque la inserción no es válida y provoca una excepción, el <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación debe llamar a la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> de sobrecarga.  
  
-Después de un monitor del cambio derivado se inserta en una memoria caché, el <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación debe llamar a <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, pasando un <see cref="T:System.Runtime.Caching.OnChangedCallback" /> objeto. El <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método se puede llamar solo una vez. Si ya se ha producido un cambio de dependencia, el <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia se llamará inmediatamente cuando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se llama. En caso contrario, el <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia se llamará solo una vez. Una vez llamada produce cuando el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> se llama al método porque el <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia ha detectado un cambio, o cuando el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> se llama al método en el <see cref="T:System.Runtime.Caching.ChangeMonitor" />, lo que ocurra primero.  
  
-El <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia proporcionada por un <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación debería quitar la entrada de caché asociada y especificar un motivo mediante la <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> enumeración.  
  
-A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> puede llamar la instancia de la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método bien antes de una implementación de caché se haya llamado <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método o después. Si el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> se llama al método antes de <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se denomina base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementación enviará una notificación a la memoria caché que esto ha sucedido y desencadenará la devolución de llamada que se pasarán al <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> inmediatamente cuando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se invoca. Cualquier dato de estado que se pasa a la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método es guardado por el supervisor de cambios y posteriormente se pasan a la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método cuando el <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se invoca el método.  
  
-Un supervisor de cambios debe implementar la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> método. Para obtener más información, vea la documentación del método <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />.  
  
-El <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga del método debe llamarse para desechar el <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia. Las reglas para llamar a Dispose son los siguientes: 
-Antes de un elemento se inserta en la memoria caché, es responsabilidad del autor de llamada para desechar un <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia.  
  
-Una vez el elemento de caché y la <see cref="T:System.Runtime.Caching.ChangeMonitor" /> las instancias que están asociadas con la se pasan a una memoria caché, el implementador de la memoria caché debe asegurarse de que el <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método se llama, incluso si se produce un error en la inserción.  
  
-Después de un elemento y sus asociados <see cref="T:System.Runtime.Caching.ChangeMonitor" /> las instancias se pasan a una memoria caché, el llamador no debe eliminar la dependencia porque cuando el <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> se llama al método, la llamada se tratará como si ha cambiado la dependencia. Como resultado, el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método se invoca automáticamente.  
  
-Teniendo estas reglas en consideración, el <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método debe llamarse en una de las maneras siguientes: 
: Deben llamar los usuarios el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga del método si deciden no insertar la instancia de supervisión de cambios en una memoria caché.  
  
-Si la implementación intenta insertar la instancia de supervisión de cambios en una caché de objetos, pero se produce un error en la inserción, la implementación de caché es responsable de llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> de sobrecarga. Cuando el intento de inserción produce una excepción, la implementación de caché debe eliminar cualquier dependencia asociada.  
  
-Si se quita la entrada de caché, también debe eliminar la implementación de caché de la dependencia.  
  
-La implementación interna de la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método llama automáticamente a la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método después de que llama a una devolución de llamada que se ha registrado mediante <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 Esta llamada al método dispose durante el desencadenamiento automático solo se produce si la inicialización de la <see cref="T:System.Runtime.Caching.ChangeMonitor" /> previamente se completó la instancia.  
  
</para></block>  
  
 Cuando llama al constructor del supervisor de cambios derivadas el <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método, si ya ha cambiado el estado de la supervisión de cambios (es decir, el estado que se supervisa ya ha cambiado cuando el constructor todavía estaba activo) la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método eliminar automáticamente la supervisión de cambios.  
  
-El <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> propiedad está establecida en <see langword="true" /> después de la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> se llama al método por la instancia de supervisión de cambios derivadas, independientemente de si un <see cref="T:System.Runtime.Caching.OnChangedCallback" /> se ha establecido el objeto mediante una llamada a la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método o no.</para></block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce">Almacenamiento en caché de ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Los constructores de clases derivadas llaman a este constructor para inicializar la clase base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Runtime.Caching.ChangeMonitor> clase tiene un constructor predeterminado. Sin embargo, las clases que heredan de la base de <xref:System.Runtime.Caching.ChangeMonitor> clase y definir la supervisión personalizada de cambio de comportamiento debe realizar la inicialización en el constructor. Para obtener más información, vea la sección Notas a los herederos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>El constructor de una clase derivada debe establecer el <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> propiedad, empezar a supervisar y llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> clase antes de devolver. Si cambia una dependencia antes de la inicialización ha finalizado (por ejemplo, si una clave de caché dependiente no se encuentra en la memoria caché), debe llamar al constructor el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método antes de llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método. En este caso, puede llamar al constructor el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método solamente después la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> se denomina método, porque el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método produce una excepción si no se ha completado la inicialización.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método se utiliza para liberar el <xref:System.Runtime.Caching.ChangeMonitor> instancia y los recursos relacionados. El público <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método se invoca para coordinar el proceso de eliminación con eventos de ciclo de vida de clave de las clases de supervisión de cambios derivadas (como inicialización) y para liberar el <xref:System.Runtime.Caching.ChangeMonitor> para que la instancia puede recolectarse de instancia. El <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método se implementa mediante las clases de supervisión de cambios para desechar los recursos administrados y no administrados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por la instancia actual de la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método invoca el <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método de clases derivadas solo una vez, la primera vez que se llama. Las llamadas posteriores a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método no tienen ningún efecto. Después de haber llamado al método, el <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> propiedad está establecida en `true`.  
  
 El <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga debe llamarse para desechar un <xref:System.Runtime.Caching.ChangeMonitor> instancia. Éstas son las reglas para llamar al método dispose:  
  
-   Antes de que se inserta un elemento en la memoria caché, es responsabilidad del llamador para desechar un <xref:System.Runtime.Caching.ChangeMonitor> instancia.  
  
-   Elemento en caché una vez y el <xref:System.Runtime.Caching.ChangeMonitor> las instancias que están asociadas con la se pasan a una memoria caché, el implementador de la memoria caché debe asegurarse de que <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> se llama, incluso si se produce un error en la inserción.  
  
-   Después de un elemento y sus asociados <xref:System.Runtime.Caching.ChangeMonitor> las instancias se pasan a una memoria caché, el llamador no debe eliminar la dependencia porque cuando el <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> se llama al método, la llamada se tratará como si ha cambiado la dependencia. Como resultado, el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método se invoca automáticamente.  
  
-   Teniendo estas reglas en consideración, el <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método debe llamarse en una de las maneras siguientes:  
  
    -   Deben llamar los usuarios la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga del método si deciden no insertar la instancia de supervisión de cambios en una memoria caché.  
  
    -   La implementación de caché es responsable de llamar a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga si la implementación intenta insertar la instancia de supervisión de cambios en una caché de objetos, pero se produce un error en la inserción. Cuando el intento de inserción produce una excepción, la implementación de la memoria caché debe eliminar cualquier dependencia asociada.  
  
    -   Si se quita la entrada de caché, la implementación de la memoria caché también debe eliminar la dependencia.  
  
 La implementación interna de la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método llama automáticamente a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método después de que llama a una devolución de llamada que se ha registrado mediante el <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método.  
  
> [!NOTE]
>  El método dispose automático durante el desencadenamiento de eventos solo se produce si la inicialización de la <xref:System.Runtime.Caching.ChangeMonitor> instancia anteriormente ha finalizado.  
  
 Cuando llama al constructor del supervisor de cambios derivadas el <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> método, si ya ha cambiado el estado de la supervisión de cambios (es decir, el estado que se supervisa ya ha cambiado cuando el constructor todavía estaba activo), a continuación, <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> método eliminación automática de la supervisión de cambios.  
  
> [!NOTE]
>  Los usuarios no deben llamar a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método. Sin embargo, no se puede impedir que los usuarios una llamada al método. Por lo tanto, si es así, el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se invoca el método. En ese caso, la entrada de caché se notifica como si ha cambiado la dependencia.  
  
 Para evitar que las clases derivadas invaliden <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método, el método no es una implementación de interfaz explícita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La inicialización no se ha completado en la clase de supervisión de cambios que llamó al método base <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar los recursos administrados y no administrados, así como todas las referencias a una instancia de <see cref="T:System.Runtime.Caching.ChangeMonitor" />; es <see langword="false" /> para liberar únicamente los recursos no administrados. Cuando se pasa <see langword="false" />, un subproceso <see langword="finalizer" /> llama al método <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> y es probable que las referencias administradas externas ya no sean válidas porque ya se han recopilado los elementos no utilizados.</param>
        <summary>Libera todos los recursos administrados y no administrados así como todas las referencias a la instancia de <see cref="T:System.Runtime.Caching.ChangeMonitor" />. Esta sobrecarga la deben implementar las clases de supervisión de cambios derivadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el valor de `disposing` valor es `true`, se eliminan todos los recursos administrados y no administrados y se liberan todas las referencias a este objeto para que la instancia de supervisión de cambios puede recolectarlas. Se garantiza que la base de <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método invocará implementada <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método solo una vez.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Supervisor de cambios debe implementar la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecarga para liberar todos los recursos administrados y cuando el valor de <paramref name="disposing" /> es <see langword="true" />. El <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecarga del método que tiene un <paramref name="disposing" /> valor <see langword="true" /> se llama solo una vez, es decir, cuando se elimina la instancia por primera vez. Supervisor de cambios no debe llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecargar directamente. Supervisor de cambios derivadas puede llamar al público sin parámetros <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método en la base de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> clase.  
  
Como alternativa, un supervisor de cambios puede implementar un método finalizador. En ese caso, puede invocar el finalizador del <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> método y pásele un <paramref name="disposing" /> valor de <see langword="false" />. Sin embargo, esto normalmente no es necesario. Supervisión de los cambios de dependencia normalmente se realiza mediante un servicio que mantiene una referencia a la instancia de supervisión de cambios. La referencia impide que la instancia se recolectan y, por tanto, hace que un método de finalizador innecesarios. Para evitar pérdidas de memoria, cuando cambia alguna dependencia, el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método desecha la instancia de supervisión de cambios (a menos que no ha finalizado la inicialización).</para></block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica que el estado supervisado por la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" /> ha cambiado.</summary>
        <value>Es <see langword="true" /> si el estado supervisado por la instancia de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> ha cambiado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede comprobar el valor de esta propiedad en una derivada <xref:System.Runtime.Caching.ChangeMonitor> clase para ver si ha cambiado una dependencia.  
  
 El valor se establece en `true` cuando se produce un cambio de dependencia (es decir, cuando el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se llama al método). Después de la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se llama al método mediante la clase derivada, el valor de la <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad será `true`, independientemente de si un <xref:System.Runtime.Caching.OnChangedCallback> instancia se ha notificado mediante una llamada a la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método.  
  
> [!NOTE]
>  Los llamadores pueden comprobar el <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad para ver si ha cambiado una dependencia. Sin embargo, en un entorno multiproceso, un enfoque más sencillo y más fácil de mantener es insertar datos en una implementación de caché sin comprobar el <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad. Implementaciones de caché deben comprobar la <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad automáticamente y no debe realizar una inserción o establecer si ya han cambiado una o varias de las dependencias asociadas.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este método lo invoca el constructor de clases derivadas para indicar que ha finalizado la inicialización.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cambia una dependencia antes de que la inicialización se completa en una clase derivada, se debe invocar el constructor de la clase derivada la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método.  
  
 Cuando el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se invoca al método, el <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad se establece automáticamente en `true` por la supervisión de cambios. Como resultado, cuando llama al constructor de la supervisión de cambios el <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> método, la clase base llama automáticamente a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método. Si la inicialización se ha completado, el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método desecha automáticamente la instancia de supervisión de cambios.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>El constructor de una clase derivada debe llamar a la base de <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método antes de que el constructor. El constructor de una clase derivada puede llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método solamente después <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> se denomina, porque el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método produce una excepción si no se ha completado la inicialización.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica que se elimina la instancia derivada de una clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <value>Es <see langword="true" /> si se elimina la instancia; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad está establecida en `true` después de la base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> llamadas al método el <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método en una clase derivada para eliminar la instancia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Referencia a un método que se invoca cuando ha cambiado una dependencia.</param>
        <summary>Lo llaman los implementadores de memoria caché para registrar una devolución de llamada y notificar a una instancia de <see cref="T:System.Runtime.Caching.ObjectCache" /> a través del delegado <see cref="T:System.Runtime.Caching.OnChangedCallback" /> cuando una dependencia ha cambiado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los implementadores de la memoria caché Utilice este método para conectarse con un supervisor de cambios. Si asociar uno o más monitores con el elemento de caché de cambios, se pasa un <xref:System.Runtime.Caching.CacheItemPolicy> instancia con una propiedad de monitores de cambio rellenada para el elemento de caché. Un implementador de la memoria caché que es compatible con los monitores de cambio es responsable de recorrer en iteración el <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> propiedad y registrar el <xref:System.Runtime.Caching.OnChangedCallback> cambiar de delegados con cada monitor que encuentra.  
  
 Dado que el <xref:System.Runtime.Caching.OnChangedCallback> delegado incluye un parámetro de estado opcional, una implementación de monitor de cambio concreta puede pasar la información de estado opcional. El implementador de la memoria caché se determina si se puede tomar una dependencia explícita del tipo de estado de un monitor de cambio personalizada que se pasa como parte de la devolución de llamada.  
  
> [!NOTE]
>  La API de extensibilidad de caché de base no tiene ningún requisito de dependencia explícita del tipo de estado.  
  
 La implementación de la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método determina automáticamente si el estado del monitor ya ha cambiado en el momento <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> se llama al método. Si el <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad es `true`, a continuación, el método llama automáticamente a la <xref:System.Runtime.Caching.OnChangedCallback> controlador de eventos, que se registró, mediante el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método. Esto ocurre porque es posible que el estado supervisado subyacente ha cambiado desde el momento en que un supervisor de cambios a la hora de una implementación de caché obtiene al monitor y se conecta a él, crea una implementación de caché. Si el estado ya ha cambiado, a continuación, el objeto que se pasa a la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método es `null`.  
  
 El <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método se puede invocar solo una vez y se iniciará una excepción en llamadas subsiguientes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método de devolución de llamada ya se ha invocado.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="onChangedCallback" /> es <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>1.  Debe llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método para recibir una notificación de cambios de dependencia. Si ya se ha producido un cambio de dependencia, el <see cref="T:System.Runtime.Caching.OnChangedCallback" /> se llamará instancia cuando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se llama. En caso contrario, el <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia se llamará una vez, cuando el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> se llama al método o cuando el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> se llama el método, lo que ocurra primero. El <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia proporcionada por la implementación de caché debe quitar la entrada de caché y si se solicita el llamador de la memoria caché, aumente el cambio necesario o un evento de actualización de vuelta al llamador caché original.  
  
2.  La implementación de la memoria caché de objeto debe quitar la entrada de caché que está asociada a un cambio de dependencia.</para></block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Datos del evento de cambio. Este valor puede ser <see langword="null" />.</param>
        <summary>Este método lo invocan las clases derivadas para generar el evento cuando cambia una dependencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se llama al método cuando se producen cambios de dependencia. El <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método también se invoca cuando se elimina una instancia de supervisión de cambios, pero la eliminación se produce solo si ya no se ha invocado la devolución de llamada.  
  
 Si el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se llama al método antes de la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> llama el método, los datos de estado de la llamada a la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método se guarda mediante la implementación de caché. Además, la devolución de llamada para el <xref:System.Runtime.Caching.OnChangedCallback> método se invoca inmediatamente cuando el <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> se invoca el método.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que representa una instancia de la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</summary>
        <value>Identificador de una instancia de la clase de supervisión de cambios.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> valor de propiedad normalmente consta de datos de cadena de dependencia nombres combinados que identifican de forma los identificadores de los datos que se supervisan mediante una <xref:System.Runtime.Caching.ChangeMonitor> instancia. El valor de la <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> propiedad es una cadena. El valor de la cadena se usa para asignar el identificador único de la <xref:System.Runtime.Caching.ChangeMonitor> instancia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Invalidando la propiedad, puede definir una implementación personalizada para el valor de cadena de la propiedad con el fin de asignar un identificador único.</para></block>
        <block subset="none" type="overrides"><para>En las clases derivadas, debe establecer el valor de la propiedad en el constructor.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>