<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d7f673552db74d3ed1ff4f6fe8dcc10612167e5c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36542119" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="40824-101">Proporciona una clase base para un tipo personalizado derivado que supervisa los cambios de estado de los datos de los que depende un elemento de caché.</span>
      <span class="sxs-lookup">
        <span data-stu-id="40824-101">Provides a base class for a derived custom type that monitors changes in the state of the data which a cache item depends on.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-102">La <xref:System.Runtime.Caching.ChangeMonitor> clase se utiliza como la clase base para las clases de monitor derivadas que están especializadas para las implementaciones de la memoria caché determinada.</span><span class="sxs-lookup"><span data-stu-id="40824-102">The <xref:System.Runtime.Caching.ChangeMonitor> class is used as the base class for derived monitor classes that are specialized for particular cache implementations.</span></span> <span data-ttu-id="40824-103">Un <xref:System.Runtime.Caching.ChangeMonitor> instancia supervisa los cambios en el estado de los datos que depende de un elemento de caché.</span><span class="sxs-lookup"><span data-stu-id="40824-103">A <xref:System.Runtime.Caching.ChangeMonitor> instance monitors changes in the state of data which a cache item depends on.</span></span> <span data-ttu-id="40824-104">Por ejemplo, el elemento puede ser una entidad de datos o de archivos cuyo contenido se almacenan en caché.</span><span class="sxs-lookup"><span data-stu-id="40824-104">For example, the item can be a file or data entity whose contents are cached.</span></span> <span data-ttu-id="40824-105">Si se actualiza el archivo o entidad de datos, debe cambiar también la entrada de caché asociada.</span><span class="sxs-lookup"><span data-stu-id="40824-105">If the file or data entity is updated, the associated cache entry must be changed also.</span></span> <span data-ttu-id="40824-106">Elementos comunes que se pueden supervisar incluyen entidades de datos (por ejemplo, los campos de la base de datos, valores, filas o tablas), otra entrada de caché y archivos y atributos de archivo.</span><span class="sxs-lookup"><span data-stu-id="40824-106">Common items that can be monitored include data entities (such as database fields, values, rows, or tables), another cache entry, and files and file attributes.</span></span>  
  
 <span data-ttu-id="40824-107">Un cambio de dependencia es un cambio en el estado de una dependencia.</span><span class="sxs-lookup"><span data-stu-id="40824-107">A dependency change is a change in the state of a dependency.</span></span> <span data-ttu-id="40824-108">En una implementación de la memoria caché típica, después de un <xref:System.Runtime.Caching.ChangeMonitor> instancia notifica a la memoria caché que una dependencia ha cambiado, la memoria caché realiza la acción necesaria, por ejemplo, invalidando la entrada de la memoria caché insertada.</span><span class="sxs-lookup"><span data-stu-id="40824-108">In a typical cache implementation, after a <xref:System.Runtime.Caching.ChangeMonitor> instance notifies the cache that a dependency has changed, the cache performs the required action, such as invalidating the inserted cache entry.</span></span>  
  
 <span data-ttu-id="40824-109">Derivados <xref:System.Runtime.Caching.ChangeMonitor> clases se pueden personalizar para supervisar los cambios de dependencia para los almacenes de datos diferentes concretos.</span><span class="sxs-lookup"><span data-stu-id="40824-109">Derived <xref:System.Runtime.Caching.ChangeMonitor> classes can be customized to monitor dependency changes for specific different data stores.</span></span> <span data-ttu-id="40824-110">Por ejemplo, hay implementaciones de la memoria caché para un sistema de archivos, memoria física o una base de datos.</span><span class="sxs-lookup"><span data-stu-id="40824-110">For example, there are cache implementations for a file system, physical memory, or a database.</span></span> <span data-ttu-id="40824-111">La <xref:System.Runtime.Caching.ChangeMonitor> clase examina los cambios que se producen fuera de la memoria caché y, a continuación, las alertas de la memoria caché que se han producido cambios.</span><span class="sxs-lookup"><span data-stu-id="40824-111">The <xref:System.Runtime.Caching.ChangeMonitor> class examines changes that occur outside the cache, and then alerts the cache that changes have occurred.</span></span>  
  
 <span data-ttu-id="40824-112">El [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] incluye las siguientes clases que derivan de <xref:System.Runtime.Caching.ChangeMonitor> clase:</span><span class="sxs-lookup"><span data-stu-id="40824-112">The [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] includes the following classes that derive from <xref:System.Runtime.Caching.ChangeMonitor> class:</span></span>  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 <span data-ttu-id="40824-113">Cada una de estas clases funciona con tipos diferentes de dependencias.</span><span class="sxs-lookup"><span data-stu-id="40824-113">Each of these classes works with different types of dependencies.</span></span> <span data-ttu-id="40824-114">Por ejemplo, la clase derivada <xref:System.Runtime.Caching.FileChangeMonitor> clase supervisa los cambios a una caché para los datos de sistema de archivos (archivos y carpetas) que depende el elemento en caché.</span><span class="sxs-lookup"><span data-stu-id="40824-114">For example, the derived <xref:System.Runtime.Caching.FileChangeMonitor> class monitors changes to a cache for file system data (files and folders) that the cache item depends on.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="40824-115">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="40824-115">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <span data-ttu-id="40824-116">
        <para>Si puede crear una implementación de caché o un cambio derivado supervisar tipo, debe seguir ciertas instrucciones. En la lista siguiente se resume estas instrucciones. Para obtener más información, consulte la documentación de métodos o propiedades individuales.  -El constructor de una clase derivada debe establecer la <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> propiedad, iniciar la supervisión y llamar a <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método antes de que el método devuelve. Si un constructor encuentra un error durante las construcciones y debe tener que desechar recursos, el constructor solo puede llamar a la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga después de la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> se denomina método porque el <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga producirá un <see cref="T:System.InvalidOperationException" /> excepción si no se completó la inicialización.  -Si se producen cambios en los datos que se está supervisando antes de que la inicialización se complete, el constructor debe llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método antes de llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método.  -Después de una derivada <see cref="T:System.Runtime.Caching.ChangeMonitor" /> se crea una instancia de tipo, debe insertar el monitor en un personalizado <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación. O si ya ha terminado con el monitor de cambio, llame a la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método.  -Después un <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia se inserta en un <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación, la <see cref="T:System.Runtime.Caching.ObjectCache" /> instancia requieren que el supervisor de cambios se elimina. Incluso si la inserción no es válida y provoca una excepción, el <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación debe llamar a la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> de sobrecarga.  : Después de un monitor de cambio derivado se inserta en una memoria caché, el <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación debe llamar a <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, pasando un <see cref="T:System.Runtime.Caching.OnChangedCallback" /> objeto. El <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método puede llamarse solo una vez. Si ya se ha producido un cambio de dependencia, el <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia será AVISADA inmediatamente cuando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se llama. En caso contrario, el <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia se llamará solo una vez. Una vez llamada produce cuando el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> se denomina método porque el <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia detectó un cambio, o cuando la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método se llama en el <see cref="T:System.Runtime.Caching.ChangeMonitor" />, lo que ocurra primero.  -El <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia proporcionada por un <see cref="T:System.Runtime.Caching.ObjectCache" /> implementación debería quitar la entrada de caché asociada y especificar un motivo mediante la <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> enumeración.  -A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia puede llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método ya sea antes de que se llama a una implementación de caché <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método o después. Si el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método se llama antes de <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se llama, la base de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementación notificará a la memoria caché que se produjo y se desencadenará la devolución de llamada que se pasan a <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> inmediatamente cuando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se invoca. Los datos de estado que se pasen a la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método se guarda el supervisor de cambios y se pasa a continuación el <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método cuando el <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se invoca el método.  -Un supervisor de cambios debe implementar la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> método. Para obtener más información, consulte el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> documentación del método.  -El <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga del método debe llamarse para eliminar la <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia. Las reglas para llamar a Dispose son los siguientes:-antes de que se inserta un elemento en la memoria caché, es responsabilidad del autor de llamada para desechar un <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancia.  -Una vez el elemento de caché y la <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancias que están asociadas a ella se pasan a una memoria caché, el implementador de la memoria caché debe asegurarse de que la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método se llama, aun cuando se produce un error en la inserción.  -Después de un elemento y su <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instancias se pasan a una memoria caché, el llamador debe desechar la dependencia porque cuando el <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> se llama al método, la llamada se tratará como si la dependencia ha cambiado. Como resultado, el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método se invoca automáticamente.  -Teniendo estas reglas en cuenta, el <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método debe llamarse en una de las maneras siguientes:-deben llamar los usuarios la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> sobrecarga del método si deciden no insertar la instancia derivada de supervisión de cambios en una memoria caché.  -Si la implementación intenta insertar la instancia de supervisión de cambios en una caché de objetos, pero se produce un error en la inserción, la implementación de la memoria caché es responsable de llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> de sobrecarga. Cuando el intento de inserción produce una excepción, la implementación de la memoria caché debe eliminar cualquier dependencia asociada.  -Si se quita la entrada de caché, la implementación de la memoria caché también debe eliminar de la dependencia.  -La implementación interna de la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método llama automáticamente a la <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> método después de que llama a una devolución de llamada que se registra a través <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  <block subset="none" type="note"><para> Esta llamada automática al método dispose durante el desencadenamiento de eventos sólo se produce si la inicialización de la <see cref="T:System.Runtime.Caching.ChangeMonitor" /> previamente se completó la instancia.  </para></block>  Al constructor de un supervisor de cambios derivado llama el <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método, si ya ha cambiado el estado de la supervisión de cambios (es decir, el estado que se supervisa ya ha cambiado cuando el constructor todavía estaba activo) la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> le (método) eliminar automáticamente el supervisor de cambios.  -El <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> propiedad está establecida en <see langword="true" /> después de la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método es invocado por la instancia de supervisión de cambios derivadas, independientemente de si un <see cref="T:System.Runtime.Caching.OnChangedCallback" /> objeto se ha configurado mediante una llamada a la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método o no.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="40824-116">
          <para>If you create a custom cache implementation or a derived change monitor type, you must follow certain guidelines. The following list summarizes these guidelines. For more information, see the documentation for individual methods or properties.  -   The constructor of a derived class must set the <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> property, begin monitoring, and call <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method before the method returns. If a constructor encounters an error during constructions and must have to dispose of resources, the constructor can only call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload after the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method is called because the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload will throw an <see cref="T:System.InvalidOperationException" /> exception if initialization is not completed.  -   If changes occur in the data that is being monitored before initialization is complete, the constructor must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method before calling the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method.  -   After a derived <see cref="T:System.Runtime.Caching.ChangeMonitor" /> type is instantiated, you must insert the monitor into a custom <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation. Or if you are finished using the change monitor, call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method.  -   After a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance is inserted into a <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation, the <see cref="T:System.Runtime.Caching.ObjectCache" /> instance require that the change monitor is disposed. Even if the insertion is invalid and causes an exception, the <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation must call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload.  -   After a derived change monitor is inserted into a cache, the <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation must call <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, by passing a <see cref="T:System.Runtime.Caching.OnChangedCallback" /> object. The <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method can be called only one time. If a dependency change has already occurred, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called immediately when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called. Otherwise, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called only one time. This one time call occurs either when the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called because the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance detected a change, or when the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called on the <see cref="T:System.Runtime.Caching.ChangeMonitor" />, whichever occurs first.  -   The <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance that is provided by an <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation should remove the associated cache entry and specify a reason by using the <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> enumeration.  -   A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method either before a cache implementation has called <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method or after. If the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called before <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called, the base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementation will notify the cache that this has occurred and will trigger the callback to be passed to <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> immediately when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is invoked. Any state data that is passed to the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is saved by the change monitor and subsequently passed to the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method when the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method is invoked.  -   A change monitor must implement the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method. For more information, see the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method documentation.  -   The <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method overload must be called to dispose of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance. The rules for calling Dispose are as follows:  -   Before an item is inserted into the cache, it is the responsibility of caller to dispose of a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.  -   Once cache item and the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instances that are associated with it are passed to a cache, the cache implementer must make sure that that the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, even if the insert fails.  -   After an item and its associated <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instances are passed to a cache, the caller must not dispose the dependency because when the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, the call is treated as if the dependency has changed. As a result, the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is automatically invoked.  -   Taking these rules into consideration, the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method must be called in one of the following ways:  -   Users must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method overload if they decide not to insert the derived change-monitor instance into a cache.  -   If the implementation tries to insert the change-monitor instance into an object cache but the insertion fails, the cache implementation is responsible for calling the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload. When the insertion attempt causes an exception, the cache implementation must dispose of any associated dependencies.  -   If the cache entry is removed, the cache implementation must also dispose of the dependency.  -   The internal implementation of the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method automatically calls the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method after it calls a callback that is registered through <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  <block subset="none" type="note"><para> This automatic call to the dispose method during the event firing only occurs if the initialization of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance was previously completed.  </para></block>  When a derived change monitor's constructor calls the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method, if the state of the change monitor has already changed (that is, the state that is monitored already changed when the constructor was still active) then the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method will automatically dispose of the change monitor.  -   The <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> property is set to <see langword="true" /> after the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called by the derived change-monitor instance, regardless of whether a <see cref="T:System.Runtime.Caching.OnChangedCallback" /> object has been set by a call to the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method or not.</para>
        </span>
      </span>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="40824-117">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-117">Initializes a new instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span>
          </span>
          <span data-ttu-id="40824-118">Los constructores de clases derivadas llaman a este constructor para inicializar la clase base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-118">This constructor is called from constructors in derived classes to initialize the base class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-119">La <xref:System.Runtime.Caching.ChangeMonitor> clase tiene un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="40824-119">The <xref:System.Runtime.Caching.ChangeMonitor> class has a default constructor.</span></span> <span data-ttu-id="40824-120">Sin embargo, las clases que heredan de la base de <xref:System.Runtime.Caching.ChangeMonitor> clase y definir una supervisión de cambio personalizada comportamiento debe realizar la inicialización en el constructor.</span><span class="sxs-lookup"><span data-stu-id="40824-120">However, classes that inherit from the base <xref:System.Runtime.Caching.ChangeMonitor> class and define custom change-monitoring behavior must perform initialization in the constructor.</span></span> <span data-ttu-id="40824-121">Para obtener más información, vea la sección Notas a los herederos.</span><span class="sxs-lookup"><span data-stu-id="40824-121">For more information, see the Notes for Inheritors section.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="40824-122">
            <para>El constructor de una clase derivada debe establecer la <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> propiedad, iniciar la supervisión y llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> clase antes de devolver. Si cambia una dependencia antes de la inicialización está completa (por ejemplo, si una clave de caché dependiente no se encuentra en la memoria caché), debe llamar al constructor el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método antes de llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método. En este caso, puede llamar al constructor el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método sólo después la <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> se denomina método, porque la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método produce una excepción si no se completó la inicialización.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-122">
              <para>The constructor of a derived class must set the <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> property, begin monitoring, and call the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> class before it returns. If a dependency changes before initialization is complete (for example, if a dependent cache key is not found in the cache), the constructor must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method before it calls the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method. In this case, constructor can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method only after the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method is called, because the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method throws an exception if initialization is not completed.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="40824-123">Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-123">Releases all resources used by the current instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-124">El <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método se utiliza para liberar el <xref:System.Runtime.Caching.ChangeMonitor> instancia y los recursos relacionados.</span><span class="sxs-lookup"><span data-stu-id="40824-124">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is used to release the <xref:System.Runtime.Caching.ChangeMonitor> instance and related resources.</span></span> <span data-ttu-id="40824-125">Público <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método se invoca para coordinar el proceso de eliminación con eventos de ciclo de vida de clave de clases de supervisión de cambios derivadas (como inicialización) y para liberar el <xref:System.Runtime.Caching.ChangeMonitor> instancia ya que la instancia se puede recolectar.</span><span class="sxs-lookup"><span data-stu-id="40824-125">The public <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is invoked to coordinate the disposal process with key life-cycle events of derived change-monitor classes (such as initialization), and to release the <xref:System.Runtime.Caching.ChangeMonitor> instance so that the instance can be garbage collected.</span></span> <span data-ttu-id="40824-126">El <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método lo implementa las clases de supervisión de cambios derivadas para desechar los recursos administrados y no administrados.</span><span class="sxs-lookup"><span data-stu-id="40824-126">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is implemented by derived change-monitor classes to dispose of their managed and unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="40824-127">Libera todos los recursos utilizados por la instancia actual de la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-127">Releases all resources that are used by the current instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-128">El <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método invoca el <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método de las clases derivadas solo una vez, la primera vez que se llama.</span><span class="sxs-lookup"><span data-stu-id="40824-128">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method invokes the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method of derived classes only one time, the first time it is called.</span></span> <span data-ttu-id="40824-129">Las llamadas posteriores a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método no tienen ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="40824-129">Subsequent calls to the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method have no effect.</span></span> <span data-ttu-id="40824-130">Después de haber llamado al método, el <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> propiedad está establecida en `true`.</span><span class="sxs-lookup"><span data-stu-id="40824-130">After the method has been called, the <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> property is set to `true`.</span></span>  
  
 <span data-ttu-id="40824-131">El <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga debe llamarse para desechar un <xref:System.Runtime.Caching.ChangeMonitor> instancia.</span><span class="sxs-lookup"><span data-stu-id="40824-131">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload must be called to dispose of a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span> <span data-ttu-id="40824-132">Éstas son las reglas para llamar al método dispose:</span><span class="sxs-lookup"><span data-stu-id="40824-132">The following are the rules for calling the dispose method:</span></span>  
  
-   <span data-ttu-id="40824-133">Antes de que se inserta un elemento en la memoria caché, es responsabilidad del llamador para desechar un <xref:System.Runtime.Caching.ChangeMonitor> instancia.</span><span class="sxs-lookup"><span data-stu-id="40824-133">Before an item is inserted into the cache, it is the caller's responsibility to dispose of a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span>  
  
-   <span data-ttu-id="40824-134">Elemento en caché una vez y la <xref:System.Runtime.Caching.ChangeMonitor> instancias que están asociadas a ella se pasan a una memoria caché, el implementador de la memoria caché que debe asegurarse de que <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> se llama, aun cuando se produce un error en la inserción.</span><span class="sxs-lookup"><span data-stu-id="40824-134">Once cache item and the <xref:System.Runtime.Caching.ChangeMonitor> instances that are associated with it are passed to a cache, the cache implementer that must make sure that <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> is called, even if the insert fails.</span></span>  
  
-   <span data-ttu-id="40824-135">Después de un elemento y sus asociados <xref:System.Runtime.Caching.ChangeMonitor> instancias se pasan a una memoria caché, el llamador debe desechar la dependencia porque cuando el <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> se llama al método, la llamada se tratará como si la dependencia ha cambiado.</span><span class="sxs-lookup"><span data-stu-id="40824-135">After an item and its associated <xref:System.Runtime.Caching.ChangeMonitor> instances are passed to a cache, the caller must not dispose the dependency because when the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is called, the call is treated as if the dependency has changed.</span></span> <span data-ttu-id="40824-136">Como resultado, el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método se invoca automáticamente.</span><span class="sxs-lookup"><span data-stu-id="40824-136">As a result, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is automatically invoked.</span></span>  
  
-   <span data-ttu-id="40824-137">Teniendo estas reglas en cuenta, el <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método debe llamarse en una de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="40824-137">Taking these rules into consideration, the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method must be called in one of the following ways:</span></span>  
  
    -   <span data-ttu-id="40824-138">Deben llamar los usuarios la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga del método si deciden no insertar la instancia derivada de supervisión de cambios en una memoria caché.</span><span class="sxs-lookup"><span data-stu-id="40824-138">Users must call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method overload if they decide not to insert the derived change-monitor instance into a cache.</span></span>  
  
    -   <span data-ttu-id="40824-139">La implementación de la memoria caché es responsable de llamar a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> sobrecarga si la implementación intenta insertar la instancia de supervisión de cambios en una caché de objetos, pero se produce un error en la inserción.</span><span class="sxs-lookup"><span data-stu-id="40824-139">The cache implementation is responsible for calling the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload if the implementation tries to insert the change-monitor instance into an object cache but the insertion fails.</span></span> <span data-ttu-id="40824-140">Cuando el intento de inserción produce una excepción, la implementación de la memoria caché debe eliminar cualquier dependencia asociada.</span><span class="sxs-lookup"><span data-stu-id="40824-140">When the insertion attempt causes an exception, the cache implementation must dispose any associated dependencies.</span></span>  
  
    -   <span data-ttu-id="40824-141">Si se quita la entrada de caché, la implementación de la memoria caché también debe eliminar la dependencia.</span><span class="sxs-lookup"><span data-stu-id="40824-141">If the cache entry is removed, the cache implementation must also dispose the dependency.</span></span>  
  
 <span data-ttu-id="40824-142">La implementación interna de la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método llama automáticamente a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método después de que llama a una devolución de llamada que se registra a través del <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método.</span><span class="sxs-lookup"><span data-stu-id="40824-142">The internal implementation of the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method automatically calls the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method after it calls a callback that is registered through the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="40824-143">El método dispose automático durante el desencadenamiento de eventos sólo se produce si la inicialización de la <xref:System.Runtime.Caching.ChangeMonitor> instancia previamente ha finalizado.</span><span class="sxs-lookup"><span data-stu-id="40824-143">This automatic dispose during the event firing only occurs if the initialization of the <xref:System.Runtime.Caching.ChangeMonitor> instance previously completed.</span></span>  
  
 <span data-ttu-id="40824-144">Al constructor de un supervisor de cambios derivado llama el <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> método, si ya ha cambiado el estado de la supervisión de cambios (es decir, el estado que se supervisa ya ha cambiado cuando el constructor todavía estaba activo), a continuación, <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> le (método) eliminar automáticamente el monitor de cambio.</span><span class="sxs-lookup"><span data-stu-id="40824-144">When a derived change monitor's constructor calls the <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method, if the state of the change monitor has already changed (that is, the state that is monitored has already changed when the constructor was still active) then <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method will automatically dispose the change monitor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="40824-145">Los usuarios no deben llamar a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método.</span><span class="sxs-lookup"><span data-stu-id="40824-145">Users should not call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method.</span></span> <span data-ttu-id="40824-146">Sin embargo, no se puede impedir que los usuarios llamar al método.</span><span class="sxs-lookup"><span data-stu-id="40824-146">However, you cannot prevent users from calling the method.</span></span> <span data-ttu-id="40824-147">Por lo tanto, si es así, el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se invoca el método.</span><span class="sxs-lookup"><span data-stu-id="40824-147">Therefore, if they do, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is invoked.</span></span> <span data-ttu-id="40824-148">En ese caso, la entrada de caché se notifica como si la dependencia ha cambiado.</span><span class="sxs-lookup"><span data-stu-id="40824-148">In that case, the cache entry is notified as if the dependency has changed.</span></span>  
  
 <span data-ttu-id="40824-149">Para evitar que las clases derivadas invaliden <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método, el método no es una implementación de interfaz explícita.</span><span class="sxs-lookup"><span data-stu-id="40824-149">To prevent derived classes from overriding <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method, the method is not an explicit interface implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="40824-150">La inicialización no se ha completado en la clase de supervisión de cambios que llamó al método base <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-150">Initialization is not complete in the derived change-monitor class that called the base <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method.</span>
          </span>
        </exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="40824-151">Es <see langword="true" /> para liberar los recursos administrados y no administrados, así como todas las referencias a una instancia de <see cref="T:System.Runtime.Caching.ChangeMonitor" />; es <see langword="false" /> para liberar únicamente los recursos no administrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-151">
              <see langword="true" /> to release managed and unmanaged resources and any references to a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
          <span data-ttu-id="40824-152">Cuando se pasa <see langword="false" />, un subproceso <see langword="finalizer" /> llama al método <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> y es probable que las referencias administradas externas ya no sean válidas porque ya se han recopilado los elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-152">When <see langword="false" /> is passed, the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method is called by a <see langword="finalizer" /> thread and any external managed references are likely no longer valid because they have already been garbage collected.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="40824-153">Libera todos los recursos administrados y no administrados así como todas las referencias a la instancia de <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-153">Releases all managed and unmanaged resources and any references to the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.</span>
          </span>
          <span data-ttu-id="40824-154">Esta sobrecarga la deben implementar las clases de supervisión de cambios derivadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-154">This overload must be implemented by derived change-monitor classes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-155">Cuando el valor de `disposing` valor es `true`, se eliminan todos los recursos administrados y no administrados y se liberan todas las referencias a este objeto para que la instancia de supervisión de cambios derivada puede ser recolectado.</span><span class="sxs-lookup"><span data-stu-id="40824-155">When the value of `disposing` value is `true`, all managed and unmanaged resources are disposed and any references to this object are released so that the derived change-monitor instance can be garbage collected.</span></span> <span data-ttu-id="40824-156">Se garantiza que la base de <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método invocará implementada <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método solo una vez.</span><span class="sxs-lookup"><span data-stu-id="40824-156">It is guaranteed that the base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method will invoke the implemented <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method only one time.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="40824-157">
            <para>Supervisor de cambios debe implementar la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecarga para liberar todos los recursos administrados y cuando el valor de <paramref name="disposing" /> es <see langword="true" />. El <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecarga del método que tiene un <paramref name="disposing" /> valo <see langword="true" /> se llama solo una vez, es decir, cuando la instancia se elimina por primera vez. No debe llamar un monitor de cambio de la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> sobrecargar directamente. Un monitor de cambio derivado puede llamar al público sin parámetros <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método en la base de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> clase.  Como alternativa, un monitor de cambio puede implementar un método finalizador. En ese caso, puede invocar el finalizador el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> método y pásele un <paramref name="disposing" /> valo <see langword="false" />. Sin embargo, esto no es necesario normalmente. Supervisión de los cambios de dependencia normalmente se realiza mediante un servicio que mantiene una referencia a la instancia de supervisión de cambios. La referencia impide que la instancia se han recopilado y, por tanto, hace que un método de finalizador innecesarios. Para evitar pérdidas de memoria, cuando una dependencia cambia, el <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> método desecha la instancia de supervisión de cambios (a menos que no ha terminado la inicialización).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-157">
              <para>A change monitor must implement the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> overload to release all managed and unmanaged resources when the value of <paramref name="disposing" /> is <see langword="true" />. The <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method overload that has a <paramref name="disposing" /> value of <see langword="true" /> is called only one time, namely, when the instance is disposed for the first time. A change monitor must not call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> overload directly. A derived change monitor can call the public parameter-less <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method on the base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.  Alternatively, a change monitor can implement a finalizer method. In that case, the finalizer can invoke the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method and pass it a <paramref name="disposing" /> value of <see langword="false" />. However, this is usually unnecessary. Monitoring for dependency changes is typically performed by a service that maintains a reference to the change-monitor instance. The reference prevents the instance from being garbage collected, and therefore makes a finalizer method unnecessary. To avoid memory leaks, when a dependency changes, the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method disposes the change-monitor instance (unless initialization has not finished).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="40824-158">Obtiene un valor que indica que el estado supervisado por la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" /> ha cambiado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-158">Gets a value that indicates that the state that is monitored by the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class has changed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="40824-159">Es <see langword="true" /> si el estado supervisado por la instancia de <see cref="T:System.Runtime.Caching.ChangeMonitor" /> ha cambiado; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-159">
              <see langword="true" /> if the state that is monitored by the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance has changed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-160">Puede comprobar el valor de esta propiedad en un derivada <xref:System.Runtime.Caching.ChangeMonitor> clase para ver si una dependencia ha cambiado.</span><span class="sxs-lookup"><span data-stu-id="40824-160">You can check the value of this property in a derived <xref:System.Runtime.Caching.ChangeMonitor> class to see whether a dependency has changed.</span></span>  
  
 <span data-ttu-id="40824-161">El valor se establece en `true` cuando se produce un cambio de dependencia (es decir, cuando el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se llama al método).</span><span class="sxs-lookup"><span data-stu-id="40824-161">The value is set to `true` when a dependency change occurs (that is, when the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called).</span></span> <span data-ttu-id="40824-162">Después de la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método llama a la clase derivada, el valor de la <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad será `true`, independientemente de si un <xref:System.Runtime.Caching.OnChangedCallback> instancia se ha notificado por una llamada a la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método.</span><span class="sxs-lookup"><span data-stu-id="40824-162">After the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called by the derived class, the value of the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property will be `true`, regardless of whether a <xref:System.Runtime.Caching.OnChangedCallback> instance has been notified by a call to the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="40824-163">Los llamadores pueden comprobar la <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad para ver si una dependencia ha cambiado.</span><span class="sxs-lookup"><span data-stu-id="40824-163">Callers can check the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property to see whether a dependency has changed.</span></span> <span data-ttu-id="40824-164">Sin embargo, en un entorno multiproceso, un enfoque más sencillo y más fácil de mantener es insertar datos en una implementación de caché sin comprobar la <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="40824-164">However, in a multi-threaded environment, a simpler and more maintainable approach is to insert data into a cache implementation without checking the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property.</span></span> <span data-ttu-id="40824-165">Deben comprobar las implementaciones de la memoria caché la <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad automáticamente y no debe realizar una inserción o set operación si uno o más dependencias asociadas ya han cambiado.</span><span class="sxs-lookup"><span data-stu-id="40824-165">Cache implementations must check the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property for you and must not perform an insert or set operation if one or more associated dependencies have already changed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="40824-166">Este método lo invoca el constructor de clases derivadas para indicar que ha finalizado la inicialización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-166">Called from the constructor of derived classes to indicate that initialization is finished.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-167">Si una dependencia cambia antes de que la inicialización se completa en una clase derivada, el constructor de la clase derivada debe invocar el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método.</span><span class="sxs-lookup"><span data-stu-id="40824-167">If a dependency changes before initialization is complete in a derived class, the constructor of the derived class must invoke the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method.</span></span>  
  
 <span data-ttu-id="40824-168">Cuando el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> se invoca el método, el <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad se establece automáticamente en `true` por el supervisor de cambios.</span><span class="sxs-lookup"><span data-stu-id="40824-168">When the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is invoked, the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property is automatically set to `true` by the change monitor.</span></span> <span data-ttu-id="40824-169">Como resultado, cuando constructor el supervisor de cambios llama a la <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> método, la clase base llama automáticamente a la <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método.</span><span class="sxs-lookup"><span data-stu-id="40824-169">As a result, when the change monitor's constructor calls the <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method, the base class will automatically call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method.</span></span> <span data-ttu-id="40824-170">Si la inicialización se ha completado, el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método elimina automáticamente la instancia de supervisión de cambios derivadas.</span><span class="sxs-lookup"><span data-stu-id="40824-170">If initialization is complete, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method automatically disposes the derived change-monitor instance.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="40824-171">
            <para>El constructor de una clase derivada debe llamar a la base de <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> método antes de que vuelva el constructor. El constructor de una clase derivada puede llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método sólo después <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> se denomina, porque el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> método produce una excepción si no se completó la inicialización.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-171">
              <para>The constructor of a derived class must call the base <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method before the constructor returns. The constructor of a derived class can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method only after <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> is called, because the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method throws an exception if initialization is not completed.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="40824-172">Obtiene un valor que indica que se elimina la instancia derivada de una clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-172">Gets a value that indicates that the derived instance of a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class is disposed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="40824-173">Es <see langword="true" /> si se elimina la instancia; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-173">
              <see langword="true" /> if the instance is disposed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-174">La propiedad se establece en `true` después de la base de <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> llamadas al método el <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> método en una clase derivada para eliminar de la instancia.</span><span class="sxs-lookup"><span data-stu-id="40824-174">The property is set to `true` after the base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method calls the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method in a derived class to dispose of the instance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">
          <span data-ttu-id="40824-175">Referencia a un método que se invoca cuando ha cambiado una dependencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-175">A reference to a method that is invoked when a dependency has changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="40824-176">Lo llaman los implementadores de memoria caché para registrar una devolución de llamada y notificar a una instancia de <see cref="T:System.Runtime.Caching.ObjectCache" /> a través del delegado <see cref="T:System.Runtime.Caching.OnChangedCallback" /> cuando una dependencia ha cambiado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-176">Called by Cache implementers to register a callback and notify an <see cref="T:System.Runtime.Caching.ObjectCache" /> instance through the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> delegate when a dependency has changed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-177">Los implementadores de la memoria caché Utilice este método para conectarse con un monitor de cambio.</span><span class="sxs-lookup"><span data-stu-id="40824-177">Cache implementers use this method to wire themselves up to a change monitor.</span></span> <span data-ttu-id="40824-178">Si asociar uno o más monitores con el elemento de caché de cambio, se pasa un <xref:System.Runtime.Caching.CacheItemPolicy> instancia con una propiedad de monitores de cambio rellenada para el elemento en caché.</span><span class="sxs-lookup"><span data-stu-id="40824-178">If you associate one or more change monitors with the cache item, you pass a <xref:System.Runtime.Caching.CacheItemPolicy> instance with a populated change monitors property to the cache item.</span></span> <span data-ttu-id="40824-179">Un implementador de la memoria caché que admite supervisiones de cambios es responsable para iterar por la <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> propiedad y registrar el <xref:System.Runtime.Caching.OnChangedCallback> cambiar de delegados a cada monitor que encuentre.</span><span class="sxs-lookup"><span data-stu-id="40824-179">A cache implementer that supports change monitors is responsible for iterating over the <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> property and register the <xref:System.Runtime.Caching.OnChangedCallback> delegates with each change monitor that it finds.</span></span>  
  
 <span data-ttu-id="40824-180">Dado que el <xref:System.Runtime.Caching.OnChangedCallback> delegado incluye un parámetro de estado opcional, una implementación de monitor de cambio concreta puede pasar información de estado opcional.</span><span class="sxs-lookup"><span data-stu-id="40824-180">Because the <xref:System.Runtime.Caching.OnChangedCallback> delegate includes an optional state parameter, a concrete change monitor implementation can pass optional state information.</span></span> <span data-ttu-id="40824-181">El implementador de la memoria caché determina si se puede tomar una dependencia explícita en el tipo de estado que un monitor de cambio personalizada que se pasa como parte de la devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="40824-181">The cache implementer determines whether an explicit dependency on the type of state that a custom change monitor passes as part of the callback can be taken.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="40824-182">La API de extensibilidad de caché de base no tiene ningún requisito de dependencia explícita en el tipo de estado.</span><span class="sxs-lookup"><span data-stu-id="40824-182">The base cache extensibility API has no requirement for explicit dependency on the type of state.</span></span>  
  
 <span data-ttu-id="40824-183">La implementación de la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método determina automáticamente si el estado del monitor ya ha cambiado en el momento <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="40824-183">The implementation of the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method automatically determines whether the state of the monitor has already changed at the time <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is called.</span></span> <span data-ttu-id="40824-184">Si el <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> propiedad es `true`, a continuación, el método se llama de forma automática la <xref:System.Runtime.Caching.OnChangedCallback> controlador de eventos, que se haya registrado, mediante el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método.</span><span class="sxs-lookup"><span data-stu-id="40824-184">If the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property is `true`, then the method automatically calls the <xref:System.Runtime.Caching.OnChangedCallback> event handler, that was registered, through the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method.</span></span> <span data-ttu-id="40824-185">Esto ocurre porque es posible que el estado supervisado subyacente ha cambiado desde el momento en que un monitor de cambio, a la hora de una implementación de caché obtiene al monitor y se conecta a él, crea una implementación de caché.</span><span class="sxs-lookup"><span data-stu-id="40824-185">This occurs because it is possible that from the time a cache implementation creates a change monitor, to the time a cache implementation gets the monitor and wires itself up to it, the underlying monitored state has changed.</span></span> <span data-ttu-id="40824-186">Si el estado ya ha cambiado, a continuación, el objeto que se pasa a la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método es `null`.</span><span class="sxs-lookup"><span data-stu-id="40824-186">If the state has already changed then the object that is passed to the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is `null`.</span></span>  
  
 <span data-ttu-id="40824-187">El <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método se puede invocar solo una vez y se iniciará una excepción en llamadas subsiguientes.</span><span class="sxs-lookup"><span data-stu-id="40824-187">The <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method can be invoked only one time, and will throw an exception on subsequent calls.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="40824-188">El método de devolución de llamada ya se ha invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-188">The callback method has already been invoked.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="40824-189">
            <paramref name="onChangedCallback" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-189">
              <paramref name="onChangedCallback" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="40824-190">
            <para>1.  Debe llamar a la <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> método recibir una notificación de los cambios de dependencia. Si ya se ha producido un cambio de dependencia, el <see cref="T:System.Runtime.Caching.OnChangedCallback" /> se invocará instancia cuando <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> se llama. En caso contrario, el <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia se llamará una vez, cuando la <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> se llama al método o cuando el <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> momento en que se llama al método, lo que ocurra primero. El <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instancia proporcionada por la implementación de la memoria caché debería quitar la entrada de caché y si se solicita el llamador de la memoria caché, se producirá el cambio necesario o el evento de actualización de vuelta al llamador caché original.  2.  La implementación de la memoria caché de objeto debe quitar la entrada de caché que está asociada a un cambio de dependencia.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-190">
              <para>1.  You must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method to be notified of any dependency changes. If a dependency change has already occurred, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called. Otherwise, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called one time, either when the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called or when the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, whichever occurs first. The <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance provided by the cache implementation should remove the cache entry and if it is requested by the cache caller, raise the necessary change or update event back to the original cache caller.  2.  The object cache implementation must remove the cache entry that is associated with a dependency change.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="40824-191">Datos del evento de cambio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-191">The data for the change event.</span>
          </span>
          <span data-ttu-id="40824-192">Este valor puede ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-192">This value can be <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="40824-193">Este método lo invocan las clases derivadas para generar el evento cuando cambia una dependencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-193">Called by derived classes to raise the event when a dependency changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-194">Normalmente, el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método se llama cuando se producen cambios de dependencia.</span><span class="sxs-lookup"><span data-stu-id="40824-194">Typically, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called when dependency changes occur.</span></span> <span data-ttu-id="40824-195">El <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> también se invoca el método cuando se elimina una instancia de supervisión de cambios, pero la eliminación solo se produce si ya no se ha invocado la devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="40824-195">The <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is also invoked when a change-monitor instance is disposed but the disposal occurs only if the callback has not already been invoked.</span></span>  
  
 <span data-ttu-id="40824-196">Si el <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método se llama antes de la <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> método se llama, los datos de estado de la llamada a la <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> método se guarda mediante la implementación de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="40824-196">If the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called before the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is called, the state data from the call to the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is saved by the cache implementation.</span></span> <span data-ttu-id="40824-197">Además, la devolución de llamada para el <xref:System.Runtime.Caching.OnChangedCallback> método se invoca inmediatamente cuando el <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> se invoca el método.</span><span class="sxs-lookup"><span data-stu-id="40824-197">Also, the callback to the <xref:System.Runtime.Caching.OnChangedCallback> method is invoked immediately when the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="40824-198">Obtiene un valor que representa una instancia de la clase <see cref="T:System.Runtime.Caching.ChangeMonitor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-198">Gets a value that represents the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="40824-199">Identificador de una instancia de la clase de supervisión de cambios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-199">The identifier for a change-monitor instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="40824-200">El <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> valor de la propiedad normalmente consta de datos de la cadena de dependencia nombres combinados que identifican de forma exclusiva los datos que está siendo supervisados por un <xref:System.Runtime.Caching.ChangeMonitor> instancia.</span><span class="sxs-lookup"><span data-stu-id="40824-200">The <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> property value typically consists of dependency names combined string data that uniquely identifiers the data that is being monitored by a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span> <span data-ttu-id="40824-201">El valor de la <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> propiedad es una cadena.</span><span class="sxs-lookup"><span data-stu-id="40824-201">The value of the <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> property is a string.</span></span> <span data-ttu-id="40824-202">El valor de la cadena se usa para asignar el identificador único de la <xref:System.Runtime.Caching.ChangeMonitor> instancia.</span><span class="sxs-lookup"><span data-stu-id="40824-202">The value of the string is used to assign the unique ID of the <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="40824-203">
            <para>Al reemplazar la propiedad, puede definir una implementación personalizada para el valor de cadena de la propiedad a fin de asignar un identificador único.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-203">
              <para>By overriding the property, you can define a custom implementation for the string value of the property in order to assign it a unique ID.</para>
            </span>
          </span>
        </block>
        <block subset="none" type="overrides">
          <span data-ttu-id="40824-204">
            <para>En las clases derivadas, debe establecer el valor de la propiedad en el constructor.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="40824-204">
              <para>In derived classes, you must set the value of the property in the constructor.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>