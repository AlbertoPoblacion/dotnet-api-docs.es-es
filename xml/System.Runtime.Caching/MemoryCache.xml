<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c6af75218569fa5ef3b2bc50fd52c286c6076c5" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51311305" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa el tipo que implementa una caché en memoria.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.Runtime.Caching.MemoryCache> es una implementación concreta de la clase abstracta <xref:System.Runtime.Caching.ObjectCache> .  
  
> [!NOTE]
>  El <xref:System.Runtime.Caching.MemoryCache> clase es similar a ASP.NET <xref:System.Web.Caching.Cache> clase. El <xref:System.Runtime.Caching.MemoryCache> clase tiene muchas propiedades y métodos para tener acceso a la memoria caché que resultará familiar si ha usado ASP.NET <xref:System.Web.Caching.Cache> clase. Las principales diferencias entre el <xref:System.Web.Caching.Cache> y <xref:System.Runtime.Caching.MemoryCache> clases que son el <xref:System.Runtime.Caching.MemoryCache> clase ha cambiado para que sea utilizable por [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] aplicaciones que no son aplicaciones de ASP.NET. Por ejemplo, el <xref:System.Runtime.Caching.MemoryCache> clase no tiene ninguna dependencia el `System.Web` ensamblado. Otra diferencia es que puede crear varias instancias de la <xref:System.Runtime.Caching.MemoryCache> clase para su uso en la misma aplicación y en la misma <xref:System.AppDomain> instancia.  
  
 El <xref:System.Runtime.Caching.MemoryCache> no se admite la clase `null` como un valor en la memoria caché. Cualquier intento de agregar o cambiar una entrada de caché con un valor de `null` se producirá un error.  
  
 El <xref:System.Runtime.Caching.MemoryCache> tipo no implementa *regiones de memoria caché*. Por lo tanto, cuando se llama a <xref:System.Runtime.Caching.MemoryCache> métodos que implementan los métodos bases que contienen un parámetro para regiones, no pase un valor para el parámetro. Los métodos que usan el parámetro región todas suministrar un valor predeterminado `null` valor. Por ejemplo, el <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> sobrecarga del método tiene un `regionName` parámetro cuyo valor predeterminado es `null`.  
  
   
  
## Examples  
 El ejemplo siguiente declara una referencia a la instancia predeterminada de la memoria caché de memoria. La entrada de caché usa un <xref:System.Runtime.Caching.CacheItemPolicy> objeto para proporcionar detalles de expulsión y expiración para la entrada de caché. También usa un <xref:System.Runtime.Caching.ChangeMonitor> objetos para supervisar el estado del origen de datos (que es un archivo) en el sistema de archivos.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="http://msdn.microsoft.com/library/942236f6-0138-4aaf-af71-a5ea451a1e23">Tutorial: Almacenar en caché datos de la aplicación en ASP.NET</related>
    <related type="Article" href="http://msdn.microsoft.com/library/c4b47ee0-4b82-4124-9bce-818088385e34">Almacenamiento en caché en aplicaciones .NET Framework</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = null)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Nombre que se va a usar para buscar información de configuración.  
  
 <c>Nota</c> No es necesario que exista información de configuración para cada nombre.  
  
Si hay una entrada de configuración coincidente, se usa la información de configuración para configurar la instancia de <see cref="T:System.Runtime.Caching.MemoryCache" />. Si no hay ninguna entrada de configuración coincidente, se puede tener acceso al nombre a través de la propiedad <see cref="P:System.Runtime.Caching.MemoryCache.Name" />, porque el nombre especificado está asociado a la instancia de <see cref="T:System.Runtime.Caching.MemoryCache" />. Para obtener información sobre la configuración de la memoria caché, vea <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />.</param>
        <param name="config">Colección de pares nombre-valor de información de configuración que se usará para configurar la memoria caché.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la clase, comprueba si hay entradas de configuración que es posible que se han reemplazado por mediante el parámetro opcional `config` parámetro del constructor. Puede pasar los parámetros siguientes en el `config` parámetro. Todos los valores se pueden pasar como enteros.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Cuando se invoca este constructor, opciones de configuración se recuperan en primer lugar de los archivos de configuración de aplicación. Si no hay entradas de configuración existen en el archivo de configuración, solo la configuración proporcionada en `config` se aplican. Si las entradas de configuración de la aplicación existen y si la información también se pasa en `config`, la información de la `config` invalida la información que se lee desde el archivo de configuración.  
  
 El valor de nombre que se asigna a una instancia de la memoria caché se utiliza de dos maneras:  
  
-   Para ayudarle a realizar un seguimiento de varias instancias de caché cuando existe más de una instancia.  
  
-   Para hacer referencia a la configuración en la configuración del archivo cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la instancia.  
  
    > [!NOTE]
    >  No hay ningún mecanismo para aplicar nombres únicos para las instancias de la memoria caché. Por lo tanto, es posible tener varias instancias de caché con el mismo nombre.  
  
    > [!CAUTION]
    >  No cree <xref:System.Runtime.Caching.MemoryCache> instancias a menos que sea necesario. Si crea instancias de caché en aplicaciones cliente y Web, el <xref:System.Runtime.Caching.MemoryCache> instancias deben crearse al principio en el ciclo de vida de la aplicación. Debe crear solo el número de instancias de caché que se usará en la aplicación y almacenar referencias a las instancias de caché en variables que se pueden acceder de forma global. Por ejemplo, en aplicaciones ASP.NET, puede almacenar las referencias de estado de la aplicación. Si crea una instancia de la memoria caché única en la aplicación, use la memoria caché predeterminada y obtener una referencia a él desde el <xref:System.Runtime.Caching.MemoryCache.Default%2A> propiedad cuando necesite tener acceso a la memoria caché.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un nombre o valor del parámetro <paramref name="config" /> no se pudo analizar.</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Un valor en la colección <paramref name="config" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre que se va a usar para buscar información de configuración.</param>
        <param name="config">Colección de pares nombre-valor de información de configuración que se usará para configurar la memoria caché.</param>
        <param name="ignoreConfigSection">Indica si se debe omitir la sección de configuración.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a agregar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Inserta una entrada de caché en la memoria caché como una instancia <see cref="T:System.Runtime.Caching.CacheItem" /> y agrega los detalles sobre cómo se debe expulsar la entrada.</summary>
        <returns>Es true si la inserción se realiza correctamente; es falso si ya hay una entrada en la memoria caché que tiene la misma clave que el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Las sobrecargas del método <xref:System.Runtime.Caching.ObjectCache.Add%2A> y <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> no admiten la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Por consiguiente, para establecer la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para una entrada de la memoria caché, use las sobrecargas del método <xref:System.Runtime.Caching.MemoryCache.Set%2A> en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserta una entrada en la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> sobrecargas del método se utilizan para insertar una entrada de caché en la memoria caché. Si no existe una entrada de caché con una clave coincidente, estos métodos insertan una nueva entrada. Si ya existe una entrada de caché con una clave coincidente, devuelven la entrada existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a agregar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Agrega una entrada de caché en la memoria caché utilizando la instancia especificada de <see cref="T:System.Runtime.Caching.CacheItem" /> y los detalles sobre cómo expulsar la entrada.</summary>
        <returns>Si existe una entrada de caché con la misma clave, se devuelve la entrada de caché existente; en caso contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `item` parámetro proporciona la clave y el valor que se usa el método. Si la memoria caché tiene una entrada de caché con la misma clave como la clave de la `item` parámetro, el método devuelve la entrada existente como un <xref:System.Runtime.Caching.CacheItem> instancia. Si no hay ninguna entrada de caché existente, el método crea una nueva mediante el uso de la clave y el valor proporcionado por el `item` parámetro y con los detalles de expulsión especificados `policy`.  
  
> [!WARNING]
>  Las sobrecargas del método <xref:System.Runtime.Caching.ObjectCache.Add%2A> y <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> no admiten la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Por consiguiente, para establecer la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para una entrada de la memoria caché, use las sobrecargas del método <xref:System.Runtime.Caching.MemoryCache.Set%2A> en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.Runtime.Caching.CacheItem.Value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de los campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no puede establecer una directiva de caducidad basada en una combinación de una fecha de expiración absoluta y una fecha de expiración variable. Se puede establecer solo uno valor de expiración explícitamente al usar la instancia <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor de expiración debe estar establecido en el campo <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o el campo <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a agregar.</param>
        <param name="value">Datos de la entrada de caché.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Agrega una entrada de caché en la memoria caché utilizando la clave especificada y un valor, y un valor de expiración absoluta.</summary>
        <returns>Si existe una entrada de caché con la misma clave, se devuelve la entrada de caché existente; en caso contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la memoria caché no tiene una entrada de caché cuyas claves coincidencias el `key` parámetro, se crea una nueva entrada de caché y el <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> sobrecarga del método devuelve `null`. Si existe una entrada de caché coincidente, se devuelve la entrada existente.  
  
> [!WARNING]
>  Las sobrecargas del método <xref:System.Runtime.Caching.ObjectCache.Add%2A> y <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> no admiten la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Por consiguiente, para establecer la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para una entrada de la memoria caché, use las sobrecargas del método <xref:System.Runtime.Caching.MemoryCache.Set%2A> en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de los campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no puede establecer una directiva de caducidad basada en una combinación de una fecha de expiración absoluta y una fecha de expiración variable. Se puede establecer solo uno valor de expiración explícitamente al usar la instancia <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor de expiración se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a agregar u obtener.</param>
        <param name="value">Datos de la entrada de caché.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" />, porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Inserta una entrada en la memoria caché utilizando la clave especificada y un valor, así como los detalles especificados sobre cómo debe expulsarse la entrada.</summary>
        <returns>Si ya existe una entrada de caché coincidente, se devuelve la entrada de caché; en caso contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Las sobrecargas del método <xref:System.Runtime.Caching.ObjectCache.Add%2A> y <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> no admiten la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Por consiguiente, para establecer la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para una entrada de la memoria caché, use las sobrecargas del método <xref:System.Runtime.Caching.MemoryCache.Set%2A> en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no puede establecer una directiva de caducidad basada en una combinación de una fecha de expiración absoluta y una fecha de expiración variable. Se puede establecer sólo uno valor de expiración explícitamente al usar la clase <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
O bien 
Se han especificado la devolución de llamada de la eliminación y la devolución de llamada de la actualización para el objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. <see cref="T:System.Runtime.Caching.MemoryCache" /> sólo permite usar un tipo de devolución de llamada por entrada de la memoria caché.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se ha establecido en un valor superior a un año.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad de memoria del equipo, en bytes, que la memoria caché puede utilizar.</summary>
        <value>Cantidad de memoria en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la instancia actual de la memoria caché supera el límite de memoria establecida por el <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propiedad, la implementación de la memoria caché quita las entradas de caché. Cada instancia de caché en la aplicación puede usar la cantidad de memoria especificada por el <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propiedad.  
  
 La configuración de la <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propiedad puede especificarse en el archivo de configuración de la aplicación. Como alternativa, puede pasarse en el constructor cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la clase. Para obtener más información sobre cómo configurar esta propiedad, vea [ &lt;namedCaches&gt; elemento (configuración de caché)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obtener más información sobre cómo establecer este valor cuando la <xref:System.Runtime.Caching.MemoryCache> se está inicializando la clase, vea el <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> método.  
  
 <xref:System.Runtime.Caching.MemoryCache> no se aplica al instante <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> cada vez que se agrega un nuevo elemento a un <xref:System.Runtime.Caching.MemoryCache> instancia. La heurística interna que extrae elementos adicionales desde el <xref:System.Runtime.Caching.MemoryCache> lo hace gradualmente y toma en cuenta la información del recolector de elementos no utilizados (consulte [recolección](~/docs/standard/garbage-collection/index.md)) y otros factores como el tamaño de caché actual y presión de memoria total del sistema. Por lo tanto, aunque el <xref:System.Runtime.Caching.MemoryCache> intenta mantener el tamaño de caché configurado <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> es posible superar temporalmente el límite mediante la adición de elementos de la caché en una frecuencia muy alta.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; elemento (configuración de caché)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a buscar.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Determina si una entrada existe en la memoria caché.</summary>
        <returns>
          <see langword="true" /> si la memoria caché contiene una entrada de caché cuya clave coincide con <paramref name="key" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Enumeración de claves de entrada de caché únicas para el objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Crea un objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> que puede activar eventos en respuesta a los cambios realizados en las entradas especificadas de la memoria caché.</summary>
        <returns>Supervisor de cambios que supervisa las entradas de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> método crea un <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instancia. Este monitor de cambios especializado que se usa para supervisar las entradas de caché que se especifican en el `keys` colección y para desencadenar eventos cuando cambian las entradas.  
  
 Una entrada supervisada se considera que han cambiado para cualquiera de los siguientes motivos:  
  
-   La clave no existe en el momento de la llamada a la <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> método. En ese caso, el resultado <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instancia inmediatamente se establece en un cambio de estado. Esto significa que, cuando el código enlaza posteriormente una devolución de llamada de notificación de cambios, la devolución de llamada se activará inmediatamente.  
  
-   La entrada de caché asociada se quitó de la memoria caché. Esto puede ocurrir si se quita la entrada explícitamente, si expira o si se expulsa para recuperar la memoria  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un elemento de la colección <paramref name="keys" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia a la instancia predeterminada de <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <value>Instancia predeterminada de la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad siempre devuelve una referencia a la instancia de caché predeterminada. Para escenarios de aplicación típicos, solo una instancia de <xref:System.Runtime.Caching.MemoryCache> es necesario.  
  
 Dado que la instancia de caché predeterminada no se crea mediante el constructor, debe usar la configuración para establecer explícitamente la memoria y los valores de sondeo para la instancia de caché predeterminada. Para obtener más información, consulte [ &lt;memoryCache&gt; elemento (configuración de caché)](~/docs/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/182a622f-f7cf-472d-9d0b-451d2fd94525">&lt;memoryCache&gt; elemento (configuración de caché)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una descripción de las características proporcionadas por la memoria caché.</summary>
        <value>Combinación bit a bit de las marcas que indican las características predeterminadas de la implementación de caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las capacidades de una implementación de caché son una combinación de los siguientes valores:  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por la instancia actual de la clase <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.Runtime.Caching.MemoryCache> instancia se enlaza a la <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> eventos. Sin embargo, durante el cierre del dominio de aplicación, si una caché basada en memoria no se ha desechado explícitamente, la instancia de caché llamará automáticamente a la <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> método.  
  
 La instancia de caché eliminado se cierra mediante los siguientes pasos:  
  
1.  El estado de la memoria caché se establece para indicar que la memoria caché se elimina. Cualquier intento de llamar a pública almacenamiento en caché de los métodos que cambian el estado de la memoria caché, como los métodos que agregar, quitar o recuperar las entradas de caché, podría provocar un comportamiento inesperado. Por ejemplo, si se llama a la <xref:System.Runtime.Caching.MemoryCache.Set%2A> método después de desecha la memoria caché, se produce un error de una operación inefectiva. Si se intenta recuperar los elementos de la memoria caché, el <xref:System.Runtime.Caching.MemoryCache.Get%2A> método siempre devolverá `null`.  
  
2.  Ya no se genera información del contador de rendimiento de la instancia actual de la memoria caché.  
  
3.  Se liberan todas las referencias a objetos almacenados en caché mantenidos por la instancia actual de la memoria caché.  
  
4.  Cualquier <xref:System.Runtime.Caching.CacheEntryChangeMonitor> se notifica a las instancias que actualmente se están supervisando las entradas en la memoria caché.  
  
5.  Se denominan objetos de devolución de llamada que proporcionan notificaciones de cambios de dichos monitores.  
  
6.  Cualquier <xref:System.Web.Caching.CacheItemRemovedCallback> se denominan instancias registradas con entradas en la memoria caché. El motivo de eliminación que se pasa a las devoluciones de llamada es <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a obtener.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Devuelve una entrada de la memoria caché.</summary>
        <returns>Referencia a la entrada de caché que se identifica mediante <paramref name="key" />, si la entrada existe; en caso contrario, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a obtener.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Devuelve la entrada especificada de la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Referencia a la entrada de caché identificada por <paramref name="key" />, si la entrada existe; de lo contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la entrada de caché especificada por `key` existe en la memoria caché, el <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> método lo devuelve como un <xref:System.Runtime.Caching.CacheItem> instancia. El <xref:System.Runtime.Caching.CacheItem.Key%2A> y <xref:System.Runtime.Caching.CacheItem.Value%2A> propiedades de la <xref:System.Runtime.Caching.CacheItem> se establecerá la instancia. Sin embargo, el <xref:System.Runtime.Caching.CacheItem.RegionName%2A> propiedad será `null`, ya que no se implementan regiones en el <xref:System.Runtime.Caching.MemoryCache> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Devuelve el número total de entradas de caché en la memoria caché.</summary>
        <returns>Número de entradas de la memoria caché.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un enumerador que se puede usar para iterar en una colección de entradas de la memoria caché.</summary>
        <returns>Objeto de enumerador que proporciona acceso a los elementos de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El enumerador devuelto por la <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> método puede utilizarse para recorrer en iteración las entradas de la memoria caché.  
  
> [!IMPORTANT]
>  Recuperar un enumerador para un <xref:System.Runtime.Caching.MemoryCache> instancia es una operación que consume muchos recursos y el bloqueo. Por lo tanto, el enumerador no debe usarse en aplicaciones de producción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">El nombre de la región.</param>
        <summary>Obtiene el tamaño de la región con nombre.</summary>
        <returns>El tamaño de la región con nombre.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Conjunto de identificadores únicos correspondientes a las entradas de caché que se van a devolver.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Devuelve un conjunto de entradas de caché que se corresponden con las claves especificadas.</summary>
        <returns>Conjunto de entradas de la memoria caché que corresponden a las claves especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una entrada de caché que se representa mediante el `keys` no existe, el valor correspondiente para el objeto devuelto en el diccionario está establecido en `null`. Por lo tanto, el diccionario devuelto siempre tiene el mismo número de elementos que el número de elementos de `keys`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Una clave individual en la colección es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único del valor de caché que se va a obtener o establecer.</param>
        <summary>Obtiene o establece un valor en la memoria caché con la propiedad de indizador predeterminada para una instancia de la clase <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <value>Valor de la instancia de caché correspondiente a la clave especificada, si la entrada existe; en caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad, el valor se inserta en la memoria caché. La directiva de expiración para la entrada de caché se establece en <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>. Si ya existe una entrada de caché con una clave coincidente, se actualiza su valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.  
  
O bien 
El valor insertado es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de la memoria caché.</summary>
        <value>Nombre de la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.Name%2A> propiedad devuelve el nombre de la instancia actual de la <xref:System.Runtime.Caching.MemoryCache> clase. En una aplicación que usa varias instancias de caché, puede usar el <xref:System.Runtime.Caching.MemoryCache.Name%2A> propiedad para ayudar a distinguir las instancias. Para obtener más información, vea el método <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType>. La memoria caché en memoria predeterminada devuelve el nombre predeterminado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el porcentaje de memoria física que la memoria caché puede utilizar.</summary>
        <value>Porcentaje de memoria física que la memoria caché puede utilizar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> propiedad devuelve el porcentaje de memoria física total del equipo que se puede usar una sola instancia de la <xref:System.Runtime.Caching.MemoryCache> clase. Si la instancia de caché supera el límite especificado, se quitan las entradas de caché.  
  
 La configuración de la <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> propiedad puede especificarse en el archivo de configuración de la aplicación. Como alternativa, puede pasarse por un autor de llamada cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la clase. Para obtener más información sobre cómo configurar esta propiedad, vea [ &lt;namedCaches&gt; elemento (configuración de caché)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obtener más información sobre cómo configurar la propiedad cuando la <xref:System.Runtime.Caching.MemoryCache> se está inicializando la clase, vea el <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; elemento (configuración de caché)</related>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tiempo máximo después del cual la memoria caché actualiza sus estadísticas de memoria.</summary>
        <value>Tiempo máximo que puede transcurrir antes de que se actualicen las estadísticas de memoria.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La configuración de la <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> propiedad puede especificarse en el archivo de configuración de la aplicación. También se puede pasar cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la clase. Para obtener más información sobre cómo configurar esta propiedad, vea [ &lt;namedCaches&gt; elemento (configuración de caché)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obtener más información sobre cómo configurar la propiedad cuando la <xref:System.Runtime.Caching.MemoryCache> se está inicializando la clase, vea el <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;namedCaches&gt; elemento (configuración de caché)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita el elemento especificado de la memoria caché.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a quitar.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Quita una entrada de la memoria caché.</summary>
        <returns>Si se encuentra la entrada en la memoria caché, se devuelve la entrada que se ha quitado; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la entrada especificada por `key` existe en la memoria caché, quitar los desencadenadores de elemento de los monitores de cambio asociada. Si se ha asociado el elemento quitado un <xref:System.Web.Caching.CacheItemUpdateCallback> objeto o un <xref:System.Web.Caching.CacheItemRemovedCallback> objeto, el motivo que se pasa a la devolución de llamada es <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a quitar.</param>
        <param name="reason">El motivo por el que se ha quitado el elemento.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Quita una entrada de caché de la memoria caché con el motivo.</summary>
        <returns>Si se encuentra la entrada en la memoria caché, se devuelve la entrada que se ha quitado; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserta una entrada en la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la entrada especificada no existe, se crea. Si la entrada especificada no existe, se actualiza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que representa una entrada de caché que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Inserta una entrada en la memoria caché utilizando una instancia de <see cref="T:System.Runtime.Caching.CacheItem" /> para proporcionar la clave y el valor de la entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al igual que otros <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas del método, el <xref:System.Runtime.Caching.MemoryCache.Set%2A> método coloca siempre un valor de la memoria caché en la memoria caché, independientemente de si una entrada ya existe con la misma clave. Si la entrada especificada no existe en la memoria caché, se inserta una nueva entrada de caché. Si la entrada especificada ya existe, se actualiza su valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="item" /> es <see langword="null" />.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItem.Key" /> es <see langword="null" />.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItem.Value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Se pasó una combinación no válida de argumentos para la entrada de la memoria caché. Esto se produce si los detalles de expiración siguientes se establecen en el objeto de directiva para la entrada de la memoria caché: 
-   Si ambos los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de los campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no puede establecer una directiva de caducidad basada en una combinación de una fecha de expiración absoluta y una fecha de expiración variable. Se puede establecer sólo uno valor de expiración explícitamente al usar la clase <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o en la propiedad <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Si se especifican la devolución de llamada de eliminación y la devolución de llamada de actualización para el objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> sólo permite usar un tipo de devolución de llamada por entrada de la memoria caché.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  
  
O bien 
<see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a insertar.</param>
        <param name="value">Datos de la entrada de caché.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Inserta una entrada en la memoria caché utilizando una clave, un valor y los detalles especificados sobre la expiración basada en el tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al igual que otros <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas del método, el <xref:System.Runtime.Caching.MemoryCache.Set%2A> método siempre coloca un valor de caché en la memoria caché, independientemente de si ya existe una entrada con la misma clave. Si la entrada especificada no existe, se inserta una nueva entrada de caché. Si la entrada especificada no existe, se actualiza.  
  
 El `absoluteExpiration` parámetro indica cuándo debe quitarse la entrada de la memoria caché.  
  
 Eliminación de una entrada desencadena los monitores de cambio asociada. Si se ha asociado el elemento quitado un <xref:System.Web.Caching.CacheItemUpdateCallback> objeto o <xref:System.Web.Caching.CacheItemRemovedCallback> objeto, el motivo de eliminación que se pasa a las devoluciones de llamada se encuentra en la <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="Value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">- Se pasó una combinación no válida de argumentos para la entrada de la memoria caché. Esto se produce si los detalles de expiración siguientes se establecen en el objeto de directiva para la entrada de la memoria caché: 
-   Si ambos los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Esto se produce porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no permite entradas de expiración basadas tanto en la fecha de expiración absoluta como en la variable. Se puede establecer sólo uno valor de expiración explícitamente al usar la clase <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Si la devolución de llamada de eliminación y la devolución de llamada de actualización se especifican en el objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> sólo permite usar un tipo de devolución de llamada por entrada de la memoria caché.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  
  
O bien 
-   La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a insertar.</param>
        <param name="value">Datos de la entrada de caché.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Inserta una entrada en la memoria caché utilizando una clave, un valor y los detalles referentes a la expulsión.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al igual que otros <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas del método, el <xref:System.Runtime.Caching.MemoryCache.Set%2A> método coloca siempre un valor de la memoria caché en la memoria caché, independientemente de si una entrada coincidente ya existe. Si la entrada especificada no existe en la memoria caché, se inserta una nueva entrada de caché. Si la entrada especificada no existe, se actualiza.  
  
 Eliminación de una entrada desencadena los monitores de cambio asociada. Si se ha asociado el elemento quitado un <xref:System.Web.Caching.CacheItemUpdateCallback> objeto o <xref:System.Web.Caching.CacheItemRemovedCallback> objeto, el motivo de eliminación que se pasa a las devoluciones de llamada se encuentra en la <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.  
  
O bien 
 <paramref name="value" /> es <see langword="null" />  
  
O bien 
La referencia de devolución de llamada que se pasó al método del asistente en la propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">- Ya existe una combinación no válida de argumentos para la entrada de la memoria caché. Esto se produce si los detalles de expiración siguientes se establecen en el objeto de directiva para la entrada de la memoria caché: 
-   Si ambos los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Esto es porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no permite entradas de expiración basadas tanto en la fecha de expiración absoluta como en la variable. Se puede establecer sólo uno valor de expiración explícitamente al usar la clase <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  
  
- Si la devolución de llamada de eliminación y la devolución de llamada de actualización se especifican en la clase <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> sólo permite usar un tipo de devolución de llamada por entrada de la memoria caché.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  
  
O bien 
La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona compatibilidad para la iteración en una colección genérica.</summary>
        <returns>Objeto de enumerador que proporciona acceso a las entradas de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Puede usarse solo cuando un <xref:System.Runtime.Caching.MemoryCache> instancia se convierte en un <xref:System.Collections.IEnumerable> interfaz.  
  
 Puede usar este método para recorrer en iteración una colección genérica de entradas de caché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">Porcentaje de entradas que se va a quitar de la memoria caché.</param>
        <summary>Quita el porcentaje especificado de entradas de caché del objeto de caché.</summary>
        <returns>Número de entradas que se han quitado de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.Trim%2A> propiedad primero quita las entradas que han superado absoluta o expiración variable. Las devoluciones de llamada que se registran para los elementos que se quitan pasarán un motivo de eliminación de <xref:System.Web.Caching.CacheItemRemovedReason.Expired>.  
  
 Si no es suficiente para alcanzar el porcentaje de recorte especificado quitando las entradas caducadas, entradas adicionales se quitará de la memoria caché según un algoritmo usado menos recientemente de (LRU) hasta que se alcance el porcentaje de recorte solicitado. Las devoluciones de llamada que se registran para los elementos que quitan de esta manera se pasará un motivo de eliminación <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>