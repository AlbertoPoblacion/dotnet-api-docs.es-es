<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1a266fcaeb9b98aa0328ce1a44d175eb4719be74" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452338" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa el tipo que implementa una caché en memoria.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.Runtime.Caching.MemoryCache> es una implementación concreta de la clase abstracta <xref:System.Runtime.Caching.ObjectCache> .  
  
> [!NOTE]
>  El <xref:System.Runtime.Caching.MemoryCache> clase es similar a ASP.NET <xref:System.Web.Caching.Cache> clase. El <xref:System.Runtime.Caching.MemoryCache> clase tiene muchas propiedades y métodos para tener acceso a la memoria caché que resultarle familiar si ha usado ASP.NET <xref:System.Web.Caching.Cache> clase. Las principales diferencias entre el <xref:System.Web.Caching.Cache> y <xref:System.Runtime.Caching.MemoryCache> las clases que son la <xref:System.Runtime.Caching.MemoryCache> clase ha cambiado para que pueda usarse por [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] las aplicaciones que no son aplicaciones de ASP.NET. Por ejemplo, el <xref:System.Runtime.Caching.MemoryCache> clase no tiene ninguna dependencia el `System.Web` ensamblado. Otra diferencia es que puede crear varias instancias de la <xref:System.Runtime.Caching.MemoryCache> clase para su uso en la misma aplicación y en la misma <xref:System.AppDomain> instancia.  
  
 El <xref:System.Runtime.Caching.MemoryCache> no permite que la clase `null` como un valor en la memoria caché. Cualquier intento de agregar o cambiar una entrada de caché con un valor de `null` se producirá un error.  
  
 El <xref:System.Runtime.Caching.MemoryCache> tipo no implementa *regiones de memoria caché*. Por lo tanto, cuando se llama a <xref:System.Runtime.Caching.MemoryCache> métodos que implementan los métodos base que contienen un parámetro para regiones, no pase un valor para el parámetro. Los métodos que usan el parámetro de región todos proporcionan un valor predeterminado `null` valor. Por ejemplo, el <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> sobrecarga del método tiene un `regionName` parámetro cuyo valor predeterminado es `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se declara una referencia a la instancia predeterminada de la memoria caché de memoria. La entrada de caché usa un <xref:System.Runtime.Caching.CacheItemPolicy> objeto para proporcionar detalles de expulsión y expiración para la entrada de caché. También usa un <xref:System.Runtime.Caching.ChangeMonitor> objeto para supervisar el estado de los datos de origen (que es un archivo) del sistema de archivos.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = null)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Nombre que se va a usar para buscar información de configuración.  
  
 <c>Nota</c> No es necesario que exista información de configuración para cada nombre.  Si hay una entrada de configuración coincidente, se usa la información de configuración para configurar la instancia de <see cref="T:System.Runtime.Caching.MemoryCache" />. Si no hay ninguna entrada de configuración coincidente, se puede tener acceso al nombre a través de la propiedad <see cref="P:System.Runtime.Caching.MemoryCache.Name" />, porque el nombre especificado está asociado a la instancia de <see cref="T:System.Runtime.Caching.MemoryCache" />. Para obtener información sobre la configuración de la memoria caché, vea <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />.</param>
        <param name="config">Colección de pares nombre-valor de información de configuración que se usará para configurar la memoria caché.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la clase, busca las entradas de configuración que podrían haber invalidado mediante el uso opcional `config` parámetro en el constructor. Puede pasar los siguientes parámetros en el `config` parámetro. Todos los valores se pueden pasar como enteros.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Cuando se invoca este constructor, valores de configuración primero se recuperan de los archivos de configuración de aplicación. Si ninguna entrada de configuración existe en el archivo de configuración de aplicación, solo la configuración proporcionada en `config` se aplican. Si las entradas de configuración de la configuración de la aplicación existen y si la información también se pasa en `config`, la información de la `config` invalida la información que se lee desde el archivo de configuración.  
  
 El valor de nombre que se asigna a una instancia de la memoria caché se utiliza de dos maneras:  
  
-   Para ayudarle a realizar un seguimiento de varias instancias de caché cuando existe más de una instancia.  
  
-   Para hacer referencia en la configuración del archivo de configuración cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la instancia.  
  
    > [!NOTE]
    >  No hay ningún mecanismo para exigir nombres únicos para las instancias de la memoria caché. Por lo tanto, es posible tener varias instancias de caché con el mismo nombre.  
  
    > [!CAUTION]
    >  No cree <xref:System.Runtime.Caching.MemoryCache> instancias a menos que sea necesario. Si crea instancias de caché en aplicaciones cliente y Web, la <xref:System.Runtime.Caching.MemoryCache> instancias deben crearse al principio en el ciclo de vida de la aplicación. Debe crear solo el número de instancias de caché que se usará en la aplicación y almacenan las referencias a las instancias de caché en las variables que pueden tener acceso a todo el mundo. Por ejemplo, en aplicaciones de ASP.NET, puede almacenar las referencias de estado de la aplicación. Si crea una instancia de la memoria caché única en la aplicación, use la memoria caché predeterminada y obtenga una referencia a él desde el <xref:System.Runtime.Caching.MemoryCache.Default%2A> propiedad cuando necesite obtener acceso a la memoria caché.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un nombre o valor del parámetro <paramref name="config" /> no se pudo analizar.</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Un valor en la colección <paramref name="config" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre que se va a usar para buscar información de configuración.</param>
        <param name="config">Colección de pares nombre-valor de información de configuración que se usará para configurar la memoria caché.</param>
        <param name="ignoreConfigSection">Indica si se debe omitir la sección de configuración.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a agregar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Inserta una entrada de caché en la memoria caché como una instancia <see cref="T:System.Runtime.Caching.CacheItem" /> y agrega los detalles sobre cómo se debe expulsar la entrada.</summary>
        <returns>Es true si la inserción se realiza correctamente; es falso si ya hay una entrada en la memoria caché que tiene la misma clave que el elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Las sobrecargas del método <xref:System.Runtime.Caching.ObjectCache.Add%2A> y <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> no admiten la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Por consiguiente, para establecer la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para una entrada de la memoria caché, use las sobrecargas del método <xref:System.Runtime.Caching.MemoryCache.Set%2A> en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserta una entrada en la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> sobrecargas de método se utilizan para insertar una entrada de caché en la memoria caché. Si no existe una entrada de caché con una clave coincidente, estos métodos insertan una nueva entrada. Si ya existe una entrada de caché con una clave coincidente, devuelven la entrada existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a agregar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Agrega una entrada de caché en la memoria caché utilizando la instancia especificada de <see cref="T:System.Runtime.Caching.CacheItem" /> y los detalles sobre cómo expulsar la entrada.</summary>
        <returns>Si existe una entrada de caché con la misma clave, se devuelve la entrada de caché existente; en caso contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `item` parámetro proporciona la clave y el valor que se utiliza el método. Si la memoria caché tiene una entrada de caché con la misma clave como la clave de la `item` parámetro, el método devuelve la entrada existente como un <xref:System.Runtime.Caching.CacheItem> instancia. Si no hay ninguna entrada de caché existente, el método crea una nueva mediante el uso de la clave y el valor proporcionado por el `item` parámetro y con los detalles de expulsión especificados por `policy`.  
  
> [!WARNING]
>  Las sobrecargas del método <xref:System.Runtime.Caching.ObjectCache.Add%2A> y <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> no admiten la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Por consiguiente, para establecer la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para una entrada de la memoria caché, use las sobrecargas del método <xref:System.Runtime.Caching.MemoryCache.Set%2A> en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La propiedad <see cref="P:System.Runtime.Caching.CacheItem.Value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de los campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no puede establecer una directiva de caducidad basada en una combinación de una fecha de expiración absoluta y una fecha de expiración variable. Se puede establecer solo uno valor de expiración explícitamente al usar la instancia <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor de expiración debe estar establecido en el campo <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o el campo <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a agregar.</param>
        <param name="value">Datos de la entrada de caché.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Agrega una entrada de caché en la memoria caché utilizando la clave especificada y un valor, y un valor de expiración absoluta.</summary>
        <returns>Si existe una entrada de caché con la misma clave, se devuelve la entrada de caché existente; en caso contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la memoria caché no tiene una entrada de caché cuyas claves coincidencias el `key` parámetro, se crea una nueva entrada de caché y la <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> sobrecarga del método devuelve `null`. Si existe una entrada de caché coincidente, se devuelve la entrada existente.  
  
> [!WARNING]
>  Las sobrecargas del método <xref:System.Runtime.Caching.ObjectCache.Add%2A> y <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> no admiten la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Por consiguiente, para establecer la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para una entrada de la memoria caché, use las sobrecargas del método <xref:System.Runtime.Caching.MemoryCache.Set%2A> en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de los campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no puede establecer una directiva de caducidad basada en una combinación de una fecha de expiración absoluta y una fecha de expiración variable. Se puede establecer solo uno valor de expiración explícitamente al usar la instancia <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor de expiración se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a agregar u obtener.</param>
        <param name="value">Datos de la entrada de caché.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" />, porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Inserta una entrada en la memoria caché utilizando la clave especificada y un valor, así como los detalles especificados sobre cómo debe expulsarse la entrada.</summary>
        <returns>Si ya existe una entrada de caché coincidente, se devuelve la entrada de caché; en caso contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Las sobrecargas del método <xref:System.Runtime.Caching.ObjectCache.Add%2A> y <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> no admiten la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>. Por consiguiente, para establecer la propiedad <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A> para una entrada de la memoria caché, use las sobrecargas del método <xref:System.Runtime.Caching.MemoryCache.Set%2A> en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no puede establecer una directiva de caducidad basada en una combinación de una fecha de expiración absoluta y una fecha de expiración variable. Se puede establecer sólo uno valor de expiración explícitamente al usar la clase <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  -o bien- Se han especificado la devolución de llamada de eliminación y la devolución de llamada de actualización para <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. <see cref="T:System.Runtime.Caching.MemoryCache" /> sólo permite usar un tipo de devolución de llamada por entrada de la memoria caché.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  -o bien- <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se ha establecido en un valor superior a un año.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad de memoria del equipo, en bytes, que la memoria caché puede utilizar.</summary>
        <value>Cantidad de memoria en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la instancia actual de la memoria caché supera el límite de memoria establecida por el <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propiedad, la implementación de la memoria caché quita las entradas de caché. Cada instancia de caché en la aplicación puede utilizar la cantidad de memoria que se especifica mediante el <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propiedad.  
  
 La configuración de la <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> propiedad puede especificarse en el archivo de configuración de aplicación. Como alternativa, se puede pasar en el constructor cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la clase. Para obtener más información sobre cómo configurar esta propiedad, vea [ &lt;namedCaches&gt; Element (Cache Settings)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obtener más información sobre cómo establecer este valor cuando la <xref:System.Runtime.Caching.MemoryCache> se está inicializando la clase, consulte el <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> método.  
  
 <xref:System.Runtime.Caching.MemoryCache> no se aplica al instante <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> cada vez que se agrega un nuevo elemento a una <xref:System.Runtime.Caching.MemoryCache> instancia. La heurística interna que extrae elementos adicionales desde la <xref:System.Runtime.Caching.MemoryCache> lo gradualmente y tiene en cuenta la información del recolector de elementos no utilizados (vea [recolección](~/docs/standard/garbage-collection/index.md)) y otros factores como el tamaño de caché actual y presión de memoria de sistema general. Por lo tanto, aunque la <xref:System.Runtime.Caching.MemoryCache> intenta mantener el tamaño de caché en el <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> es posible temporalmente supere el límite mediante la adición de elementos de la caché con una tasa muy alta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a buscar.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Determina si una entrada existe en la memoria caché.</summary>
        <returns>
          <see langword="true" /> si la memoria caché contiene una entrada de caché cuya clave coincide con <paramref name="key" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Enumeración de claves de entrada de caché únicas para el objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Crea un objeto <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" /> que puede activar eventos en respuesta a los cambios realizados en las entradas especificadas de la memoria caché.</summary>
        <returns>Supervisor de cambios que supervisa las entradas de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> método crea un <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instancia. Este monitor de cambios especializado se usa para supervisar las entradas de caché que se especifican en el `keys` colección y para desencadenar eventos cuando cambian las entradas.  
  
 Se considera que una entrada supervisada ha cambiado por cualquiera de los siguientes motivos:  
  
-   La clave no existe en el momento de la llamada a la <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> método. En ese caso, el cuadro <xref:System.Runtime.Caching.CacheEntryChangeMonitor> instancia inmediatamente se establece en un estado modificado. Esto significa que, cuando el código enlaza posteriormente una devolución de llamada de notificación de cambios, la devolución de llamada se activará inmediatamente.  
  
-   La entrada de caché asociada se quitó de la memoria caché. Esto puede ocurrir si se quita la entrada explícitamente, si expira o si se expulsa para recuperar memoria  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Un elemento de la colección <paramref name="keys" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia a la instancia predeterminada de <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <value>Instancia predeterminada de la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad siempre devuelve una referencia a la instancia de caché predeterminada. Para escenarios de aplicación típicos, solo una instancia de <xref:System.Runtime.Caching.MemoryCache> es necesario.  
  
 Dado que el constructor no crea la instancia de caché predeterminada, debe usar la configuración para establecer explícitamente la memoria y los valores de sondeo para la instancia de caché predeterminada. Para obtener más información, consulte [ &lt;memoryCache&gt; Element (Cache Settings)](~/docs/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una descripción de las características proporcionadas por la memoria caché.</summary>
        <value>Combinación bit a bit de las marcas que indican las características predeterminadas de la implementación de caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las capacidades de una implementación de caché son una combinación de los siguientes valores:  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por la instancia actual de la clase <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.Runtime.Caching.MemoryCache> instancia se enlaza a la <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> eventos. Sin embargo, durante el cierre del dominio de aplicación, si no ha eliminado explícitamente una memoria caché basado en memoria, la instancia de la memoria caché llamará automáticamente a la <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> método.  
  
 La instancia de la memoria caché dispuesta se apaga siguiendo estos pasos:  
  
1.  El estado de la memoria caché se establece para indicar que la memoria caché se elimina. Cualquier intento de llamar a pública métodos que cambian el estado de la memoria caché, el almacenamiento en caché, como métodos que agregar, quitar o recuperar las entradas de caché, podría producir un comportamiento inesperado. Por ejemplo, si se llama a la <xref:System.Runtime.Caching.MemoryCache.Set%2A> método después de que se elimina la memoria caché, se produce un error de operación inefectiva. Si se intenta recuperar los elementos de la memoria caché, el <xref:System.Runtime.Caching.MemoryCache.Get%2A> método siempre devolverá `null`.  
  
2.  Ya no se genera información de contador de rendimiento de la instancia actual de la memoria caché.  
  
3.  Se liberan todas las referencias a objetos en caché mantenidos por la instancia actual de la memoria caché.  
  
4.  Cualquier <xref:System.Runtime.Caching.CacheEntryChangeMonitor> se notificación a instancias que actualmente se están supervisando las entradas en la memoria caché.  
  
5.  Se denominan objetos de devolución de llamada que proporcionan notificación de cambios para los monitores.  
  
6.  Cualquier <xref:System.Web.Caching.CacheItemRemovedCallback> se denominan instancias que se registran entradas en la memoria caché. El motivo de eliminación que se pasa a las devoluciones de llamada es <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a obtener.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Devuelve una entrada de la memoria caché.</summary>
        <returns>Referencia a la entrada de caché que se identifica mediante <paramref name="key" />, si la entrada existe; en caso contrario, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a obtener.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Devuelve la entrada especificada de la memoria caché como una instancia de <see cref="T:System.Runtime.Caching.CacheItem" />.</summary>
        <returns>Referencia a la entrada de caché identificada por <paramref name="key" />, si la entrada existe; de lo contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la entrada de caché especificado por `key` existe en la memoria caché, el <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> método devuelve como un <xref:System.Runtime.Caching.CacheItem> instancia. El <xref:System.Runtime.Caching.CacheItem.Key%2A> y <xref:System.Runtime.Caching.CacheItem.Value%2A> propiedades de la <xref:System.Runtime.Caching.CacheItem> se establecerá la instancia. Sin embargo, el <xref:System.Runtime.Caching.CacheItem.RegionName%2A> propiedad será `null`, porque las regiones no se implementan en la <xref:System.Runtime.Caching.MemoryCache> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = null) As Long" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Devuelve el número total de entradas de caché en la memoria caché.</summary>
        <returns>Número de entradas de la memoria caché.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un enumerador que se puede usar para iterar en una colección de entradas de la memoria caché.</summary>
        <returns>Objeto de enumerador que proporciona acceso a los elementos de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El enumerador devuelto por el <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> método se puede utilizar para recorrer en iteración las entradas en la memoria caché.  
  
> [!IMPORTANT]
>  Recuperar un enumerador para una <xref:System.Runtime.Caching.MemoryCache> instancia es una operación que consume muchos recursos y bloqueo. Por lo tanto, el enumerador no debe usarse en aplicaciones de producción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = null) As Long" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">El nombre de la región.</param>
        <summary>Obtiene el tamaño de la región con nombre.</summary>
        <returns>El tamaño de la región con nombre.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Conjunto de identificadores únicos correspondientes a las entradas de caché que se van a devolver.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Devuelve un conjunto de entradas de caché que se corresponden con las claves especificadas.</summary>
        <returns>Conjunto de entradas de la memoria caché que corresponden a las claves especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una entrada de caché que se representa mediante el `keys` no existe, el valor correspondiente para el objeto devuelto en el diccionario está establecido en `null`. Por lo tanto, el diccionario devuelto siempre tiene el mismo número de elementos que el número de elementos de `keys`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Una clave individual en la colección es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único del valor de caché que se va a obtener o establecer.</param>
        <summary>Obtiene o establece un valor en la memoria caché con la propiedad de indizador predeterminada para una instancia de la clase <see cref="T:System.Runtime.Caching.MemoryCache" />.</summary>
        <value>Valor de la instancia de caché correspondiente a la clave especificada, si la entrada existe; en caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se establece esta propiedad, el valor se inserta en la memoria caché. La directiva de expiración para la entrada de caché se establece en <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>. Si ya existe una entrada de caché con una clave coincidente, se actualiza su valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.  -o bien- El valor insertado es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de la memoria caché.</summary>
        <value>Nombre de la memoria caché.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.Name%2A> propiedad devuelve el nombre de la instancia actual de la <xref:System.Runtime.Caching.MemoryCache> clase. En una aplicación que usa varias instancias de caché, puede usar el <xref:System.Runtime.Caching.MemoryCache.Name%2A> propiedad para ayudar a distinguir las instancias. Para obtener más información, vea el método <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType>. La memoria caché basado en memoria de forma predeterminada, devuelve el nombre predeterminado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el porcentaje de memoria física que la memoria caché puede utilizar.</summary>
        <value>Porcentaje de memoria física que la memoria caché puede utilizar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> propiedad devuelve el porcentaje de memoria física total del equipo que se puede usar una única instancia de la <xref:System.Runtime.Caching.MemoryCache> clase. Si la instancia de caché supera el límite especificado, se quitan las entradas de caché.  
  
 La configuración de la <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> propiedad puede especificarse en el archivo de configuración de aplicación. Como alternativa, se puede pasar por un autor de llamada cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la clase. Para obtener más información sobre cómo configurar esta propiedad, vea [ &lt;namedCaches&gt; Element (Cache Settings)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obtener más información sobre cómo configurar la propiedad cuando la <xref:System.Runtime.Caching.MemoryCache> se está inicializando la clase, consulte el <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tiempo máximo después del cual la memoria caché actualiza sus estadísticas de memoria.</summary>
        <value>Tiempo máximo que puede transcurrir antes de que se actualicen las estadísticas de memoria.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La configuración de la <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> propiedad puede especificarse en el archivo de configuración de aplicación. O bien se puede pasar cuando el <xref:System.Runtime.Caching.MemoryCache> se inicializa la clase. Para obtener más información sobre cómo configurar esta propiedad, vea [ &lt;namedCaches&gt; Element (Cache Settings)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Para obtener más información sobre cómo configurar la propiedad cuando la <xref:System.Runtime.Caching.MemoryCache> se está inicializando la clase, consulte el <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita el elemento especificado de la memoria caché.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a quitar.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Quita una entrada de la memoria caché.</summary>
        <returns>Si se encuentra la entrada en la memoria caché, se devuelve la entrada que se ha quitado; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la entrada especificada por `key` existe en la memoria caché, quitar los desencadenadores de elemento de los monitores de cambio asociada. Si el elemento quitado se asoció una <xref:System.Web.Caching.CacheItemUpdateCallback> objeto o un <xref:System.Web.Caching.CacheItemRemovedCallback> de objeto, el motivo que se pasa a la devolución de llamada es <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = null) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Un identificador único para la entrada de caché que se va a quitar.</param>
        <param name="reason">El motivo por el que se ha quitado el elemento.</param>
        <param name="regionName">Una región con nombre de la memoria caché a la que se agregó una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Quita una entrada de caché de la memoria caché con el motivo.</summary>
        <returns>Si se encuentra la entrada en la memoria caché, se devuelve la entrada que se ha quitado; de lo contrario, se devuelve <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserta una entrada en la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la entrada especificada no existe, se crea. Si la entrada especificada no existe, se actualiza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que representa una entrada de caché que se va a insertar.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <summary>Inserta una entrada en la memoria caché utilizando una instancia de <see cref="T:System.Runtime.Caching.CacheItem" /> para proporcionar la clave y el valor de la entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al igual que otros <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas del método, el <xref:System.Runtime.Caching.MemoryCache.Set%2A> método coloca siempre un valor de la memoria caché en la memoria caché, sin tener en cuenta si una entrada ya existe con la misma clave. Si la entrada especificada no existe en la memoria caché, se inserta una nueva entrada de caché. Si la entrada especificada ya existe, se actualiza su valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> es <see langword="null" />.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItem.Key" /> es <see langword="null" />.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItem.Value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Se pasó una combinación no válida de argumentos para la entrada de la memoria caché. Esto se produce si los detalles de expiración siguientes se establecen en el objeto de directiva para la entrada de la memoria caché: - si los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de los campos <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no puede establecer una directiva de caducidad basada en una combinación de una fecha de expiración absoluta y una fecha de expiración variable. Se puede establecer sólo uno valor de expiración explícitamente al usar la clase <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o en la propiedad <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  - Si se especifican la devolución de llamada de eliminación y la devolución de llamada de actualización para el objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> sólo permite usar un tipo de devolución de llamada por entrada de la memoria caché.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  -o bien- <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a insertar.</param>
        <param name="value">Datos de la entrada de caché.</param>
        <param name="absoluteExpiration">Fecha y hora fijas a las que expirará la entrada de caché.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Inserta una entrada en la memoria caché utilizando una clave, un valor y los detalles especificados sobre la expiración basada en el tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al igual que otros <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas del método, el <xref:System.Runtime.Caching.MemoryCache.Set%2A> método siempre coloca un valor de caché en la memoria caché, independientemente de si ya existe una entrada con la misma clave. Si la entrada especificada no existe, se inserta una nueva entrada de caché. Si la entrada especificada no existe, se actualiza.  
  
 El `absoluteExpiration` parámetro indica cuando se debe quitar la entrada de la memoria caché.  
  
 Quitar una entrada desencadena los monitores de cambio asociada. Si el elemento quitado se asoció una <xref:System.Web.Caching.CacheItemUpdateCallback> objeto o <xref:System.Web.Caching.CacheItemRemovedCallback> de objeto, el motivo de eliminación que se pasa a las devoluciones de llamada se encuentra en la <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.  -o bien- <paramref name="Value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">- Se pasó una combinación no válida de argumentos para la entrada de la memoria caché. Esto se produce si los detalles de expiración siguientes se establecen en el objeto de directiva para la entrada de la memoria caché: - si los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Esto se produce porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no permite entradas de expiración basadas tanto en la fecha de expiración absoluta como en la variable. Se puede establecer sólo uno valor de expiración explícitamente al usar la clase <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  - Si la devolución de llamada de eliminación y la devolución de llamada de actualización se especifican en el objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> sólo permite usar un tipo de devolución de llamada por entrada de la memoria caché.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la entrada de caché que se va a insertar.</param>
        <param name="value">Datos de la entrada de caché.</param>
        <param name="policy">Objeto que contiene detalles sobre la expulsión de la entrada de caché. Este objeto proporciona más opciones de expulsión que una simple expiración absoluta.</param>
        <param name="regionName">Región con nombre de la memoria caché a la que se puede agregar una entrada de caché. No pase un valor para este parámetro. De manera predeterminada, este parámetro es <see langword="null" /> porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no implementa regiones.</param>
        <summary>Inserta una entrada en la memoria caché utilizando una clave, un valor y los detalles referentes a la expulsión.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al igual que otros <xref:System.Runtime.Caching.MemoryCache.Set%2A> sobrecargas del método, el <xref:System.Runtime.Caching.MemoryCache.Set%2A> método coloca siempre un valor de la memoria caché en la memoria caché, sin tener en cuenta si una entrada coincidente ya existe. Si la entrada especificada no existe en la memoria caché, se inserta una nueva entrada de caché. Si la entrada especificada no existe, se actualiza.  
  
 Quitar una entrada desencadena los monitores de cambio asociada. Si el elemento quitado se asoció una <xref:System.Web.Caching.CacheItemUpdateCallback> objeto o <xref:System.Web.Caching.CacheItemRemovedCallback> de objeto, el motivo de eliminación que se pasa a las devoluciones de llamada se encuentra en la <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> es <see langword="null" />.  -o bien- <paramref name="value" /> es <see langword="null" /> -o bien- La referencia de devolución de llamada que se pasó al método de aplicación auxiliar en la propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">- Ya existe una combinación no válida de argumentos para la entrada de la memoria caché. Esto se produce si los detalles de expiración siguientes se establecen en el objeto de directiva para la entrada de la memoria caché: - si los valores de expiración absolutos y variables del objeto <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> se establecen en valores distintos de los valores predeterminados de <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> y <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />. Esto es porque la clase <see cref="T:System.Runtime.Caching.MemoryCache" /> no permite entradas de expiración basadas tanto en la fecha de expiración absoluta como en la variable. Se puede establecer sólo uno valor de expiración explícitamente al usar la clase <see cref="T:System.Runtime.Caching.MemoryCache" />. El otro valor se debe establecer en <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> o <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />.  - Si la devolución de llamada de eliminación y la devolución de llamada de actualización se especifican en la clase <see cref="T:System.Runtime.Caching.CacheItemPolicy" />. La clase <see cref="T:System.Runtime.Caching.MemoryCache" /> sólo permite usar un tipo de devolución de llamada por entrada de la memoria caché.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> está establecida en un valor menor que <see cref="F:System.TimeSpan.Zero" />.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> se establece en un valor superior a un año.  -o bien- La propiedad <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> no es un valor de la enumeración <see cref="T:System.Runtime.Caching.CacheItemPriority" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="regionName" /> no es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona compatibilidad para la iteración en una colección genérica.</summary>
        <returns>Objeto de enumerador que proporciona acceso a las entradas de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Se puede utilizar solo cuando un <xref:System.Runtime.Caching.MemoryCache> instancia se convierte en un <xref:System.Collections.IEnumerable> interfaz.  
  
 Puede usar este método para recorrer en iteración una colección genérica de entradas de caché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">Porcentaje de entradas que se va a quitar de la memoria caché.</param>
        <summary>Quita el porcentaje especificado de entradas de caché del objeto de caché.</summary>
        <returns>Número de entradas que se han quitado de la memoria caché.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Runtime.Caching.MemoryCache.Trim%2A> propiedad primero quita las entradas que han superado absoluto o la expiración variable. Las devoluciones de llamada que se registran para los elementos que se quitan se pasarán un motivo de eliminación de <xref:System.Web.Caching.CacheItemRemovedReason.Expired>.  
  
 Si quitar las entradas caducadas es insuficiente para alcanzar el porcentaje de recorte especificado, se quitarán las entradas adicionales de la memoria caché basada en un algoritmo de (LRU) usado menos recientemente hasta que se alcance el porcentaje de recorte solicitado. Las devoluciones de llamada que se registran para los elementos que quitan de esta manera se pasarán un motivo de eliminación <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>