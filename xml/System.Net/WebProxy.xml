<Type Name="WebProxy" FullName="System.Net.WebProxy">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1d162adca4957231bfc8934d137abbcb8e8cb143" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37642618" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebProxy : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WebProxy extends System.Object implements class System.Net.IWebProxy, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.WebProxy" />
  <TypeSignature Language="VB.NET" Value="Public Class WebProxy&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebProxy : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type WebProxy = class&#xA;    interface ISerializable&#xA;    interface IWebProxy" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.WebProxy</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Contiene la configuración del proxy HTTP para la clase <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> clase contiene la configuración de proxy que <xref:System.Net.WebRequest> las instancias se usan para determinar si se utiliza un proxy Web para enviar solicitudes. Configuración de proxy puede especificarse en el equipo y los archivos de configuración de aplicación y las aplicaciones Web de global puede usar instancias de la <xref:System.Net.WebProxy> clase para personalizar el uso del proxy Web. El <xref:System.Net.WebProxy> clase es la implementación base de la <xref:System.Net.IWebProxy> interfaz.  
  
 Para obtener instancias de la clase de proxy Web, puede usar cualquiera de los métodos siguientes:  
  
-   El <xref:System.Net.WebProxy.%23ctor%2A> constructor.  
  
-   Método <xref:System.Net.WebProxy.GetDefaultProxy%2A>.  
  
-   Método <xref:System.Net.GlobalProxySelection.Select%2A>.  
  
 Estos métodos suministrar un <xref:System.Net.WebProxy> instancia que puede personalizar; la diferencia entre ellos es cómo se inicializa la instancia antes de devolverlos a la aplicación. El <xref:System.Net.WebProxy.%23ctor%2A> constructor devuelve una instancia de la <xref:System.Net.WebProxy> clase con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en `null`. Cuando se usa una solicitud de un <xref:System.Net.WebProxy> instancia en este estado, no hay ningún proxy se usa para enviar la solicitud.  
  
 El <xref:System.Net.WebProxy.GetDefaultProxy%2A> método devuelve una instancia de la <xref:System.Net.WebProxy> clase con el <xref:System.Net.WebProxy.Address%2A>, <xref:System.Net.WebProxy.BypassProxyOnLocal%2A>, y <xref:System.Net.WebProxy.BypassList%2A> propiedades establecidas en los valores utilizados por Internet Explorer 5.5 y versiones posteriores.  
  
 El <xref:System.Net.GlobalProxySelection.Select%2A> método devuelve una instancia de la <xref:System.Net.WebProxy> clase con la las propiedades establecidas según una combinación de valores de archivo de configuración y de Internet Explorer.  
  
 La <xref:System.Net.WebProxy> clase admite la detección automática y la ejecución de scripts de configuración de proxy. Esta característica también se conoce como detección automática de proxy web (WPAD). Cuando se usa la configuración automática de proxy, un script de configuración, normalmente se denomina Wpad.dat, debe se encuentra, descargar, compilado y ejecutar. Si estas operaciones se realizan correctamente, el script devuelve a los servidores proxy que pueden usarse para una solicitud.  
  
   
  
## Examples  
 El siguiente código de ejemplo, se asigna un <xref:System.Net.WebProxy> instancia a un <xref:System.Net.WebRequest> instancia. El <xref:System.Net.WebRequest> instancia utiliza el proxy para conectarse a recursos externos de Internet. (Para obtener un ejemplo que muestra cómo utilizar la característica WPAD, consulte la documentación de la <xref:System.Net.IWebProxyScript> clase.)  
  
 [!code-cpp[Classic WebProxy Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic WebProxy Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebProxy Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic WebProxy Example/CS/source.cs#1)]
 [!code-vb[Classic WebProxy Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic WebProxy Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.WebProxy" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una instancia vacía de la clase <see cref="T:System.Net.WebProxy" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor predeterminado inicializa una instancia vacía de la <xref:System.Net.WebProxy> clase con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en `null`.  
  
 Cuando el <xref:System.Net.WebProxy.Address%2A> propiedad es `null`, el <xref:System.Net.WebProxy.IsBypassed%2A> devuelve del método `true` y <xref:System.Net.WebProxy.GetProxy%2A> método devuelve la dirección de destino.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#1)]
 [!code-csharp[NCLWebProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy Address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Address">Identificador URI del servidor proxy.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.WebProxy" /> con el identificador URI especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en un <xref:System.Uri> que contiene la instancia `Address`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#6)]
 [!code-csharp[NCLWebProxy#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">
          <paramref name="Address" /> no es un identificador URI válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy Address" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="Address">Una instancia de <see cref="T:System.Uri" /> que contiene la dirección del servidor proxy.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.WebProxy" /> a partir de la instancia de la clase <see cref="T:System.Uri" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en el `Address` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#2)]
 [!code-csharp[NCLWebProxy#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WebProxy (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WebProxy(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Los datos de serialización.</param>
        <param name="streamingContext">El contexto de los datos serializados.</param>
        <summary>Inicializa una instancia de la clase <see cref="T:System.Net.WebProxy" /> utilizando el contenido previamente serializado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el sistema para deserializar un <xref:System.Net.WebProxy> instancia; no de las aplicaciones no llaman.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="Address">Identificador URI del servidor proxy.</param>
        <param name="BypassOnLocal">Es <see langword="true" /> si se va a omitir el proxy para las direcciones locales; de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.WebProxy" /> con la dirección URI y el valor de omisión especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en un <xref:System.Uri> instancia que contiene `Address` y <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> propiedad establecida en `BypassOnLocal`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#7)]
 [!code-csharp[NCLWebProxy#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">
          <paramref name="Address" /> no es un identificador URI válido.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Host, int Port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Host, int32 Port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Host As String, Port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Host, int Port);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * int -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Host, Port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Host" Type="System.String" />
        <Parameter Name="Port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Host">Nombre de host del proxy.</param>
        <param name="Port">Número de puerto de <c>Host</c> que se va a usar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.WebProxy" /> con el host y número de puerto especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en un <xref:System.Uri> instancia de la forma http:// `Host` : `Port`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#5)]
 [!code-csharp[NCLWebProxy#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">El identificador URI obtenido al combinar <paramref name="Host" /> y <paramref name="Port" /> no es un identificador URI válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="Address">Una instancia de <see cref="T:System.Uri" /> que contiene la dirección del servidor proxy.</param>
        <param name="BypassOnLocal">Es <see langword="true" /> si se va a omitir el proxy para las direcciones locales; de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Net.WebProxy" /> con la instancia de <see cref="T:System.Uri" /> y el valor de omisión.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en `Address` y con el <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> propiedad establecida en `BypassOnLocal`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#3)]
 [!code-csharp[NCLWebProxy#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal, string[] BypassList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal, string[] BypassList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean, BypassList As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool * string[] -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="Address">Identificador URI del servidor proxy.</param>
        <param name="BypassOnLocal">Es <see langword="true" /> si se va a omitir el proxy para las direcciones locales; de lo contrario, es <see langword="false" />.</param>
        <param name="BypassList">Matriz de cadenas de expresiones regulares que contienen las direcciones URI de los servidores que se van a omitir.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.WebProxy" /> con la dirección URI, el valor de omisión y la lista de direcciones URI que se deben omitir especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en un <xref:System.Uri> instancia que contiene `Address`, <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> propiedad establecida en `BypassOnLocal`y el <xref:System.Net.WebProxy.BypassList%2A> propiedad establecida en `BypassList`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#8)]
 [!code-csharp[NCLWebProxy#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">
          <paramref name="Address" /> no es un identificador URI válido.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
        <altmember cref="P:System.Net.WebProxy.BypassList" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal, string[] BypassList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal, string[] BypassList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean, BypassList As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool * string[] -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="Address">Una instancia de <see cref="T:System.Uri" /> que contiene la dirección del servidor proxy.</param>
        <param name="BypassOnLocal">Es <see langword="true" /> si se va a omitir el proxy para las direcciones locales; de lo contrario, es <see langword="false" />.</param>
        <param name="BypassList">Matriz de cadenas de expresiones regulares que contiene las direcciones URI de los servidores que se van a omitir.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Net.WebProxy" /> con la instancia de <see cref="T:System.Uri" />, el valor de omisión y la lista de direcciones URI que se deben omitir especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en `Address`, <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> propiedad establecida en `BypassOnLocal`y el <xref:System.Net.WebProxy.BypassList%2A> propiedad establecida en `BypassList`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#4)]
 [!code-csharp[NCLWebProxy#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (string Address, bool BypassOnLocal, string[] BypassList, System.Net.ICredentials Credentials);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string Address, bool BypassOnLocal, string[] BypassList, class System.Net.ICredentials Credentials) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.String,System.Boolean,System.String[],System.Net.ICredentials)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As String, BypassOnLocal As Boolean, BypassList As String(), Credentials As ICredentials)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(System::String ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList, System::Net::ICredentials ^ Credentials);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : string * bool * string[] * System.Net.ICredentials -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList, Credentials)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.String" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
        <Parameter Name="Credentials" Type="System.Net.ICredentials" />
      </Parameters>
      <Docs>
        <param name="Address">Identificador URI del servidor proxy.</param>
        <param name="BypassOnLocal">Es <see langword="true" /> si se va a omitir el proxy para las direcciones locales; de lo contrario, es <see langword="false" />.</param>
        <param name="BypassList">Matriz de cadenas de expresiones regulares que contiene las direcciones URI de los servidores que se van a omitir.</param>
        <param name="Credentials">Una instancia de <see cref="T:System.Net.ICredentials" /> que se envía al servidor proxy para autenticación.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.WebProxy" /> con la dirección URI, el valor de omisión, la lista de direcciones URI que se deben omitir y las credenciales especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en un <xref:System.Uri> instancia que contiene `Address`, <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> propiedad establecida en `BypassOnLocal`, el <xref:System.Net.WebProxy.BypassList%2A> propiedad establecida en `BypassList`, y el <xref:System.Net.WebProxy.Credentials%2A> propiedad establecida en `Credentials`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#9)]
 [!code-csharp[NCLWebProxy#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">
          <paramref name="Address" /> no es un identificador URI válido.</exception>
        <altmember cref="P:System.Net.WebProxy.BypassProxyOnLocal" />
        <altmember cref="P:System.Net.WebProxy.BypassList" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebProxy (Uri Address, bool BypassOnLocal, string[] BypassList, System.Net.ICredentials Credentials);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri Address, bool BypassOnLocal, string[] BypassList, class System.Net.ICredentials Credentials) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.#ctor(System.Uri,System.Boolean,System.String[],System.Net.ICredentials)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Address As Uri, BypassOnLocal As Boolean, BypassList As String(), Credentials As ICredentials)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebProxy(Uri ^ Address, bool BypassOnLocal, cli::array &lt;System::String ^&gt; ^ BypassList, System::Net::ICredentials ^ Credentials);" />
      <MemberSignature Language="F#" Value="new System.Net.WebProxy : Uri * bool * string[] * System.Net.ICredentials -&gt; System.Net.WebProxy" Usage="new System.Net.WebProxy (Address, BypassOnLocal, BypassList, Credentials)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Address" Type="System.Uri" />
        <Parameter Name="BypassOnLocal" Type="System.Boolean" />
        <Parameter Name="BypassList" Type="System.String[]" />
        <Parameter Name="Credentials" Type="System.Net.ICredentials" />
      </Parameters>
      <Docs>
        <param name="Address">Una instancia de <see cref="T:System.Uri" /> que contiene la dirección del servidor proxy.</param>
        <param name="BypassOnLocal">Es <see langword="true" /> si se va a omitir el proxy para las direcciones locales; de lo contrario, es <see langword="false" />.</param>
        <param name="BypassList">Matriz de cadenas de expresiones regulares que contiene las direcciones URI de los servidores que se van a omitir.</param>
        <param name="Credentials">Una instancia de <see cref="T:System.Net.ICredentials" /> que se envía al servidor proxy para autenticación.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Net.WebProxy" /> con la instancia de <see cref="T:System.Uri" />, el valor de omisión, la lista de direcciones URI que se deben omitir y las credenciales especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy> instancia se inicializa con el <xref:System.Net.WebProxy.Address%2A> propiedad establecida en `Address`, <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> propiedad establecida en `BypassOnLocal`, el <xref:System.Net.WebProxy.BypassList%2A> propiedad establecida en `BypassList`y el <xref:System.Net.WebProxy.Credentials%2A> propiedad establecida en `Credentials`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NCLWebProxy#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#13)]
 [!code-csharp[NCLWebProxy#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.Address" />
      <MemberSignature Language="VB.NET" Value="Public Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri with get, set" Usage="System.Net.WebProxy.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la dirección del servidor proxy.</summary>
        <value>Una instancia de <see cref="T:System.Uri" /> que contiene la dirección del servidor proxy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy.Address%2A> propiedad contiene la dirección del servidor proxy. Cuando no está habilitada la detección automática de proxy y no se ha especificado ningún script de configuración automática, el <xref:System.Net.WebProxy.Address%2A> propiedad y <xref:System.Net.WebProxy.BypassList%2A> determinan el servidor proxy utilizado para una solicitud.  
  
 Cuando el <xref:System.Net.WebProxy.Address%2A> propiedad es `null`, las solicitudes de omitir el proxy y conectarse directamente al host de destino.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra las propiedades de un <xref:System.Net.WebProxy> objeto, incluida su <xref:System.Net.WebProxy.Address%2A>.  
  
 [!code-cpp[NCLAutoProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#1)]
 [!code-csharp[NCLAutoProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BypassArrayList">
      <MemberSignature Language="C#" Value="public System.Collections.ArrayList BypassArrayList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList BypassArrayList" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassArrayList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BypassArrayList As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ArrayList ^ BypassArrayList { System::Collections::ArrayList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BypassArrayList : System.Collections.ArrayList" Usage="System.Net.WebProxy.BypassArrayList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista de direcciones que no usan el servidor proxy.</summary>
        <value>Objeto <see cref="T:System.Collections.ArrayList" /> que contiene una lista de matrices <see cref="P:System.Net.WebProxy.BypassList" />, que representan los identificadores URI que no utilizarán el servidor proxy cuando se tenga acceso a ellos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy.BypassList%2A> es una lista de la matriz de cadenas de expresiones regulares que describen los identificadores URI que un <xref:System.Net.WebRequest> instancia obtiene acceso directamente en lugar de a través del servidor proxy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BypassList">
      <MemberSignature Language="C#" Value="public string[] BypassList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] BypassList" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassList" />
      <MemberSignature Language="VB.NET" Value="Public Property BypassList As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ BypassList { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BypassList : string[] with get, set" Usage="System.Net.WebProxy.BypassList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una matriz de direcciones que no usan el servidor proxy.</summary>
        <value>Matriz que contiene una lista de expresiones regulares que describen las direcciones URI que no usarán el servidor proxy cuando se tenga acceso a ellas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy.BypassList%2A> propiedad contiene una matriz de expresiones regulares que describen las direcciones URI que un <xref:System.Net.WebRequest> instancia obtiene acceso directamente en lugar de a través del servidor proxy.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra las propiedades de un <xref:System.Net.WebProxy> objeto, incluida su <xref:System.Net.WebProxy.BypassList%2A> propiedad.  
  
 [!code-cpp[NCLAutoProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#1)]
 [!code-csharp[NCLAutoProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.Regex" />
      </Docs>
    </Member>
    <Member MemberName="BypassProxyOnLocal">
      <MemberSignature Language="C#" Value="public bool BypassProxyOnLocal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BypassProxyOnLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.BypassProxyOnLocal" />
      <MemberSignature Language="VB.NET" Value="Public Property BypassProxyOnLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BypassProxyOnLocal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BypassProxyOnLocal : bool with get, set" Usage="System.Net.WebProxy.BypassProxyOnLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se omitirá el servidor proxy para las direcciones locales.</summary>
        <value>Es <see langword="true" /> si se va a omitir el servidor proxy para las direcciones locales; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La configuración de la <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> propiedad determina si <xref:System.Net.WebRequest> instancias usan el servidor proxy al obtener acceso a recursos locales de Internet.  
  
 Si <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> es `true`, las solicitudes que se realicen a los recursos locales de Internet no usarán el servidor proxy. Las solicitudes locales se identifican por la ausencia de un punto (.) en el URI, como en http://webserver/, o tener acceso al servidor local, incluidos http://localhost, http://loopback, o http://127.0.0.1. Cuando <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> es `false`, todas las solicitudes de Internet se realizan a través del servidor proxy.  
  
> [!NOTE]
>  Las solicitudes a un host local con un URI que contenga un punto usarán al proxy. Para evitar el uso de un servidor proxy en estos casos, crear una entrada para el host en el <xref:System.Net.WebProxy.BypassList%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a un constructor que establece esta propiedad y obtener el valor de esta propiedad.  
  
 [!code-cpp[NCLWebProxy#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#7)]
 [!code-csharp[NCLWebProxy#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultProxy">
      <MemberSignature Language="C#" Value="public static System.Net.IWebProxy CreateDefaultProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.IWebProxy CreateDefaultProxy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.CreateDefaultProxy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDefaultProxy () As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::IWebProxy ^ CreateDefaultProxy();" />
      <MemberSignature Language="F#" Value="static member CreateDefaultProxy : unit -&gt; System.Net.IWebProxy" Usage="System.Net.WebProxy.CreateDefaultProxy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.WebProxy.Credentials" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Net.IWebProxy.Credentials</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece las credenciales que se van a enviar al servidor proxy para la autenticación.</summary>
        <value>Una instancia de <see cref="T:System.Net.ICredentials" /> que contiene las credenciales que se enviarán al servidor proxy para la autenticación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy.Credentials%2A> propiedad contiene las credenciales de autenticación para enviar al servidor proxy en respuesta a un código de estado HTTP 407 (autorización de proxy). En la mayoría de los escenarios de cliente, debe usar el <xref:System.Net.CredentialCache.DefaultCredentials%2A>, que son las credenciales del usuario que ha iniciado sesión actualmente. Para ello, establezca el <xref:System.Net.WebProxy.UseDefaultCredentials%2A> propiedad `true` en lugar de establecer esta propiedad.  
  
> [!NOTE]
>  Si establece la <xref:System.Net.WebProxy.Credentials%2A> propiedad credenciales distintas de la <xref:System.Net.CredentialCache.DefaultCredentials%2A>, estableciendo el <xref:System.Net.WebProxy.UseDefaultCredentials%2A> propiedad `true` hace que un <xref:System.InvalidOperationException>. Para evitar esto, debe establecer el <xref:System.Net.WebProxy.Credentials%2A> propiedad `null` antes de establecer el <xref:System.Net.WebProxy.UseDefaultCredentials%2A> propiedad `true`. Del mismo modo, no se puede establecer esta propiedad a cualquier valor cuando <xref:System.Net.WebProxy.UseDefaultCredentials%2A> es `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer esta propiedad cuando la propiedad <see cref="P:System.Net.WebProxy.UseDefaultCredentials" /> estaba establecida en <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultProxy">
      <MemberSignature Language="C#" Value="public static System.Net.WebProxy GetDefaultProxy ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.WebProxy GetDefaultProxy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetDefaultProxy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDefaultProxy () As WebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::WebProxy ^ GetDefaultProxy();" />
      <MemberSignature Language="F#" Value="static member GetDefaultProxy : unit -&gt; System.Net.WebProxy" Usage="System.Net.WebProxy.GetDefaultProxy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Please use the proxy selected for you by default. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebProxy</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee la configuración proxy no dinámica de Internet Explorer.</summary>
        <returns>Una instancia de <see cref="T:System.Net.WebProxy" /> que contiene la configuración proxy no dinámica de Internet Explorer 5.5 y posterior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy.GetDefaultProxy%2A> método lee la configuración de proxy no dinámica almacenada por Internet Explorer 5.5 y versiones posteriores y crea un <xref:System.Net.WebProxy> instancia con esos valores.  
  
 El <xref:System.Net.WebProxy.GetDefaultProxy%2A> método no acepta valores dinámicos que se generan desde los scripts que ejecutan Internet Explorer, de entradas de configuración automática o de las búsquedas DNS o DHCP.  
  
 Las aplicaciones deben usar el <xref:System.Net.WebRequest.DefaultWebProxy%2A?displayProperty=nameWithType> propiedad y el <xref:System.Net.WebRequest.GetSystemWebProxy%2A?displayProperty=nameWithType> método en lugar de la <xref:System.Net.WebProxy.GetDefaultProxy%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este método.  
  
 [!code-cpp[NCLWebProxy#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#11)]
 [!code-csharp[NCLWebProxy#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#11)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso sin restricciones a los recursos de red. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="webProxy.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que se rellena con datos.</param>
        <param name="streamingContext">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> que especifica el destino de esta serialización.</param>
        <summary>Llena <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con los datos necesarios para serializar el objeto de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los objetos incluidos en el <xref:System.Runtime.Serialization.SerializationInfo> automáticamente se realiza un seguimiento y serializan el formateador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProxy">
      <MemberSignature Language="C#" Value="public Uri GetProxy (Uri destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Uri GetProxy(class System.Uri destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.GetProxy(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProxy (destination As Uri) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Uri ^ GetProxy(Uri ^ destination);" />
      <MemberSignature Language="F#" Value="abstract member GetProxy : Uri -&gt; Uri&#xA;override this.GetProxy : Uri -&gt; Uri" Usage="webProxy.GetProxy destination" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Net.IWebProxy.GetProxy(System.Uri)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="destination">La instancia de <see cref="T:System.Uri" /> del recurso de Internet solicitado.</param>
        <summary>Devuelve el identificador URI del proxy para una solicitud.</summary>
        <returns>La instancia de <see cref="T:System.Uri" /> del recurso de Internet si el recurso se encuentra en la lista de omisiones; en caso contrario, la instancia de <see cref="T:System.Uri" /> del proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy.GetProxy%2A> método devuelve el identificador URI que el <xref:System.Net.WebRequest> instancia se usa para tener acceso al recurso de Internet.  
  
 <xref:System.Net.WebProxy.GetProxy%2A> Compara `destination` con el contenido de <xref:System.Net.WebProxy.BypassList%2A>, usando la <xref:System.Net.WebProxy.IsBypassed%2A> método. Si <xref:System.Net.WebProxy.IsBypassed%2A> devuelve `true`, <xref:System.Net.WebProxy.GetProxy%2A> devuelve `destination` y <xref:System.Net.WebRequest> instancia no utiliza el servidor proxy.  
  
 Si `destination` no está en <xref:System.Net.WebProxy.BypassList%2A>, <xref:System.Net.WebRequest> instancia utiliza el servidor proxy y el <xref:System.Net.WebProxy.Address%2A> se devuelve la propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.WebProxy> de objetos y llama a este método para obtener el proxy que se ha seleccionado para un recurso.  
  
 [!code-cpp[NCLAutoProxy#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLAutoProxy/CPP/proxy.cpp#2)]
 [!code-csharp[NCLAutoProxy#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAutoProxy/CS/proxy.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="destination" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsBypassed">
      <MemberSignature Language="C#" Value="public bool IsBypassed (Uri host);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsBypassed(class System.Uri host) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.IsBypassed(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBypassed (host As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsBypassed(Uri ^ host);" />
      <MemberSignature Language="F#" Value="abstract member IsBypassed : Uri -&gt; bool&#xA;override this.IsBypassed : Uri -&gt; bool" Usage="webProxy.IsBypassed host" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Net.IWebProxy.IsBypassed(System.Uri)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="host">La instancia de <see cref="T:System.Uri" /> del host que se comprobará para el uso del proxy.</param>
        <summary>Indica si se va a usar el servidor proxy para el host especificado.</summary>
        <returns>Es <see langword="true" /> si el servidor proxy no se debe utilizar para <paramref name="host" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.WebProxy.IsBypassed%2A> método se usa para determinar si se debe omitir el servidor proxy al obtener acceso a un recurso de Internet.  
  
 El <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> y <xref:System.Net.WebProxy.BypassList%2A> propiedades controlan el valor devuelto de la <xref:System.Net.WebProxy.IsBypassed%2A> método.  
  
 <xref:System.Net.WebProxy.IsBypassed%2A> Devuelve `true` en cualquiera de las condiciones siguientes:  
  
-   Si <xref:System.Net.WebProxy.BypassProxyOnLocal%2A> es `true` y `host` es un URI local. Las solicitudes locales se identifican por la ausencia de un punto (.) en el URI, como en "http://webserver/".  
  
-   Si `host` coincide con una expresión regular en <xref:System.Net.WebProxy.BypassList%2A>.  
  
-   Si <xref:System.Net.WebProxy.Address%2A> es `null`.  
  
 Devuelven todas las demás condiciones `false`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.WebProxy> de objetos y llama a este método para comprobar si la lista de omisión se ha establecido correctamente.  
  
 [!code-cpp[NCLWebProxy#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLWebProxy/CPP/nclwebproxy.cpp#12)]
 [!code-csharp[NCLWebProxy#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLWebProxy/CS/nclwebproxy.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="host" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.WebProxy.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que se va a rellenar con datos.</param>
        <param name="streamingContext">Una estructura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que especifica el destino de esta serialización.</param>
        <summary>Crea los datos y el contexto de la serialización utilizados por el sistema para serializar un objeto <see cref="T:System.Net.WebProxy" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema llama a este método para serializar un objeto; las aplicaciones no llaman directamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.WebProxy.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.WebProxy.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.WebProxy</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que controla si se envían <see cref="P:System.Net.CredentialCache.DefaultCredentials" /> con las solicitudes.</summary>
        <value>Es <see langword="true" /> si se utilizan las credenciales predeterminadas; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en `true` cuando las solicitudes realizadas por este <xref:System.Net.WebProxy> objeto, si lo solicita el servidor, se debe autenticar con las credenciales del usuario que ha iniciado sesión actualmente. Para las aplicaciones cliente, este es el comportamiento deseado en la mayoría de los escenarios. Para las aplicaciones de nivel intermedio, como las aplicaciones ASP.NET, en lugar de usar esta propiedad, normalmente se establecería el <xref:System.Net.WebProxy.Credentials%2A> propiedad a las credenciales del cliente en cuyo nombre se realiza la solicitud.  
  
 En la tabla siguiente se muestra el efecto de la configuración de la <xref:System.Net.WebProxy.UseDefaultCredentials%2A> valor, según el valor de la <xref:System.Net.WebProxy.Credentials%2A> propiedad.  
  
|Valor de <xref:System.Net.WebProxy.Credentials%2A>|Valor de <xref:System.Net.WebProxy.UseDefaultCredentials%2A>|Efecto|  
|----------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|------------|  
|<xref:System.Net.CredentialCache.DefaultCredentials%2A>|`true`|Ningún efecto.|  
|<xref:System.Net.CredentialCache.DefaultCredentials%2A>|`false`|El valor de <xref:System.Net.WebProxy.Credentials%2A> está establecido en `null`.|  
|`null`|`true`|El valor de <xref:System.Net.WebProxy.Credentials%2A> está establecido en <xref:System.Net.CredentialCache.DefaultCredentials%2A>.|  
|Cualquier otro valor distinto <xref:System.Net.CredentialCache.DefaultCredentials%2A> o `null`|`true` o `false`|Establecer <xref:System.Net.WebProxy.UseDefaultCredentials%2A> produce una excepción.|  
  
 Si <xref:System.Net.WebProxy.UseDefaultCredentials%2A> es `false`, puede cambiar el <xref:System.Net.WebProxy.Credentials%2A> propiedad en cualquier credencial. Si <xref:System.Net.WebProxy.UseDefaultCredentials%2A> es `true`, cambiar el <xref:System.Net.WebProxy.Credentials%2A> propiedad desde <xref:System.Net.CredentialCache.DefaultCredentials%2A> (el valor que se establece cuando el <xref:System.Net.WebProxy.UseDefaultCredentials%2A> propiedad está establecida en `true`) se iniciará una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentó establecer esta propiedad cuando la propiedad <see cref="P:System.Net.WebProxy.Credentials" /> contenía credenciales distintas de las predeterminadas.</exception>
      </Docs>
    </Member>
  </Members>
</Type>