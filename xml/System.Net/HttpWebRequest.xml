<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e375cff6d3f3621aa35b61963b8d8aa09e4f97b6" />
    <Meta Name="ms.sourcegitcommit" Value="b3480b6208c3cad466469e76294a96f5ab1ef04c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/16/2018" />
    <Meta Name="ms.locfileid" Value="35691825" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides an HTTP-specific implementation of the <see cref="T:System.Net.WebRequest" /> class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest> proporciona compatibilidad para las propiedades y métodos definidos en <xref:System.Net.WebRequest> y para otras propiedades y métodos que permiten al usuario interactuar directamente con los servidores mediante HTTP.  
  
 No utilice la <xref:System.Net.HttpWebRequest.%23ctor%2A> constructor. Use la <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> método para inicializar nuevos <xref:System.Net.HttpWebRequest> objetos. Si el esquema para el identificador uniforme de recursos (URI) es `http://` o `https://`, <xref:System.Net.WebRequest.Create%2A> devuelve un <xref:System.Net.HttpWebRequest> objeto.  
  
 El <xref:System.Net.HttpWebRequest.GetResponse%2A> método realiza una solicitud sincrónica al recurso especificado en el <xref:System.Net.HttpWebRequest.RequestUri%2A> propiedad y devuelve un <xref:System.Net.HttpWebResponse> que contiene el objeto de respuesta. Pueden recibir los datos de respuesta mediante el uso de la secuencia devuelta por <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Si se cierra el objeto de respuesta o la secuencia de respuesta, se perderá los datos restantes. Los datos restantes se se agotará y el socket se puede volver a usar para las solicitudes posteriores al cerrar la secuencia o el objeto de respuesta si mantiene las condiciones siguientes: es una solicitud keep-alive "o" canalizada, sólo una pequeña cantidad de datos debe recibirán, o los datos restantes se reciben en un pequeño intervalo de tiempo. Si ninguna de las condiciones mencionadas mantenga o se supera el tiempo de carga, se cerrará el socket. Para las conexiones canalizadas o persistente, se recomienda encarecidamente que la aplicación lee las secuencias hasta el final del archivo. Esto garantiza que el socket se puede volver a usar para lo que produce un mejor rendimiento y menos recursos que usa las solicitudes posteriores.  
  
 Cuando desea enviar datos al recurso, el <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método devuelve un <xref:System.IO.Stream> objeto que se va a usar para enviar datos. El <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> y <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> métodos proporcionan acceso asincrónico a la secuencia de datos de envío.  
  
 Para la autenticación de cliente con <xref:System.Net.HttpWebRequest>, el certificado de cliente debe instalarse en el almacén de certificados My del usuario actual.  
  
 El <xref:System.Net.HttpWebRequest> clase produce un <xref:System.Net.WebException> cuando se producen errores al obtener acceso a un recurso. El <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> propiedad contiene un <xref:System.Net.WebExceptionStatus> valor que indica el origen del error. Cuando <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> es <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, <xref:System.Net.WebException.Response%2A> propiedad contiene el <xref:System.Net.HttpWebResponse> recibidos del recurso.  
  
 <xref:System.Net.HttpWebRequest> expone valores de encabezado HTTP comunes enviados al recurso de Internet como propiedades, métodos establecen o establecido por el sistema; en la tabla siguiente contiene una lista completa. Puede establecer otros encabezados en la <xref:System.Net.HttpWebRequest.Headers%2A> propiedad como pares nombre/valor. Tenga en cuenta que los servidores y las memorias caché pueden cambiar o agregar encabezados durante la solicitud.  
  
 En la tabla siguiente se enumera los encabezados HTTP que se establecen mediante propiedades o métodos o el sistema.  
  
|Header|Establecer|  
|------------|------------|  
|Aceptar|Establecer el <xref:System.Net.HttpWebRequest.Accept%2A> propiedad.|  
|Conexión|Establecer el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad.|  
|Longitud del contenido|Establecer el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad.|  
|Content-Type|Establecer el <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad.|  
|Esperar|Establecer el <xref:System.Net.HttpWebRequest.Expect%2A> propiedad.|  
|Fecha|Establecido por el sistema hasta la fecha actual.|  
|administrador de flujos de trabajo|Establecido por el sistema a la información de host actual.|  
|If-Modified-Since|Establecer el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad.|  
|Intervalo|Establecer el <xref:System.Net.HttpWebRequest.AddRange%2A> método.|  
|Sitio de referencia|Establecer el <xref:System.Net.HttpWebRequest.Referer%2A> propiedad.|  
|Codificación de transferencia|Establecer el <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propiedad (la <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad debe ser `true`).|  
|Agente de usuario|Establecer el <xref:System.Net.HttpWebRequest.UserAgent%2A> propiedad.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> se registra automáticamente. No es necesario llamar a la <xref:System.Net.WebRequest.RegisterPrefix%2A> método para registrar <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> antes de usar URI a partir `http://` o `https://`.  
  
 El equipo local o un archivo de configuración de la aplicación puede especificar que se puede usar un proxy predeterminado. Si el <xref:System.Net.HttpWebRequest.Proxy%2A> se especifica la propiedad, a continuación, la configuración de proxy de la <xref:System.Net.HttpWebRequest.Proxy%2A> el equipo local o un archivo de configuración de aplicación de reemplazo de propiedad y el <xref:System.Net.HttpWebRequest> instancia usará la configuración de proxy especificada. Si no se especifica ningún proxy en un archivo de configuración y la <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad no se especifica, el <xref:System.Net.HttpWebRequest> clase usa la configuración de proxy heredada de Internet Explorer en el equipo local. Si no hay ninguna configuración de proxy en Internet Explorer, la solicitud se envía directamente al servidor.  
  
 La <xref:System.Net.HttpWebRequest> clase analiza una lista de omisión de proxy con caracteres comodín heredadas de Internet Explorer de forma diferente de la lista de omisión se analiza directamente por Internet Explorer. Por ejemplo, el <xref:System.Net.HttpWebRequest> clase analizará una lista de omisión de "nt *" de Internet Explorer como una expresión regular "nt. $". Esto difiere del comportamiento nativo de Internet Explorer. Por lo que una dirección URL de "`http://intxxxxx`" omitiría el proxy utilizando la <xref:System.Net.HttpWebRequest> clase, pero no omitiría el proxy utilizando Internet Explorer.  
  
> [!NOTE]
>  El marco de trabajo se almacena en caché las sesiones SSL que se crean y se intenta reutilizar una sesión almacenada en caché para una nueva solicitud, si es posible. Al intentar reutilizar una sesión SSL, el marco de trabajo usa el primer elemento de <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (si hay alguno), o intenta reutilizar una sesión anónima si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> está vacía.  
  
> [!NOTE]
>  Por motivos de seguridad, las cookies están deshabilitadas de forma predeterminada. Si desea utilizar cookies, use la <xref:System.Net.HttpWebRequest.CookieContainer%2A> propiedad para permitir las cookies.  
  
 .NET Framework 4.6 incluye una nueva característica de seguridad que bloquea el cifrado no seguro y los algoritmos para las conexiones de hash. Aplicaciones de uso de TLS/SSL a través de API, como HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. y destino es .NET Framework 4.6 obtienen el comportamiento más seguras de forma predeterminada.  
  
 Los desarrolladores que desee dejar de seguir este comportamiento para mantener la interoperabilidad con los servicios de SSL3 existentes o TLS con servicios de RC4. [En este artículo](https://support.microsoft.com/kb/3069494) explica cómo modificar el código para que el nuevo comportamiento está deshabilitado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.HttpWebRequest> para el URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">Para obtener acceso al URI solicitado o cualquier URI que se redirige la solicitud. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. These constructors are obsolete; see the Remarks section for details.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Ambos <xref:System.Net.HttpWebRequest> constructores están obsoletos y no debe usarse. Llame a la <xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType> método para inicializar nuevos <xref:System.Net.HttpWebRequest> objetos.     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. This constructor is obsolete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class from the specified instances of the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" /> classes. This constructor is obsolete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación debe ejecutarse en modo de plena confianza al utilizar la serialización.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso no restringido a los recursos de red. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels a request to an Internet resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Abort%2A> método cancela una solicitud a un recurso. Después de cancela una solicitud, una llamada a la <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, o <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método causas un <xref:System.Net.WebException> con el <xref:System.Net.WebException.Status%2A> propiedad establecida en <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 El <xref:System.Net.HttpWebRequest.Abort%2A> método sincrónicamente ejecutará la devolución de llamada especificado para el <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> métodos si el <xref:System.Net.HttpWebRequest.Abort%2A> método se llama mientras alguna de estas operaciones están pendiente. Esto puede conducir a posibles problemas de interbloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 En el caso de solicitudes asincrónicas, es responsabilidad de la aplicación de cliente para implementar su propio mecanismo de tiempo de espera. En el ejemplo de código siguiente se muestra cómo hacerlo.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Accept" /> HTTP header.</summary>
        <value>Valor del encabezado HTTP <see langword="Accept" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para borrar la `Accept` encabezado HTTP, establezca el <xref:System.Net.HttpWebRequest.Accept%2A> propiedad `null`.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.Accept%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds a range header to the request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo de bytes a la solicitud.  
  
 Si `range` es positivo, el `range` parámetro especifica el punto inicial del intervalo. El servidor debería empezar a enviar datos desde el `range` los parámetros especificados al final de los datos de la entidad HTTP.  
  
 Si `range` es negativo, el `range` parámetro especifica el punto final del intervalo. El servidor debería empezar a enviar datos desde el principio de los datos de la entidad HTTP en el `range` los parámetros especificados.  
  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 Un ejemplo de un encabezado de intervalo en una solicitud del protocolo HTTP que solicita al servidor que envíe los primeros 100 bytes (desde el principio hasta el byte de posición 99) sería la siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `range` parámetro sería -99.  
  
 Un servidor HTTP indica la compatibilidad para los encabezados de intervalo con el encabezado Accept-Ranges. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, sólo los encabezados HTTP asociados a la solicitud completa se analiza y están disponibles a través de propiedades en la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados a cada intervalo se devuelven en la respuesta.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un encabezado de intervalo a la solicitud.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo de bytes a la solicitud.  
  
 Si `range` es positivo, el `range` parámetro especifica el punto inicial del intervalo. El servidor debería empezar a enviar datos desde el `range` los parámetros especificados al final de los datos de la entidad HTTP.  
  
 Si `range` es negativo, el `range` parámetro especifica el punto final del intervalo. El servidor debería empezar a enviar datos desde el principio de los datos de la entidad HTTP en el `range` los parámetros especificados.  
  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 Un ejemplo de un encabezado de intervalo en una solicitud del protocolo HTTP que solicita al servidor que envíe los primeros 100 bytes (desde el principio hasta el byte de posición 99) sería la siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `range` parámetro sería -99.  
  
 Un servidor HTTP indica la compatibilidad para los encabezados de intervalo con el encabezado Accept-Ranges. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, sólo los encabezados HTTP asociados a la solicitud completa se analiza y están disponibles a través de propiedades en la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados a cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo de bytes a la solicitud.  
  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 Un ejemplo de un encabezado de intervalo en una solicitud del protocolo HTTP que se las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `from` parámetros se especificarían como 0 y el `to` parámetros se especificarían como 99. El especificador de intervalo se establece automáticamente como "bytes" por este método.  
  
 Un servidor HTTP indica la compatibilidad para los encabezados de intervalo con el encabezado Accept-Ranges. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, sólo los encabezados HTTP asociados a la solicitud completa se analiza y están disponibles a través de propiedades en la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados a cada intervalo se devuelven en la respuesta.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se agrega un encabezado de intervalo a la solicitud.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo de bytes a la solicitud.  
  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 Un ejemplo de un encabezado de intervalo en una solicitud del protocolo HTTP que se las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `from` parámetros se especificarían como 0 y el `to` parámetros se especificarían como 99. El especificador de intervalo se establece automáticamente como "bytes" por este método.  
  
 Un servidor HTTP indica la compatibilidad para los encabezados de intervalo con el encabezado Accept-Ranges. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, sólo los encabezados HTTP asociados a la solicitud completa se analiza y están disponibles a través de propiedades en la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados a cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo a la solicitud.  
  
 Si `range` es positivo, el `range` parámetro especifica el punto inicial del intervalo. El servidor debería empezar a enviar datos desde el `range` los parámetros especificados al final de los datos de la entidad HTTP.  
  
 Si `range` es negativo, el `range` parámetro especifica el punto final del intervalo. El servidor debería empezar a enviar datos desde el principio de los datos de la entidad HTTP en el `range` los parámetros especificados.  
  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 El `rangeSpecifier` parámetro normalmente se especificaría como "bytes", puesto que se trata del único especificador de intervalo reconocido por la mayoría de los servidores HTTP. Establecer el `rangeSpecifier` parámetro a alguna otra cadena permite la compatibilidad de especificadores de intervalo personalizado que no sea de bytes (el especificador de intervalo de bytes definido en RFC 2616 por IETF).  
  
 Un ejemplo de un encabezado de intervalo en una solicitud del protocolo HTTP que se las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 En este ejemplo, el `rangeSpecifier` parámetro se especificaría como "bytes" y el `range` parámetro sería -99.  
  
 Un servidor HTTP indica la compatibilidad para los encabezados de intervalo con el encabezado Accept-Ranges en la respuesta. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, sólo los encabezados HTTP asociados a la solicitud completa se analiza y están disponibles a través de propiedades en la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados a cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo a la solicitud.  
  
 Si `range` es positivo, el `range` parámetro especifica el punto inicial del intervalo. El servidor debería empezar a enviar datos desde el `range` los parámetros especificados al final de los datos de la entidad HTTP.  
  
 Si `range` es negativo, el `range` parámetro especifica el punto final del intervalo. El servidor debería empezar a enviar datos desde el principio de los datos de la entidad HTTP en el `range` los parámetros especificados.  
  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 El `rangeSpecifier` parámetro normalmente se especificaría como "bytes", puesto que se trata del único especificador de intervalo reconocido por la mayoría de los servidores HTTP. Establecer el `rangeSpecifier` parámetro a alguna otra cadena permite la compatibilidad de especificadores de intervalo personalizado que no sea de bytes (el especificador de intervalo de bytes definido en RFC 2616 por IETF).  
  
 Un ejemplo de un encabezado de intervalo en una solicitud del protocolo HTTP que se las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 En este ejemplo, el `rangeSpecifier` parámetro se especificaría como "bytes" y el `range` parámetro sería -99.  
  
 Un servidor HTTP indica la compatibilidad para los encabezados de intervalo con el encabezado Accept-Ranges en la respuesta. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, sólo los encabezados HTTP asociados a la solicitud completa se analiza y están disponibles a través de propiedades en la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados a cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo a la solicitud.  
  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 El `rangeSpecifier` parámetro normalmente se especificaría como "bytes", puesto que se trata del único especificador de intervalo reconocido por la mayoría de los servidores HTTP. Establecer el `rangeSpecifier` parámetro a alguna otra cadena permite la compatibilidad de especificadores de intervalo personalizado que no sea de bytes (el especificador de intervalo de bytes definido en RFC 2616 por IETF).  
  
 Un ejemplo de un encabezado de intervalo en una solicitud del protocolo HTTP que se las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `rangeSpecifier` parámetro se especificaría como "bytes", la `from` parámetro debería ser 0 y el `to` parámetro sería 99.  
  
 Un servidor HTTP indica la compatibilidad para los encabezados de intervalo con el encabezado Accept-Ranges en la respuesta. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La cadena especificada en el encabezado Accept-Ranges es el especificador del intervalo que se especificarían por en el `rangeSpecifier` parámetro para este método.  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, sólo los encabezados HTTP asociados a la solicitud completa se analiza y están disponibles a través de propiedades en la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados a cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método agrega un encabezado de intervalo a la solicitud.  
  
 Puesto que todas las entidades HTTP se representan en mensajes HTTP como secuencias de bytes, el concepto de un intervalo de bytes es significativo para cualquier entidad HTTP. Sin embargo, no todos los clientes y servidores necesitan admitir las operaciones de intervalo de bytes.  
  
 El encabezado de intervalo en una solicitud permite que un cliente solicitar que solo desea recibir alguna parte del intervalo especificado de bytes en una entidad HTTP. Servidores no son necesarios para admitir las solicitudes de encabezado de intervalo.  
  
 El `rangeSpecifier` parámetro normalmente se especificaría como "bytes", puesto que se trata del único especificador de intervalo reconocido por la mayoría de los servidores HTTP. Establecer el `rangeSpecifier` parámetro a alguna otra cadena permite la compatibilidad de especificadores de intervalo personalizado que no sea de bytes (el especificador de intervalo de bytes definido en RFC 2616 por IETF).  
  
 Un ejemplo de un encabezado de intervalo en una solicitud del protocolo HTTP que se las solicitudes de los primeros 100 bytes sería el siguiente:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 En este ejemplo, el `rangeSpecifier` parámetro se especificaría como "bytes", la `from` parámetro debería ser 0 y el `to` parámetro sería 99.  
  
 Un servidor HTTP indica la compatibilidad para los encabezados de intervalo con el encabezado Accept-Ranges en la respuesta. Un ejemplo del encabezado Accept-Ranges desde un servidor que admite intervalos de bytes sería como sigue:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 La cadena especificada en el encabezado Accept-Ranges es el especificador del intervalo que se especificarían por en el `rangeSpecifier` parámetro para este método.  
  
 Si no se recibe un encabezado Accept-Ranges en el encabezado de la respuesta del servidor, el servidor no admite los encabezados de intervalo. Un ejemplo del encabezado Accept-Ranges desde un servidor que no admite intervalos, pero que reconoce el encabezado Accept-Ranges, sería como sigue:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Al recibir la respuesta de una solicitud de intervalo, sólo los encabezados HTTP asociados a la solicitud completa se analiza y están disponibles a través de propiedades en la <xref:System.Net.HttpWebResponse> clase. Encabezados asociados a cada intervalo se devuelven en la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Uniform Resource Identifier (URI) of the Internet resource that actually responds to the request.</summary>
        <value>
          <see cref="T:System.Uri" /> que identifica el recurso de Internet que responde realmente a la solicitud. El valor predeterminado es el identificador URI utilizado por el método <see cref="M:System.Net.WebRequest.Create(System.String)" /> para inicializar la solicitud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Address%2A> propiedad está establecida en el URI, una vez completados los redireccionamientos que se producen durante la solicitud.  
  
 El URI de la solicitud original se mantiene en el <xref:System.Net.HttpWebRequest.RequestUri%2A> propiedad.  
  
   
  
## Examples  
 El siguiente código de ejemplo se comprueba para ver si el <xref:System.Net.HttpWebRequest> objeto `req` se ha redirigido a otra ubicación para satisfacer la solicitud y establece el valor de la `hasChanged` variable `true` si se redirige la solicitud; encasocontrario`hasChanged`está establecido en `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the request should follow redirection responses.</summary>
        <value>
          <see langword="true" /> si la solicitud debe seguir automáticamente las respuestas de redirección recibidas del recurso de Internet; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> a `true` si desea que la solicitud siga automáticamente los encabezados de redirección de HTTP a la nueva ubicación del recurso. Establece el número máximo de redireccionamientos que debe seguir el <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propiedad.  
  
 Si <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> se establece en `false`, todas las respuestas con un código de estado HTTP comprendido entre 300 y 399 se devuelve a la aplicación.  
  
 El encabezado de autorización se borra en redirecciones automáticas y <xref:System.Net.HttpWebRequest> intentará automáticamente volver a autenticarse en la ubicación redirigida. En la práctica, esto significa que una aplicación no puede colocar información de autenticación personalizada en el encabezado de autorización si es posible encontrar redirección. En su lugar, la aplicación debe implementar y registrar un módulo de autenticación personalizado. El <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> y la clase relacionada se usan para implementar un módulo de autenticación personalizado. El <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> método registra un módulo de autenticación personalizado.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propiedad para permitir que la solicitud debe seguir las respuestas de redirección.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the received from the Internet resource.</summary>
        <value>
          <see langword="true" /> para habilitar el almacenamiento en búfer de los datos recibidos del recurso de Internet; <see langword="false" /> para deshabilitar el almacenamiento en búfer. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the data sent to the Internet resource.</summary>
        <value>
          <see langword="true" /> para habilitar el almacenamiento de los datos enviados al recurso de Internet en el búfer; <see langword="false" /> para deshabilitar el almacenamiento en el búfer. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> es `true`, por lo que es listo para ser reenviados en caso de redirecciones o la autenticación de las solicitudes de los datos se almacena en búfer en memoria.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> propiedad que se va a deshabilitar el almacenamiento en búfer de datos.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Establecer <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> a <see langword="true" /> puede provocar problemas de rendimiento al cargar grandes conjuntos de datos porque el búfer de datos podría usar toda la memoria disponible.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of decompression that is used.</summary>
        <value>Un <see cref="T:System.Net.DecompressionMethods" /> objeto que indica el tipo de descompresión que se utiliza.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The object's current state does not allow this property to be set.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método inicia una solicitud asincrónica para una secuencia que se usa para enviar datos el <xref:System.Net.HttpWebRequest>. El método de devolución de llamada asincrónica usa el <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método para devolver la secuencia real.  
  
 El <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método requiere algunas tareas de configuración sincrónico para completar (resolución de DNS, la detección del servidor proxy y conexión de socket TCP, por ejemplo) antes de que este método pase al estado asincrónico. Como resultado, este método nunca se debería llamar en un subproceso de interfaz de usuario porque puede tardar bastante tiempo (hasta varios minutos, según la configuración de red) para completar las tareas de configuración inicial de sincrónica antes de una excepción para que se produce un error o el método tiene éxito.  
  
 Para obtener más información sobre el grupo de subprocesos, vea [The Managed Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método, debe utilizar el <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método para realizar una solicitud asincrónica para una instancia de secuencia.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The stream is being used by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request to an Internet resource.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request for a response.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método inicia una solicitud asincrónica para una respuesta del recurso de Internet. El método de devolución de llamada asincrónica usa el <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método para devolver los datos reales <xref:System.Net.WebResponse>.  
  
 A <xref:System.Net.ProtocolViolationException> se produce en varios casos cuando las propiedades se establecen en el <xref:System.Net.HttpWebRequest> clase está en conflicto. Esta excepción se produce si una aplicación establece el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad y el <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad `true`y, a continuación, envía una solicitud HTTP GET. Esta excepción se produce si una aplicación intenta enviar fragmentada a un servidor que sólo admite el protocolo HTTP 1.0, donde no se admite. Esta excepción se produce si una aplicación intenta enviar datos sin establecer el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad o el <xref:System.Net.HttpWebRequest.SendChunked%2A> es `false` cuando se deshabilita el almacenamiento en búfer y en una conexión de keepalive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad es `true`)`.`  
  
 Si un <xref:System.Net.WebException> es produce, use la <xref:System.Net.WebException.Response%2A> y <xref:System.Net.WebException.Status%2A> propiedades de la excepción para determinar la respuesta del servidor.  
  
 El <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método requiere algunas tareas de configuración sincrónico para completar (resolución de DNS, la detección del servidor proxy y conexión de socket TCP, por ejemplo) antes de que este método pase al estado asincrónico. Como resultado, este método nunca se debería llamar en un subproceso de interfaz de usuario porque puede tardar bastante tiempo (hasta varios minutos, según la configuración de red) para completar las tareas de configuración inicial de sincrónica antes de una excepción para que se produce un error o el método tiene éxito.  
  
 Para obtener más información sobre el grupo de subprocesos, vea [ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927).  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método, debe utilizar el <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para realizar una solicitud asincrónica de un recurso de Internet.  
  
> [!NOTE]
>  En el caso de solicitudes asincrónicas, es responsabilidad de la aplicación de cliente para implementar su propio mecanismo de tiempo de espera. En el ejemplo de código siguiente se muestra cómo hacerlo.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" /> and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the collection of security certificates that are associated with this request.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> que contiene los certificados de seguridad asociados a esta solicitud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación puede agregar un certificado a una colección, pero que no tenga derechos de acceso a él. Para usar un certificado que contiene la colección, la aplicación debe tener los mismos derechos de acceso que la entidad que emitió el certificado.  
  
> [!NOTE]
>  El marco de trabajo se almacena en caché las sesiones SSL que se crean y se intenta reutilizar una sesión almacenada en caché para una nueva solicitud, si es posible. Al intentar reutilizar una sesión SSL, el marco de trabajo usa el primer elemento de <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (si hay alguno), o intenta reutilizar una sesión anónima si <xref:System.Net.HttpWebRequest.ClientCertificates%2A> está vacía.  
  
> [!NOTE]
>  Por motivos de rendimiento, no debe agregar un certificado de cliente a un <xref:System.Net.HttpWebRequest> a menos que sepa que va a pedir el servidor.  
>   
>  Para obtener un ejemplo de código que ilustra cómo enumerar los certificados en el almacén de certificados de cliente, consulte la <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value specified for a set operation is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Connection" /> HTTP header.</summary>
        <value>Valor del encabezado HTTP <see langword="Connection" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La solicitud se envía el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad al recurso de Internet como el `Connection` encabezado HTTP. Si el valor de la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad es `true`, el valor "Keep-alive" se anexa al final de la `Connection` encabezado.  
  
 Para borrar la `Connection` encabezado HTTP, establezca el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad `null`.  
  
 Cambiar el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad después de que la solicitud se ha iniciado mediante una llamada a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método produce un <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad para establecer el valor del encabezado HTTP de conexión.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value of <see cref="P:System.Net.HttpWebRequest.Connection" /> is set to Keep-alive or Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the connection group for the request.</summary>
        <value>Nombre del grupo de conexiones para esta solicitud. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propiedad le permite asociar una solicitud a un grupo de conexiones. Esto es útil cuando la aplicación realiza solicitudes a un servidor para diferentes usuarios, como un sitio Web que recupera información del cliente desde un servidor de base de datos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar la información de usuario para formar un grupo de conexiones, suponiendo que las variables `username`, `password`, y `domain` son establecidas por la aplicación antes de llama a este código.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cada grupo de conexiones crea conexiones adicionales para un servidor. Esto puede dar lugar a superar el número de conexiones establecidas por la <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> propiedad para ese servidor.</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see langword="Content-length" /> HTTP header.</summary>
        <value>Número de bytes de los datos enviados al recurso de Internet. El valor predeterminado es -1, que indica que no se estableció el valor de la propiedad y no hay datos de solicitud para enviar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad contiene el valor que se envía como el `Content-length` encabezado HTTP con la solicitud.  
  
 Cualquier valor distinto de -1 en el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad indica que la solicitud de carga los datos y que solo los métodos que cargan datos pueden establecerse el <xref:System.Net.HttpWebRequest.Method%2A> propiedad.  
  
 Después de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad se establece en un valor, ese número de bytes debe escribirse en la secuencia de solicitud que se devuelve mediante una llamada a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método o ambos el <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> y <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> métodos.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad a la longitud de la cadena que se va a registrar.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The new <see cref="P:System.Net.HttpWebRequest.ContentLength" /> value is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Content-type" /> HTTP header.</summary>
        <value>Valor del encabezado HTTP <see langword="Content-type" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad contiene el tipo de medio de la solicitud. Valores asignados a la <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad reemplace cualquier contenido existente cuando la solicitud se envía el `Content-type` encabezado HTTP.  
  
 Para borrar la `Content-type` encabezado HTTP, establezca el <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad `null`.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection> . Si <xref:System.Net.WebHeaderCollection> está establecido, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate method called when an HTTP 100-continue response is received from the Internet resource.</summary>
        <value>Delegado que implementa el método de devolución de llamada que se ejecuta cuando se devuelve una respuesta HTTP Continue desde el recurso de Internet. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propiedad especifica el método de devolución de llamada que se llamará cuando el cliente recibe 100-respuesta de continuar.  
  
 Cuando el <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propiedad está establecida, el cliente llama al delegado siempre que las respuestas de tipo de protocolo <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) se reciben. Esto es útil si desea que el cliente se muestra el estado de los datos recibidos del recurso de Internet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a timeout, in milliseconds, to wait until the 100-Continue is received from the server.</summary>
        <value>El tiempo de espera, en milisegundos, que se espera hasta que se recibe 100-Continue.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el 100-continuar se recibe la respuesta antes de que expire el tiempo de espera, se puede enviar el cuerpo de entidad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the cookies associated with the request.</summary>
        <value>
          <see cref="T:System.Net.CookieContainer" /> que contiene las cookies asociadas a esta solicitud.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.CookieContainer%2A> propiedad proporciona una instancia de la <xref:System.Net.CookieContainer> clase que contiene las cookies asociadas a esta solicitud.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> es `null` de forma predeterminada. Debe asignar un <xref:System.Net.CookieContainer> objeto a la propiedad que se va a tener las cookies devueltas en el <xref:System.Net.HttpWebResponse.Cookies%2A> propiedad de la <xref:System.Net.HttpWebResponse> devuelto por la <xref:System.Net.HttpWebRequest.GetResponse%2A> método.  
  
> [!NOTE]
>  Por motivos de seguridad, las cookies están deshabilitadas de forma predeterminada. Si desea utilizar cookies, use la <xref:System.Net.HttpWebRequest.CookieContainer%2A> propiedad para permitir las cookies.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía una solicitud a una dirección URL y se muestra las cookies devueltas en la respuesta.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets authentication information for the request.</summary>
        <value>
          <see cref="T:System.Net.ICredentials" /> que contiene las credenciales de autenticación asociadas a la solicitud. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Credentials%2A> propiedad contiene información de autenticación para identificar al creador de la solicitud. El <xref:System.Net.HttpWebRequest.Credentials%2A> propiedad puede ser un <xref:System.Net.NetworkCredential>, en cuyo caso el usuario, la contraseña y la información de dominio contenida en el <xref:System.Net.NetworkCredential> objeto se usa para autenticar la solicitud, o puede ser un <xref:System.Net.CredentialCache>, en cuyo caso el uniforme de recursos Identificador (URI) de la solicitud se usa para determinar el usuario, la contraseña y la información de dominio que se utiliza para autenticar la solicitud.  
  
 En la mayoría de los escenarios de cliente, debe usar el <xref:System.Net.CredentialCache.DefaultCredentials%2A> propiedad, que contiene las credenciales del usuario que ha iniciado sesión actualmente. Para ello, establezca la <xref:System.Net.WebClient.UseDefaultCredentials%2A> propiedad `true` en lugar de establecer esta propiedad.  
  
 Si el <xref:System.Net.HttpWebRequest> clase se utiliza en una aplicación de nivel intermedio, como una aplicación de ASP.NET, las credenciales en el <xref:System.Net.CredentialCache.DefaultCredentials%2A> propiedad pertenece a la cuenta de ejecución de la página ASP (las credenciales del servidor). Normalmente, esta propiedad se establecería en las credenciales del cliente en cuyo nombre se realiza la solicitud.  
  
> [!NOTE]
>  El esquema de autenticación NTLM no puede utilizarse para suplantar a otro usuario. Kerberos debe configurarse específicamente para admitir la suplantación.  
  
 Para restringir HttpWebRequest a uno o varios métodos de autenticación, utilice la <xref:System.Net.CredentialCache> de clases y enlazar sus credenciales a uno o varios esquemas de autenticación  
  
 Esquemas de autenticación admitidos incluyen Digest, Negotiate, Kerberos, NTLM y Basic.  
  
 Por motivos de seguridad, al seguir automáticamente las redirecciones, almacenar las credenciales que desea incluir en la redirección en una <xref:System.Net.CredentialCache> y asignarlo a esta propiedad. Esta propiedad se establecerá automáticamente `null` tras la redirección si contiene nada excepto un <xref:System.Net.CredentialCache>. Con este valor de propiedad se establece automáticamente en `null` en dichas condiciones impide que las credenciales que se envían a un destino no deseado.
  
## Examples  
 El ejemplo de código siguiente establece las credenciales para una solicitud.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the <see langword="Date" /> HTTP header value to use in an HTTP request.</summary>
        <value>Valor del encabezado Date de la solicitud HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el encabezado Date es `null`, el valor devuelto se establecerá <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 El <xref:System.Net.HttpWebRequest.Date%2A> propiedad es un estándar <xref:System.DateTime?displayProperty=nameWithType> objeto y puede contener una <xref:System.DateTimeKind?displayProperty=nameWithType> campo de <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, o <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Cualquier tipo de tiempo se puede establecer cuando se usa el <xref:System.Net.HttpWebRequest.Date%2A> propiedad. Si <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> se establece o recupera, el <xref:System.Net.HttpWebRequest.Date%2A> propiedad se supone que <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (hora local).  
  
 Las clases en el <xref:System.Net> espacio de nombres siempre escriben el <xref:System.Net.HttpWebRequest.Date%2A> propiedad en la conexión durante la transmisión en formulario estándar utilizando el formato GMT (Utc).  
  
 Si el <xref:System.Net.HttpWebRequest.Date%2A> propiedad está establecida en <xref:System.DateTime.MinValue?displayProperty=nameWithType>, la `Date` se quita el encabezado HTTP de la <xref:System.Net.HttpWebRequest.Headers%2A> propiedad y el <xref:System.Net.WebHeaderCollection>.  
  
 Si el <xref:System.Net.HttpWebRequest.Date%2A> propiedad es <xref:System.DateTime.MinValue?displayProperty=nameWithType>, esto indica que la `Date` encabezado HTTP no está incluido en el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad y el <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
 Si el <xref:System.Net.HttpWebRequest.Date%2A> se establece y se realiza un intento para enviar un <xref:System.Net.HttpWebRequest> sin cuerpo, con un <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> iniciará la <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, y <xref:System.Net.HttpWebRequest.EndGetResponse%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default cache policy for this request.</summary>
        <value>
          <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> que especifica la directiva de caché activa para esta solicitud cuando ninguna otra directiva es aplicable.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad, registra la directiva especificada para los esquemas HTTP y HTTPS. Esta directiva se usa para esta solicitud si:  
  
 No hay ningún <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> propiedad especificada para esta solicitud.  
  
 \- o -  
  
 La configuración de equipo y aplicación archivos no especifican una directiva de caché que se aplica para el identificador uniforme de recursos (URI) utilizado para crear esta solicitud.  
  
 La directiva de caché determina si el recurso solicitado se pueden obtener de una caché en lugar de enviar la solicitud al equipo host del recurso.  
  
 Una copia de un recurso solo se agrega a la memoria caché si el flujo de respuesta para el recurso se recupera y leer hasta el final de la secuencia. Así que otra solicitud para el mismo recurso podría utilizar una copia en caché, según el nivel de directiva de caché para esta solicitud.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso no restringido a los recursos de red. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default maximum length of an HTTP error response.</summary>
        <value>Longitud máxima predeterminada de una respuesta de error de HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default for the <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> property.</summary>
        <value>Longitud, en kilobytes (1024 bytes), del valor máximo predeterminado para los encabezados de respuesta recibidos. El archivo de configuración predeterminado establece este valor en 64 kilobytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud del encabezado de respuesta recibido la línea de estado de respuesta y caracteres de control adicionales que se reciben como parte del protocolo HTTP. Un valor de-1 significa que se impone ningún límite en los encabezados de respuesta recibidos; un valor de 0 significa que se producirá un error en todas las solicitudes.  
  
 Este valor también puede cambiarse en el archivo de configuración. El impacto de esta propiedad se puede invalidar estableciendo la <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propiedad en una instancia de la <xref:System.Net.HttpWebRequest> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is not equal to -1 and is less than zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método completa una solicitud asincrónica para una secuencia que se inició la <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método. Después de la <xref:System.IO.Stream> ha devuelto el objeto, es posible enviar datos con la <xref:System.Net.HttpWebRequest> mediante el uso de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  Debe establecer el valor de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad antes de escribir datos en la secuencia.  
  
> [!CAUTION]
>  Debe llamar a la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para cerrar la secuencia y liberar la conexión para su reutilización. Error al cerrar la secuencia hace que la aplicación se ejecute fuera de las conexiones.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método para finalizar una solicitud asincrónica para una instancia de secuencia.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método completa una solicitud asincrónica para una secuencia que se inició la <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método y salidas el <xref:System.Net.TransportContext> asociado a la secuencia. Después de la <xref:System.IO.Stream> ha devuelto el objeto, es posible enviar datos con la <xref:System.Net.HttpWebRequest> mediante el uso de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Algunas aplicaciones que usan la autenticación de Windows integrada con protección ampliada que necesite poder consultar la capa de transporte utilizada por <xref:System.Net.HttpWebRequest> para recuperar el token de enlace de canal (CBT) del canal TLS subyacente. El <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método proporciona acceso a esta información para los métodos HTTP que tienen un cuerpo de solicitud (`POST` y `PUT` las solicitudes). Esto solo es necesario si la aplicación está implementando su propia autenticación y necesita tener acceso a CBT.  
  
> [!NOTE]
>  Si una aplicación necesita establecer el valor de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad, a continuación, esto debe realizarse antes de recuperar la secuencia y escribir datos en él.  
  
> [!CAUTION]
>  Debe llamar a la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para cerrar la secuencia y liberar la conexión para su reutilización. Error al cerrar la secuencia hace que la aplicación se ejecute fuera de las conexiones.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a response.</param>
        <summary>Ends an asynchronous request to an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método completa una solicitud asincrónica de un recurso de Internet que se inició mediante una llamada a la <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método.  
  
> [!CAUTION]
>  Debe llamar a la <xref:System.Net.HttpWebResponse.Close%2A> método para cerrar la secuencia y liberar la conexión. Si no lo hace puede provocar que la aplicación se ejecute fuera de las conexiones.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método para finalizar una solicitud asincrónica de un recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult." />  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> property is greater than 0 but the data has not been written to the request stream.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Expect" /> HTTP header.</summary>
        <value>Contenido del encabezado HTTP <see langword="Expect" />. El valor predeterminado es <see langword="null" />.  
  
 <block subset="none" type="note"><para> El valor de esta propiedad se almacena en <see cref="T:System.Net.WebHeaderCollection" />. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> is set to a string that contains "100-continue" as a substring.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data required to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los objetos incluidos en el <xref:System.Runtime.Serialization.SerializationInfo> se realiza un seguimiento automáticamente y se serializa el formateador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método devuelve una secuencia que se utilizará para enviar los datos el <xref:System.Net.HttpWebRequest>. Después de la <xref:System.IO.Stream> ha devuelto el objeto, es posible enviar datos con la <xref:System.Net.HttpWebRequest> mediante el uso de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Si una aplicación necesita establecer el valor de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad, a continuación, esto debe realizarse antes de recuperar la secuencia.  
  
 Debe llamar a la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para cerrar la secuencia y liberar la conexión para su reutilización. Error al cerrar la secuencia hace que la aplicación se ejecute fuera de las conexiones.  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, debe utilizar el <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método para devolver una instancia de secuencia.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">The <see cref="T:System.Net.TransportContext" /> for the <see cref="T:System.IO.Stream" />.</param>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método devuelve una secuencia que se utilizará para enviar los datos la <xref:System.Net.HttpWebRequest> y genera el <xref:System.Net.TransportContext> asociado a la secuencia. Después de la <xref:System.IO.Stream> ha devuelto el objeto, es posible enviar datos con la <xref:System.Net.HttpWebRequest> mediante el uso de la <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Algunas aplicaciones que usan la autenticación de Windows integrada con protección ampliada que necesite poder consultar la capa de transporte utilizada por <xref:System.Net.HttpWebRequest> para recuperar el token de enlace de canal (CBT) del canal TLS subyacente. El <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método proporciona acceso a esta información para los métodos HTTP que tienen un cuerpo de solicitud (`POST` y `PUT` las solicitudes). Esto solo es necesario si la aplicación está implementando su propia autenticación y necesita tener acceso a CBT.  
  
 Si una aplicación necesita establecer el valor de la <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad, a continuación, esto debe realizarse antes de recuperar la secuencia.  
  
 Debe llamar a la <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para cerrar la secuencia y liberar la conexión para su reutilización. Error al cerrar la secuencia hace que la aplicación se ejecute fuera de las conexiones.  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, debe utilizar el <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method was unable to obtain the <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a response from an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.GetResponse%2A> método devuelve un <xref:System.Net.WebResponse> objeto que contiene la respuesta del recurso de Internet. Devuelve la instancia real es una <xref:System.Net.HttpWebResponse>y se puede convertir a esa clase a las propiedades de acceso específica de HTTP.  
  
 A <xref:System.Net.ProtocolViolationException> se produce en varios casos cuando las propiedades se establecen en el <xref:System.Net.HttpWebRequest> clase está en conflicto. Esta excepción se produce si una aplicación establece el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad y el <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad `true`y, a continuación, envía una solicitud HTTP GET. Esta excepción se produce si una aplicación intenta enviar fragmentada a un servidor que sólo admite el protocolo HTTP 1.0, donde no se admite. Esta excepción se produce si una aplicación intenta enviar datos sin establecer el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad o el <xref:System.Net.HttpWebRequest.SendChunked%2A> es `false` cuando se deshabilita el almacenamiento en búfer y en una conexión de keepalive (la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad es `true`)`.`  
  
> [!CAUTION]
>  Debe llamar a la <xref:System.Net.HttpWebResponse.Close%2A> método para cerrar la secuencia y liberar la conexión. Si no lo hace puede provocar que la aplicación se ejecute fuera de las conexiones.  
  
 Cuando se utiliza el método POST, debe obtener la secuencia de solicitud, escribir los datos que se va a y cierra la secuencia. Este método bloquea mientras espera el contenido que se envía; Si no hay ningún conjunto de tiempo de espera y no proporcionar contenido, los bloques de subproceso que realiza la llamada indefinidamente.  
  
> [!NOTE]
>  Varias llamadas a <xref:System.Net.HttpWebRequest.GetResponse%2A> devuelven el mismo objeto de respuesta; la solicitud no se vuelve a emitir.  
  
> [!NOTE]
>  La aplicación no puede mezclar métodos sincrónicos y asincrónicos para una solicitud determinada. Si se llama a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, debe utilizar el <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar la respuesta.  
  
> [!NOTE]
>  Si un <xref:System.Net.WebException> es produce, use la <xref:System.Net.WebException.Response%2A> y <xref:System.Net.WebException.Status%2A> propiedades de la excepción para determinar la respuesta del servidor.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Por motivos de seguridad, las cookies están deshabilitadas de forma predeterminada. Si desea utilizar cookies, utilice el <xref:System.Net.HttpWebRequest.CookieContainer%2A> propiedad para permitir las cookies.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene la respuesta para una solicitud.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater or equal to zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, this request includes data to be sent to the server. Requests that send data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether a response has been received from an Internet resource.</summary>
        <value>
          <see langword="true" /> si se ha recibido una respuesta; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente código de ejemplo se comprueba el <xref:System.Net.HttpWebRequest.HaveResponse%2A> propiedad para determinar si se ha recibido una respuesta desde un recurso de Internet.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a collection of the name/value pairs that make up the HTTP headers.</summary>
        <value>
          <see cref="T:System.Net.WebHeaderCollection" /> que contiene los pares nombre-valor que componen los encabezados de la solicitud HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Headers%2A> colección contiene los encabezados de protocolo asociados a la solicitud. En la tabla siguiente se enumera los encabezados HTTP que no se almacenan en la <xref:System.Net.HttpWebRequest.Headers%2A> colección pero están establecido por el sistema o establecer propiedades o métodos.  
  
|Header|Establecer|  
|------------|------------|  
|Aceptar|Establecer el <xref:System.Net.HttpWebRequest.Accept%2A> propiedad.|  
|Conexión|Establecer el <xref:System.Net.HttpWebRequest.Connection%2A> propiedad y <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad.|  
|Longitud del contenido|Establecer el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad.|  
|Content-Type|Establecer el <xref:System.Net.HttpWebRequest.ContentType%2A> propiedad.|  
|Esperar|Establecer el <xref:System.Net.HttpWebRequest.Expect%2A> propiedad.|  
|Fecha|Establecer el <xref:System.Net.HttpWebRequest.Date%2A> propiedad.|  
|administrador de flujos de trabajo|Establecer el <xref:System.Net.HttpWebRequest.Host%2A> propiedad.|  
|If-Modified-Since|Establecer el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad.|  
|Intervalo|Establecer el <xref:System.Net.HttpWebRequest.AddRange%2A> método.|  
|Sitio de referencia|Establecer el <xref:System.Net.HttpWebRequest.Referer%2A> propiedad.|  
|Codificación de transferencia|Establecer el <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propiedad (la <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad debe ser true).|  
|Agente de usuario|Establecer el <xref:System.Net.HttpWebRequest.UserAgent%2A> propiedad.|  
  
 El <xref:System.Net.WebHeaderCollection.Add%2A> método produce una <xref:System.ArgumentException> si se intenta establecer uno de estos encabezados protegidos.  
  
 Cambiar el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad después de que la solicitud se ha iniciado mediante una llamada a <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método produce un <xref:System.InvalidOperationException>.  
  
 No se debe suponer que los valores de encabezado permanecerán sin cambios, porque las memorias caché y los servidores Web pueden cambiar o agregar encabezados a una solicitud Web.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad para imprimir los pares de nombre/valor de encabezado HTTP en la consola.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the Host header value to use in an HTTP request independent from the request URI.</summary>
        <value>Valor del encabezado Host de la solicitud HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Host%2A> propiedad puede utilizarse para establecer el Host del valor de encabezado que se usa en una solicitud HTTP independiente del URI de solicitud. El <xref:System.Net.HttpWebRequest.Host%2A> propiedad puede constar de un nombre de host y un número de puerto opcional. Un encabezado de Host sin información de puerto implica el puerto predeterminado para el servicio solicitado (puerto 80 para una dirección URL HTTP, por ejemplo).  
  
 El formato para especificar un host y puerto debe seguir las reglas en la sección 14.23 de RFC2616 publicada por IETF. Un ejemplo que cumpla con estos requisitos que especifica un puerto de 8080 sería el siguiente valor para el <xref:System.Net.HttpWebRequest.Host%2A> propiedad:  
  
 `www.contoso.com:8080`  
  
 Mediante el <xref:System.Net.HttpWebRequest.Host%2A> propiedad para especificar explícitamente un valor de encabezado de Host personalizado también afecta a las áreas de almacenamiento en caché, las cookies y la autenticación. Cuando una aplicación proporciona credenciales para un prefijo URI concreto, las aplicaciones deben asegurarse de usar el URI que contiene el valor del encabezado de Host, no el servidor de destino en el URI. La clave se usa al almacenar en caché los recursos, usa el valor de encabezado de Host en lugar de con el URI de solicitud. Las cookies se almacenan en un <xref:System.Net.CookieContainer> y agrupados lógicamente por el nombre de dominio del servidor. Si la aplicación especifica un encabezado de Host, este valor se utilizará como dominio.  
  
 Si el <xref:System.Net.HttpWebRequest.Host%2A> no se establece la propiedad, a continuación, el valor del encabezado Host para usar en una solicitud HTTP se basa en el URI de solicitud.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The Host header cannot be set to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The Host header cannot be set to an invalid value.</exception>
        <exception cref="T:System.InvalidOperationException">The Host header cannot be set after the <see cref="T:System.Net.HttpWebRequest" /> has already started to be sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="If-Modified-Since" /> HTTP header.</summary>
        <value>
          <see cref="T:System.DateTime" /> que contiene el contenido del encabezado HTTP <see langword="If-Modified-Since" />. El valor predeterminado es el de la fecha y la hora actuales.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad es un estándar <xref:System.DateTime?displayProperty=nameWithType> objeto y puede contener una <xref:System.DateTimeKind?displayProperty=nameWithType> campo de <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, o <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Cualquier tipo de tiempo se puede establecer cuando se usa el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad. Si <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> se establece o recupera, el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad se supone que <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (hora local).  
  
 Las clases en el <xref:System.Net> espacio de nombres siempre escriben el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad en la conexión durante la transmisión en formulario estándar utilizando el formato GMT (Utc).  
  
 Si el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad está establecida en <xref:System.DateTime.MinValue?displayProperty=nameWithType>, la `If-Modified-Since` se quita el encabezado HTTP de la <xref:System.Net.HttpWebRequest.Headers%2A> propiedad y el <xref:System.Net.WebHeaderCollection>.  
  
 Si el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad es <xref:System.DateTime.MinValue?displayProperty=nameWithType>, esto indica que la `If-Modified-Since` encabezado HTTP no está incluido en el <xref:System.Net.HttpWebRequest.Headers%2A> propiedad y el <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente código de ejemplo se comprueba el <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to make a persistent connection to the Internet resource.</summary>
        <value>
          <see langword="true" /> Si la solicitud al recurso de Internet debe contener un <see langword="Connection" /> encabezado HTTP con el valor Keep-alive; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en `true` para enviar un `Connection` encabezado HTTP con el valor Keep-alive. Una aplicación usa <xref:System.Net.HttpWebRequest.KeepAlive%2A> para indicar una preferencia por las conexiones persistentes. Cuando el <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad es `true`, la aplicación realiza conexiones persistentes en los servidores que las admiten.  
  
> [!NOTE]
>  Cuando se utiliza HTTP/1.1, Keep-Alive predeterminada está activada. Establecer <xref:System.Net.HttpWebRequest.KeepAlive%2A> a `false` penada enviar un `Connection: Close` encabezado para el servidor.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad `false` para evitar que se establezca una conexión persistente con el recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of redirects that the request follows.</summary>
        <value>El número máximo de respuestas de redirección que seguirá la solicitud. El valor predeterminado es 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propiedad establece el número máximo de redireccionamientos que debe seguir si la solicitud la <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propiedad es `true`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se establece el valor de esta propiedad.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is set to 0 or less.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowed length of the response headers.</summary>
        <value>La longitud en kilobytes (1024 bytes) de los encabezados de respuesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud del encabezado de respuesta incluye la línea de estado de respuesta y caracteres de control adicionales que se reciben como parte del protocolo HTTP. Un valor de-1 significa que se impone ningún límite en los encabezados de respuesta; un valor de 0 significa que se producirá un error en todas las solicitudes.  
  
 Si el <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propiedad no se establece explícitamente, el valor predeterminado es el valor de la <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> propiedad.  
  
 Si la longitud del encabezado de respuesta recibido supera el valor de la <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propiedad, el <xref:System.Net.HttpWebRequest.EndGetResponse%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> métodos producirán una <xref:System.Net.WebException> con el <xref:System.Net.WebException.Status%2A> propiedad establecida en <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se establece el valor de esta propiedad.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set after the request has already been submitted.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the media type of the request.</summary>
        <value>Tipo del medio de la solicitud. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Net.HttpWebRequest.MediaType%2A> afecta a la propiedad el <xref:System.Net.HttpWebResponse.CharacterSet%2A> propiedad. Al establecer el <xref:System.Net.HttpWebRequest.MediaType%2A> en la solicitud, se elige el tipo de medio correspondiente en la lista de conjuntos de caracteres devuelto en la respuesta `Content-type` encabezado HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the method for the request.</summary>
        <value>Método de solicitud que se debe utilizar para establecer contacto con el recurso de Internet. El valor predeterminado es GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Method%2A> propiedad puede establecerse en cualquiera de los verbos del protocolo HTTP 1.1: GET, HEAD, POST, PUT, DELETE, TRACE u opciones.  
  
 Si el <xref:System.Net.HttpWebRequest.ContentLength%2A> propiedad se establece en cualquier valor distinto de -1, el <xref:System.Net.HttpWebRequest.Method%2A> propiedad debe establecerse en una propiedad de protocolo que carga los datos.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.Method%2A> propiedad POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No method is supplied.  -or-  The method string contains invalid characters.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to pipeline the request to the Internet resource.</summary>
        <value>
          <see langword="true" /> si la solicitud debe canalizarse; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una aplicación usa el <xref:System.Net.HttpWebRequest.Pipelined%2A> propiedad para indicar una preferencia por las conexiones canalizadas. Cuando <xref:System.Net.HttpWebRequest.Pipelined%2A> es `true`, una aplicación realiza conexiones canalizadas en los servidores que las admiten.  
  
 Las conexiones canalizadas sólo se realizan cuando el <xref:System.Net.HttpWebRequest.KeepAlive%2A> propiedad también es `true`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se imprime el valor de la <xref:System.Net.HttpWebRequest.Pipelined%2A> propiedad en la consola.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send an Authorization header with the request.</summary>
        <value>
          <see langword="true" /> se envía un encabezado de autorización HTTP con las solicitudes después de la autenticación ha llevado a cabo; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de una solicitud de cliente a un determinado <xref:System.Uri> se autentica correctamente, si <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> es `true` y se proporcionan credenciales, el encabezado de autorización se envía con cada solicitud a cualquier <xref:System.Uri> que coincida con la específica <xref:System.Uri>hasta la última barra diagonal. Por tanto, si la solicitud de cliente se autenticó correctamente ante un determinado <xref:System.Uri> que contiene lo siguiente:  
  
 `http://www.contoso.com/firstpath/`  
  
 A continuación, el encabezado de autorización para la autenticación previa se envía con cada solicitud para cualquiera de los siguientes <xref:System.Uri> instancias:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 Sin embargo, el encabezado de autorización no se envía con las solicitudes a cualquiera de los siguientes <xref:System.Uri> instancias:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Si la solicitud de cliente a un determinado <xref:System.Uri> es autenticado no correctamente, la solicitud utiliza los procedimientos de autenticación estándar.  
  
 Con la excepción de la primera solicitud, el <xref:System.Net.WebRequest.PreAuthenticate%2A> propiedad indica si se envía información de autenticación con las solicitudes posteriores para un <xref:System.Uri> que coincida con la específica <xref:System.Uri> hasta la última barra diagonal sin tener que esperar al desafío del servidor.  
  
 El siguiente diálogo entre cliente y servidor ilustra el efecto de esta propiedad. El cuadro de diálogo se da por supuesto que la autenticación básica está en uso.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> es `false`:  
  
 Cliente: GET someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: GET con encabezados de autorización  
  
 Servidor: 200 Aceptar  
  
 Cliente: GET someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: GET con encabezados de autorización  
  
 Servidor: 200 Aceptar  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> es `true`:  
  
 Cliente: GET someUrl  
  
 Servidor: 401 WWW-Authenticate Basic  
  
 Cliente: GET con encabezados de autorización  
  
 Servidor: 200 Aceptar  
  
 Cliente: GET someUrl con encabezados de autorización  
  
 Si el esquema de autenticación no es compatible con la autenticación previa, el valor de esta propiedad se omite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the version of HTTP to use for the request.</summary>
        <value>Versión HTTP que se va a utilizar para la solicitud. De manera predeterminada, es <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Net.HttpWebRequest> clase admite sólo las versiones 1.0 y 1.1 de HTTP. Establecer <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> a una versión diferente se produce una excepción.  
  
> [!NOTE]
>  Para establecer la versión HTTP de la solicitud actual, utilice la <xref:System.Net.HttpVersion.Version10> y <xref:System.Net.HttpVersion.Version11> campos de la <xref:System.Net.HttpVersion> clase.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The HTTP version is set to a value other than 1.0 or 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets proxy information for the request.</summary>
        <value>Objeto <see cref="T:System.Net.IWebProxy" /> que se utiliza para especificar el servidor proxy de la solicitud. El valor predeterminado se establece mediante una llamada a la propiedad <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad identifica el <xref:System.Net.WebProxy> objeto que se va a usar para procesar las solicitudes a los recursos de Internet. Para especificar que no debe utilizarse ningún proxy, establezca la <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad a la instancia del proxy devuelta por la <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> método.  
  
 El equipo local o un archivo de configuración de la aplicación puede especificar que se puede usar un proxy predeterminado. Si el <xref:System.Net.HttpWebRequest.Proxy%2A> se especifica la propiedad, a continuación, la configuración de proxy de la <xref:System.Net.HttpWebRequest.Proxy%2A> el equipo local o un archivo de configuración de aplicación de reemplazo de propiedad y el <xref:System.Net.HttpWebRequest> instancia usará la configuración de proxy especificada. Si no se especifica ningún proxy en un archivo de configuración y la <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad no se especifica, el <xref:System.Net.HttpWebRequest> clase usa la configuración de proxy heredada de Internet Explorer en el equipo local. Si no hay ninguna configuración de proxy en Internet Explorer, la solicitud se envía directamente al servidor.  
  
 La <xref:System.Net.HttpWebRequest> clase analiza una lista de omisión de proxy con caracteres comodín heredada de Internet Explorer el mismo tal y como se analiza la lista de omisión directamente por Internet Explorer. Por ejemplo, el <xref:System.Net.HttpWebRequest> clase analizará una lista de omisión de "nt *" de Internet Explorer como una expresión regular "nt.\*". Por lo que una dirección URL de "`http://nt.com`" omitiría el proxy utilizando la <xref:System.Net.HttpWebRequest> clase y el uso de Internet Explorer.  
  
 La <xref:System.Net.HttpWebRequest> clase admite la omisión del proxy local. La clase considera que un destino es local si se cumple cualquiera de las condiciones siguientes:  
  
-   El destino contiene un nombre sin formato (sin puntos en la dirección URL).  
  
-   El destino contiene una dirección de bucle invertido (<xref:System.Net.IPAddress.Loopback> o <xref:System.Net.IPAddress.IPv6Loopback>) o el destino contiene un <xref:System.Net.IPAddress> asignada al equipo local.  
  
-   El sufijo del dominio de destino coincide con sufijo del dominio del equipo local (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Cambiar el <xref:System.Net.HttpWebRequest.Proxy%2A> propiedad después de que la solicitud se ha iniciado mediante una llamada a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método produce un <xref:System.InvalidOperationException>. Para obtener información sobre el elemento de proxy [ \&lt; defaultProxy\&gt; Elemento (configuración de red)](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Net.HttpWebRequest.Proxy%2A> método para obtener la información de proxy para la solicitud.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> is set to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have permission for the requested operation.</exception>
        <permission cref="T:System.Net.WebPermission">Para obtener o establecer el <see cref="P:System.Net.HttpWebRequest.Proxy" /> propiedad. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a time-out in milliseconds when writing to or reading from a stream.</summary>
        <value>El número de milisegundos antes de que se agote el tiempo de espera de la operación de lectura o escritura. El valor predeterminado es 300.000 milisegundos (5 minutos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propiedad se utiliza cuando se escribe en la secuencia devuelta por la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método o leer desde la secuencia devuelta por la <xref:System.Net.HttpWebResponse.GetResponseStream%2A> método.  
  
 En concreto, el <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propiedad controla el tiempo de espera para la <xref:System.IO.Stream.Read%2A> método, que se utiliza para leer la secuencia devuelta por la <xref:System.Net.HttpWebResponse.GetResponseStream%2A> método y para la <xref:System.IO.Stream.Write%2A> método, que se usa para escribir en la secuencia devuelta por la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método.  
  
 Para especificar la cantidad de tiempo de espera para que la solicitud que se complete, use la <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad.  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra cómo establecer la propiedad <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has already been sent.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than or equal to zero and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Referer" /> HTTP header.</summary>
        <value>Valor del encabezado HTTP <see langword="Referer" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propiedad es `true`, el <xref:System.Net.HttpWebRequest.Referer%2A> propiedad se establece automáticamente cuando la solicitud se redirige a otro sitio.  
  
 Para borrar la `Referer` encabezado HTTP, establezca el <xref:System.Net.HttpWebRequest.Referer%2A> propiedad `null`.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.Referer%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the original Uniform Resource Identifier (URI) of the request.</summary>
        <value>
          <see cref="T:System.Uri" /> que contiene el identificador URI del recurso de Internet pasado al método <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Uri> objeto pasa a <xref:System.Net.HttpWebRequest> por la llamada a <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 Después de una redirección de encabezado no cambia el <xref:System.Net.HttpWebRequest.RequestUri%2A> propiedad. Para obtener el identificador URI real que respondió a la solicitud, examine el <xref:System.Net.HttpWebRequest.Address%2A> propiedad.  
  
   
  
## Examples  
 El siguiente código de ejemplo se comprueba para ver si el <xref:System.Net.HttpWebRequest> objeto `req` se ha redirigido a otra ubicación para satisfacer la solicitud y establece el valor de la `hasChanged` variable `true` si la solicitud se ha redirigido; en caso contrario, `hasChanged` se establece en `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send data in segments to the Internet resource.</summary>
        <value>
          <see langword="true" /> para enviar datos al recurso de Internet en segmentos; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Net.HttpWebRequest.SendChunked%2A> es `true`, la solicitud envía los datos en segmentos al recurso de Internet. El recurso de Internet debe admitir la recepción de datos fragmentados.  
  
 Cambiar el <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad después de que la solicitud se ha iniciado mediante una llamada a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método produce un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad `true` para que se pueden enviar datos en segmentos al recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback function to validate the server certificate.</summary>
        <value>Función de devolución de llamada para validar el certificado de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado es que no se ha establecido ninguna función de devolución de llamada y el <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> propiedad es `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the service point to use for the request.</summary>
        <value>
          <see cref="T:System.Net.ServicePoint" /> que representa la conexión de red con el recurso de Internet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> propiedad puede ser diferente de <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> si se redirige la solicitud.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the request provides support for a <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> Si la solicitud admite un <see cref="T:System.Net.CookieContainer" />; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los objetos incluidos en el <xref:System.Runtime.Serialization.SerializationInfo> se realiza un seguimiento automáticamente y se serializa el formateador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the time-out value in milliseconds for the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> and <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> methods.</summary>
        <value>Número de milisegundos que se va a esperar antes de que se agote el tiempo de espera de la solicitud. El valor predeterminado es 100.000 milisegundos (100 segundos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> es el número de milisegundos que una solicitud sincrónica posterior realizada con el <xref:System.Net.HttpWebRequest.GetResponse%2A> método espera una respuesta y el <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método espera una secuencia. El <xref:System.Net.HttpWebRequest.Timeout%2A> se aplica a toda solicitud y respuesta, no individualmente a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> y <xref:System.Net.HttpWebRequest.GetResponse%2A> llamadas al método. Si el recurso no se devuelve dentro del período de tiempo de espera, la solicitud produce un <xref:System.Net.WebException> con el <xref:System.Net.WebException.Status%2A> propiedad establecida en <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 El <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad debe establecerse antes de la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> se llama al método. Cambiar el <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad después de llamar a la <xref:System.Net.HttpWebRequest.GetRequestStream%2A> o <xref:System.Net.HttpWebRequest.GetResponse%2A> método no tiene ningún efecto  
  
 El <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad no tiene ningún efecto en las solicitudes asincrónicas realizadas con la <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método.  
  
> [!CAUTION]
>  En el caso de solicitudes asincrónicas, la aplicación cliente implementa su propio mecanismo de tiempo de espera. Consulte el ejemplo en el <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método.  
  
 Para especificar la cantidad de tiempo para esperar una lectura o escritura agota el tiempo de operación, use el <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propiedad.  
  
 Una consulta de sistema de nombres de dominio (DNS) puede tardar hasta 15 segundos en volver o tiempo de espera. Si la solicitud contiene un nombre de host que requiere resolución y establece <xref:System.Net.FileWebRequest.Timeout%2A> en un valor inferior a 15 segundos, puede tardar 15 segundos o más antes de un <xref:System.Net.WebException> se produce para indicar un tiempo de espera en la solicitud.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.Timeout%2A> propiedad de la <xref:System.Net.HttpWebRequest> objeto.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Transfer-encoding" /> HTTP header.</summary>
        <value>Valor del encabezado HTTP <see langword="Transfer-encoding" />. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para poder configurar la <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propiedad, primero debe establecer la <xref:System.Net.HttpWebRequest.SendChunked%2A> propiedad `true`. Borrar <xref:System.Net.HttpWebRequest.TransferEncoding%2A> estableciéndolo en `null` no tiene ningún efecto en el valor de <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Valores asignados a la <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propiedad reemplace cualquier contenido existente.  
  
> [!NOTE]
>  El valor de esta propiedad se almacena en <xref:System.Net.WebHeaderCollection>. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set when <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to the value "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to allow high-speed NTLM-authenticated connection sharing.</summary>
        <value>
          <see langword="true" /> para mantener abierta la conexión autenticada; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado de esta propiedad es `false`, lo que hace que la conexión actual que se cerrará una vez completada una solicitud. La aplicación debe pasar a través de la secuencia de autenticación cada vez que emite una solicitud nueva.  
  
 Si esta propiedad se establece en `true`, la conexión utilizada para recuperar la respuesta permanece abierta después de haber realizado la autenticación. En este caso, otras solicitudes que tienen esta propiedad establecida en `true` puede usar la conexión sin volver a autenticar. En otras palabras, si se ha autenticado una conexión para el usuario A, el usuario B puede volver a usar la conexión; solicitud del usuario B se cumple en función de las credenciales del usuario A.  
  
> [!CAUTION]
>  Dado que es posible que una aplicación para usar la conexión sin autenticarse, necesita asegurarse de que no hay ninguna vulnerabilidad administrativa en el sistema cuando se establece esta propiedad en `true`. Si la aplicación envía solicitudes para varios usuarios (suplanta a varias cuentas de usuario) y se basa en la autenticación para proteger los recursos, no establezca esta propiedad en `true` a menos que utilice grupos de conexión tal y como se describe a continuación.  
  
 Puede que desee habilitar este mecanismo si los tiene problemas de rendimiento y la aplicación se ejecuta en un servidor Web con autenticación integrada de Windows.  
  
 Si habilita a esta configuración, abre el sistema a riesgos de seguridad. Si establece la <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> propiedad `true` Asegúrese de tomar las precauciones siguientes:  
  
-   Use la <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propiedad para administrar las conexiones para los distintos usuarios. Esto evita la posible uso de la conexión de las aplicaciones no autenticadas. Por ejemplo, un usuario debe tener un nombre de grupo de conexión único que sea diferente del usuario B. Esto proporciona un nivel de aislamiento para cada cuenta de usuario.  
  
-   Ejecute la aplicación en un entorno protegido para evitar vulnerabilidades de seguridad de conexión posibles.  
  
 Si controla el servidor back-end, como alternativa puede desactivar la persistencia de autenticación. Esto aumenta el rendimiento en menor medida, pero es más seguro. Para obtener más detalles, busque AuthPersistence en MSDN library en [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Si ambos <xref:System.Net.WebRequest.PreAuthenticate%2A> y <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> se establecen en `true`, cada solicitud se envía utilizando una conexión del grupo no seguro, pero con un encabezado de autorización.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Se requiere permiso Web no restringido para establecer esta propiedad.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that controls whether default credentials are sent with requests.</summary>
        <value>Es <see langword="true" /> si se utilizan las credenciales predeterminadas; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en `true` cuando las solicitudes realizan por este <xref:System.Net.HttpWebRequest> objeto, si lo solicita el servidor, se debe autenticar con las credenciales del usuario que ha iniciado sesión actualmente. Para aplicaciones cliente, este es el comportamiento deseado en la mayoría de los escenarios. Para las aplicaciones de nivel intermedio, como las aplicaciones de ASP.NET, en lugar de utilizar esta propiedad, normalmente se establecería la <xref:System.Net.HttpWebRequest.Credentials%2A> propiedad a las credenciales del cliente en cuyo nombre se realiza la solicitud.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You attempted to set this property after the request was sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="User-agent" /> HTTP header.</summary>
        <value>Valor del encabezado HTTP <see langword="User-agent" />. El valor predeterminado es <see langword="null" />.  
  
 <block subset="none" type="note"><para> El valor de esta propiedad se almacena en <see cref="T:System.Net.WebHeaderCollection" />. Si se establece WebHeaderCollection, se pierde el valor de propiedad.  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.HttpWebRequest.UserAgent%2A> propiedad.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>